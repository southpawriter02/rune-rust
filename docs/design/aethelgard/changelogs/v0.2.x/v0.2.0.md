# Changelog: v0.2.0 - The Arena: Combat System Foundation

**Versions:** v0.2.0a through v0.2.0c
**Release Dates:** 2025-12-19 (all parts)

## Table of Contents

- [Overview](#overview)
- [Part A: The Arena (State & Initiative)](#part-a-the-arena-state--initiative)
  - [Summary](#summary)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Logging Matrix](#logging-matrix)
  - [Test Coverage](#test-coverage)
  - [DI Registration](#di-registration)
  - [Verification Results](#verification-results)
  - [Directory Structure After Release](#directory-structure-after-release)
  - [Running Tests](#running-tests)
  - [Next Steps](#next-steps)
- [Part B: The Exchange (Actions & Resolution)](#part-b-the-exchange-actions--resolution)
  - [Summary](#summary-1)
  - [New Files Created](#new-files-created-1)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-1)
  - [DI Registration](#di-registration-1)
  - [Verification Results](#verification-results-1)
  - [Directory Structure After Release](#directory-structure-after-release-1)
  - [Running Tests](#running-tests-1)
  - [Next Steps](#next-steps-1)
- [Part C: The Interface (Combat UI)](#part-c-the-interface-combat-ui)
  - [Summary](#summary-2)
  - [Design Pillars](#design-pillars)
  - [New Files Created](#new-files-created-2)
  - [Files Modified](#files-modified-2)
  - [Code Implementation Details](#code-implementation-details-2)
  - [Logging Matrix](#logging-matrix-2)
  - [Test Coverage](#test-coverage-2)
  - [DI Registration](#di-registration-2)
  - [Verification Results](#verification-results-2)
  - [Directory Structure After Release](#directory-structure-after-release-2)
  - [Running Tests](#running-tests-2)
  - [Next Steps](#next-steps-2)

---

## Overview

Version 0.2.0 represents a major milestone in Rune & Rust development, establishing the complete foundational infrastructure for turn-based combat. This multi-part release introduces combat state management, initiative calculation, attack resolution mechanics, and a polished Terminal User Interface (TUI) for combat visualization.

The implementation follows a systematic three-phase approach:
- **Part A (The Arena - State & Initiative)**: Establishes combat lifecycle services, initiative rolling using the FINESSE + WITS (Vigilance) formula, and the Combatant Adapter Pattern for isolating combat-volatile state from persistent entity data.
- **Part B (The Exchange - Actions & Resolution)**: Implements the Static Defense system (Defense Score = 10 + FINESSE - Stress), stamina-based action economy, and five-tier attack outcome classification (Fumble, Miss, Glancing, Solid, Critical).
- **Part C (The Interface - Combat UI)**: Transforms debug logs into a playable TUI with structured combat screens, narrative enemy health descriptions, and a dual logging system separating player-visible events from development diagnostics.

Key architectural achievements include the Service Delegation Pattern for attack resolution, d10-based initiative with Finesse tiebreakers, static lookup dictionaries for attack type properties, and the ViewModel Pattern for UI data transformation. The release added 96 comprehensive tests across all three parts, achieving full test coverage for the combat domain while maintaining zero test failures and strict adherence to MVVM principles.

---

## Part A: The Arena (State & Initiative)

**Release Date:** 2025-12-19

### Summary

This release establishes the foundational infrastructure for turn-based combat in Rune & Rust. The implementation introduces combat state management, initiative calculation, and turn order resolution using the Combatant Adapter Pattern to isolate combat-volatile state from persistent character/enemy data. The Core Layer gained combat domain models and service contracts, the Engine Layer received two new combat lifecycle services, and the Test Layer added 36 comprehensive tests validating the combat initialization sequence. Key architectural patterns employed include the Adapter Pattern for combatant wrapping, Singleton DI for stateless combat services, and d10-based initiative using the FINESSE + WITS (Vigilance) formula.

---

### New Files Created

#### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/Enemy.cs` | Stub enemy entity with attribute dictionary, HP tracking, and GetAttribute method for combat integration |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Adapter wrapping Character or Enemy for combat with combat-volatile state (Initiative, CurrentHp, CurrentStamina) and static factory methods |
| `RuneAndRust.Core/Models/CombatState.cs` | Tracks active combat encounter state including turn order list, round number, turn index, and computed properties for active combatant |
| `RuneAndRust.Core/Interfaces/IInitiativeService.cs` | Contract defining RollInitiative and SortTurnOrder operations for combat turn sequencing |
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Contract defining combat lifecycle operations (StartCombat, NextTurn, EndCombat) |

#### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/InitiativeService.cs` | Implements initiative calculation using d10 + FINESSE + WITS and turn order sorting with Finesse tiebreaker |
| `RuneAndRust.Engine/Services/CombatService.cs` | Manages combat lifecycle including combatant registration, initiative rolling, turn advancement, and phase transitions |

#### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/InitiativeServiceTests.cs` | Contains 12 tests validating initiative calculation formula, attribute integration, and turn order sorting with tiebreakers |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Contains 18 tests validating combat state creation, turn advancement, round cycling, and phase management |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Interfaces/IDiceService.cs` | Added RollSingle method signature with `int sides` and `string context` parameters for single die rolls |
| `RuneAndRust.Engine/Services/DiceService.cs` | Implemented RollSingle with side count validation (clamping to minimum 1), logging at Trace and Debug levels, and Random.Shared usage |
| `RuneAndRust.Core/Models/GameState.cs` | Added `CombatState?` property with `[JsonIgnore]` attribute to track active combat; added CombatState reset to Reset method |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `ICombatService?` constructor parameter; implemented `debug-combat` command creating Training Dummy enemy and initiating combat via ICombatService.StartCombat |
| `RuneAndRust.Terminal/Program.cs` | Registered IInitiativeService as Singleton and ICombatService as Singleton in DI container; updated boot message to display v0.2.0a |
| `RuneAndRust.Tests/Engine/DiceServiceTests.cs` | Added 6 tests for RollSingle covering range validation, side clamping, context logging, and distribution randomness |

---

### Code Implementation Details

#### Enemy Entity (Stub Implementation)

**File:** `RuneAndRust.Core/Entities/Enemy.cs`

**Properties:**
- `Guid Id` - Unique identifier, defaults to `Guid.NewGuid()`
- `string Name` - Display name, defaults to "Training Dummy"
- `Dictionary<CharacterAttribute, int> Attributes` - Attribute dictionary with default values (Sturdiness: 5, Might: 5, Wits: 3, Will: 3, Finesse: 3)
- `int MaxHp` - Maximum health points, defaults to 50
- `int CurrentHp` - Current health points, defaults to 50

**Methods:**
- `int GetAttribute(CharacterAttribute attr)` - Returns attribute value from dictionary or 0 if not found

**Notes:**
- Marked as stub entity for v0.2.0a; will be expanded with behaviors and AI in v0.2.1
- Uses `using CharacterAttribute = RuneAndRust.Core.Enums.Attribute;` to disambiguate from System.Attribute

#### Combatant Adapter Pattern

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

**Adapter Properties:**
- `Guid Id` - Unique identifier for combatant instance
- `string Name` - Display name copied from source entity
- `bool IsPlayer` - Flag distinguishing player from enemy combatants

**Combat-Volatile State:**
- `int Initiative` - Initiative roll result for turn order
- `int CurrentHp` - Combat HP copied from source at combat start
- `int MaxHp` - Maximum HP from source entity
- `int CurrentStamina` - Combat stamina copied from source at combat start
- `int MaxStamina` - Maximum stamina from source entity

**Source References:**
- `CharacterEntity? CharacterSource` - Reference to source Character if player combatant
- `Enemy? EnemySource` - Reference to source Enemy if enemy combatant

**Methods:**
- `int GetAttribute(CharacterAttribute attr)` - Delegates to CharacterSource.GetEffectiveAttribute or EnemySource.GetAttribute; returns 0 if no source set
- `static Combatant FromCharacter(CharacterEntity c)` - Factory method creating player combatant with IsPlayer = true, copying HP and Stamina
- `static Combatant FromEnemy(Enemy e)` - Factory method creating enemy combatant with IsPlayer = false, CurrentStamina and MaxStamina set to 0

**Design Rationale:**
- Isolates combat-volatile state from persistent entity data
- Prevents direct modification of Character/Enemy HP during combat simulation
- Allows combat to be rolled back or canceled without affecting source entities

#### CombatState Model

**File:** `RuneAndRust.Core/Models/CombatState.cs`

**Properties:**
- `Guid Id` - Unique identifier for combat encounter
- `List<Combatant> TurnOrder` - Ordered list of combatants sorted by initiative (highest first)
- `int RoundNumber` - Current round number, starts at 1
- `int TurnIndex` - Zero-based index of active combatant in TurnOrder

**Computed Properties:**
- `Combatant? ActiveCombatant` - Returns `TurnOrder[TurnIndex]` if valid, otherwise null
- `bool IsPlayerTurn` - Returns `ActiveCombatant?.IsPlayer ?? false`

**Behaviors:**
- TurnOrder starts empty and is populated by CombatService.StartCombat
- RoundNumber increments when TurnIndex wraps past end of TurnOrder
- TurnIndex wraps to 0 when incremented past TurnOrder.Count - 1

#### InitiativeService Implementation

**File:** `RuneAndRust.Engine/Services/InitiativeService.cs`

**Dependencies:**
- `IDiceService` - For rolling d10 initiative die
- `ILogger<InitiativeService>` - For structured logging

**Method: RollInitiative**
```csharp
void RollInitiative(Combatant combatant)
```
- Rolls 1d10 using `_dice.RollSingle(10, $"Initiative:{combatant.Name}")`
- Retrieves Finesse and Wits attributes from combatant via GetAttribute
- Calculates Vigilance as `finesse + wits`
- Sets `combatant.Initiative = roll + vigilance`
- Logs at Trace level for method entry with combatant name
- Logs at Debug level with final total, breakdown showing d10 roll and Vigilance modifier

**Method: SortTurnOrder**
```csharp
List<Combatant> SortTurnOrder(IEnumerable<Combatant> combatants)
```
- Sorts combatants using LINQ OrderByDescending with three-tier comparison:
  1. Primary: Initiative value (descending)
  2. Tiebreaker 1: Finesse attribute (descending)
  3. Tiebreaker 2: Random GUID (`Guid.NewGuid()`)
- Returns new list instance (does not mutate input)
- Logs at Trace level with combatant count
- Logs at Debug level with formatted turn order string showing Name(Initiative)

**Initiative Formula:** `d10 + FINESSE + WITS (Vigilance)`

**Tiebreaker Rules:**
1. Descending by Initiative
2. Descending by Finesse
3. Random (Guid.NewGuid())

#### CombatService Implementation

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

**Dependencies:**
- `GameState` - Singleton game state for CombatState and Phase management
- `IInitiativeService` - For rolling initiative and sorting turn order
- `ILogger<CombatService>` - For structured logging

**Method: StartCombat**
```csharp
void StartCombat(List<Enemy> enemies)
```
- Validates CurrentCharacter is not null; logs warning and returns early if null
- Creates new CombatState instance
- Creates Combatant from CurrentCharacter using `Combatant.FromCharacter`
- Rolls initiative for player combatant via `_initiative.RollInitiative`
- Adds player to TurnOrder
- Iterates enemies, creating Combatants via `Combatant.FromEnemy`, rolling initiative, adding to TurnOrder
- Sorts TurnOrder using `_initiative.SortTurnOrder`
- Sets `_gameState.CombatState` to new state
- Sets `_gameState.Phase` to `GamePhase.Combat`
- Logs at Information level with enemy count, round number, and active combatant name

**Method: NextTurn**
```csharp
void NextTurn()
```
- Validates CombatState is not null; logs warning and returns early if null
- Increments TurnIndex
- If TurnIndex >= TurnOrder.Count, wraps to 0 and increments RoundNumber
- Logs at Information level when new round begins
- Logs at Information level with active combatant name and type (Player/Enemy)

**Method: EndCombat**
```csharp
void EndCombat()
```
- Logs at Information level
- Sets `_gameState.Phase` to `GamePhase.Exploration`
- Sets `_gameState.CombatState` to null

**Behaviors:**
- StartCombat always initializes RoundNumber to 1 and TurnIndex to 0
- NextTurn handles cycling from last combatant back to first
- Round number increments occur at cycle point, not at start of first combatant's turn

#### DiceService.RollSingle Method

**File:** `RuneAndRust.Engine/Services/DiceService.cs`

**Method Signature:**
```csharp
int RollSingle(int sides, string context = "Unspecified")
```

**Behaviors:**
- Validates `sides >= 1`; clamps to 1 if invalid with Warning log
- Uses `Random.Shared.Next(1, sides + 1)` for random value generation
- Logs at Trace level with sides and context before rolling
- Logs at Debug level with result, sides, and context after rolling
- Returns raw die value (1 to sides, inclusive)

**Validation:**
- Negative sides: Logs Warning and clamps to 1
- Zero sides: Logs Warning and clamps to 1
- Valid sides: No clamping or warning

#### debug-combat Command

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

**Command:** `debug-combat`

**Behavior:**
- Available in Exploration phase
- Validates `_combatService != null` and `_gameState.CurrentCharacter != null`
- Creates stub Training Dummy enemy with 30 MaxHp and 30 CurrentHp
- Calls `_combatService.StartCombat(new List<Enemy> { dummyEnemy })`
- Displays yellow debug message: "[yellow]DEBUG: Combat initiated with Training Dummy.[/]"
- If validation fails, displays red error message

**Purpose:**
- Provides quick combat testing without dungeon population
- Demonstrates combat initialization flow for development iteration

---

### Logging Matrix

#### DiceService

| Event | Level | Template |
|-------|-------|----------|
| RollSingle entry | Trace | `"Rolling 1d{Sides} for {Context}"` |
| RollSingle result | Debug | `"Rolled {Result} on 1d{Sides} ({Context})"` |
| Invalid die sides | Warning | `"Invalid die sides {Sides} for {Context}. Clamping to minimum of 1."` |

#### InitiativeService

| Event | Level | Template |
|-------|-------|----------|
| RollInitiative entry | Trace | `"Rolling initiative for {Name}"` |
| Initiative result | Debug | `"{Name} rolled initiative: {Total} (d10:{Roll} + Vigilance:{Vig})"` |
| SortTurnOrder entry | Trace | `"Sorting turn order for {Count} combatants"` |
| Turn order result | Debug | `"Turn order: {Order}"` (formatted as "Name(Initiative) → Name(Initiative)") |

#### CombatService

| Event | Level | Template |
|-------|-------|----------|
| StartCombat entry | Information | `"Initializing Combat. Enemies: {Count}"` |
| No active character | Warning | `"Cannot start combat without active character"` |
| Player added | Debug | `"Added player {Name} to combat"` |
| Enemy added | Debug | `"Added enemy {Name} to combat"` |
| Combat started | Information | `"Combat Started. Round {Round}. Active: {Name}"` |
| NextTurn called with no combat | Warning | `"NextTurn called but no combat is active"` |
| Round begins | Information | `"Round {Round} begins"` |
| Turn change | Information | `"Turn: {Name} ({Type})"` (Type = "Player" or "Enemy") |
| EndCombat | Information | `"Combat Ended"` |

---

### Test Coverage

```
Total: 1209 | Passed: 1207 | Failed: 2 | Duration: 477ms
```

**Note:** 2 pre-existing failures in `TextRedactorTests` unrelated to combat implementation.

**New Tests Added:** 36 tests (12 InitiativeServiceTests + 18 CombatServiceTests + 6 DiceService.RollSingle tests)

#### InitiativeServiceTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| `RollInitiative_SetsInitiativeProperty` | Verifies RollInitiative sets the Initiative property to a value greater than 0 |
| `RollInitiative_AddsAttributesToRoll` | Validates formula: d10(5) + Finesse(4) + Wits(3) = 12 using Character combatant |
| `RollInitiative_UsesEnemyAttributes` | Validates formula: d10(7) + Finesse(6) + Wits(2) = 15 using Enemy combatant |
| `RollInitiative_CallsDiceServiceWithCorrectContext` | Verifies DiceService.RollSingle called with context "Initiative:TestFighter" |
| `RollInitiative_WithZeroAttributes_ReturnsRollValueOnly` | Validates combatant with no source returns only d10 roll value (attributes = 0) |
| `SortTurnOrder_HigherInitiativeFirst` | Validates descending sort by initiative (fast combatant before slow combatant) |
| `SortTurnOrder_FinesseBreaksTies` | Validates Finesse tiebreaker when Initiative values are equal (nimble before clumsy) |
| `SortTurnOrder_EmptyList_ReturnsEmpty` | Validates empty input produces empty output |
| `SortTurnOrder_SingleCombatant_ReturnsSame` | Validates single combatant returns list containing that combatant |
| `SortTurnOrder_MultipleCombatants_SortsCorrectly` | Validates multi-combatant sort produces descending order by initiative |
| `SortTurnOrder_ReturnsNewList` | Validates method returns new list instance, not input list reference |
| Helper: `CreateCombatantWithFinesse` | Test helper creating Character-based combatant with specified initiative and finesse |

#### CombatServiceTests (18 tests)

| Test Name | Description |
|-----------|-------------|
| `StartCombat_SetsPhaseToСombat` | Validates GameState.Phase transitions from Exploration to Combat |
| `StartCombat_CreatesCombatState` | Validates GameState.CombatState is not null after StartCombat |
| `StartCombat_AddsPlayerAndEnemies` | Validates TurnOrder contains 3 combatants (1 player + 2 enemies) |
| `StartCombat_SortsTurnOrder` | Verifies IInitiativeService.SortTurnOrder called exactly once |
| `StartCombat_RollsInitiativeForAllCombatants` | Verifies IInitiativeService.RollInitiative called exactly twice (player + 1 enemy) |
| `StartCombat_WithNoCharacter_DoesNothing` | Validates early return when CurrentCharacter is null, Phase remains Exploration |
| `StartCombat_SetsRoundToOne` | Validates CombatState.RoundNumber initialized to 1 |
| `StartCombat_SetsTurnIndexToZero` | Validates CombatState.TurnIndex initialized to 0 |
| `StartCombat_PlayerCombatantIsMarkedAsPlayer` | Validates player combatant has IsPlayer = true and CharacterSource set |
| `StartCombat_EnemyCombatantIsNotMarkedAsPlayer` | Validates enemy combatant has IsPlayer = false and EnemySource set |
| `NextTurn_IncrementsTurnIndex` | Validates TurnIndex increases by 1 when NextTurn called mid-round |
| `NextTurn_WrapsToZeroAtEndOfTurnOrder` | Validates TurnIndex wraps from 1 to 0 when at last combatant |
| `NextTurn_IncrementsRoundWhenWrapping` | Validates RoundNumber increments from 1 to 2 when TurnIndex wraps |
| `NextTurn_WithNoCombat_DoesNothing` | Validates NextTurn does not throw when CombatState is null |
| `NextTurn_MiddleOfRound_DoesNotIncrementRound` | Validates RoundNumber remains 1 when advancing from TurnIndex 0 to 1 |
| `EndCombat_SetsPhaseToExploration` | Validates GameState.Phase transitions from Combat to Exploration |
| `EndCombat_ClearsCombatState` | Validates GameState.CombatState set to null |
| `EndCombat_WhenNoCombatActive_DoesNotThrow` | Validates EndCombat safe to call when CombatState already null |
| Helper: `CreateTestCharacter` | Test helper creating Character entity with specified name and default attributes |
| Helper: `CreateTestEnemy` | Test helper creating Enemy entity with specified name, 50 MaxHp, 50 CurrentHp |
| Helper: `SetupActiveCombat` | Test helper creating CombatState with specified combatant count for turn advancement tests |

#### DiceServiceTests - RollSingle Tests (6 new tests)

| Test Name | Description |
|-----------|-------------|
| `RollSingle_ReturnsValueInRange` | Validates 100 RollSingle(10) calls return values between 1 and 10 inclusive |
| `RollSingle_WithDifferentSides_ReturnsValueInRange` | Validates d6 returns 1-6 and d20 returns 1-20 across 50 samples each |
| `RollSingle_WithZeroSides_ClampsToOne` | Validates sides=0 returns 1 and logs Warning |
| `RollSingle_WithNegativeSides_ClampsToOne` | Validates sides=-5 returns 1 and logs Warning |
| `RollSingle_LogsContext` | Verifies context "InitiativeRoll" appears in log messages |
| `RollSingle_Distribution_ShouldBeReasonablyRandom` | Validates 1000 d10 rolls produce each value 1-10 at least 50 times (statistical randomness) |

---

### DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<ICombatService, CombatService>();
```

**Justification for Singleton Lifetime:**
- Both services are stateless and thread-safe
- InitiativeService depends only on IDiceService (also Singleton) and ILogger
- CombatService depends on GameState (Singleton), IInitiativeService (Singleton), and ILogger
- Singleton registration avoids unnecessary instantiation overhead in game loop

---

### Verification Results

#### Build Output

```
Build succeeded.

    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.62
```

**Note:** Warning MSB3277 regarding EntityFrameworkCore.Relational version conflict is pre-existing and does not affect combat implementation.

#### Test Output

```
Failed!  - Failed:     2, Passed:  1207, Skipped:     0, Total:  1209, Duration: 477 ms
```

**New Tests:**
- InitiativeServiceTests: 12/12 passed
- CombatServiceTests: 18/18 passed
- DiceServiceTests (RollSingle): 6/6 passed

**Pre-existing Failures:**
- `TextRedactorTests.RedactText_AtFiftyPercent_ReturnsMixedText` - Unrelated to combat
- `TextRedactorTests.RedactText_ContainsRedactedBlocks_UsesGreyMarkup` - Unrelated to combat

---

### Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── Character.cs
│   ├── CodexEntry.cs
│   ├── DataCapture.cs
│   ├── Enemy.cs [NEW]
│   ├── InteractableObject.cs
│   ├── Room.cs
│   └── SaveGame.cs
├── Enums/
│   ├── Attribute.cs
│   ├── Direction.cs
│   ├── EquipmentSlot.cs
│   ├── GamePhase.cs
│   ├── ItemRarity.cs
│   ├── ObjectState.cs
│   ├── ObjectType.cs
│   └── PendingGameAction.cs
├── Interfaces/
│   ├── ICharacterRepository.cs
│   ├── ICodexEntryRepository.cs
│   ├── ICombatService.cs [NEW]
│   ├── IDataCaptureRepository.cs
│   ├── IDataCaptureService.cs
│   ├── IDescriptorEngine.cs
│   ├── IDiceService.cs [MODIFIED]
│   ├── IGameService.cs
│   ├── IInitiativeService.cs [NEW]
│   ├── IInputHandler.cs
│   ├── IInteractableObjectRepository.cs
│   ├── IInteractionService.cs
│   ├── IJournalService.cs
│   ├── INavigationService.cs
│   ├── IRepository.cs
│   ├── IRoomRepository.cs
│   ├── ISaveGameRepository.cs
│   └── IStatCalculationService.cs
├── Models/
│   ├── Combat/
│   │   └── Combatant.cs [NEW]
│   ├── CombatState.cs [NEW]
│   ├── GameState.cs [MODIFIED]
│   └── (other model files)

RuneAndRust.Engine/
├── Services/
│   ├── CombatService.cs [NEW]
│   ├── CommandParser.cs [MODIFIED]
│   ├── DataCaptureService.cs
│   ├── DescriptorEngine.cs
│   ├── DiceService.cs [MODIFIED]
│   ├── GameService.cs
│   ├── InitiativeService.cs [NEW]
│   ├── InteractionService.cs
│   ├── JournalService.cs
│   ├── NavigationService.cs
│   ├── SaveManager.cs
│   ├── StatCalculationService.cs
│   └── TextRedactor.cs
├── Factories/
│   ├── CharacterFactory.cs
│   └── ObjectSpawner.cs
└── (other directories)

RuneAndRust.Tests/
├── Engine/
│   ├── CombatServiceTests.cs [NEW]
│   ├── DataCaptureServiceTests.cs
│   ├── DescriptorEngineTests.cs
│   ├── DiceServiceTests.cs [MODIFIED]
│   ├── InitiativeServiceTests.cs [NEW]
│   ├── InteractionServiceTests.cs
│   ├── JournalServiceTests.cs
│   ├── NavigationServiceTests.cs
│   ├── StatCalculationServiceTests.cs
│   └── TextRedactorTests.cs
└── (other directories)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── Services/
    ├── CharacterCreationController.cs
    └── TerminalInputHandler.cs
```

---

### Running Tests

#### Run All Tests
```bash
dotnet test
```

#### Run Combat Tests Only
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests"
dotnet test --filter "FullyQualifiedName~InitiativeServiceTests"
```

#### Run DiceService Tests (Including RollSingle)
```bash
dotnet test --filter "FullyQualifiedName~DiceServiceTests"
```

#### Run New Combat Tests (Combined)
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests|FullyQualifiedName~InitiativeServiceTests"
```

---

### Next Steps

**Planned for v0.2.1:**
- Implement combat action system (Attack, Defend, UseItem, Flee)
- Add damage calculation service using dice pools
- Implement enemy AI decision-making patterns
- Create combat UI display with turn indicator and combatant health bars
- Add combat logging to Scavenger's Journal
- Implement stamina cost for combat actions
- Add status effects (Bleeding, Stunned, Fortified)
- Create combat victory/defeat resolution with XP awards
- Add loot drops from defeated enemies
- Implement flee mechanics with FINESSE check

**Planned for v0.2.2:**
- Expand Enemy entity with behaviors, loot tables, and AI personality types
- Add enemy type definitions (Automaton, Revenant, Beast, Construct)
- Implement enemy spawning in DungeonGenerator
- Create bestiary entries for Codex system
- Add combat encounter triggers in Exploration phase
- Implement surprise round mechanics
- Add multi-target combat encounters

---

## Part B: The Exchange (Actions & Resolution)

**Release Date:** 2025-12-19

### Summary

This release implements the combat attack resolution system for Rune & Rust, transforming the turn-based infrastructure from v0.2.0a into a functional combat engine. The implementation introduces a Static Defense system using the formula `Defense Score = 10 + FINESSE - Stress` converted to `Success Threshold = Defense / 5`, a stamina-based action economy with variable costs per attack type, and a five-tier outcome classification system (Fumble, Miss, Glancing, Solid, Critical). The Core Layer gained attack-related enums and models, the Engine Layer received the AttackResolutionService and extended CombatService with attack execution, and the Test Layer added 28 comprehensive tests validating attack mechanics. Key architectural patterns employed include the Service Delegation Pattern for attack resolution, static lookup dictionaries for stamina costs and weapon dice, and defender-wins-ties tie resolution.

---

### New Files Created

#### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/AttackOutcome.cs` | Enum defining hit quality classification (Fumble, Miss, Glancing, Solid, Critical) with damage modifier semantics |
| `RuneAndRust.Core/Enums/AttackType.cs` | Enum defining attack types (Light, Standard, Heavy) with associated stamina costs and weapon dice |
| `RuneAndRust.Core/Models/Combat/AttackResult.cs` | Record encapsulating attack resolution output including outcome, net successes, raw damage, final damage, and hit status |
| `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs` | Contract defining attack resolution operations including melee attacks, stamina costs, defense calculation, and success thresholds |

#### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Implements attack mechanics including hit determination, damage calculation with outcome modifiers, and soak reduction |

#### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/AttackResolutionServiceTests.cs` | Contains 28 tests validating stamina costs, defense calculations, attack outcomes, damage modifiers, and edge cases |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Enemy.cs` | Added `MaxStamina` and `CurrentStamina` properties with default value 35 for enemy stamina parity |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Updated `FromEnemy` factory method to copy stamina values from Enemy source |
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Extended with `ExecutePlayerAttack`, `RemoveDefeatedCombatant`, `CheckVictoryCondition`, and `GetCombatStatus` methods |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added IAttackResolutionService dependency; implemented attack execution, combatant removal, victory checking, and status display; added message builder methods |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added attack command parsing (`attack`, `light`, `heavy`, `status`, `end`) with target resolution and attack type routing |
| `RuneAndRust.Terminal/Program.cs` | Registered `IAttackResolutionService` as Singleton in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added mock for IAttackResolutionService; added 18 new tests for ExecutePlayerAttack, RemoveDefeatedCombatant, CheckVictoryCondition, and GetCombatStatus |
| `RuneAndRust.Tests/Engine/CommandParserTests.cs` | Added mock ICombatService to fix flee command tests with proper EndCombat callback |
| `RuneAndRust.Engine/Services/TextRedactor.cs` | Fixed pseudo-random visibility algorithm to properly distribute word redaction using improved formula |

---

### Code Implementation Details

#### AttackOutcome Enum

**File:** `RuneAndRust.Core/Enums/AttackOutcome.cs`

```csharp
public enum AttackOutcome
{
    Fumble = 0,    // 0 successes AND 1+ botches
    Miss = 1,      // Net successes <= 0 (defender wins ties)
    Glancing = 2,  // Net successes 1-2 (half damage)
    Solid = 3,     // Net successes 3-4 (full damage)
    Critical = 4   // Net successes 5+ (double damage)
}
```

**Semantic Mapping:**
- `Fumble`: Critical failure with potential negative consequences
- `Miss`: Attack failed to connect, no damage dealt
- `Glancing`: Weak hit, deals half damage after modifiers
- `Solid`: Clean hit, deals full damage
- `Critical`: Devastating hit, deals double damage

#### AttackType Enum

**File:** `RuneAndRust.Core/Enums/AttackType.cs`

```csharp
public enum AttackType
{
    Light = 0,     // 15 stamina, d4 damage, +1 to hit
    Standard = 1,  // 25 stamina, d6 damage, no modifier
    Heavy = 2      // 40 stamina, d8 damage, -1 to hit
}
```

**Attack Type Properties:**

| Type | Stamina Cost | Weapon Die | Hit Modifier |
|------|--------------|------------|--------------|
| Light | 15 | d4 | +1 |
| Standard | 25 | d6 | 0 |
| Heavy | 40 | d8 | -1 |

#### AttackResult Record

**File:** `RuneAndRust.Core/Models/Combat/AttackResult.cs`

```csharp
public record AttackResult(
    AttackOutcome Outcome,
    int NetSuccesses,
    int RawDamage,
    int FinalDamage,
    bool IsHit
);
```

**Properties:**
- `Outcome`: The quality classification of the attack roll
- `NetSuccesses`: Attacker's successes minus defender's threshold
- `RawDamage`: Damage before soak reduction, after outcome modifiers
- `FinalDamage`: Final damage after soak, minimum 1 on hit, 0 on miss
- `IsHit`: Boolean indicating whether damage should be applied

#### IAttackResolutionService Interface

**File:** `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs`

**Contract Methods:**
- `AttackResult ResolveMeleeAttack(Combatant attacker, Combatant defender, AttackType attackType)` - Resolves a complete melee attack
- `int GetStaminaCost(AttackType attackType)` - Returns stamina cost for attack type
- `bool CanAffordAttack(Combatant combatant, AttackType attackType)` - Checks stamina availability
- `int CalculateDefenseScore(Combatant defender)` - Calculates 10 + FINESSE - Stress
- `int GetSuccessThreshold(int defenseScore)` - Converts Defense Score to threshold via Defense / 5

#### AttackResolutionService Implementation

**File:** `RuneAndRust.Engine/Services/AttackResolutionService.cs`

**Dependencies:**
- `IDiceService` - For attack dice pool rolls and weapon damage rolls
- `ILogger<AttackResolutionService>` - For structured logging

**Static Configuration Dictionaries:**
```csharp
private static readonly Dictionary<AttackType, int> StaminaCosts = new()
{
    { AttackType.Light, 15 },
    { AttackType.Standard, 25 },
    { AttackType.Heavy, 40 }
};

private static readonly Dictionary<AttackType, int> WeaponDice = new()
{
    { AttackType.Light, 4 },    // d4
    { AttackType.Standard, 6 }, // d6
    { AttackType.Heavy, 8 }     // d8
};

private static readonly Dictionary<AttackType, int> HitModifiers = new()
{
    { AttackType.Light, 1 },    // +1 to hit
    { AttackType.Standard, 0 }, // No modifier
    { AttackType.Heavy, -1 }    // -1 to hit
};
```

**Method: ResolveMeleeAttack**

Attack Resolution Algorithm:
1. Calculate attack pool = `Might + HitModifier`, minimum 1 die
2. Roll attack pool as d10 dice pool (8+ = success, 1 = botch)
3. Calculate Defense Score = `10 + FINESSE - Stress` (Stress defaults to 0)
4. Calculate Success Threshold = `DefenseScore / 5` (rounded down)
5. Calculate Net Successes = `Roll.Successes - Threshold`
6. Determine Outcome:
   - Fumble: 0 successes AND 1+ botches
   - Miss: Net Successes <= 0 (defender wins ties)
   - Glancing: Net Successes 1-2
   - Solid: Net Successes 3-4
   - Critical: Net Successes 5+
7. If hit, calculate Raw Damage = `Might + WeaponDie roll`
8. Apply outcome modifier:
   - Glancing: Raw / 2
   - Critical: Raw * 2
   - Solid: No modifier
9. Calculate Soak = `Sturdiness` (armor future expansion)
10. Calculate Final Damage = `Max(1, ModifiedDamage - Soak)` on hit, 0 on miss

**Defense Calculation Examples:**
| Finesse | Stress | Defense Score | Threshold |
|---------|--------|---------------|-----------|
| 3 | 0 | 13 | 2 |
| 5 | 0 | 15 | 3 |
| 10 | 0 | 20 | 4 |

#### Extended CombatService

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

**New Dependency:**
- `IAttackResolutionService` - For attack resolution delegation

**Method: ExecutePlayerAttack**
```csharp
string ExecutePlayerAttack(string targetName, AttackType attackType)
```
- Validates combat state is active
- Validates it's the player's turn (`IsPlayerTurn` property)
- Finds target by partial name match (case-insensitive)
- Checks stamina affordability via IAttackResolutionService
- Deducts stamina cost from attacker
- Resolves attack via `_attackResolution.ResolveMeleeAttack`
- Applies damage to target on hit
- Checks for death (HP <= 0) and removes defeated combatant
- Checks victory condition (no enemies remain)
- Returns narrative message describing attack result

**Method: RemoveDefeatedCombatant**
```csharp
void RemoveDefeatedCombatant(Combatant combatant)
```
- Removes combatant from TurnOrder list
- Adjusts TurnIndex if removed combatant was before current position
- Wraps TurnIndex to 0 if current position exceeds new list length

**Method: CheckVictoryCondition**
```csharp
bool CheckVictoryCondition()
```
- Returns true if no combatants with `IsPlayer = false` remain in TurnOrder

**Method: GetCombatStatus**
```csharp
string GetCombatStatus()
```
- Formats multi-line combat status string
- Shows round number, all combatants with HP/Stamina, active turn marker

**Message Builder Methods:**
- `BuildHitMessage` - Formats hit messages with outcome text and damage
- `BuildMissMessage` - Formats miss/fumble messages
- `BuildDeathMessage` - Formats fatal blow messages
- `BuildVictoryMessage` - Formats victory messages when last enemy dies

#### Enemy Stamina Addition

**File:** `RuneAndRust.Core/Entities/Enemy.cs`

**New Properties:**
```csharp
public int MaxStamina { get; set; } = 35;
public int CurrentStamina { get; set; } = 35;
```

**Default Value Rationale:**
- Based on formula: 20 + (Finesse * 3) + (Sturdiness * 2)
- With default Finesse=3, Sturdiness=5: 20 + 9 + 10 = 39, rounded to 35

#### Combatant.FromEnemy Update

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

**Change:** Updated factory method to copy stamina values:
```csharp
public static Combatant FromEnemy(Enemy e) => new()
{
    Name = e.Name,
    IsPlayer = false,
    EnemySource = e,
    CurrentHp = e.CurrentHp,
    MaxHp = e.MaxHp,
    CurrentStamina = e.CurrentStamina,  // NEW
    MaxStamina = e.MaxStamina           // NEW
};
```

#### CommandParser Attack Commands

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

**New Combat Commands:**

| Command | Aliases | Description |
|---------|---------|-------------|
| `attack <target>` | `hit`, `strike` | Standard attack (25 stamina, d6) |
| `light <target>` | `quick`, `fast` | Light attack (15 stamina, d4, +1 hit) |
| `heavy <target>` | `power`, `strong` | Heavy attack (40 stamina, d8, -1 hit) |
| `status` | - | Display combat status |
| `end` | `pass`, `wait` | End combat (flee) |

**Target Resolution:**
- Partial name match, case-insensitive
- Example: `attack dummy` matches "Training Dummy"

#### TextRedactor Algorithm Fix

**File:** `RuneAndRust.Engine/Services/TextRedactor.cs`

**Problem:** Original formula `((i * 7 + 13) % 100)` clustered values too low for small word counts, causing all words to be visible even at 50% completion.

**Solution:** Changed to `((i * 37 + 13) % 97 * 100 / 97)` which:
- Uses larger prime multiplier (37) for better spread
- Uses modulo 97 (prime) for more uniform distribution
- Scales back to 0-99 range

---

### Logging Matrix

#### AttackResolutionService

| Event | Level | Template |
|-------|-------|----------|
| Attack resolution start | Information | `"Resolving {AttackType} attack: {Attacker} vs {Defender}"` |
| Attack pool calculation | Debug | `"Attack pool: Base {Base} + Modifier {Mod} = {Pool}"` |
| Roll vs defense | Debug | `"{Attacker} rolled {Successes} successes (Botches: {Botches}) vs Defense {Defense} (Threshold: {Threshold})"` |
| Net successes outcome | Debug | `"Net successes: {Net}, Outcome: {Outcome}, IsHit: {IsHit}"` |
| Raw damage calculation | Debug | `"Raw damage: Might {Might} + d{Die} ({Roll}) = {Raw}"` |
| Final damage calculation | Debug | `"Damage calc: Raw {Raw} - Soak {Soak} = Final {Final}"` |
| Attack resolved | Information | `"Attack resolved: {Outcome} - {Attacker} dealt {Damage} damage to {Defender}"` |
| Defense calculation | Trace | `"Defense calculation for {Defender}: 10 + Finesse({Finesse}) - Stress({Stress}) = {Defense}"` |

#### CombatService (Extended)

| Event | Level | Template |
|-------|-------|----------|
| No combat active (attack) | Warning | `"ExecutePlayerAttack called but no combat is active"` |
| Not player's turn | Debug | `"Attack attempted but it is not the player's turn"` |
| Target not found | Debug | `"Target '{TargetName}' not found in combat"` |
| Insufficient stamina | Debug | `"{Attacker} cannot afford {AttackType} attack. Stamina: {Current}/{Cost}"` |
| Stamina spent | Debug | `"{Attacker} spent {Cost} stamina. Remaining: {Current}/{Max}"` |
| Attack executed | Information | `"{Attacker} attacks {Target} ({AttackType}): {Outcome}"` |
| Damage applied | Debug | `"{Target} took {Damage} damage. HP: {Current}/{Max}"` |
| Target slain | Warning | `"{Target} was slain! HP: 0/{Max}"` |
| Combatant removed | Debug | `"Removed {Name} from turn order"` |
| Combat victory | Information | `"Combat Victory! All enemies defeated."` |

---

### Test Coverage

```
Total: 1257 | Passed: 1257 | Failed: 0 | Duration: 537ms
```

**New Tests Added:** 46 tests (28 AttackResolutionServiceTests + 18 CombatServiceTests extensions)

#### AttackResolutionServiceTests (28 tests)

##### GetStaminaCost Tests

| Test Name | Description |
|-----------|-------------|
| `GetStaminaCost_ReturnsCorrectCost` [Theory] | Validates Light=15, Standard=25, Heavy=40 stamina costs |

##### CanAffordAttack Tests

| Test Name | Description |
|-----------|-------------|
| `CanAffordAttack_WithSufficientStamina_ReturnsTrue` | Validates 60 stamina can afford 25 cost |
| `CanAffordAttack_WithExactStamina_ReturnsTrue` | Validates 25 stamina can afford 25 cost |
| `CanAffordAttack_WithInsufficientStamina_ReturnsFalse` | Validates 24 stamina cannot afford 25 cost |
| `CanAffordAttack_HeavyAttack_RequiresMoreStamina` | Validates 39 stamina cannot afford 40 cost |

##### CalculateDefenseScore Tests

| Test Name | Description |
|-----------|-------------|
| `CalculateDefenseScore_ReturnsCorrectValue` [Theory] | Validates Finesse 1→11, 5→15, 10→20 defense scores |

##### GetSuccessThreshold Tests

| Test Name | Description |
|-----------|-------------|
| `GetSuccessThreshold_ReturnsCorrectValue` [Theory] | Validates Defense 10→2, 11→2, 15→3, 20→4, 5→1 thresholds |

##### ResolveMeleeAttack - Outcome Tests

| Test Name | Description |
|-----------|-------------|
| `ResolveMeleeAttack_WhenMiss_ReturnsNoDamage` | Validates 2 successes vs threshold 3 = Miss with 0 damage |
| `ResolveMeleeAttack_WhenFumble_ReturnsNoDamage` | Validates 0 successes + 2 botches = Fumble with 0 damage |
| `ResolveMeleeAttack_DefenderWinsTies_IsMiss` | Validates 3 successes vs threshold 3 = Miss (net = 0) |
| `ResolveMeleeAttack_GlancingBlow_HalvesDamage` | Validates net 2 = Glancing with half damage |
| `ResolveMeleeAttack_SolidHit_FullDamage` | Validates net 3 = Solid with full damage |
| `ResolveMeleeAttack_CriticalHit_DoublesDamage` | Validates net 6 = Critical with double damage |

##### ResolveMeleeAttack - Attack Type Modifiers

| Test Name | Description |
|-----------|-------------|
| `ResolveMeleeAttack_LightAttack_UsesD4AndBonusToHit` | Validates d4 weapon die and Might+1 pool |
| `ResolveMeleeAttack_HeavyAttack_UsesD8AndPenaltyToHit` | Validates d8 weapon die and Might-1 pool |
| `ResolveMeleeAttack_StandardAttack_UsesD6AndNoModifier` | Validates d6 weapon die and Might pool |

##### ResolveMeleeAttack - Soak and Minimum Damage

| Test Name | Description |
|-----------|-------------|
| `ResolveMeleeAttack_MinimumOneDamage_WhenHit` | Validates minimum 1 damage on hit even with high soak |
| `ResolveMeleeAttack_SoakReducesDamage` | Validates Sturdiness 5 reduces damage by 5 |

##### ResolveMeleeAttack - Edge Cases

| Test Name | Description |
|-----------|-------------|
| `ResolveMeleeAttack_LowMightWithHeavyPenalty_MinimumOneDie` | Validates Might 1 + Heavy (-1) still rolls 1 die minimum |

#### CombatServiceTests - New Tests (18 tests)

##### ExecutePlayerAttack Tests

| Test Name | Description |
|-----------|-------------|
| `ExecutePlayerAttack_WhenNoCombat_ReturnsNotInCombatMessage` | Validates error message when CombatState is null |
| `ExecutePlayerAttack_WhenNotPlayerTurn_ReturnsNotYourTurnMessage` | Validates error message when enemy's turn |
| `ExecutePlayerAttack_TargetNotFound_ReturnsTargetNotFoundMessage` | Validates error message for invalid target name |
| `ExecutePlayerAttack_InsufficientStamina_ReturnsNotEnoughStaminaMessage` | Validates error message when stamina too low |
| `ExecutePlayerAttack_SuccessfulHit_DeductsStamina` | Validates stamina reduced by attack cost |
| `ExecutePlayerAttack_Hit_AppliesDamageToTarget` | Validates target HP reduced by FinalDamage |
| `ExecutePlayerAttack_Miss_DoesNotApplyDamage` | Validates target HP unchanged on miss |
| `ExecutePlayerAttack_KillsEnemy_RemovesFromTurnOrder` | Validates dead enemy removed from TurnOrder |
| `ExecutePlayerAttack_KillsLastEnemy_ReturnsVictoryMessage` | Validates VICTORY message when last enemy dies |
| `ExecutePlayerAttack_PartialMatch_FindsTarget` | Validates "dummy" matches "Training Dummy" |

##### RemoveDefeatedCombatant Tests

| Test Name | Description |
|-----------|-------------|
| `RemoveDefeatedCombatant_RemovesCombatantFromTurnOrder` | Validates combatant removed from list |
| `RemoveDefeatedCombatant_AdjustsTurnIndex_WhenRemovedBeforeCurrent` | Validates TurnIndex decremented when earlier combatant removed |
| `RemoveDefeatedCombatant_DoesNotAdjustTurnIndex_WhenRemovedAfterCurrent` | Validates TurnIndex unchanged when later combatant removed |
| `RemoveDefeatedCombatant_WhenNoCombat_DoesNotThrow` | Validates safe no-op when CombatState is null |

##### CheckVictoryCondition Tests

| Test Name | Description |
|-----------|-------------|
| `CheckVictoryCondition_WhenNoEnemiesRemain_ReturnsTrue` | Validates true when only player in TurnOrder |
| `CheckVictoryCondition_WhenEnemiesRemain_ReturnsFalse` | Validates false when enemies still in TurnOrder |
| `CheckVictoryCondition_WhenNoCombat_ReturnsFalse` | Validates false when CombatState is null |

##### GetCombatStatus Tests

| Test Name | Description |
|-----------|-------------|
| `GetCombatStatus_WhenNoCombat_ReturnsNoActiveCombatMessage` | Validates "No active combat" message |
| `GetCombatStatus_IncludesRoundNumber` | Validates "Round 3" appears in output |
| `GetCombatStatus_IncludesAllCombatants` | Validates player and enemy names appear |
| `GetCombatStatus_ShowsHpAndStamina` | Validates "HP 75/100" and "Stamina 40/60" format |

---

### DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Attack Resolution Service
services.AddSingleton<IAttackResolutionService, AttackResolutionService>();
```

**Justification for Singleton Lifetime:**
- Service is stateless (all state passed via parameters)
- Depends only on IDiceService (Singleton) and ILogger
- Static configuration dictionaries are readonly
- Thread-safe for concurrent combat scenarios

---

### Verification Results

#### Build Output

```
Build succeeded.

    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.84
```

**Note:** Warning MSB3277 regarding EntityFrameworkCore.Relational version conflict is pre-existing and does not affect combat implementation.

#### Test Output

```
Passed!  - Failed:     0, Passed:  1257, Skipped:     0, Total:  1257, Duration: 537 ms
```

**New Tests:**
- AttackResolutionServiceTests: 28/28 passed
- CombatServiceTests (new): 18/18 passed
- TextRedactorTests: 19/19 passed (2 previously failing now fixed)

---

### Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── Character.cs
│   ├── CodexEntry.cs
│   ├── DataCapture.cs
│   ├── Enemy.cs [MODIFIED]
│   ├── InteractableObject.cs
│   ├── Room.cs
│   └── SaveGame.cs
├── Enums/
│   ├── Attribute.cs
│   ├── AttackOutcome.cs [NEW]
│   ├── AttackType.cs [NEW]
│   ├── Direction.cs
│   ├── EquipmentSlot.cs
│   ├── GamePhase.cs
│   ├── ItemRarity.cs
│   ├── ObjectState.cs
│   ├── ObjectType.cs
│   └── PendingGameAction.cs
├── Interfaces/
│   ├── IAttackResolutionService.cs [NEW]
│   ├── ICharacterRepository.cs
│   ├── ICodexEntryRepository.cs
│   ├── ICombatService.cs [MODIFIED]
│   ├── IDataCaptureRepository.cs
│   ├── IDataCaptureService.cs
│   ├── IDescriptorEngine.cs
│   ├── IDiceService.cs
│   ├── IGameService.cs
│   ├── IInitiativeService.cs
│   └── (other interfaces)
├── Models/
│   ├── Combat/
│   │   ├── AttackResult.cs [NEW]
│   │   └── Combatant.cs [MODIFIED]
│   ├── CombatState.cs
│   ├── GameState.cs
│   └── (other model files)

RuneAndRust.Engine/
├── Services/
│   ├── AttackResolutionService.cs [NEW]
│   ├── CombatService.cs [MODIFIED]
│   ├── CommandParser.cs [MODIFIED]
│   ├── DataCaptureService.cs
│   ├── DescriptorEngine.cs
│   ├── DiceService.cs
│   ├── GameService.cs
│   ├── InitiativeService.cs
│   ├── InteractionService.cs
│   ├── JournalService.cs
│   ├── NavigationService.cs
│   ├── SaveManager.cs
│   ├── StatCalculationService.cs
│   └── TextRedactor.cs [MODIFIED]
├── Factories/
│   └── (factory files)
└── (other directories)

RuneAndRust.Tests/
├── Engine/
│   ├── AttackResolutionServiceTests.cs [NEW]
│   ├── CombatServiceTests.cs [MODIFIED]
│   ├── CommandParserTests.cs [MODIFIED]
│   ├── DataCaptureServiceTests.cs
│   ├── DescriptorEngineTests.cs
│   ├── DiceServiceTests.cs
│   ├── InitiativeServiceTests.cs
│   ├── InteractionServiceTests.cs
│   ├── JournalServiceTests.cs
│   ├── NavigationServiceTests.cs
│   ├── StatCalculationServiceTests.cs
│   └── TextRedactorTests.cs
└── (other directories)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── Services/
    ├── CharacterCreationController.cs
    └── TerminalInputHandler.cs
```

---

### Running Tests

#### Run All Tests
```bash
dotnet test
```

#### Run Attack Resolution Tests Only
```bash
dotnet test --filter "FullyQualifiedName~AttackResolutionServiceTests"
```

#### Run Combat Tests (Full Suite)
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests|FullyQualifiedName~AttackResolutionServiceTests"
```

#### Run TextRedactor Tests (Fixed)
```bash
dotnet test --filter "FullyQualifiedName~TextRedactorTests"
```

---

### Next Steps

**Planned for v0.2.0c:**
- Implement enemy AI attack actions during enemy turns
- Add stamina regeneration between rounds
- Implement flee mechanics with FINESSE + WITS check
- Add combat action feedback with colored output
- Implement blocking/defensive stance mechanics

**Planned for v0.2.1:**
- Add status effects (Bleeding, Stunned, Fortified)
- Implement weapon equipment affecting attack type and damage
- Create combat victory rewards (XP, loot drops)
- Add defeat handling (death, respawn, load save)
- Implement multi-target combat encounters

**Planned for v0.2.2:**
- Expand Enemy entity with AI behavior patterns
- Add enemy type definitions (Automaton, Revenant, Beast)
- Implement surprise round mechanics
- Create bestiary entries for Codex system
- Add combat encounter triggers in Exploration phase

---

## Part C: The Interface (Combat UI)

**Release Date:** 2025-12-19

### Summary

This release implements the visual layer for combat in Rune & Rust, transforming debug logs into a playable Terminal User Interface (TUI) using Spectre.Console. The implementation introduces a structured combat screen with three distinct regions: a player stats header bar, an initiative-sorted turn order table, and a rolling combat log panel. Key design pillars enforced include hiding enemy HP as narrative descriptions ("Healthy", "Wounded", "Critical", "Dead") while showing exact player HP/Stamina values, and maintaining dual logging systems where player-visible combat events (with Spectre markup) are separate from Serilog debug traces. The Core Layer gained ViewModels for UI data transformation and a new renderer interface, the Engine Layer extended CombatService with ViewModel generation and combat log management, the Terminal Layer received the CombatScreenRenderer implementation, and the Test Layer added 32 comprehensive tests validating ViewModel generation, narrative health thresholds, and combat log behavior.

---

### Design Pillars

#### Hide Enemy Numbers
- Enemy HP displayed as narrative health: "Healthy" (green), "Wounded" (yellow), "Critical" (red), "Dead" (grey)
- Player HP/Stamina displayed as exact numbers
- Health thresholds: >75% = Healthy, 26-75% = Wounded, 1-25% = Critical, 0% = Dead

#### Dual Logging System
- **Combat Log**: Player-visible rolling buffer (max 10 events) with Spectre markup for TUI display
- **Serilog**: Debug/trace logging for development and diagnostics
- Both systems receive entries but serve different purposes

#### Separation of Concerns
- **ViewModel Pattern**: CombatState transformed to CombatViewModel for display
- **Renderer Interface**: ICombatScreenRenderer allows testability (nullable in GameService)
- **ViewModels in Core Layer**: Avoids circular dependency with ICombatService

---

### New Files Created

#### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Record types for combat UI data transformation: CombatViewModel, CombatantView, PlayerStatsView |
| `RuneAndRust.Core/Interfaces/ICombatScreenRenderer.cs` | Contract defining combat UI rendering with Render(CombatViewModel) method |

#### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Spectre.Console implementation rendering header, turn order table, and combat log panel |

---

### Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Added `GetViewModel()` and `LogCombatEvent(string)` method signatures |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added combat log queue, ViewModel generation, narrative health mapping, Spectre markup message builders |
| `RuneAndRust.Engine/Services/GameService.cs` | Added ICombatService and ICombatScreenRenderer dependencies; integrated combat screen rendering in game loop |
| `RuneAndRust.Terminal/Program.cs` | Registered CombatScreenRenderer in DI container; updated version to v0.2.0c |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added 32 new tests for LogCombatEvent, GetViewModel, narrative health thresholds, and combat log integration |
| `RuneAndRust.Tests/Engine/GameServiceTests.cs` | Updated GameService constructor calls with new ICombatService and ICombatScreenRenderer parameters |
| `RuneAndRust.Tests/Engine/GameLoopTests.cs` | Updated GameService constructor calls with new ICombatService and ICombatScreenRenderer parameters |

---

### Code Implementation Details

#### CombatViewModel Records

**File:** `RuneAndRust.Core/ViewModels/CombatViewModel.cs`

```csharp
public record CombatViewModel(
    int RoundNumber,
    string ActiveCombatantName,
    List<CombatantView> TurnOrder,
    List<string> CombatLog,
    PlayerStatsView PlayerStats
);

public record CombatantView(
    Guid Id,
    string Name,
    bool IsPlayer,
    bool IsActive,
    string HealthStatus,    // "75/100" for player, "[green]Healthy[/]" for enemy
    string StatusEffects,   // Placeholder for future expansion
    string InitiativeDisplay
);

public record PlayerStatsView(
    int CurrentHp,
    int MaxHp,
    int CurrentStamina,
    int MaxStamina
);
```

**Design Rationale:**
- Immutable records ensure thread-safety and predictable state
- HealthStatus contains pre-formatted display strings (Spectre markup for enemies)
- StatusEffects reserved for future status effect icons
- PlayerStats separated for header rendering convenience

#### ICombatScreenRenderer Interface

**File:** `RuneAndRust.Core/Interfaces/ICombatScreenRenderer.cs`

```csharp
public interface ICombatScreenRenderer
{
    void Render(CombatViewModel viewModel);
}
```

**Contract:**
- Single method renders complete combat screen
- Clears terminal before rendering
- Displays header (player stats), turn order table, and combat log panel

#### CombatScreenRenderer Implementation

**File:** `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`

**Dependencies:**
- `ILogger<CombatScreenRenderer>` - For trace logging
- Spectre.Console - For TUI rendering

**Layout Structure:**
```
┌─ COMBAT ───────────────────────────────────────────┐
│   HP: 75/100    Stamina: 40/60                     │ <- RenderHeader
├────────────────────────────────────────────────────┤
│ Init │ Name              │ Condition               │ <- RenderTurnOrder
│   15 │ > TestPlayer      │ 75/100                  │
│   12 │   Training Dummy  │ [yellow]Wounded[/]      │
├────────────────────────────────────────────────────┤
│ ╔══════════════════════════════════════════════════╗
│ ║ Round 1                                          ║ <- RenderCombatLog
│ ║ [bold]Combat begins![/]                          ║
│ ║ [cyan]Player[/] faces [red]Training Dummy[/].    ║
│ ╚══════════════════════════════════════════════════╝
└────────────────────────────────────────────────────┘
```

**Method: RenderHeader**
```csharp
private static void RenderHeader(PlayerStatsView stats)
```
- Displays HP with color coding (green >50%, yellow 25-50%, red <25%)
- Displays Stamina with color coding (cyan >50%, yellow 25-50%, red <25%)
- Uses Spectre.Console Rule for header separator

**Method: RenderTurnOrder**
```csharp
private static void RenderTurnOrder(List<CombatantView> turnOrder)
```
- Creates Spectre Table with Init, Name, Condition columns
- Active combatant marked with `>` prefix in yellow
- Player names displayed in cyan, enemy names in red
- Health status passed through (pre-formatted with Spectre markup)

**Method: RenderCombatLog**
```csharp
private static void RenderCombatLog(int roundNumber, List<string> combatLog)
```
- Creates Spectre Panel with heavy border
- Header shows current round number
- Displays all combat log entries (up to 10)
- Empty log shows "[grey]No combat events yet.[/]"

**Method: EscapeMarkup**
```csharp
private static string EscapeMarkup(string text)
```
- Escapes `[` and `]` to prevent Spectre markup injection
- Applied to combatant names for safety

#### Extended ICombatService Interface

**File:** `RuneAndRust.Core/Interfaces/ICombatService.cs`

**New Method Signatures:**
```csharp
CombatViewModel? GetViewModel();
void LogCombatEvent(string message);
```

**GetViewModel Contract:**
- Returns null if no combat is active
- Returns null if no player is in turn order (abnormal state)
- Transforms CombatState to display-ready CombatViewModel
- Converts enemy HP to narrative descriptions

**LogCombatEvent Contract:**
- Adds message to rolling buffer (max 10 entries)
- Oldest entry removed when buffer is full
- Messages may contain Spectre markup

#### Extended CombatService Implementation

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

**New Fields:**
```csharp
private readonly Queue<string> _combatLog = new();
private const int MaxLogHistory = 10;
```

**Method: LogCombatEvent**
```csharp
public void LogCombatEvent(string message)
{
    if (_combatLog.Count >= MaxLogHistory)
    {
        _combatLog.Dequeue();
    }
    _combatLog.Enqueue(message);
    _logger.LogTrace("Combat log: {Message}", message);
}
```
- FIFO queue maintains insertion order
- Dequeues oldest when at capacity
- Mirrors entry to Serilog at Trace level

**Method: GetViewModel**
```csharp
public CombatViewModel? GetViewModel()
```
- Returns null on invalid state (no combat, no player)
- Maps each Combatant to CombatantView via `MapToView`
- Converts combat log queue to list snapshot
- Creates PlayerStatsView from player Combatant

**Method: MapToView**
```csharp
private static CombatantView MapToView(Combatant combatant, Combatant? activeCombatant)
```
- Player health: `"{CurrentHp}/{MaxHp}"` (exact numbers)
- Enemy health: Calls `GetNarrativeHealth` for narrative description
- IsActive determined by ID comparison with active combatant

**Method: GetNarrativeHealth**
```csharp
private static string GetNarrativeHealth(Combatant combatant)
```
- Returns Spectre-formatted health descriptions:
  - `<= 0%`: `"[grey]Dead[/]"`
  - `<= 25%`: `"[red]Critical[/]"`
  - `<= 75%`: `"[yellow]Wounded[/]"`
  - `> 75%`: `"[green]Healthy[/]"`
- Handles edge case of `MaxHp <= 0` returning `"Unknown"`

**New Message Builders:**
```csharp
private static string BuildLogMessage(AttackResult result, Combatant target,
    bool isDeath = false, bool isVictory = false)
private static string BuildMissLogMessage(AttackResult result, Combatant target)
```
- Create Spectre-formatted strings for combat log display
- Different from existing `BuildHitMessage`/`BuildMissMessage` (plain text for input handler)

**StartCombat Updates:**
```csharp
_combatLog.Clear();
LogCombatEvent("[bold]Combat begins![/]");
LogCombatEvent($"[cyan]{player.Name}[/] faces {string.Join(", ", enemies.Select(e => $"[red]{e.Name}[/]"))}.");
```
- Clears log from previous combat
- Adds initial combat messages with Spectre markup

**ExecutePlayerAttack Updates:**
- Calls `LogCombatEvent(BuildLogMessage(...))` on hit/death/victory
- Calls `LogCombatEvent(BuildMissLogMessage(...))` on miss

#### Extended GameService

**File:** `RuneAndRust.Engine/Services/GameService.cs`

**New Dependencies:**
```csharp
private readonly ICombatService _combatService;
private readonly ICombatScreenRenderer? _combatRenderer;
```

**Constructor Update:**
```csharp
public GameService(
    ILogger<GameService> logger,
    IInputHandler inputHandler,
    CommandParser parser,
    GameState state,
    ICombatService combatService,
    ICombatScreenRenderer? combatRenderer = null)
```
- `combatRenderer` is nullable for testability
- Tests can pass `null` to skip rendering

**Game Loop Update:**
```csharp
while (_state.Phase != GamePhase.Quit)
{
    // 1. Render combat UI if in combat phase
    if (_state.Phase == GamePhase.Combat && _combatRenderer != null)
    {
        var viewModel = _combatService.GetViewModel();
        if (viewModel != null)
        {
            _combatRenderer.Render(viewModel);
        }
    }

    // 2. Get input and process...
}
```
- Combat screen renders before each input prompt when in Combat phase
- Null checks prevent crashes when renderer not available or no combat active

---

### Logging Matrix

#### CombatScreenRenderer

| Event | Level | Template |
|-------|-------|----------|
| Combat screen rendered | Trace | `"Rendered combat screen"` |

#### CombatService (New Entries)

| Event | Level | Template |
|-------|-------|----------|
| Combat log event added | Trace | `"Combat log: {Message}"` |
| ViewModel generated | Trace | `"Generated CombatViewModel for Round {Round}"` |

#### GameService

| Event | Level | Template |
|-------|-------|----------|
| Game loop initialized | Information | `"Game Loop Initialized."` |
| Game loop ended | Information | `"Game Loop Ended. Shutting down."` |

---

### Test Coverage

```
Total: 1289 | Passed: 1289 | Failed: 0 | Duration: 558ms
```

**New Tests Added:** 32 tests in CombatServiceTests

#### LogCombatEvent Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `LogCombatEvent_AddsMessageToLog` | Validates message appears in GetViewModel().CombatLog |
| `LogCombatEvent_MaxTenEntries_RemovesOldest` | Validates 12 entries reduces to 10, oldest removed |
| `LogCombatEvent_PreservesInsertionOrder` | Validates FIFO order maintained in log |

#### GetViewModel Tests (14 tests)

| Test Name | Description |
|-----------|-------------|
| `GetViewModel_WhenNoCombat_ReturnsNull` | Validates null when CombatState is null |
| `GetViewModel_ReturnsCorrectRoundNumber` | Validates RoundNumber matches state |
| `GetViewModel_ReturnsActiveCombatantName` | Validates ActiveCombatantName from state |
| `GetViewModel_ReturnsAllCombatantsInTurnOrder` | Validates TurnOrder count and order |
| `GetViewModel_MarksActiveCombatant` | Validates IsActive flag on active combatant |
| `GetViewModel_PlayerShowsExactHpNumbers` | Validates player HealthStatus is "75/100" format |
| `GetViewModel_EnemyShowsNarrativeHealth_Healthy` | Validates "Healthy" at 100% HP |
| `GetViewModel_EnemyShowsNarrativeHealth_Wounded` | Validates "Wounded" at 50% HP |
| `GetViewModel_EnemyShowsNarrativeHealth_Critical` | Validates "Critical" at 20% HP |
| `GetViewModel_EnemyShowsNarrativeHealth_Dead` | Validates "Dead" at 0% HP |
| `GetViewModel_IncludesPlayerStats` | Validates PlayerStats HP/Stamina values |
| `GetViewModel_IncludesCombatLog` | Validates CombatLog contains logged events |
| `GetViewModel_WhenNoPlayer_ReturnsNull` | Validates null when only enemies in combat |

#### Narrative Health Thresholds Tests (9 tests via Theory)

| Test Name | Description |
|-----------|-------------|
| `GetViewModel_NarrativeHealthThresholds_AreCorrect` [Theory] | Validates boundary conditions: 100%→Healthy, 76%→Healthy, 75%→Wounded, 50%→Wounded, 26%→Wounded, 25%→Critical, 10%→Critical, 1%→Critical, 0%→Dead |

#### StartCombat Combat Log Tests (3 tests)

| Test Name | Description |
|-----------|-------------|
| `StartCombat_ClearsPreviousCombatLog` | Validates new combat clears old log entries |
| `StartCombat_AddsInitialCombatBeginsMessage` | Validates "Combat begins!" in log |
| `StartCombat_LogsEnemyNames` | Validates enemy names appear in initial log |

#### ExecutePlayerAttack Combat Log Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `ExecutePlayerAttack_Hit_LogsToCombatLog` | Validates hit adds entry with target name |
| `ExecutePlayerAttack_Miss_LogsToCombatLog` | Validates miss/evade logged |
| `ExecutePlayerAttack_Critical_LogsCriticalMessage` | Validates "CRITICAL" in log on crit |
| `ExecutePlayerAttack_Victory_LogsVictoryMessage` | Validates "VICTORY" in log on last kill |

---

### DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<IAttackResolutionService, AttackResolutionService>();
services.AddSingleton<ICombatService, CombatService>();
services.AddSingleton<ICombatScreenRenderer, CombatScreenRenderer>();
```

**Justification for Singleton Lifetime:**
- `CombatScreenRenderer` is stateless (all state passed via ViewModel)
- Depends only on ILogger (transient-safe)
- Console output is inherently single-threaded
- Matches other combat service lifetimes

---

### Verification Results

#### Build Output

```
Build succeeded.

    63 Warning(s)
    0 Error(s)

Time Elapsed 00:00:03.20
```

**Note:** Warnings are pre-existing EntityFrameworkCore version conflicts and xUnit async advisories, unrelated to this release.

#### Test Output

```
Passed!  - Failed:     0, Passed:  1289, Skipped:     0, Total:  1289, Duration: 558 ms
```

**Test Progression:**
- v0.2.0b: 1257 tests
- v0.2.0c: 1289 tests (+32 new tests)

---

### Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   └── (unchanged)
├── Enums/
│   └── (unchanged)
├── Interfaces/
│   ├── ICombatScreenRenderer.cs [NEW]
│   ├── ICombatService.cs [MODIFIED]
│   └── (other interfaces unchanged)
├── Models/
│   └── (unchanged)
└── ViewModels/
    └── CombatViewModel.cs [NEW]

RuneAndRust.Engine/
├── Services/
│   ├── CombatService.cs [MODIFIED]
│   ├── GameService.cs [MODIFIED]
│   └── (other services unchanged)
└── (other directories unchanged)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── Services/
    ├── CharacterCreationController.cs
    ├── CombatScreenRenderer.cs [NEW]
    └── TerminalInputHandler.cs

RuneAndRust.Tests/
├── Engine/
│   ├── CombatServiceTests.cs [MODIFIED +32 tests]
│   ├── GameLoopTests.cs [MODIFIED - constructor params]
│   ├── GameServiceTests.cs [MODIFIED - constructor params]
│   └── (other test files unchanged)
└── (other directories unchanged)
```

---

### Running Tests

#### Run All Tests
```bash
dotnet test
```

#### Run Combat ViewModel Tests Only
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests.GetViewModel"
```

#### Run Combat Log Tests Only
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests.LogCombatEvent"
```

#### Run Narrative Health Threshold Tests
```bash
dotnet test --filter "FullyQualifiedName~NarrativeHealthThresholds"
```

---

### Next Steps

**Planned for v0.2.0d:**
- Implement enemy AI attack actions during enemy turns
- Add stamina regeneration between rounds
- Implement flee mechanics with FINESSE + WITS check
- Add blocking/defensive stance mechanics

**Planned for v0.2.1:**
- Add status effects (Bleeding, Stunned, Fortified)
- Implement weapon equipment affecting attack type and damage
- Create combat victory rewards (XP, loot drops)
- Add defeat handling (death, respawn, load save)
- Implement multi-target combat encounters

**Planned for v0.2.2:**
- Expand Enemy entity with AI behavior patterns
- Add enemy type definitions (Automaton, Revenant, Beast)
- Implement surprise round mechanics
- Create bestiary entries for Codex system
- Add combat encounter triggers in Exploration phase
