# v0.0.9d Implementation Plan: Loot & Currency

**Version:** 0.0.9d
**Parent:** v0.0.9 (Monster Variety & Loot)
**Prerequisites:** v0.0.9c Complete (Monster Tiers & Traits)
**Design Specification:** [v0.0.9d-design-specification.md](v0.0.9d-design-specification.md)
**Status:** Ready for Implementation
**Target Tests:** ~356 -> ~382 (+26 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
   - [Configuration](#configuration)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose
This implementation phase creates the foundational economy and reward systems for Rune and Rust. We will implement a configurable currency system (with Gold as the default) and a data-driven loot table system. When monsters are defeated, they will now drop items and currency based on weighted probabilities and tier multipliers. This loot persists in the room until collected by the player, creating a tangible sense of reward and progression.

### Scope
- **In Scope:**
  - `CurrencyDefinition` for configurable currencies (Gold, Souls, etc.).
  - `LootTable`, `LootEntry`, `CurrencyDrop`, and `LootDrop` for defining and generating rewards.
  - `LootService` to calculate drops based on monster definitions and tier multipliers.
  - Updates to `Player` to track currency.
  - Updates to `Room` to hold dropped loot.
  - Updates to `Monster` and `MonsterDefinition` to link to loot tables.
  - `loot` and `take` commands in `GameSessionService`.
  - `status` command update to show currency.
  - JSON configuration for currencies and monster loot tables.

- **Out of Scope:**
  - Shops, vendors, and trading.
  - Item crafting or complex inventory management (beyond basic pickup).
  - Spending currency (future versions).

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Loot Persistence** | Stored in Room | Allows players to return to uncollected loot and decouples combat from inventory management. |
| **Percentage Math** | Float (0.0-1.0) | Standard probability representation for drop chances. |
| **Currency Storage** | Dictionary<string, int> on Player | Flexible support for multiple currency types without hardcoding fields. |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.9c (Monster Tiers & Traits)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `Monster.LootMultiplier` | `src/Core/RuneAndRust.Domain/Entities/Monster.cs` | Used to multiply currency amounts and drop chances. |
| `MonsterDefinition` | `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs` | Updated to include `LootTable`. |

---

## Current System Analysis

### Existing Reward System
Currently, defeating a monster grants Experience Points (XP) immediately. There are no items or currency dropped.

### New Reward Flow
```
Combat Ends (Victory)
    â”œâ”€â”€ Calculate XP (Existing)
    â”œâ”€â”€ Generate Loot (New)
    â”‚   â”œâ”€â”€ Roll for Items (LootTable)
    â”‚   â”œâ”€â”€ Roll for Currency (LootTable)
    â”‚   â””â”€â”€ Apply Tier Multiplier
    â””â”€â”€ Add Loot to Room
        â””â”€â”€ Player notified: "The Goblin dropped 5 Gold!"
```

---

## Detailed Implementation

### Domain Layer

#### 1. CurrencyDefinition.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/CurrencyDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

public class CurrencyDefinition
{
    public string Id { get; init; } = string.Empty;
    public string Name { get; init; } = string.Empty;
    public string PluralName { get; init; } = string.Empty;
    public string Symbol { get; init; } = string.Empty;
    public string Color { get; init; } = "yellow";
    public int SortOrder { get; init; } = 0;

    public static CurrencyDefinition Create(
        string id, string name, string pluralName, string symbol,
        string color = "yellow", int sortOrder = 0)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        
        return new CurrencyDefinition
        {
            Id = id.ToLowerInvariant(), Name = name, PluralName = pluralName,
            Symbol = symbol, Color = color, SortOrder = sortOrder
        };
    }

    public string GetDisplayName(int amount) => amount == 1 ? Name : PluralName;
    public static CurrencyDefinition Gold => Create("gold", "Gold", "Gold", "G", "yellow", 0);
}
```

#### 2. LootEntry.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootEntry.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

public readonly record struct LootEntry
{
    public string ItemId { get; init; }
    public int Weight { get; init; }
    public int MinQuantity { get; init; }
    public int MaxQuantity { get; init; }
    public float DropChance { get; init; }

    public static LootEntry Create(string itemId, int weight = 100, int minQuantity = 1, int maxQuantity = 1, float dropChance = 1.0f)
    {
        return new LootEntry { ItemId = itemId.ToLowerInvariant(), Weight = weight, MinQuantity = minQuantity, MaxQuantity = maxQuantity, DropChance = Math.Clamp(dropChance, 0f, 1f) };
    }
}
```

#### 3. CurrencyDrop.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CurrencyDrop.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

public readonly record struct CurrencyDrop
{
    public string CurrencyId { get; init; }
    public int MinAmount { get; init; }
    public int MaxAmount { get; init; }
    public float DropChance { get; init; }

    public static CurrencyDrop Create(string currencyId, int minAmount, int maxAmount, float dropChance = 1.0f)
    {
        return new CurrencyDrop { CurrencyId = currencyId.ToLowerInvariant(), MinAmount = minAmount, MaxAmount = maxAmount, DropChance = Math.Clamp(dropChance, 0f, 1f) };
    }
}
```

#### 4. DroppedItem.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DroppedItem.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

public readonly record struct DroppedItem
{
    public string ItemId { get; init; }
    public string Name { get; init; }
    public int Quantity { get; init; }

    public static DroppedItem Create(string itemId, string name, int quantity = 1)
    {
        return new DroppedItem { ItemId = itemId, Name = name, Quantity = quantity };
    }
}
```

#### 5. LootDrop.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

public readonly record struct LootDrop
{
    public IReadOnlyList<DroppedItem> Items { get; init; }
    public IReadOnlyDictionary<string, int> Currency { get; init; }

    public bool IsEmpty => (Items == null || Items.Count == 0) && (Currency == null || Currency.Count == 0);
    public static LootDrop Empty => new() { Items = [], Currency = new Dictionary<string, int>() };

    public static LootDrop Create(IEnumerable<DroppedItem>? items = null, IDictionary<string, int>? currency = null)
    {
        return new LootDrop
        {
            Items = items?.ToList() ?? [],
            Currency = currency != null ? new Dictionary<string, int>(currency) : new Dictionary<string, int>()
        };
    }
    
    // CombineWith method implementation as per design spec
    public LootDrop CombineWith(LootDrop other) { /* ... implementation ... */ return this; } // Simplified for brevity here
}
```

#### 6. LootTable.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/LootTable.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

public class LootTable
{
    public IReadOnlyList<LootEntry> Entries { get; init; } = [];
    public IReadOnlyList<CurrencyDrop> CurrencyDrops { get; init; } = [];

    public static LootTable Create(IEnumerable<LootEntry>? entries = null, IEnumerable<CurrencyDrop>? currencyDrops = null)
    {
        return new LootTable { Entries = entries?.ToList() ?? [], CurrencyDrops = currencyDrops?.ToList() ?? [] };
    }
}
```

#### 7. Update MonsterDefinition.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`

```csharp
// Add Property
public LootTable? LootTable { get; init; }

// Modify Create to accept lootTable
```

#### 8. Update Player.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`

```csharp
private readonly Dictionary<string, int> _currency = new(StringComparer.OrdinalIgnoreCase);
public IReadOnlyDictionary<string, int> Currency => _currency.AsReadOnly();

public void AddCurrency(string currencyId, int amount) { /* ... */ }
public bool RemoveCurrency(string currencyId, int amount) { /* ... */ }
public int GetCurrency(string currencyId) { /* ... */ }
```

#### 9. Update Room.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

```csharp
private readonly List<DroppedItem> _droppedItems = [];
private readonly Dictionary<string, int> _droppedCurrency = new(StringComparer.OrdinalIgnoreCase);

public IReadOnlyList<DroppedItem> DroppedItems => _droppedItems.AsReadOnly();
public IReadOnlyDictionary<string, int> DroppedCurrency => _droppedCurrency.AsReadOnly();

public void AddLoot(LootDrop loot) { /* ... */ }
public LootDrop CollectAllLoot() { /* ... */ }
```

### Application Layer

#### 10. ILootService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/ILootService.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

public interface ILootService
{
    LootDrop GenerateLoot(Monster monster);
    LootDrop GenerateLoot(MonsterDefinition definition, float lootMultiplier);
    LootDrop CollectLoot(Player player, Room room);
    CurrencyDefinition? GetCurrency(string currencyId);
    IReadOnlyList<CurrencyDefinition> GetAllCurrencies();
}
```

#### 11. Update IConfigurationProvider.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`

```csharp
IReadOnlyList<CurrencyDefinition> GetCurrencies();
CurrencyDefinition? GetCurrencyById(string currencyId);
```

#### 12. LootService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/LootService.cs`

```csharp
public class LootService : ILootService
{
    // dependency injection...

    public LootDrop GenerateLoot(Monster monster)
    {
        var def = _monsterService.GetMonsterDefinition(monster.DefinitionId);
        if (def == null) return LootDrop.Empty;
        return GenerateLoot(def, monster.LootMultiplier);
    }

    public LootDrop GenerateLoot(MonsterDefinition definition, float lootMultiplier)
    {
        if (definition.LootTable == null) return LootDrop.Empty;

        var items = new List<DroppedItem>();
        var currency = new Dictionary<string, int>();

        // Currency Logic
        foreach (var drop in definition.LootTable.CurrencyDrops)
        {
            if (_random.NextSingle() <= (drop.DropChance * lootMultiplier))
            {
                int amount = _random.Next(drop.MinAmount, drop.MaxAmount + 1);
                amount = (int)(amount * lootMultiplier);
                if (amount > 0) currency[drop.CurrencyId] = amount;
            }
        }
        
        // Item Logic (Simplified for now - expand in future if needed)
        // ...

        return LootDrop.Create(items, currency);
    }

    public LootDrop CollectLoot(Player player, Room room)
    {
        var loot = room.CollectAllLoot();
        if (loot.IsEmpty) return loot;

        foreach (var kvp in loot.Currency)
        {
            player.AddCurrency(kvp.Key, kvp.Value);
        }
        // Add items to player inventory (when inventory exists)

        return loot;
    }
}
```

### Infrastructure Layer

#### 13. Update JsonConfigurationProvider.cs (MODIFY)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`

```csharp
// Implement GetCurrencies() loading from currency.json
// Update monster loading to parse embedded LootTable
```

### Configuration

#### 14. currency.json (NEW)

**File:** `config/currency.json`

```json
{
  "currencies": [
    { "id": "gold", "name": "Gold", "pluralName": "Gold", "symbol": "G", "color": "yellow", "sortOrder": 0 }
  ]
}
```

#### 15. Update monsters.json (MODIFY)

**File:** `config/monsters.json`

Add `lootTable` to monsters.
```json
{
  "id": "goblin",
  "lootTable": {
    "currencyDrops": [
      { "currencyId": "gold", "minAmount": 1, "maxAmount": 5, "dropChance": 0.5 }
    ]
  }
}
```

### Presentation Layer

#### 16. Update GameSessionService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

- **Combat Victory**: Call `LootService.GenerateLoot`, then `Room.AddLoot`. Display message: "The monster dropped [Loot Details]!".
- **Command `loot` / `take`**: Call `LootService.CollectLoot`. Display message: "You collected [Loot Details].".
- **Command `status`**: Display current currency (e.g., "Gold: 50").
- **Command `look`**: Display "There is loot here: [Loot Details]" if room has loot.

#### 17. Update SpectreGameRenderer.cs (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

- Support rendering `LootDrop` nicely (e.g., "5 Gold" in yellow).
- Update status panel to show currency.

---

## Flow Diagrams

### Loot Generation Flow

```
Monster Defeated (Tier: Elite, LootMult: 2.0)
       â”‚
       â–¼
LootService.GenerateLoot(Monster)
       â”‚
       â”œâ”€â”€ Currency Drop: Gold (Chance: 0.5 * 2.0 = 1.0) -> Guaranteed
       â”œâ”€â”€ Amount: Random(1, 5) * 2.0 -> e.g., 3 * 2 = 6 Gold
       â”‚
       â–¼
Result: LootDrop { Currency: { "Gold": 6 } }
       â”‚
       â–¼
Room.AddLoot(Result)
       â”‚
       â–¼
Renderer: "The Elite Goblin dropped 6 Gold!"
```

### Loot Collection Flow

```
Player types "take" or "loot"
       â”‚
       â–¼
LootService.CollectLoot(Player, Room)
       â”‚
       â”œâ”€â”€ Room.CollectAllLoot() -> Returns { "Gold": 6 }
       â”‚   â””â”€â”€ Room loot cleared
       â”‚
       â”œâ”€â”€ Player.AddCurrency("gold", 6)
       â”‚
       â–¼
Result: LootDrop { "Gold": 6 }
       â”‚
       â–¼
Renderer: "You collected 6 Gold."
```

---

## Testing Strategy

### Test Files

#### 1. CurrencyDefinitionTests.cs
**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/CurrencyDefinitionTests.cs`
- `GetDisplayName_ReturnsSingularOrPlural`

#### 2. LootServiceTests.cs
**File:** `tests/RuneAndRust.Application.UnitTests/Services/LootServiceTests.cs`
- `GenerateLoot_AppliesMultipliers`
- `GenerateLoot_RespectsDropChances`
- `CollectLoot_TransfersToPlayer`
- `CollectLoot_ClearsRoom`

#### 3. RoomTests.cs (Update)
**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/RoomTests.cs`
- `AddLoot_AccumulatesCurrency`
- `CollectAllLoot_ReturnsAndClears`

#### 4. PlayerTests.cs (Update)
**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerTests.cs`
- `AddCurrency_IncreasesAmount`
- `RemoveCurrency_DecreasesAmount`
- `RemoveCurrency_ReturnsFalseAssumingInsufficientFunds`

---

## Logging Strategy

| Operation | Level | Example |
|-----------|-------|---------|
| Loot Gen | Info | "Generated loot for Goblin: 5 Gold" |
| Loot Collect| Info | "Player collected: 5 Gold" |

---

## Implementation Checklist

> **Legend:** ğŸŸ¢ No dependencies | ğŸŸ¡ Has dependencies | ğŸ”´ Critical path
> **Complexity:** â­ Simple | â­â­ Moderate | â­â­â­ Complex

---

### Phase 1: Domain Layer (Value Objects & Definitions)

#### 1.1 Create `CurrencyDefinition.cs` ğŸŸ¢ â­â­

**File:** `src/Core/RuneAndRust.Domain/Definitions/CurrencyDefinition.cs`

- [ ] Create new file in `Definitions/` directory
- [ ] Add namespace: `RuneAndRust.Domain.Definitions`
- [ ] Add XML documentation for class
- [ ] **Properties (all `init`-only):**
  - [ ] `string Id` - unique identifier (normalized lowercase)
  - [ ] `string Name` - singular display name ("Gold")
  - [ ] `string PluralName` - plural display name ("Gold", or "Gems" for "Gem")
  - [ ] `string Symbol` - compact symbol ("G", "ğŸ’")
  - [ ] `string Color` - Spectre.Console color name (default: "yellow")
  - [ ] `int SortOrder` - display ordering (default: 0)
- [ ] **Factory method `Create()`:**
  - [ ] Validate `Id`, `Name`, `PluralName`, `Symbol` not null/whitespace
  - [ ] Normalize `Id` to lowercase
  - [ ] Return new instance with validated values
- [ ] **Method `GetDisplayName(int amount)`:**
  - [ ] Return `Name` if amount == 1, else `PluralName`
- [ ] **Static property `Gold`:**
  - [ ] Returns default gold currency: id="gold", name="Gold", symbol="G", color="yellow"

**Acceptance:** `CurrencyDefinition.Gold.GetDisplayName(5)` returns "Gold". Validation rejects empty names.

---

#### 1.2 Create `LootEntry.cs` ğŸŸ¢ â­â­

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootEntry.cs`

- [ ] Create new file in `ValueObjects/` directory
- [ ] Add namespace: `RuneAndRust.Domain.ValueObjects`
- [ ] Define as `readonly record struct` (immutable value object)
- [ ] Add XML documentation for struct
- [ ] **Properties (all `init`-only):**
  - [ ] `string ItemId` - ID of item to drop (normalized lowercase)
  - [ ] `int Weight` - relative weight for selection (default: 100)
  - [ ] `int MinQuantity` - minimum quantity to drop (default: 1)
  - [ ] `int MaxQuantity` - maximum quantity to drop (default: 1)
  - [ ] `float DropChance` - probability 0.0-1.0 (default: 1.0f)
- [ ] **Factory method `Create()`:**
  - [ ] Validate `ItemId` not null/whitespace
  - [ ] Validate `Weight > 0`
  - [ ] Validate `MinQuantity >= 0`
  - [ ] Validate `MaxQuantity >= MinQuantity`
  - [ ] Clamp `DropChance` to 0.0-1.0 range
  - [ ] Normalize `ItemId` to lowercase
  - [ ] Return new instance

**Acceptance:** `LootEntry.Create("health_potion", 50, 1, 2, 0.25f)` creates valid entry.

---

#### 1.3 Create `CurrencyDrop.cs` ğŸŸ¢ â­â­

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CurrencyDrop.cs`

- [ ] Create new file in `ValueObjects/` directory
- [ ] Add namespace: `RuneAndRust.Domain.ValueObjects`
- [ ] Define as `readonly record struct`
- [ ] Add XML documentation
- [ ] **Properties (all `init`-only):**
  - [ ] `string CurrencyId` - ID of currency to drop
  - [ ] `int MinAmount` - minimum amount to drop
  - [ ] `int MaxAmount` - maximum amount to drop
  - [ ] `float DropChance` - probability 0.0-1.0 (default: 1.0f)
- [ ] **Factory method `Create()`:**
  - [ ] Validate `CurrencyId` not null/whitespace
  - [ ] Validate `MinAmount >= 0`
  - [ ] Validate `MaxAmount >= MinAmount`
  - [ ] Clamp `DropChance` to 0.0-1.0 range
  - [ ] Normalize `CurrencyId` to lowercase
  - [ ] Return new instance

**Acceptance:** `CurrencyDrop.Create("gold", 5, 15, 0.8f)` creates valid drop.

---

#### 1.4 Create `DroppedItem.cs` ğŸŸ¢ â­

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DroppedItem.cs`

- [ ] Create new file in `ValueObjects/` directory
- [ ] Add namespace: `RuneAndRust.Domain.ValueObjects`
- [ ] Define as `readonly record struct`
- [ ] Add XML documentation
- [ ] **Properties (all `init`-only):**
  - [ ] `string ItemId` - ID of the dropped item
  - [ ] `string Name` - display name of the item
  - [ ] `int Quantity` - amount dropped (default: 1)
- [ ] **Factory method `Create(string itemId, string name, int quantity = 1)`:**
  - [ ] Return new instance with provided values

**Acceptance:** `DroppedItem.Create("health_potion", "Health Potion", 2)` creates valid item.

---

#### 1.5 Create `LootDrop.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs`
**Depends on:** 1.4 (uses `DroppedItem`)

- [ ] Create new file in `ValueObjects/` directory
- [ ] Add namespace: `RuneAndRust.Domain.ValueObjects`
- [ ] Define as `readonly record struct`
- [ ] Add XML documentation
- [ ] **Properties (all `init`-only):**
  - [ ] `IReadOnlyList<DroppedItem> Items` - dropped items list
  - [ ] `IReadOnlyDictionary<string, int> Currency` - currency ID to amount map
- [ ] **Computed Properties:**
  - [ ] `bool IsEmpty` - true if no items and no currency
  - [ ] `bool HasItems` - true if items list is non-empty
  - [ ] `bool HasCurrency` - true if currency dict is non-empty
- [ ] **Static property `Empty`:**
  - [ ] Returns LootDrop with empty collections
- [ ] **Factory method `Create()`:**
  - [ ] Accept optional items enumerable and currency dictionary
  - [ ] Return new instance with copied collections
- [ ] **Method `CombineWith(LootDrop other)`:**
  - [ ] Combine item lists (append)
  - [ ] Combine currency dictionaries (sum values)
  - [ ] Return new combined LootDrop

**Acceptance:** `LootDrop.Create(items, currency).CombineWith(other)` correctly merges loot.

---

#### 1.6 Create `LootTable.cs` ğŸŸ¡ â­â­

**File:** `src/Core/RuneAndRust.Domain/Definitions/LootTable.cs`
**Depends on:** 1.2, 1.3 (references `LootEntry`, `CurrencyDrop`)

- [ ] Create new file in `Definitions/` directory
- [ ] Add namespace: `RuneAndRust.Domain.Definitions`
- [ ] Add XML documentation for class
- [ ] **Properties (all `init`-only):**
  - [ ] `IReadOnlyList<LootEntry> Entries` - possible item drops
  - [ ] `IReadOnlyList<CurrencyDrop> CurrencyDrops` - possible currency drops
- [ ] **Computed Property:**
  - [ ] `bool HasEntries` - true if either list is non-empty
- [ ] **Static property `Empty`:**
  - [ ] Returns LootTable with empty collections
- [ ] **Factory method `Create()`:**
  - [ ] Accept optional entries and currencyDrops
  - [ ] Return new instance

**Acceptance:** `LootTable.Create(entries, currencyDrops).HasEntries` returns correct value.

---

#### 1.7 Update `MonsterDefinition.cs` ğŸŸ¡ â­

**File:** `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`
**Depends on:** 1.6 (uses `LootTable`)

- [ ] **Add new property:**
  - [ ] `LootTable? LootTable { get; init; }` with XML docs
- [ ] **Update `Create()` factory method signature:**
  - [ ] Add parameter: `LootTable? lootTable = null`
- [ ] **Update `Create()` factory method body:**
  - [ ] Assign `LootTable = lootTable`

**Acceptance:** Existing monster definitions continue to work (nullable). New property accessible.

---

#### 1.8 Update `Player.cs` ğŸŸ¡ â­â­â­

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs`
**Depends on:** 1.1 (currency system concept)

- [ ] **Add private field:**
  - [ ] `private readonly Dictionary<string, int> _currency = new(StringComparer.OrdinalIgnoreCase);`
- [ ] **Add public property:**
  - [ ] `IReadOnlyDictionary<string, int> Currency => _currency.AsReadOnly();` with XML docs
- [ ] **Add method `GetCurrency(string currencyId)`:**
  - [ ] Return 0 if null/whitespace
  - [ ] Normalize to lowercase, lookup in dictionary
  - [ ] Return amount or 0 if not found
- [ ] **Add method `AddCurrency(string currencyId, int amount)`:**
  - [ ] Validate currencyId not null/whitespace
  - [ ] Validate amount >= 0 (`ThrowIfNegative`)
  - [ ] If amount == 0, return early
  - [ ] Normalize currencyId, add/update dictionary
- [ ] **Add method `RemoveCurrency(string currencyId, int amount)`:**
  - [ ] Validate parameters
  - [ ] Check if player has sufficient funds
  - [ ] Return false if insufficient, true if successful
- [ ] **Add method `CanAfford(string currencyId, int amount)`:**
  - [ ] Return `GetCurrency(currencyId) >= amount`
- [ ] **Update private EF constructor:**
  - [ ] Initialize `_currency = new(...)`

**Acceptance:** `player.AddCurrency("gold", 50)` then `player.GetCurrency("gold")` returns 50.

---

#### 1.9 Update `Room.cs` ğŸŸ¡ â­â­â­ ğŸ”´

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`
**Depends on:** 1.4, 1.5 (uses `DroppedItem`, `LootDrop`)
**Critical:** Loot storage and collection

- [ ] **Add private fields:**
  - [ ] `private readonly List<DroppedItem> _droppedItems = [];`
  - [ ] `private readonly Dictionary<string, int> _droppedCurrency = new(StringComparer.OrdinalIgnoreCase);`
- [ ] **Add public properties:**
  - [ ] `IReadOnlyList<DroppedItem> DroppedItems => _droppedItems.AsReadOnly();`
  - [ ] `IReadOnlyDictionary<string, int> DroppedCurrency => _droppedCurrency.AsReadOnly();`
  - [ ] `bool HasDroppedLoot => _droppedItems.Count > 0 || _droppedCurrency.Count > 0;`
- [ ] **Add method `AddLoot(LootDrop loot)`:**
  - [ ] Return early if loot.IsEmpty
  - [ ] AddRange items from loot.Items
  - [ ] Accumulate currency from loot.Currency
- [ ] **Add method `CollectAllLoot()`:**
  - [ ] Return LootDrop.Empty if no loot
  - [ ] Create LootDrop from current items and currency
  - [ ] Clear `_droppedItems` and `_droppedCurrency`
  - [ ] Return collected LootDrop
- [ ] **Add method `ClearDroppedLoot()`:**
  - [ ] Clear both collections
- [ ] **Update private EF constructor:**
  - [ ] Initialize both collections

**Acceptance:** `room.AddLoot(loot)` then `room.CollectAllLoot()` returns same loot and clears room.

---

### Phase 2: Application Layer (Service Contracts)

#### 2.1 Create `CurrencyConfigurationDto.cs` ğŸŸ¢ â­

**File:** `src/Core/RuneAndRust.Application/Configuration/CurrencyConfigurationDto.cs`

- [ ] Create new file in `Configuration/` directory
- [ ] Add namespace: `RuneAndRust.Application.Configuration`
- [ ] Add using for `System.Text.Json.Serialization`
- [ ] **Define `CurrencyConfiguration` class:**
  - [ ] `[JsonPropertyName("currencies")] List<CurrencyDefinitionDto> Currencies`
- [ ] **Define `CurrencyDefinitionDto` class with JSON attributes:**
  - [ ] `id`, `name`, `pluralName`, `symbol`, `color`, `sortOrder`

**Acceptance:** DTO can deserialize from `currency.json` without exceptions.

---

#### 2.2 Create `LootTableDto.cs` ğŸŸ¢ â­

**File:** `src/Core/RuneAndRust.Application/Configuration/LootTableDto.cs`

- [ ] Create new file in `Configuration/` directory
- [ ] Add namespace: `RuneAndRust.Application.Configuration`
- [ ] Add using for `System.Text.Json.Serialization`
- [ ] **Define `LootTableDto` class:**
  - [ ] `[JsonPropertyName("currencyDrops")] List<CurrencyDropDto> CurrencyDrops`
  - [ ] `[JsonPropertyName("entries")] List<LootEntryDto> Entries`
- [ ] **Define `CurrencyDropDto` class:**
  - [ ] `currencyId`, `minAmount`, `maxAmount`, `dropChance`
- [ ] **Define `LootEntryDto` class:**
  - [ ] `itemId`, `weight`, `minQuantity`, `maxQuantity`, `dropChance`

**Acceptance:** DTO can deserialize loot tables embedded in `monsters.json`.

---

#### 2.3 Update `MonsterConfigurationDto.cs` ğŸŸ¡ â­

**File:** `src/Core/RuneAndRust.Application/Configuration/MonsterConfigurationDto.cs`
**Depends on:** 2.2 (uses `LootTableDto`)

- [ ] **Add new property to `MonsterDefinitionDto`:**
  - [ ] `[JsonPropertyName("lootTable")] LootTableDto? LootTable`

**Acceptance:** Existing monster JSON with new `lootTable` field parses correctly.

---

#### 2.4 Update `IGameConfigurationProvider.cs` ğŸŸ¡ â­

**File:** `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`
**Depends on:** 1.1 (references `CurrencyDefinition`)

- [ ] Add using for `RuneAndRust.Domain.Definitions` (if not present)
- [ ] **Add interface method declarations:**
  - [ ] `IReadOnlyList<CurrencyDefinition> GetCurrencies()` with XML docs
  - [ ] `CurrencyDefinition? GetCurrencyById(string currencyId)` with XML docs

**Acceptance:** Interface compiles; `JsonConfigurationProvider` shows compile errors (expected).

---

#### 2.5 Create `ILootService.cs` ğŸŸ¡ â­

**File:** `src/Core/RuneAndRust.Application/Interfaces/ILootService.cs`
**Depends on:** 1.1, 1.5 Domain definitions

- [ ] Create new file in `Interfaces/` directory
- [ ] Add namespace: `RuneAndRust.Application.Interfaces`
- [ ] Add usings for Domain definitions, entities, value objects
- [ ] **Define `ILootService` interface with XML docs:**
  - [ ] `LootDrop GenerateLoot(Monster monster)` - generate loot from defeated monster
  - [ ] `LootDrop GenerateLoot(MonsterDefinition definition, float lootMultiplier)` - with explicit multiplier
  - [ ] `LootDrop CollectLoot(Player player, Room room)` - collect room loot to player
  - [ ] `CurrencyDefinition? GetCurrency(string currencyId)` - lookup currency
  - [ ] `IReadOnlyList<CurrencyDefinition> GetAllCurrencies()` - list all currencies

**Acceptance:** Interface compiles with complete XML documentation.

---

#### 2.6 Create `LootService.cs` ğŸŸ¡ â­â­â­ ğŸ”´

**File:** `src/Core/RuneAndRust.Application/Services/LootService.cs`
**Depends on:** 2.4, 2.5, 1.6, v0.0.9c's `IMonsterService`
**Critical:** Core loot generation logic

- [ ] Create new file in `Services/` directory
- [ ] Add namespace: `RuneAndRust.Application.Services`
- [ ] Add usings for interfaces, definitions, entities, value objects, logging
- [ ] **Define `LootService` class implementing `ILootService`:**
- [ ] **Private fields:**
  - [ ] `readonly ILogger<LootService> _logger`
  - [ ] `readonly IGameConfigurationProvider _configProvider`
  - [ ] `readonly IMonsterService _monsterService`
  - [ ] `readonly Random _random`
- [ ] **Public constructor:**
  - [ ] Parameters: `logger`, `configProvider`, `monsterService`
  - [ ] Null checks with `ArgumentNullException`
  - [ ] Initialize `_random = new Random()`
- [ ] **Internal constructor (for testing):**
  - [ ] With explicit `Random` parameter
- [ ] **Implement `GenerateLoot(Monster monster)`:**
  - [ ] Validate monster not null
  - [ ] Return empty if no DefinitionId
  - [ ] Lookup definition via `_monsterService.GetDefinition()`
  - [ ] Return empty if definition not found
  - [ ] Call `GenerateLoot(definition, monster.LootMultiplier)`
- [ ] **Implement `GenerateLoot(MonsterDefinition, float lootMultiplier)`:**
  - [ ] Return empty if LootTable null or no entries
  - [ ] Call `GenerateItemDrops()` and `GenerateCurrencyDrops()`
  - [ ] Create and return LootDrop
  - [ ] Log at Debug level
- [ ] **Add private `GenerateItemDrops(LootTable, float multiplier)`:**
  - [ ] For each LootEntry in table:
    - [ ] Calculate adjusted chance (entry.DropChance * multiplier, capped at 1.0)
    - [ ] Roll `_random.NextSingle()` against adjusted chance
    - [ ] If successful: pick random quantity, apply multiplier, create DroppedItem
  - [ ] Return list of items
- [ ] **Add private `GenerateCurrencyDrops(LootTable, float multiplier)`:**
  - [ ] For each CurrencyDrop in table:
    - [ ] Roll against DropChance (no multiplier on chance for currency)
    - [ ] If successful: pick random amount, apply multiplier with rounding
    - [ ] Add to dictionary (accumulate if same currency)
  - [ ] Return dictionary
- [ ] **Add private `GetItemDisplayName(string itemId)`:**
  - [ ] Convert snake_case ID to Title Case name
  - [ ] (Placeholder until ItemService exists)
- [ ] **Implement `CollectLoot(Player, Room)`:**
  - [ ] Validate parameters not null
  - [ ] Return empty if `!room.HasDroppedLoot`
  - [ ] Call `room.CollectAllLoot()`
  - [ ] For each currency: `player.AddCurrency()`
  - [ ] Log at Info level (player collected X items, Y currency)
  - [ ] Return collected loot
- [ ] **Implement `GetCurrency(string currencyId)`:**
  - [ ] Return null if null/whitespace
  - [ ] Normalize and call `_configProvider.GetCurrencyById()`
- [ ] **Implement `GetAllCurrencies()`:**
  - [ ] Return `_configProvider.GetCurrencies()`

**Acceptance:** `GenerateLoot(orc, 2.0f)` with Elite tier correctly doubles amounts and improves drop chances.

---

### Phase 3: Infrastructure Layer (Data Loading)

#### 3.1 Update `JsonConfigurationProvider.cs` ğŸŸ¡ â­â­ ğŸ”´

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`
**Depends on:** 2.1, 2.2, 2.3, 2.4, 1.1-1.6
**Critical:** Enables all configuration loading

- [ ] Add usings for new DTOs and `CurrencyDefinition`, `LootTable`, value objects
- [ ] **Add private field:**
  - [ ] `private List<CurrencyDefinition>? _currencies;`
- [ ] **Implement `GetCurrencies()`:**
  - [ ] Null check `_currencies`
  - [ ] If null, load from `currency.json` via `LoadConfiguration<CurrencyConfiguration>`
  - [ ] Map each DTO with `MapToCurrencyDefinition()`
  - [ ] Cache in `_currencies`
  - [ ] Return cached list
- [ ] **Implement `GetCurrencyById(string currencyId)`:**
  - [ ] Call `GetCurrencies()` to ensure loaded
  - [ ] Return `FirstOrDefault` matching ID (case-insensitive)
- [ ] **Add private helper `MapToCurrencyDefinition(CurrencyDefinitionDto dto)`:**
  - [ ] Call `CurrencyDefinition.Create()` with all mapped values
  - [ ] Return created definition
- [ ] **Update `MapToMonsterDefinition()` for LootTable:**
  - [ ] If `dto.LootTable` is not null:
    - [ ] Map `dto.LootTable.CurrencyDrops` to `List<CurrencyDrop>`
    - [ ] Map `dto.LootTable.Entries` to `List<LootEntry>`
    - [ ] Create `LootTable` from mapped lists
  - [ ] Set `LootTable` property on returned definition

**Acceptance:** `GetCurrencies()` returns currencies from JSON. Monsters load with embedded loot tables.

---

### Phase 4: Configuration (Data Files)

#### 4.1 Create `config/currency.json` ğŸŸ¢ â­

**File:** `config/currency.json`

- [ ] Create new file in `config/` directory
- [ ] Add JSON structure with `$schema` reference
- [ ] **Add `currencies` array with initial currency:**
- [ ] **Gold:**
  - [ ] id: "gold", name: "Gold", pluralName: "Gold"
  - [ ] symbol: "G", color: "yellow", sortOrder: 0
- [ ] Validate JSON syntax

**Acceptance:** JSON parses without errors. Gold currency loads correctly.

---

#### 4.2 Update `config/monsters.json` ğŸŸ¡ â­â­

**File:** `config/monsters.json`
**Depends on:** 4.1 (references currency IDs)

- [ ] **Add `lootTable` to each existing monster:**
- [ ] **Goblin:**
  - [ ] currencyDrops: gold 5-15, 80% chance
  - [ ] entries: health_potion 15% chance, rusty_dagger 5% chance
- [ ] **Skeleton:**
  - [ ] currencyDrops: gold 8-20, 90% chance
  - [ ] entries: bone_dust 30% chance, ancient_coin 10% chance
- [ ] **Orc:**
  - [ ] currencyDrops: gold 15-35, 100% chance
  - [ ] entries: health_potion 25% chance, iron_sword 10%, orcish_helm 5%
- [ ] **Giant Spider:**
  - [ ] currencyDrops: gold 3-10, 50% chance
  - [ ] entries: spider_silk 40% chance, venom_sac 15%
- [ ] **Slime:**
  - [ ] currencyDrops: gold 1-5, 30% chance
  - [ ] entries: slime_residue 50% chance
- [ ] Validate JSON syntax

**Acceptance:** All monsters have loot tables. LootService generates appropriate drops.

---

### Phase 5: Presentation Layer (Commands & Display)

#### 5.1 Update `GameSessionService.cs` ğŸŸ¡ â­â­â­

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`
**Depends on:** 2.6 (`ILootService`)

- [ ] **Add dependency:**
  - [ ] Add `private readonly ILootService _lootService` field
  - [ ] Update constructor to inject `ILootService lootService`
- [ ] **Update combat victory handling:**
  - [ ] After combat victory, call `_lootService.GenerateLoot(monster)`
  - [ ] If loot not empty, call `room.AddLoot(loot)`
  - [ ] Generate message: "The {monster.DisplayName} dropped {loot details}!"
- [ ] **Add `HandleLootCommand(GameSession session)`:**
  - [ ] Check `room.HasDroppedLoot`, return "Nothing to collect" if empty
  - [ ] Call `_lootService.CollectLoot(player, room)`
  - [ ] Build response: "You collected:" with item and currency list
  - [ ] Show new gold total
- [ ] **Add `HandleTakeCommand(GameSession session, string target)`:**
  - [ ] If target empty/null, delegate to `HandleLootCommand`
  - [ ] (Future: specific item pickup)
- [ ] **Update `HandleLookCommand()`:**
  - [ ] After room description, if `room.HasDroppedLoot`:
    - [ ] Display: "There is loot here: {loot summary}"
- [ ] **Update `HandleStatusCommand()`:**
  - [ ] Add currency display section
  - [ ] Format: "Gold: {amount}" for each non-zero currency
- [ ] **Register new commands:**
  - [ ] "loot" â†’ `HandleLootCommand`
  - [ ] "take" â†’ `HandleTakeCommand`

**Acceptance:** `loot` command collects gold. `status` shows gold total. Combat drops loot.

---

#### 5.2 Update `SpectreGameRenderer.cs` ğŸŸ¡ â­â­

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`
**Depends on:** 2.6 (`ILootService` for currency lookup)

- [ ] **Add dependency (optional for currency colors):**
  - [ ] Add `private readonly ILootService _lootService` field
  - [ ] Update constructor if needed
- [ ] **Add method `FormatLootDrop(LootDrop loot)`:**
  - [ ] Build string with colored currency display
  - [ ] Format: `[yellow]5 Gold[/]`
  - [ ] Join multiple currencies/items with commas
  - [ ] Return formatted string
- [ ] **Add method `FormatCurrencyDisplay(Dictionary<string, int> currency)`:**
  - [ ] For each currency, get definition for color and name
  - [ ] Format with Spectre.Console markup
- [ ] **Update room display to show dropped loot:**
  - [ ] If `room.HasDroppedLoot`:
    - [ ] Display "Items on ground:" section with loot summary
- [ ] **Update status panel (if applicable):**
  - [ ] Add currency section showing player's gold

**Acceptance:** Loot displays in yellow. Room shows dropped items. Status shows gold.

---

### Phase 6: Testing (Verification)

#### 6.1 Create `CurrencyDefinitionTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/CurrencyDefinitionTests.cs`
**Depends on:** 1.1

- [ ] Create test file with `[Fact]` and `[Theory]` tests
- [ ] **Test cases (~3 tests):**
  - [ ] `Create_ValidInputs_ReturnsCurrencyWithCorrectValues`
  - [ ] `Create_EmptyId_ThrowsArgumentException`
  - [ ] `GetDisplayName_SingleAmount_ReturnsSingular`
  - [ ] `GetDisplayName_MultipleAmount_ReturnsPlural`
  - [ ] `Gold_ReturnsDefaultGoldCurrency`

**Acceptance:** All tests pass.

---

#### 6.2 Create `LootDropTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/LootDropTests.cs`
**Depends on:** 1.5

- [ ] Create test file
- [ ] **Test cases (~4 tests):**
  - [ ] `Empty_HasNoItemsOrCurrency`
  - [ ] `Create_WithItems_HasItemsTrue`
  - [ ] `CombineWith_MergesItems`
  - [ ] `CombineWith_SumsCurrency`

**Acceptance:** All tests pass. Combine logic verified.

---

#### 6.3 Create `LootServiceTests.cs` ğŸŸ¡ â­â­â­

**File:** `tests/RuneAndRust.Application.UnitTests/Services/LootServiceTests.cs`
**Depends on:** 2.6

- [ ] Create test file with mock `IGameConfigurationProvider`, `IMonsterService`
- [ ] **Test cases (~5 tests):**
  - [ ] `GenerateLoot_NoLootTable_ReturnsEmpty`
  - [ ] `GenerateLoot_AppliesLootMultiplier` (use seeded Random)
  - [ ] `GenerateLoot_RespectsDropChances`
  - [ ] `CollectLoot_TransfersCurrencyToPlayer`
  - [ ] `CollectLoot_ClearsRoomLoot`
  - [ ] `GetCurrency_ValidId_ReturnsCurrency`

**Acceptance:** All tests pass with mocked dependencies.

---

#### 6.4 Update `PlayerTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerTests.cs`
**Depends on:** 1.8

- [ ] **Add new test cases (~4 tests):**
  - [ ] `AddCurrency_IncreasesAmount`
  - [ ] `AddCurrency_AccumulatesMultipleAdditions`
  - [ ] `RemoveCurrency_DecreasesAmount`
  - [ ] `RemoveCurrency_InsufficientFunds_ReturnsFalse`
  - [ ] `CanAfford_ReturnsCorrectResult`
  - [ ] `GetCurrency_NotOwned_ReturnsZero`

**Acceptance:** Currency operations work correctly.

---

#### 6.5 Update `RoomTests.cs` ğŸŸ¡ â­â­

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/RoomTests.cs`
**Depends on:** 1.9

- [ ] **Add new test cases (~4 tests):**
  - [ ] `AddLoot_StoresItemsAndCurrency`
  - [ ] `AddLoot_AccumulatesCurrency`
  - [ ] `CollectAllLoot_ReturnsAllLoot`
  - [ ] `CollectAllLoot_ClearsRoom`
  - [ ] `HasDroppedLoot_ReturnsCorrectState`

**Acceptance:** Loot storage and collection work correctly.

---

### Phase 7: Integration & DI Registration

#### 7.1 Update DI Container Registration ğŸŸ¡ â­

**File:** (DI setup file in Presentation layer)
**Depends on:** 2.6, 5.1

- [ ] Register `ILootService` â†’ `LootService`
- [ ] Update `GameSessionService` registration (new constructor parameter)
- [ ] Update any affected constructor chains

**Acceptance:** Application starts without DI resolution errors. Monsters drop loot.

---

### Implementation Order Summary

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: Domain (Value Objects & Definitions)               â”‚
â”‚  1.1 CurrencyDefinition.cs â”€â”€â”€â”€â”€â”                           â”‚
â”‚  1.2 LootEntry.cs  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚  1.3 CurrencyDrop.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ 1.5, 1.6                â”‚
â”‚  1.4 DroppedItem.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚  1.5 LootDrop.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ 1.9                     â”‚
â”‚  1.6 LootTable.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â†’ 1.7                     â”‚
â”‚  1.7 MonsterDefinition.cs â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚  1.8 Player.cs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚  1.9 Room.cs (CRITICAL) â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: Application (Services)                             â”‚
â”‚  2.1-2.3 DTOs (parallel)                                    â”‚
â”‚  2.4 IConfigurationProvider â”€â”€â”€â”€â”¬â”€â†’ 2.6                     â”‚
â”‚  2.5 ILootService â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                           â”‚
â”‚  2.6 LootService (CRITICAL) â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: Infrastructure (Data Loading)                      â”‚
â”‚  3.1 JsonConfigurationProvider (CRITICAL PATH)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 4: Configuration                                      â”‚
â”‚  4.1 currency.json â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚  4.2 monsters.json (update) â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 5: Presentation                                       â”‚
â”‚  5.1 GameSessionService.cs (commands)                       â”‚
â”‚  5.2 SpectreGameRenderer.cs (display)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 6: Testing                                            â”‚
â”‚  6.1 CurrencyDefinitionTests.cs                             â”‚
â”‚  6.2 LootDropTests.cs                                       â”‚
â”‚  6.3 LootServiceTests.cs                                    â”‚
â”‚  6.4 PlayerTests.cs (updates)                               â”‚
â”‚  6.5 RoomTests.cs (updates)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 7: Integration                                        â”‚
â”‚  7.1 DI Container Registration                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Estimated Effort

| Phase | Tasks | Complexity | Est. Time |
|-------|-------|------------|-----------|
| Domain Layer (Value Objects) | 5 files | â­â­ | 2-3 hours |
| Domain Layer (Entities) | 4 files | â­â­â­ | 2-3 hours |
| Application Layer (DTOs) | 3 files | â­ | 30 min |
| Application Layer (Services) | 3 files | â­â­â­ | 3-4 hours |
| Infrastructure Layer | 1 file | â­â­ | 1 hour |
| Configuration | 2 files | â­â­ | 1 hour |
| Presentation Layer | 2 files | â­â­â­ | 2-3 hours |
| Testing | 5 files | â­â­â­ | 3-4 hours |
| Integration | 1 task | â­ | 30 min |
| **Total** | **26 items** | | **16-20 hours** |

---

## Acceptance Criteria

### Functional Criteria

#### Loot Generation
| Criterion | Verification |
|-----------|--------------|
| **Loot Drops** | Defeating a Goblin with loot table drops 5-15 gold at 80% chance |
| **Tier Scaling** | Elite monsters (2.0x multiplier) drop doubled gold amounts and improved drop chances |
| **Empty Tables** | Monsters without loot tables drop nothing (no errors) |
| **Probabilistic Drops** | Items at 15% drop chance drop approximately 15% of the time over many trials |
| **Quantity Ranges** | Quantity picks randomly between MinQuantity and MaxQuantity, then multiplied |

#### Loot Collection
| Criterion | Verification |
|-----------|--------------|
| **Room Persistence** | Loot dropped by monster remains in room until collected |
| **Multiple Drops** | Multiple monster kills accumulate loot in room |
| **Currency Transfer** | `loot` command adds currency to player.Currency |
| **Room Cleared** | After collection, room.HasDroppedLoot returns false |
| **Empty Room** | `loot` in room with no loot returns "Nothing to collect" |

#### Player Currency
| Criterion | Verification |
|-----------|--------------|
| **AddCurrency** | `player.AddCurrency("gold", 50)` increases gold by 50 |
| **Accumulation** | Multiple AddCurrency calls accumulate correctly |
| **GetCurrency** | Returns 0 for currencies player doesn't have |
| **CanAfford** | Returns true/false based on available currency |
| **RemoveCurrency** | Fails gracefully if insufficient funds (returns false) |

### Visual Criteria

| Criterion | Verification |
|-----------|--------------|
| **Combat Victory** | "The Goblin dropped 12 Gold!" displayed after victory |
| **Loot Command** | "You collected: â€¢ 12 Gold" with summary and new total |
| **Status Command** | Shows "Gold: 50" in player status |
| **Room Look** | "Items on ground: 12 Gold" shown in room description |
| **Currency Color** | Gold displayed in yellow using Spectre.Console markup |

### Data Verification

| Criterion | Verification |
|-----------|--------------|
| **currency.json** | Contains gold currency with all required fields |
| **monsters.json** | All 5 monsters have loot tables with balanced values |
| **Backward Compat** | Monsters without lootTable field spawn with no loot (no errors) |
| **Case Insensitivity** | "Gold", "gold", "GOLD" all resolve to same currency |
| **Caching** | Currency configuration loaded once and cached |

### Integration Criteria

| Criterion | Verification |
|-----------|--------------|
| **DI Resolution** | Application starts without DI errors for ILootService |
| **Combat Integration** | LootService called after successful combat |
| **Command Registration** | "loot" and "take" commands recognized |
| **Tier Multiplier** | `Monster.LootMultiplier` from v0.0.9c used correctly |
| **All Tests Pass** | ~20 new/updated tests pass with full coverage |

---

## File Summary

### Files to Create
- `src/Core/RuneAndRust.Domain/Definitions/CurrencyDefinition.cs`
- `src/Core/RuneAndRust.Domain/Definitions/LootTable.cs`
- `src/Core/RuneAndRust.Domain/ValueObjects/LootEntry.cs`
- `src/Core/RuneAndRust.Domain/ValueObjects/CurrencyDrop.cs`
- `src/Core/RuneAndRust.Domain/ValueObjects/DroppedItem.cs`
- `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs`
- `src/Core/RuneAndRust.Application/Configuration/CurrencyConfigurationDto.cs`
- `src/Core/RuneAndRust.Application/Configuration/LootTableDto.cs`
- `src/Core/RuneAndRust.Application/Interfaces/ILootService.cs`
- `src/Core/RuneAndRust.Application/Services/LootService.cs`
- `config/currency.json`

### Files to Modify
- `src/Core/RuneAndRust.Domain/Definitions/MonsterDefinition.cs`
- `src/Core/RuneAndRust.Domain/Entities/Player.cs`
- `src/Core/RuneAndRust.Domain/Entities/Room.cs`
- `src/Core/RuneAndRust.Application/Configuration/MonsterConfigurationDto.cs`
- `src/Core/RuneAndRust.Application/Interfaces/IConfigurationProvider.cs`
- `src/Infrastructure/RuneAndRust.Infrastructure/Configuration/JsonConfigurationProvider.cs`
- `config/monsters.json`
- `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`
- `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

### Test Files Summary

| File | Test Count | Coverage Focus |
|------|------------|----------------|
| `CurrencyDefinitionTests.cs` | ~5 | Validation, GetDisplayName, defaults |
| `LootDropTests.cs` | ~4 | Empty, creation, CombineWith merging |
| `LootServiceTests.cs` | ~6 | Generation, multipliers, collection |
| `PlayerTests.cs` (Updates) | ~6 | Add/Remove/Get currency, CanAfford |
| `RoomTests.cs` (Updates) | ~5 | AddLoot, CollectAllLoot, accumulation |
| **Total** | **~26** | |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Loot inflation unbalances economy | Medium | Medium | Start with low currency amounts (1-10 gold) |
| Room loot not persisting between saves | Medium | High | Test save/load with dropped loot |
| Drop chance math edge cases | Low | Medium | Clamp probabilities 0.0-1.0, test edge cases |
| Player currency overflow | Low | Low | Use int (2B+ max), monitor in testing |
| UI clutter from loot messages | Medium | Low | Consolidate multi-item drops into summary |

---

## Provides to Future Phases

### To Shops & Vendors (Future)

| Type | Usage |
|------|-------|
| `Player.Currency` | Player's gold used for purchases |
| `CurrencyDefinition` | Shop displays use currency names/symbols |
| `Player.RemoveCurrency()` | Spending removes currency |
| `Player.CanAfford()` | Checks purchasing power |

### To Item Quality System (Future)

| Type | Usage |
|------|-------|
| `LootEntry.Weight` | Quality tiers have different weights |
| `LootTable` | Extended with quality modifiers |
| `DroppedItem` | Extended with quality/rarity field |

### To Trading System (Future)

| Type | Usage |
|------|-------|
| `Player.Currency` | Trade currency between players |
| `CurrencyDefinition` | Multiple currency support ready |
| `LootDrop.CombineWith()` | Merge traded items |

