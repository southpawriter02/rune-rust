# v0.1.2d Design Specification: Transitional Zones & Discovery

**Version:** 0.1.2d
**Phase Name:** Transitional Zones & Discovery
**Parent Version:** v0.1.2 (Dungeon Theming & Biomes)
**Prerequisites:** v0.1.2c Complete (Environmental Hazards)
**Estimated Tests:** ~22 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [BiomeTransition Entity](#4-biometransition-entity)
5. [TransitionStyle Enum](#5-transitionstyle-enum)
6. [TransitionBlend Value Object](#6-transitionblend-value-object)
7. [BiomeProgress Value Object](#7-biomeprogress-value-object)
8. [TransitionService](#8-transitionservice)
9. [Player Biome Integration](#9-player-biome-integration)
10. [Codex Integration](#10-codex-integration)
11. [Data Model Changes](#11-data-model-changes)
12. [Configuration File Schemas](#12-configuration-file-schemas)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement transitional zones between biomes with gradual descriptor blending and mixed encounter tables. This phase completes the v0.1.2 biome system by creating seamless transitions between themed areas, tracking player discovery progress, and integrating biome exploration with the codex system for lore collection.

### 1.2 Current State

| Area | Current State (v0.1.2c) | Target State (v0.1.2d) |
|------|-------------------------|------------------------|
| Biome boundaries | Abrupt changes between biomes | Configurable transition zones with blending |
| Zone blending | None | TransitionBlend with weighted descriptors/spawns |
| Discovery tracking | None | BiomeProgress on Player entity |
| Biome connections | Implicit | Explicit BiomeTransition rules |
| Codex integration | Basic entries | Biome discovery unlocks lore entries |
| Spawn mixing | Single-biome tables | Mixed spawn tables for transitions |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | `BiomeTransition` |
| **Value Objects** | `TransitionBlend`, `BiomeProgress` |
| **Enums** | `TransitionStyle` |
| **Services** | `TransitionService` (with `ITransitionService` interface) |
| **DTOs** | `BiomeDiscoveryResult` |
| **Configuration** | `biome-transitions.json`, `biome-transitions-schema.json` |
| **Entity Updates** | `Player.BiomeProgress` property, `Room.TransitionBlend` |
| **Tests** | ~22 new unit tests |

### 1.4 Architectural Significance

This version establishes the **biome transition pattern** that completes the v0.1.2 biome system:
- Configurable transition rules define allowed biome connections
- Linear blend calculations for smooth descriptor/spawn mixing
- Immutable BiomeProgress tracking with dictionary-based statistics
- Discovery events trigger codex unlocks and notifications
- TransitionService coordinates all transition logic

---

## 2. Feature Overview

```
v0.1.2d Transitional Zones & Discovery
├── BiomeTransition Entity
│   ├── FromBiomeId (source biome)
│   ├── ToBiomeId (destination biome)
│   ├── IsAllowed (connection permitted)
│   ├── TransitionLength (rooms in transition)
│   ├── Style (Gradual, Abrupt, Portal, Vertical)
│   ├── TransitionDescription (narrative text)
│   ├── Probability (occurrence chance)
│   ├── RequiredDepth (minimum depth)
│   └── Bidirectional (both directions)
├── TransitionStyle Enum
│   ├── Gradual (multi-room blend)
│   ├── Abrupt (instant change)
│   ├── Portal (magical doorway)
│   └── Vertical (stairs/pit)
├── TransitionBlend Value Object
│   ├── PrimaryBiomeId
│   ├── SecondaryBiomeId
│   ├── BlendRatio (0.0 to 1.0)
│   ├── PrimaryWeight (computed)
│   ├── SecondaryWeight (computed)
│   ├── IsPure (computed)
│   ├── ForPosition() factory
│   ├── SelectBiomeForSpawn()
│   └── GetBlendedDescriptor()
├── BiomeProgress Value Object
│   ├── DiscoveredBiomes (biome → timestamp)
│   ├── RoomsVisited (biome → count)
│   ├── MonstersDefeated (biome → count)
│   ├── DeepestDepth (biome → depth)
│   ├── HasDiscovered()
│   ├── GetDiscoveryDate()
│   ├── DiscoverBiome()
│   ├── RecordRoomVisit()
│   ├── RecordMonsterDefeat()
│   └── UpdateDeepestDepth()
├── TransitionService
│   ├── GetTransition(from, to)
│   ├── GetConnectableBiomes(biomeId, depth)
│   ├── CreateBlend(position, from, to, roomsFromStart, length)
│   ├── GetTransitionalDescriptors(blend, position)
│   └── GetMixedSpawnTable(blend)
├── Player Biome Integration
│   ├── Player.BiomeProgress property
│   └── Player.EnterBiome() method
├── Codex Integration
│   └── Biome discovery unlocks lore entries
└── Configuration
    ├── biome-transitions.json
    └── biome-transitions-schema.json
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Biome discovery notifications displayed to player                           │
│  ├── GameView shows discovery message on new biome                           │
│  ├── Codex UI shows unlocked biome entries                                   │
│  └── Status displays current biome with transition indicator                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  TransitionService                   BiomeService (Updated)                  │
│  ├── GetTransition()                 └── Integrates with TransitionService   │
│  ├── GetConnectableBiomes()                                                  │
│  ├── CreateBlend()                   RoomGeneratorService (Updated)          │
│  ├── GetTransitionalDescriptors()    └── Applies transition blends           │
│  └── GetMixedSpawnTable()                                                    │
│                                      CodexService (Updated)                  │
│  Interfaces:                         └── Biome discovery unlocks             │
│  └── ITransitionService                                                      │
│                                      DTOs:                                   │
│  Configuration:                      └── BiomeDiscoveryResult                │
│  └── BiomeTransitionConfigDto                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Definitions:                  Value Objects:                                │
│  ┌─────────────────────────┐  ┌─────────────────────────────────────────┐   │
│  │ BiomeTransition         │  │ TransitionBlend                         │   │
│  │ ├── FromBiomeId         │  │ ├── PrimaryBiomeId: string              │   │
│  │ ├── ToBiomeId           │  │ ├── SecondaryBiomeId: string            │   │
│  │ ├── IsAllowed           │  │ ├── BlendRatio: float                   │   │
│  │ ├── TransitionLength    │  │ ├── PrimaryWeight: float (computed)     │   │
│  │ ├── Style               │  │ ├── SecondaryWeight: float (computed)   │   │
│  │ ├── TransitionDescription│  │ ├── IsPure: bool (computed)             │   │
│  │ ├── Probability         │  │ ├── ForPosition(): TransitionBlend      │   │
│  │ ├── RequiredDepth       │  │ ├── SelectBiomeForSpawn()               │   │
│  │ └── Bidirectional       │  │ └── GetBlendedDescriptor()              │   │
│  └─────────────────────────┘  └─────────────────────────────────────────┘   │
│                                                                              │
│  Enums:                        ┌─────────────────────────────────────────┐   │
│  ┌─────────────────────────┐  │ BiomeProgress                           │   │
│  │ TransitionStyle         │  │ ├── DiscoveredBiomes: Dict<string,DateTime>│
│  │ ├── Gradual             │  │ ├── RoomsVisited: Dict<string,int>      │   │
│  │ ├── Abrupt              │  │ ├── MonstersDefeated: Dict<string,int>  │   │
│  │ ├── Portal              │  │ ├── DeepestDepth: Dict<string,int>      │   │
│  │ └── Vertical            │  │ ├── HasDiscovered()                     │   │
│  └─────────────────────────┘  │ ├── DiscoverBiome()                     │   │
│                               │ ├── RecordRoomVisit()                   │   │
│  Entities (Updated):          │ ├── RecordMonsterDefeat()               │   │
│  ┌─────────────────────────┐  │ └── UpdateDeepestDepth()                │   │
│  │ Player                  │  └─────────────────────────────────────────┘   │
│  │ ├── BiomeProgress       │                                                │
│  │ └── EnterBiome()        │                                                │
│  └─────────────────────────┘                                                │
│  ┌─────────────────────────┐                                                │
│  │ Room                    │                                                │
│  │ └── TransitionBlend?    │                                                │
│  └─────────────────────────┘                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  ├── GetBiomeTransitions(): IReadOnlyList<BiomeTransition>                  │
│  └── Loads and deserializes config/biome-transitions.json                   │
│                                                                              │
│  Configuration Files:                                                        │
│  ├── config/biome-transitions.json (transition rules)                       │
│  └── config/schemas/biome-transitions-schema.json (validation)              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Transition Flow Diagram

```
┌───────────────────────────────────────┐
│ Player moves from Room A (Biome X)    │
│ to Room B (potentially Biome Y)       │
└───────────────┬───────────────────────┘
                │
                ▼
┌───────────────────────────────────────┐
│ TransitionService.GetTransition()     │
│ Checks if transition X → Y exists     │
└───────────────┬───────────────────────┘
                │
        ┌───────┴───────┐
        │               │
        ▼               ▼
┌───────────────┐ ┌─────────────────────┐
│ No transition │ │ Transition found    │
│ Same biome or │ │                     │
│ not allowed   │ └──────────┬──────────┘
└───────────────┘            │
                             ▼
              ┌──────────────────────────────┐
              │ Check TransitionStyle        │
              └──────────────┬───────────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌───────────────┐ ┌───────────────────┐ ┌───────────────┐
│ Gradual       │ │ Portal/Vertical   │ │ Abrupt        │
│               │ │                   │ │               │
│ CreateBlend() │ │ Special narrative │ │ Instant       │
│ for position  │ │ transition        │ │ biome change  │
└───────┬───────┘ └─────────┬─────────┘ └───────┬───────┘
        │                   │                   │
        ▼                   ▼                   ▼
┌────────────────────────────────────────────────────────┐
│ GetTransitionalDescriptors() / GetMixedSpawnTable()    │
│ ├── Blend descriptors from both biomes                 │
│ └── Mix spawn tables with weighted entries             │
└────────────────────────────────────────────────────────┘
                             │
                             ▼
┌────────────────────────────────────────────────────────┐
│ Player.EnterBiome(biomeId, depth)                      │
│ ├── Check if first visit (discovery)                   │
│ ├── Update BiomeProgress                               │
│ └── Return BiomeDiscoveryResult                        │
└────────────────────────────────────────────────────────┘
                             │
                             ▼
┌────────────────────────────────────────────────────────┐
│ If IsNewDiscovery:                                     │
│ ├── Trigger codex unlock                               │
│ ├── Display discovery notification                     │
│ └── Award discovery experience (future)                │
└────────────────────────────────────────────────────────┘
```

### 3.3 Blend Calculation Diagram

```
Transition Zone: Catacombs → Sewers (TransitionLength: 3)

Room 0 (Catacombs)    Room 1           Room 2           Room 3 (Sewers)
    │                   │                │                │
    ▼                   ▼                ▼                ▼
┌─────────┐       ┌─────────┐      ┌─────────┐      ┌─────────┐
│Blend: 0 │       │Blend:0.33│     │Blend:0.67│     │Blend: 1 │
│100% Cat │       │67% Cat   │     │33% Cat   │     │100% Sew │
│0% Sewer │       │33% Sewer │     │67% Sewer │     │0% Cat   │
└─────────┘       └─────────┘      └─────────┘      └─────────┘
    │                   │                │                │
    ▼                   ▼                ▼                ▼
Descriptors:      Mixed pool:      Mixed pool:      Descriptors:
- Dusty tombs     - Some dust      - Dampness       - Murky water
- Bone echoes     - Dripping       - Echoing water  - Rats squeaking
- Decay smell     - Mixed smells   - Sewage smell   - Strong sewage
```

---

## 4. BiomeTransition Entity

### 4.1 Purpose

Defines the rules governing transitions between two biomes, including whether the transition is allowed, its style, length, and any depth requirements.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Definitions/BiomeTransition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines transition rules between two biomes.
/// </summary>
public class BiomeTransition
{
    /// <summary>
    /// Gets the source biome ID.
    /// </summary>
    public string FromBiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets the destination biome ID.
    /// </summary>
    public string ToBiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets whether this transition is allowed.
    /// </summary>
    public bool IsAllowed { get; init; } = true;

    /// <summary>
    /// Gets the number of transition rooms between biomes.
    /// </summary>
    public int TransitionLength { get; init; } = 2;

    /// <summary>
    /// Gets the transition style.
    /// </summary>
    public TransitionStyle Style { get; init; } = TransitionStyle.Gradual;

    /// <summary>
    /// Gets description text for the transition zone.
    /// </summary>
    public string TransitionDescription { get; init; } = string.Empty;

    /// <summary>
    /// Gets the probability this transition occurs when changing biomes.
    /// </summary>
    public float Probability { get; init; } = 1.0f;

    /// <summary>
    /// Gets required depth for this transition.
    /// </summary>
    public int? RequiredDepth { get; init; }

    /// <summary>
    /// Gets whether the transition is bidirectional.
    /// </summary>
    public bool Bidirectional { get; init; } = true;

    /// <summary>
    /// Creates a validated BiomeTransition instance.
    /// </summary>
    /// <param name="fromBiomeId">Source biome ID.</param>
    /// <param name="toBiomeId">Destination biome ID.</param>
    /// <param name="isAllowed">Whether transition is permitted.</param>
    /// <param name="transitionLength">Number of transition rooms.</param>
    /// <param name="style">Transition style.</param>
    /// <param name="transitionDescription">Narrative description.</param>
    /// <param name="probability">Occurrence probability.</param>
    /// <param name="requiredDepth">Minimum depth requirement.</param>
    /// <param name="bidirectional">Whether transition works both ways.</param>
    /// <returns>A new BiomeTransition instance.</returns>
    /// <exception cref="ArgumentException">Thrown when IDs are empty or probability is out of range.</exception>
    public static BiomeTransition Create(
        string fromBiomeId,
        string toBiomeId,
        bool isAllowed = true,
        int transitionLength = 2,
        TransitionStyle style = TransitionStyle.Gradual,
        string transitionDescription = "",
        float probability = 1.0f,
        int? requiredDepth = null,
        bool bidirectional = true)
    {
        if (string.IsNullOrWhiteSpace(fromBiomeId))
            throw new ArgumentException("FromBiomeId cannot be empty.", nameof(fromBiomeId));

        if (string.IsNullOrWhiteSpace(toBiomeId))
            throw new ArgumentException("ToBiomeId cannot be empty.", nameof(toBiomeId));

        if (probability < 0f || probability > 1f)
            throw new ArgumentException("Probability must be between 0 and 1.", nameof(probability));

        if (transitionLength < 0)
            throw new ArgumentException("TransitionLength cannot be negative.", nameof(transitionLength));

        return new BiomeTransition
        {
            FromBiomeId = fromBiomeId,
            ToBiomeId = toBiomeId,
            IsAllowed = isAllowed,
            TransitionLength = transitionLength,
            Style = style,
            TransitionDescription = transitionDescription,
            Probability = probability,
            RequiredDepth = requiredDepth,
            Bidirectional = bidirectional
        };
    }

    /// <summary>
    /// Checks if this transition applies to the given biome pair.
    /// </summary>
    /// <param name="fromBiome">Source biome ID.</param>
    /// <param name="toBiome">Destination biome ID.</param>
    /// <returns>True if this transition applies.</returns>
    public bool AppliesTo(string fromBiome, string toBiome)
    {
        if (FromBiomeId == fromBiome && ToBiomeId == toBiome)
            return true;

        if (Bidirectional && FromBiomeId == toBiome && ToBiomeId == fromBiome)
            return true;

        return false;
    }

    /// <summary>
    /// Checks if the transition is valid at the given depth.
    /// </summary>
    /// <param name="depth">Current dungeon depth.</param>
    /// <returns>True if the transition can occur at this depth.</returns>
    public bool IsValidAtDepth(int depth)
    {
        if (!RequiredDepth.HasValue)
            return true;

        return depth >= RequiredDepth.Value;
    }
}
```

### 4.3 Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `FromBiomeId` | `string` | `""` | Source biome identifier |
| `ToBiomeId` | `string` | `""` | Destination biome identifier |
| `IsAllowed` | `bool` | `true` | Whether this transition is permitted |
| `TransitionLength` | `int` | `2` | Number of rooms in the transition zone |
| `Style` | `TransitionStyle` | `Gradual` | How the transition occurs |
| `TransitionDescription` | `string` | `""` | Narrative text describing the transition |
| `Probability` | `float` | `1.0f` | Chance this transition occurs (0.0 to 1.0) |
| `RequiredDepth` | `int?` | `null` | Minimum depth for this transition |
| `Bidirectional` | `bool` | `true` | Whether transition works in both directions |

---

## 5. TransitionStyle Enum

### 5.1 Purpose

Defines the different ways biome transitions can occur, affecting both gameplay and narrative presentation.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/Definitions/TransitionStyle.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Styles of biome transitions.
/// </summary>
public enum TransitionStyle
{
    /// <summary>
    /// Gradual blend over multiple rooms.
    /// Descriptors and spawns mix proportionally across the transition zone.
    /// </summary>
    Gradual,

    /// <summary>
    /// Abrupt change at a border.
    /// Immediate transition with no blending zone.
    /// </summary>
    Abrupt,

    /// <summary>
    /// Special portal/door transition.
    /// Magical or artificial passage between biomes.
    /// </summary>
    Portal,

    /// <summary>
    /// Vertical transition (stairs, pit).
    /// Elevation change between biomes.
    /// </summary>
    Vertical
}
```

### 5.3 Style Behaviors

| Style | TransitionLength | Descriptor Behavior | Narrative |
|-------|------------------|---------------------|-----------|
| `Gradual` | 2-5 rooms | Linear blend | "The environment slowly shifts..." |
| `Abrupt` | 0 rooms | Instant switch | "You cross into a different zone..." |
| `Portal` | 1 room | Special portal descriptors | "A shimmering portal leads to..." |
| `Vertical` | 1-2 rooms | Elevation-based mixing | "Stone stairs descend into..." |

---

## 6. TransitionBlend Value Object

### 6.1 Purpose

Represents the blended state of a transitional zone, calculating weighted influences from both source and destination biomes for descriptor and spawn selection.

### 6.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TransitionBlend.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the blended state of a transitional zone.
/// </summary>
public readonly record struct TransitionBlend
{
    /// <summary>
    /// Gets the primary biome ID.
    /// </summary>
    public string PrimaryBiomeId { get; init; }

    /// <summary>
    /// Gets the secondary biome ID.
    /// </summary>
    public string SecondaryBiomeId { get; init; }

    /// <summary>
    /// Gets the blend ratio (0.0 = all primary, 1.0 = all secondary).
    /// </summary>
    public float BlendRatio { get; init; }

    /// <summary>
    /// Gets the primary biome weight for spawn selection.
    /// </summary>
    public float PrimaryWeight => 1.0f - BlendRatio;

    /// <summary>
    /// Gets the secondary biome weight for spawn selection.
    /// </summary>
    public float SecondaryWeight => BlendRatio;

    /// <summary>
    /// Gets whether this is a pure biome (no blend).
    /// </summary>
    public bool IsPure => BlendRatio == 0.0f || BlendRatio == 1.0f;

    /// <summary>
    /// Gets whether this blend represents a transitional zone.
    /// </summary>
    public bool IsTransitional => !IsPure;

    /// <summary>
    /// Gets the dominant biome ID (primary if ratio less than 0.5, otherwise secondary).
    /// </summary>
    public string DominantBiomeId => BlendRatio < 0.5f ? PrimaryBiomeId : SecondaryBiomeId;

    /// <summary>
    /// Creates a blend for a specific position in a transition.
    /// </summary>
    /// <param name="fromBiome">Source biome ID.</param>
    /// <param name="toBiome">Destination biome ID.</param>
    /// <param name="positionInTransition">Current room position (0 = start).</param>
    /// <param name="transitionLength">Total rooms in transition.</param>
    /// <returns>A TransitionBlend with calculated ratio.</returns>
    public static TransitionBlend ForPosition(
        string fromBiome,
        string toBiome,
        int positionInTransition,
        int transitionLength)
    {
        if (transitionLength <= 0)
        {
            return new TransitionBlend
            {
                PrimaryBiomeId = fromBiome,
                SecondaryBiomeId = toBiome,
                BlendRatio = 1.0f
            };
        }

        var ratio = (float)positionInTransition / transitionLength;
        return new TransitionBlend
        {
            PrimaryBiomeId = fromBiome,
            SecondaryBiomeId = toBiome,
            BlendRatio = Math.Clamp(ratio, 0f, 1f)
        };
    }

    /// <summary>
    /// Creates a pure blend for a single biome (no transition).
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>A TransitionBlend representing a pure biome.</returns>
    public static TransitionBlend Pure(string biomeId)
    {
        return new TransitionBlend
        {
            PrimaryBiomeId = biomeId,
            SecondaryBiomeId = biomeId,
            BlendRatio = 0f
        };
    }

    /// <summary>
    /// Selects a biome for spawning based on blend weights.
    /// </summary>
    /// <param name="random">Random number generator.</param>
    /// <returns>The selected biome ID.</returns>
    public string SelectBiomeForSpawn(Random random)
    {
        if (random == null)
            throw new ArgumentNullException(nameof(random));

        return random.NextDouble() < PrimaryWeight
            ? PrimaryBiomeId
            : SecondaryBiomeId;
    }

    /// <summary>
    /// Gets blended descriptors from both biomes.
    /// </summary>
    /// <param name="primary">Primary biome descriptors.</param>
    /// <param name="secondary">Secondary biome descriptors.</param>
    /// <param name="descriptorType">Type of descriptor to retrieve.</param>
    /// <param name="random">Random number generator.</param>
    /// <returns>A descriptor string from the weighted selection.</returns>
    public string GetBlendedDescriptor(
        BiomeDescriptors primary,
        BiomeDescriptors secondary,
        string descriptorType,
        Random random)
    {
        if (random == null)
            throw new ArgumentNullException(nameof(random));

        var usePrimary = random.NextDouble() < PrimaryWeight;
        var source = usePrimary ? primary : secondary;

        var pool = descriptorType.ToLowerInvariant() switch
        {
            "lighting" => source.Lighting,
            "sounds" => source.Sounds,
            "smells" => source.Smells,
            "textures" => source.Textures,
            "atmosphere" => source.Atmosphere,
            "temperature" => source.Temperature,
            _ => Array.Empty<string>()
        };

        if (pool == null || !pool.Any())
            return string.Empty;

        return pool[random.Next(pool.Count)];
    }

    /// <summary>
    /// Returns a string representation of the blend.
    /// </summary>
    public override string ToString()
    {
        if (IsPure)
            return $"Pure({PrimaryBiomeId})";

        return $"Blend({PrimaryBiomeId}:{PrimaryWeight:P0} + {SecondaryBiomeId}:{SecondaryWeight:P0})";
    }
}
```

### 6.3 Properties

| Property | Type | Description |
|----------|------|-------------|
| `PrimaryBiomeId` | `string` | Source/primary biome identifier |
| `SecondaryBiomeId` | `string` | Destination/secondary biome identifier |
| `BlendRatio` | `float` | 0.0 (all primary) to 1.0 (all secondary) |
| `PrimaryWeight` | `float` | Computed: `1.0 - BlendRatio` |
| `SecondaryWeight` | `float` | Computed: `BlendRatio` |
| `IsPure` | `bool` | True if ratio is 0.0 or 1.0 |
| `IsTransitional` | `bool` | True if this is a blended zone |
| `DominantBiomeId` | `string` | Biome with higher weight |

### 6.4 Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `ForPosition(from, to, position, length)` | `TransitionBlend` | Creates blend for position in transition |
| `Pure(biomeId)` | `TransitionBlend` | Creates pure single-biome blend |
| `SelectBiomeForSpawn(random)` | `string` | Weighted random biome selection |
| `GetBlendedDescriptor(primary, secondary, type, random)` | `string` | Weighted descriptor selection |

---

## 7. BiomeProgress Value Object

### 7.1 Purpose

Tracks player progress in discovering and exploring biomes, including discovery timestamps, room visit counts, monster defeats, and deepest depth reached per biome.

### 7.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BiomeProgress.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks player progress in discovering biomes.
/// </summary>
public record BiomeProgress
{
    /// <summary>
    /// Gets discovered biome IDs with discovery timestamps.
    /// </summary>
    public IReadOnlyDictionary<string, DateTime> DiscoveredBiomes { get; init; }
        = new Dictionary<string, DateTime>();

    /// <summary>
    /// Gets rooms visited per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> RoomsVisited { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Gets monsters defeated per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> MonstersDefeated { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Gets deepest depth reached per biome.
    /// </summary>
    public IReadOnlyDictionary<string, int> DeepestDepth { get; init; }
        = new Dictionary<string, int>();

    /// <summary>
    /// Gets the total number of discovered biomes.
    /// </summary>
    public int TotalDiscovered => DiscoveredBiomes.Count;

    /// <summary>
    /// Gets the total rooms visited across all biomes.
    /// </summary>
    public int TotalRoomsVisited => RoomsVisited.Values.Sum();

    /// <summary>
    /// Gets the total monsters defeated across all biomes.
    /// </summary>
    public int TotalMonstersDefeated => MonstersDefeated.Values.Sum();

    /// <summary>
    /// Checks if a biome has been discovered.
    /// </summary>
    /// <param name="biomeId">The biome ID to check.</param>
    /// <returns>True if the biome has been discovered.</returns>
    public bool HasDiscovered(string biomeId) =>
        DiscoveredBiomes.ContainsKey(biomeId);

    /// <summary>
    /// Gets the discovery date for a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Discovery timestamp, or null if not discovered.</returns>
    public DateTime? GetDiscoveryDate(string biomeId) =>
        DiscoveredBiomes.TryGetValue(biomeId, out var date) ? date : null;

    /// <summary>
    /// Gets the room count for a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Number of rooms visited in this biome.</returns>
    public int GetRoomsVisited(string biomeId) =>
        RoomsVisited.GetValueOrDefault(biomeId, 0);

    /// <summary>
    /// Gets the monster defeat count for a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Number of monsters defeated in this biome.</returns>
    public int GetMonstersDefeated(string biomeId) =>
        MonstersDefeated.GetValueOrDefault(biomeId, 0);

    /// <summary>
    /// Gets the deepest depth for a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Deepest depth reached in this biome.</returns>
    public int GetDeepestDepth(string biomeId) =>
        DeepestDepth.GetValueOrDefault(biomeId, 0);

    /// <summary>
    /// Records discovery of a new biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Updated BiomeProgress (new instance if changed).</returns>
    public BiomeProgress DiscoverBiome(string biomeId)
    {
        if (HasDiscovered(biomeId)) return this;

        var newDiscovered = new Dictionary<string, DateTime>(DiscoveredBiomes)
        {
            [biomeId] = DateTime.UtcNow
        };

        return this with { DiscoveredBiomes = newDiscovered };
    }

    /// <summary>
    /// Records discovery of a new biome with a specific timestamp.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <param name="discoveryTime">The discovery timestamp.</param>
    /// <returns>Updated BiomeProgress (new instance if changed).</returns>
    public BiomeProgress DiscoverBiome(string biomeId, DateTime discoveryTime)
    {
        if (HasDiscovered(biomeId)) return this;

        var newDiscovered = new Dictionary<string, DateTime>(DiscoveredBiomes)
        {
            [biomeId] = discoveryTime
        };

        return this with { DiscoveredBiomes = newDiscovered };
    }

    /// <summary>
    /// Records a room visit in a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Updated BiomeProgress.</returns>
    public BiomeProgress RecordRoomVisit(string biomeId)
    {
        var current = RoomsVisited.GetValueOrDefault(biomeId, 0);
        var updated = new Dictionary<string, int>(RoomsVisited)
        {
            [biomeId] = current + 1
        };

        var result = HasDiscovered(biomeId)
            ? this
            : DiscoverBiome(biomeId);

        return result with { RoomsVisited = updated };
    }

    /// <summary>
    /// Records a monster defeat in a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Updated BiomeProgress.</returns>
    public BiomeProgress RecordMonsterDefeat(string biomeId)
    {
        var current = MonstersDefeated.GetValueOrDefault(biomeId, 0);
        var updated = new Dictionary<string, int>(MonstersDefeated)
        {
            [biomeId] = current + 1
        };

        return this with { MonstersDefeated = updated };
    }

    /// <summary>
    /// Updates the deepest depth reached in a biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <param name="depth">The depth reached.</param>
    /// <returns>Updated BiomeProgress (new instance if depth is deeper).</returns>
    public BiomeProgress UpdateDeepestDepth(string biomeId, int depth)
    {
        var current = DeepestDepth.GetValueOrDefault(biomeId, 0);
        if (depth <= current) return this;

        var updated = new Dictionary<string, int>(DeepestDepth)
        {
            [biomeId] = depth
        };

        return this with { DeepestDepth = updated };
    }

    /// <summary>
    /// Gets all discovered biome IDs.
    /// </summary>
    /// <returns>Collection of discovered biome IDs.</returns>
    public IEnumerable<string> GetDiscoveredBiomeIds() =>
        DiscoveredBiomes.Keys;

    /// <summary>
    /// Gets discovery statistics for a specific biome.
    /// </summary>
    /// <param name="biomeId">The biome ID.</param>
    /// <returns>Summary of biome progress.</returns>
    public (DateTime? Discovered, int Rooms, int Monsters, int Depth) GetBiomeStats(string biomeId)
    {
        return (
            GetDiscoveryDate(biomeId),
            GetRoomsVisited(biomeId),
            GetMonstersDefeated(biomeId),
            GetDeepestDepth(biomeId)
        );
    }
}
```

### 7.3 Properties

| Property | Type | Description |
|----------|------|-------------|
| `DiscoveredBiomes` | `IReadOnlyDictionary<string, DateTime>` | Biome IDs mapped to discovery timestamps |
| `RoomsVisited` | `IReadOnlyDictionary<string, int>` | Biome IDs mapped to room visit counts |
| `MonstersDefeated` | `IReadOnlyDictionary<string, int>` | Biome IDs mapped to monster defeat counts |
| `DeepestDepth` | `IReadOnlyDictionary<string, int>` | Biome IDs mapped to deepest depth reached |
| `TotalDiscovered` | `int` | Total number of discovered biomes |
| `TotalRoomsVisited` | `int` | Total rooms visited across all biomes |
| `TotalMonstersDefeated` | `int` | Total monsters defeated across all biomes |

### 7.4 Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `HasDiscovered(biomeId)` | `bool` | Checks if biome was discovered |
| `GetDiscoveryDate(biomeId)` | `DateTime?` | Gets discovery timestamp |
| `DiscoverBiome(biomeId)` | `BiomeProgress` | Records new discovery |
| `RecordRoomVisit(biomeId)` | `BiomeProgress` | Increments room count |
| `RecordMonsterDefeat(biomeId)` | `BiomeProgress` | Increments monster count |
| `UpdateDeepestDepth(biomeId, depth)` | `BiomeProgress` | Updates max depth if deeper |
| `GetBiomeStats(biomeId)` | `tuple` | Gets all stats for a biome |

---

## 8. TransitionService

### 8.1 Purpose

Manages all biome transition logic including finding valid transitions, creating blend states, generating transitional descriptors, and mixing spawn tables.

### 8.2 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ITransitionService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service interface for managing biome transitions.
/// </summary>
public interface ITransitionService
{
    /// <summary>
    /// Gets the transition rules between two biomes.
    /// </summary>
    /// <param name="fromBiome">Source biome ID.</param>
    /// <param name="toBiome">Destination biome ID.</param>
    /// <returns>The transition rules, or null if none defined.</returns>
    BiomeTransition? GetTransition(string fromBiome, string toBiome);

    /// <summary>
    /// Gets valid biomes that can connect to the specified biome.
    /// </summary>
    /// <param name="biomeId">Source biome ID.</param>
    /// <param name="depth">Current dungeon depth.</param>
    /// <returns>List of connectable biome IDs.</returns>
    IReadOnlyList<string> GetConnectableBiomes(string biomeId, int depth);

    /// <summary>
    /// Creates a transition blend for a room position.
    /// </summary>
    /// <param name="position">Room position in 3D space.</param>
    /// <param name="fromBiome">Source biome ID.</param>
    /// <param name="toBiome">Destination biome ID.</param>
    /// <param name="roomsFromStart">Number of rooms from transition start.</param>
    /// <param name="transitionLength">Total transition length.</param>
    /// <returns>The calculated transition blend.</returns>
    TransitionBlend CreateBlend(
        Position3D position,
        string fromBiome,
        string toBiome,
        int roomsFromStart,
        int transitionLength);

    /// <summary>
    /// Generates descriptors for a transitional room.
    /// </summary>
    /// <param name="blend">The transition blend state.</param>
    /// <param name="position">Room position.</param>
    /// <returns>Blended biome descriptors.</returns>
    BiomeDescriptors GetTransitionalDescriptors(TransitionBlend blend, Position3D position);

    /// <summary>
    /// Gets a mixed spawn table for a transitional zone.
    /// </summary>
    /// <param name="blend">The transition blend state.</param>
    /// <returns>Combined spawn table with weighted entries.</returns>
    BiomeSpawnTable GetMixedSpawnTable(TransitionBlend blend);

    /// <summary>
    /// Checks if a transition between two biomes is allowed.
    /// </summary>
    /// <param name="fromBiome">Source biome ID.</param>
    /// <param name="toBiome">Destination biome ID.</param>
    /// <param name="depth">Current dungeon depth.</param>
    /// <returns>True if the transition is allowed.</returns>
    bool IsTransitionAllowed(string fromBiome, string toBiome, int depth);

    /// <summary>
    /// Gets all transitions from a specific biome.
    /// </summary>
    /// <param name="biomeId">Source biome ID.</param>
    /// <returns>List of all transitions from this biome.</returns>
    IReadOnlyList<BiomeTransition> GetTransitionsFrom(string biomeId);
}
```

### 8.3 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/TransitionService.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing biome transitions.
/// </summary>
public class TransitionService : ITransitionService
{
    private readonly IBiomeService _biomeService;
    private readonly IConfigurationProvider _config;
    private readonly SeededRandomService _random;
    private readonly ILogger<TransitionService> _logger;

    /// <summary>
    /// Initializes a new instance of TransitionService.
    /// </summary>
    /// <param name="biomeService">Biome service for biome data.</param>
    /// <param name="config">Configuration provider for transition data.</param>
    /// <param name="random">Seeded random service.</param>
    /// <param name="logger">Logger instance.</param>
    public TransitionService(
        IBiomeService biomeService,
        IConfigurationProvider config,
        SeededRandomService random,
        ILogger<TransitionService> logger)
    {
        _biomeService = biomeService ?? throw new ArgumentNullException(nameof(biomeService));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public BiomeTransition? GetTransition(string fromBiome, string toBiome)
    {
        _logger.LogDebug("Getting transition from {FromBiome} to {ToBiome}", fromBiome, toBiome);

        return _config.GetBiomeTransitions()
            .FirstOrDefault(t => t.AppliesTo(fromBiome, toBiome));
    }

    /// <inheritdoc/>
    public IReadOnlyList<string> GetConnectableBiomes(string biomeId, int depth)
    {
        _logger.LogDebug("Getting connectable biomes for {BiomeId} at depth {Depth}", biomeId, depth);

        var transitions = _config.GetBiomeTransitions()
            .Where(t => t.IsAllowed)
            .Where(t => t.IsValidAtDepth(depth))
            .Where(t => t.FromBiomeId == biomeId || (t.Bidirectional && t.ToBiomeId == biomeId))
            .Select(t => t.FromBiomeId == biomeId ? t.ToBiomeId : t.FromBiomeId)
            .Distinct()
            .ToList();

        _logger.LogDebug("Found {Count} connectable biomes for {BiomeId}", transitions.Count, biomeId);

        return transitions;
    }

    /// <inheritdoc/>
    public TransitionBlend CreateBlend(
        Position3D position,
        string fromBiome,
        string toBiome,
        int roomsFromStart,
        int transitionLength)
    {
        _logger.LogDebug(
            "Creating blend at position {Position} from {From} to {To}, room {Room} of {Length}",
            position, fromBiome, toBiome, roomsFromStart, transitionLength);

        return TransitionBlend.ForPosition(
            fromBiome,
            toBiome,
            roomsFromStart,
            transitionLength);
    }

    /// <inheritdoc/>
    public BiomeDescriptors GetTransitionalDescriptors(TransitionBlend blend, Position3D position)
    {
        _logger.LogDebug("Getting transitional descriptors for blend {Blend}", blend);

        var primary = _biomeService.GetBiome(blend.PrimaryBiomeId);
        var secondary = _biomeService.GetBiome(blend.SecondaryBiomeId);

        if (primary == null || secondary == null)
        {
            _logger.LogWarning(
                "Could not find biome definitions for blend: primary={Primary}, secondary={Secondary}",
                blend.PrimaryBiomeId, blend.SecondaryBiomeId);
            return BiomeDescriptors.Default;
        }

        return new BiomeDescriptors
        {
            Lighting = BlendDescriptorList(
                primary.Descriptors.Lighting,
                secondary.Descriptors.Lighting,
                blend.BlendRatio),
            Sounds = BlendDescriptorList(
                primary.Descriptors.Sounds,
                secondary.Descriptors.Sounds,
                blend.BlendRatio),
            Smells = BlendDescriptorList(
                primary.Descriptors.Smells,
                secondary.Descriptors.Smells,
                blend.BlendRatio),
            Textures = BlendDescriptorList(
                primary.Descriptors.Textures,
                secondary.Descriptors.Textures,
                blend.BlendRatio),
            Atmosphere = BlendDescriptorList(
                primary.Descriptors.Atmosphere,
                secondary.Descriptors.Atmosphere,
                blend.BlendRatio),
            Temperature = BlendDescriptorList(
                primary.Descriptors.Temperature,
                secondary.Descriptors.Temperature,
                blend.BlendRatio),
            DescriptorPoolPrefix = $"transition.{blend.PrimaryBiomeId}.{blend.SecondaryBiomeId}"
        };
    }

    /// <inheritdoc/>
    public BiomeSpawnTable GetMixedSpawnTable(TransitionBlend blend)
    {
        _logger.LogDebug("Getting mixed spawn table for blend {Blend}", blend);

        var primary = _biomeService.GetSpawnTable(blend.PrimaryBiomeId);
        var secondary = _biomeService.GetSpawnTable(blend.SecondaryBiomeId);

        if (primary == null)
        {
            _logger.LogDebug("No primary spawn table, returning secondary");
            return secondary ?? new BiomeSpawnTable();
        }

        if (secondary == null)
        {
            _logger.LogDebug("No secondary spawn table, returning primary");
            return primary;
        }

        // Combine monster pools with adjusted weights
        var combinedMonsters = primary.MonsterPool
            .Select(e => e with { Weight = (int)(e.Weight * blend.PrimaryWeight) })
            .Concat(secondary.MonsterPool
                .Select(e => e with { Weight = (int)(e.Weight * blend.SecondaryWeight) }))
            .Where(e => e.Weight > 0)
            .ToList();

        var combinedItems = primary.ItemPool
            .Select(e => e with { Weight = (int)(e.Weight * blend.PrimaryWeight) })
            .Concat(secondary.ItemPool
                .Select(e => e with { Weight = (int)(e.Weight * blend.SecondaryWeight) }))
            .Where(e => e.Weight > 0)
            .ToList();

        _logger.LogDebug(
            "Combined spawn table has {MonsterCount} monsters and {ItemCount} items",
            combinedMonsters.Count, combinedItems.Count);

        return new BiomeSpawnTable
        {
            BiomeId = $"transition:{blend.PrimaryBiomeId}:{blend.SecondaryBiomeId}",
            MonsterPool = combinedMonsters,
            ItemPool = combinedItems,
            LootModifiers = BlendLootModifiers(
                primary.LootModifiers,
                secondary.LootModifiers,
                blend.BlendRatio)
        };
    }

    /// <inheritdoc/>
    public bool IsTransitionAllowed(string fromBiome, string toBiome, int depth)
    {
        var transition = GetTransition(fromBiome, toBiome);

        if (transition == null)
        {
            _logger.LogDebug("No transition defined from {From} to {To}", fromBiome, toBiome);
            return false;
        }

        if (!transition.IsAllowed)
        {
            _logger.LogDebug("Transition from {From} to {To} is explicitly disallowed", fromBiome, toBiome);
            return false;
        }

        if (!transition.IsValidAtDepth(depth))
        {
            _logger.LogDebug(
                "Transition from {From} to {To} requires depth {Required}, current is {Current}",
                fromBiome, toBiome, transition.RequiredDepth, depth);
            return false;
        }

        return true;
    }

    /// <inheritdoc/>
    public IReadOnlyList<BiomeTransition> GetTransitionsFrom(string biomeId)
    {
        return _config.GetBiomeTransitions()
            .Where(t => t.FromBiomeId == biomeId || (t.Bidirectional && t.ToBiomeId == biomeId))
            .ToList();
    }

    /// <summary>
    /// Blends two descriptor lists based on ratio.
    /// </summary>
    private IReadOnlyList<string> BlendDescriptorList(
        IReadOnlyList<string> primary,
        IReadOnlyList<string> secondary,
        float ratio)
    {
        if (primary == null || !primary.Any())
            return secondary ?? Array.Empty<string>();

        if (secondary == null || !secondary.Any())
            return primary;

        var primaryCount = (int)(primary.Count * (1 - ratio));
        var secondaryCount = (int)(secondary.Count * ratio);

        return primary.Take(Math.Max(1, primaryCount))
            .Concat(secondary.Take(Math.Max(1, secondaryCount)))
            .ToList();
    }

    /// <summary>
    /// Blends loot modifiers using linear interpolation.
    /// </summary>
    private LootModifiers BlendLootModifiers(
        LootModifiers primary,
        LootModifiers secondary,
        float ratio)
    {
        return new LootModifiers
        {
            GoldMultiplier = Lerp(primary.GoldMultiplier, secondary.GoldMultiplier, ratio),
            DropRateMultiplier = Lerp(primary.DropRateMultiplier, secondary.DropRateMultiplier, ratio),
            QualityBonus = (int)Lerp(primary.QualityBonus, secondary.QualityBonus, ratio),
            RareChanceModifier = Lerp(primary.RareChanceModifier, secondary.RareChanceModifier, ratio)
        };
    }

    /// <summary>
    /// Linear interpolation between two values.
    /// </summary>
    private static float Lerp(float a, float b, float t) => a + (b - a) * t;
}
```

### 8.4 Methods Summary

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `GetTransition` | `fromBiome`, `toBiome` | `BiomeTransition?` | Gets transition rules for biome pair |
| `GetConnectableBiomes` | `biomeId`, `depth` | `IReadOnlyList<string>` | Gets valid connecting biomes |
| `CreateBlend` | `position`, `from`, `to`, `roomsFromStart`, `length` | `TransitionBlend` | Creates blend state |
| `GetTransitionalDescriptors` | `blend`, `position` | `BiomeDescriptors` | Gets blended descriptors |
| `GetMixedSpawnTable` | `blend` | `BiomeSpawnTable` | Creates mixed spawn table |
| `IsTransitionAllowed` | `from`, `to`, `depth` | `bool` | Checks if transition permitted |
| `GetTransitionsFrom` | `biomeId` | `IReadOnlyList<BiomeTransition>` | Gets all transitions from biome |

---

## 9. Player Biome Integration

### 9.1 Purpose

Extends the Player entity with biome discovery tracking and provides methods for recording biome exploration progress.

### 9.2 Player Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Player.cs` (additions)

```csharp
// Add to Player class

/// <summary>
/// Gets the player's biome discovery progress.
/// </summary>
public BiomeProgress BiomeProgress { get; private set; } = new BiomeProgress();

/// <summary>
/// Records entering a biome, updating discovery tracking.
/// </summary>
/// <param name="biomeId">The biome being entered.</param>
/// <param name="depth">Current dungeon depth.</param>
/// <returns>Result indicating if this was a new discovery.</returns>
public BiomeDiscoveryResult EnterBiome(string biomeId, int depth)
{
    if (string.IsNullOrWhiteSpace(biomeId))
        throw new ArgumentException("BiomeId cannot be empty.", nameof(biomeId));

    var wasNew = !BiomeProgress.HasDiscovered(biomeId);

    BiomeProgress = BiomeProgress
        .RecordRoomVisit(biomeId)
        .UpdateDeepestDepth(biomeId, depth);

    return new BiomeDiscoveryResult
    {
        BiomeId = biomeId,
        IsNewDiscovery = wasNew,
        TotalRoomsVisited = BiomeProgress.GetRoomsVisited(biomeId),
        DeepestDepth = BiomeProgress.GetDeepestDepth(biomeId),
        DiscoveryTime = wasNew ? BiomeProgress.GetDiscoveryDate(biomeId) : null
    };
}

/// <summary>
/// Records defeating a monster in a biome.
/// </summary>
/// <param name="biomeId">The biome where the monster was defeated.</param>
public void RecordMonsterDefeatInBiome(string biomeId)
{
    if (string.IsNullOrWhiteSpace(biomeId))
        return;

    BiomeProgress = BiomeProgress.RecordMonsterDefeat(biomeId);
}

/// <summary>
/// Sets the player's biome progress (for loading saved games).
/// </summary>
/// <param name="progress">The biome progress to set.</param>
internal void SetBiomeProgress(BiomeProgress progress)
{
    BiomeProgress = progress ?? new BiomeProgress();
}
```

### 9.3 BiomeDiscoveryResult DTO

**File:** `src/Core/RuneAndRust.Application/DTOs/BiomeDiscoveryResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Result of entering a biome, indicating discovery status.
/// </summary>
public record BiomeDiscoveryResult
{
    /// <summary>
    /// Gets the biome ID that was entered.
    /// </summary>
    public string BiomeId { get; init; } = string.Empty;

    /// <summary>
    /// Gets whether this was a new discovery.
    /// </summary>
    public bool IsNewDiscovery { get; init; }

    /// <summary>
    /// Gets total rooms visited in this biome.
    /// </summary>
    public int TotalRoomsVisited { get; init; }

    /// <summary>
    /// Gets the deepest depth reached in this biome.
    /// </summary>
    public int DeepestDepth { get; init; }

    /// <summary>
    /// Gets the discovery timestamp if this was a new discovery.
    /// </summary>
    public DateTime? DiscoveryTime { get; init; }

    /// <summary>
    /// Gets whether this entry should trigger a codex unlock.
    /// </summary>
    public bool ShouldUnlockCodex => IsNewDiscovery;
}
```

### 9.4 Room Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (additions)

```csharp
// Add to Room class

/// <summary>
/// Gets the transition blend for this room, if in a transitional zone.
/// </summary>
public TransitionBlend? TransitionBlend { get; private set; }

/// <summary>
/// Gets whether this room is in a transitional zone.
/// </summary>
public bool IsTransitional => TransitionBlend?.IsTransitional ?? false;

/// <summary>
/// Sets the transition blend for this room.
/// </summary>
/// <param name="blend">The transition blend, or null for non-transitional rooms.</param>
public void SetTransitionBlend(TransitionBlend? blend)
{
    TransitionBlend = blend;
}
```

---

## 10. Codex Integration

### 10.1 Purpose

Integrates biome discovery with the codex system to unlock lore entries when players discover new biomes.

### 10.2 Codex Updates

**File:** `src/Core/RuneAndRust.Application/Services/CodexService.cs` (additions)

```csharp
// Add to CodexService class

/// <summary>
/// Unlocks a biome entry in the codex.
/// </summary>
/// <param name="biomeId">The biome ID to unlock.</param>
/// <returns>True if a new entry was unlocked.</returns>
public bool UnlockBiomeEntry(string biomeId)
{
    var entryId = $"biome:{biomeId}";

    if (IsEntryUnlocked(entryId))
    {
        _logger.LogDebug("Biome entry {BiomeId} already unlocked", biomeId);
        return false;
    }

    var biome = _biomeService.GetBiome(biomeId);
    if (biome == null)
    {
        _logger.LogWarning("Cannot unlock codex entry for unknown biome {BiomeId}", biomeId);
        return false;
    }

    UnlockEntry(new CodexEntry
    {
        Id = entryId,
        Category = CodexCategory.Locations,
        Title = biome.Name,
        Description = biome.Description,
        UnlockedAt = DateTime.UtcNow
    });

    _logger.LogInformation("Unlocked codex entry for biome {BiomeId}: {BiomeName}", biomeId, biome.Name);
    return true;
}
```

### 10.3 GameSessionService Updates

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs` (additions)

```csharp
// Add to ProcessRoomEntry or equivalent method

/// <summary>
/// Processes player entering a room, including biome discovery.
/// </summary>
private void ProcessBiomeEntry(Room room)
{
    if (string.IsNullOrWhiteSpace(room.BiomeId))
        return;

    var discoveryResult = _player.EnterBiome(room.BiomeId, room.Position.Z);

    if (discoveryResult.IsNewDiscovery)
    {
        _logger.LogInformation(
            "Player discovered new biome: {BiomeId}",
            discoveryResult.BiomeId);

        // Unlock codex entry
        if (discoveryResult.ShouldUnlockCodex)
        {
            _codexService.UnlockBiomeEntry(discoveryResult.BiomeId);
        }

        // Queue discovery notification for display
        QueueNotification(new BiomeDiscoveryNotification
        {
            BiomeId = discoveryResult.BiomeId,
            BiomeName = _biomeService.GetBiome(discoveryResult.BiomeId)?.Name ?? "Unknown"
        });
    }
}
```

---

## 11. Data Model Changes

### 11.1 New Definitions

| Definition | Layer | Description |
|------------|-------|-------------|
| `BiomeTransition` | Domain | Transition rules between biomes |

### 11.2 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `TransitionBlend` | Domain | Blended state for transitional zones |
| `BiomeProgress` | Domain | Player biome discovery tracking |

### 11.3 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `TransitionStyle` | Domain | Transition types (Gradual, Abrupt, Portal, Vertical) |

### 11.4 New DTOs

| DTO | Layer | Description |
|-----|-------|-------------|
| `BiomeDiscoveryResult` | Application | Result of entering a biome |

### 11.5 Entity Updates

| Entity | Change | Description |
|--------|--------|-------------|
| `Player` | Add `BiomeProgress` property | Tracks biome discovery |
| `Player` | Add `EnterBiome()` method | Records biome entry |
| `Player` | Add `RecordMonsterDefeatInBiome()` method | Tracks kills per biome |
| `Room` | Add `TransitionBlend?` property | Stores blend state |
| `Room` | Add `IsTransitional` property | Computed from blend |

### 11.6 Service Updates

| Service | Change | Description |
|---------|--------|-------------|
| `IConfigurationProvider` | Add `GetBiomeTransitions()` | Returns transition rules |
| `IBiomeService` | Add `GetSpawnTable()` reference | Used by TransitionService |
| `CodexService` | Add `UnlockBiomeEntry()` | Unlocks biome lore |

---

## 12. Configuration File Schemas

### 12.1 Biome Transitions Configuration

**File:** `config/biome-transitions.json`

```json
{
  "$schema": "./schemas/biome-transitions-schema.json",
  "transitions": [
    {
      "fromBiomeId": "catacombs",
      "toBiomeId": "sewers",
      "isAllowed": true,
      "transitionLength": 2,
      "style": "Gradual",
      "transitionDescription": "The burial chambers give way to older, flooded passages.",
      "probability": 0.8,
      "bidirectional": true
    },
    {
      "fromBiomeId": "catacombs",
      "toBiomeId": "ancient-ruins",
      "isAllowed": true,
      "transitionLength": 3,
      "style": "Gradual",
      "transitionDescription": "Ancient stonework emerges from behind crumbling tomb walls.",
      "probability": 0.6,
      "requiredDepth": 3,
      "bidirectional": true
    },
    {
      "fromBiomeId": "mines",
      "toBiomeId": "volcanic-caverns",
      "isAllowed": true,
      "transitionLength": 3,
      "style": "Gradual",
      "transitionDescription": "The tunnels grow warmer, the stone blackening as you descend toward the earth's fire.",
      "probability": 0.6,
      "requiredDepth": 5,
      "bidirectional": true
    },
    {
      "fromBiomeId": "ancient-ruins",
      "toBiomeId": "frozen-depths",
      "isAllowed": true,
      "transitionLength": 2,
      "style": "Portal",
      "transitionDescription": "An ancient portal shimmers with cold blue light, leading to frozen chambers beyond.",
      "probability": 0.4,
      "requiredDepth": 4,
      "bidirectional": true
    },
    {
      "fromBiomeId": "sewers",
      "toBiomeId": "mines",
      "isAllowed": true,
      "transitionLength": 2,
      "style": "Vertical",
      "transitionDescription": "A rusted ladder descends through a drainage grate into worked stone tunnels.",
      "probability": 0.7,
      "requiredDepth": 2,
      "bidirectional": false
    },
    {
      "fromBiomeId": "frozen-depths",
      "toBiomeId": "volcanic-caverns",
      "isAllowed": false,
      "transitionDescription": "These extreme environments cannot connect naturally.",
      "bidirectional": true
    }
  ]
}
```

### 12.2 JSON Schema

**File:** `config/schemas/biome-transitions-schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "biome-transitions-schema.json",
  "title": "Biome Transitions Configuration",
  "description": "Defines transition rules between biomes",
  "type": "object",
  "required": ["transitions"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "transitions": {
      "type": "array",
      "description": "List of biome transition rules",
      "items": {
        "type": "object",
        "required": ["fromBiomeId", "toBiomeId"],
        "properties": {
          "fromBiomeId": {
            "type": "string",
            "minLength": 1,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Source biome ID (kebab-case)"
          },
          "toBiomeId": {
            "type": "string",
            "minLength": 1,
            "pattern": "^[a-z][a-z0-9-]*$",
            "description": "Destination biome ID (kebab-case)"
          },
          "isAllowed": {
            "type": "boolean",
            "default": true,
            "description": "Whether this transition is permitted"
          },
          "transitionLength": {
            "type": "integer",
            "minimum": 0,
            "maximum": 10,
            "default": 2,
            "description": "Number of rooms in the transition zone"
          },
          "style": {
            "type": "string",
            "enum": ["Gradual", "Abrupt", "Portal", "Vertical"],
            "default": "Gradual",
            "description": "How the transition occurs"
          },
          "transitionDescription": {
            "type": "string",
            "description": "Narrative text describing the transition"
          },
          "probability": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "default": 1.0,
            "description": "Chance this transition occurs (0.0 to 1.0)"
          },
          "requiredDepth": {
            "type": "integer",
            "minimum": 0,
            "description": "Minimum depth for this transition to be available"
          },
          "bidirectional": {
            "type": "boolean",
            "default": true,
            "description": "Whether transition works in both directions"
          }
        }
      }
    }
  }
}
```

### 12.3 Configuration DTO

**File:** `src/Core/RuneAndRust.Application/Configuration/BiomeTransitionConfigurationDto.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// DTO for deserializing biome transition configuration.
/// </summary>
public class BiomeTransitionConfigurationDto
{
    /// <summary>
    /// Gets or sets the list of transition definitions.
    /// </summary>
    public List<BiomeTransitionDto> Transitions { get; set; } = new();
}

/// <summary>
/// DTO for a single biome transition definition.
/// </summary>
public class BiomeTransitionDto
{
    /// <summary>
    /// Gets or sets the source biome ID.
    /// </summary>
    public string FromBiomeId { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the destination biome ID.
    /// </summary>
    public string ToBiomeId { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets whether this transition is allowed.
    /// </summary>
    public bool IsAllowed { get; set; } = true;

    /// <summary>
    /// Gets or sets the number of transition rooms.
    /// </summary>
    public int TransitionLength { get; set; } = 2;

    /// <summary>
    /// Gets or sets the transition style.
    /// </summary>
    public string Style { get; set; } = "Gradual";

    /// <summary>
    /// Gets or sets the transition description.
    /// </summary>
    public string TransitionDescription { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the transition probability.
    /// </summary>
    public float Probability { get; set; } = 1.0f;

    /// <summary>
    /// Gets or sets the required depth.
    /// </summary>
    public int? RequiredDepth { get; set; }

    /// <summary>
    /// Gets or sets whether the transition is bidirectional.
    /// </summary>
    public bool Bidirectional { get; set; } = true;

    /// <summary>
    /// Converts this DTO to a domain entity.
    /// </summary>
    public BiomeTransition ToDomain()
    {
        var style = Enum.TryParse<TransitionStyle>(Style, true, out var parsedStyle)
            ? parsedStyle
            : TransitionStyle.Gradual;

        return BiomeTransition.Create(
            FromBiomeId,
            ToBiomeId,
            IsAllowed,
            TransitionLength,
            style,
            TransitionDescription,
            Probability,
            RequiredDepth,
            Bidirectional);
    }
}
```

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `TransitionService` | Information | Transition created, blend applied |
| `TransitionService` | Debug | Blend calculations, connectable biome queries |
| `TransitionService` | Warning | Missing biome definitions for blend |
| `TransitionService` | Error | Invalid transition configuration |
| `Player` | Information | New biome discovered |
| `Player` | Debug | Biome progress updates |
| `CodexService` | Information | Biome entry unlocked |
| `CodexService` | Debug | Entry unlock checks |
| `CodexService` | Warning | Unknown biome for codex |
| `JsonConfigurationProvider` | Information | Transition config loaded |
| `JsonConfigurationProvider` | Warning | Invalid transition entries skipped |
| `JsonConfigurationProvider` | Error | Configuration file errors |

### 13.2 Log Message Examples

```csharp
// Information
_logger.LogInformation("Player discovered new biome: {BiomeId}", biomeId);
_logger.LogInformation("Unlocked codex entry for biome {BiomeId}: {BiomeName}", biomeId, biomeName);
_logger.LogInformation("Loaded {Count} biome transitions from configuration", transitions.Count);

// Debug
_logger.LogDebug("Creating blend at position {Position} from {From} to {To}, room {Room} of {Length}",
    position, fromBiome, toBiome, roomsFromStart, transitionLength);
_logger.LogDebug("Getting connectable biomes for {BiomeId} at depth {Depth}", biomeId, depth);
_logger.LogDebug("Combined spawn table has {MonsterCount} monsters and {ItemCount} items",
    combinedMonsters.Count, combinedItems.Count);

// Warning
_logger.LogWarning("Could not find biome definitions for blend: primary={Primary}, secondary={Secondary}",
    blend.PrimaryBiomeId, blend.SecondaryBiomeId);
_logger.LogWarning("Cannot unlock codex entry for unknown biome {BiomeId}", biomeId);

// Error
_logger.LogError("Failed to load biome transitions: {Error}", exception.Message);
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| BiomeTransition Entity | ~4 |
| TransitionBlend Value Object | ~5 |
| BiomeProgress Value Object | ~5 |
| TransitionService | ~5 |
| Player Biome Integration | ~3 |
| **Total** | **~22** |

### 14.2 BiomeTransition Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/BiomeTransitionTests.cs`

```csharp
namespace RuneAndRust.Domain.UnitTests.Definitions;

[TestFixture]
public class BiomeTransitionTests
{
    [Test]
    public void Create_WithValidParameters_CreatesTransition()
    {
        // Arrange & Act
        var transition = BiomeTransition.Create(
            fromBiomeId: "catacombs",
            toBiomeId: "sewers",
            transitionLength: 2,
            style: TransitionStyle.Gradual);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(transition.FromBiomeId, Is.EqualTo("catacombs"));
            Assert.That(transition.ToBiomeId, Is.EqualTo("sewers"));
            Assert.That(transition.TransitionLength, Is.EqualTo(2));
            Assert.That(transition.Style, Is.EqualTo(TransitionStyle.Gradual));
            Assert.That(transition.IsAllowed, Is.True);
            Assert.That(transition.Bidirectional, Is.True);
        });
    }

    [Test]
    public void Create_WithEmptyFromBiomeId_ThrowsArgumentException()
    {
        // Act & Assert
        Assert.Throws<ArgumentException>(() =>
            BiomeTransition.Create(fromBiomeId: "", toBiomeId: "sewers"));
    }

    [Test]
    public void AppliesTo_WithMatchingBiomePair_ReturnsTrue()
    {
        // Arrange
        var transition = BiomeTransition.Create("catacombs", "sewers");

        // Act & Assert
        Assert.Multiple(() =>
        {
            Assert.That(transition.AppliesTo("catacombs", "sewers"), Is.True);
            Assert.That(transition.AppliesTo("sewers", "catacombs"), Is.True); // Bidirectional
            Assert.That(transition.AppliesTo("mines", "sewers"), Is.False);
        });
    }

    [Test]
    public void IsValidAtDepth_WithRequiredDepth_EnforcesMinimum()
    {
        // Arrange
        var transition = BiomeTransition.Create(
            fromBiomeId: "mines",
            toBiomeId: "volcanic-caverns",
            requiredDepth: 5);

        // Act & Assert
        Assert.Multiple(() =>
        {
            Assert.That(transition.IsValidAtDepth(4), Is.False);
            Assert.That(transition.IsValidAtDepth(5), Is.True);
            Assert.That(transition.IsValidAtDepth(10), Is.True);
        });
    }
}
```

### 14.3 TransitionBlend Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/TransitionBlendTests.cs`

```csharp
namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class TransitionBlendTests
{
    [Test]
    public void ForPosition_AtStart_ReturnsZeroRatio()
    {
        // Arrange & Act
        var blend = TransitionBlend.ForPosition("catacombs", "sewers", 0, 3);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(blend.BlendRatio, Is.EqualTo(0f));
            Assert.That(blend.PrimaryWeight, Is.EqualTo(1f));
            Assert.That(blend.SecondaryWeight, Is.EqualTo(0f));
            Assert.That(blend.IsPure, Is.True);
        });
    }

    [Test]
    public void ForPosition_AtMiddle_ReturnsHalfRatio()
    {
        // Arrange & Act
        var blend = TransitionBlend.ForPosition("catacombs", "sewers", 1, 2);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(blend.BlendRatio, Is.EqualTo(0.5f));
            Assert.That(blend.PrimaryWeight, Is.EqualTo(0.5f));
            Assert.That(blend.SecondaryWeight, Is.EqualTo(0.5f));
            Assert.That(blend.IsPure, Is.False);
        });
    }

    [Test]
    public void ForPosition_AtEnd_ReturnsFullRatio()
    {
        // Arrange & Act
        var blend = TransitionBlend.ForPosition("catacombs", "sewers", 3, 3);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(blend.BlendRatio, Is.EqualTo(1f));
            Assert.That(blend.PrimaryWeight, Is.EqualTo(0f));
            Assert.That(blend.SecondaryWeight, Is.EqualTo(1f));
            Assert.That(blend.IsPure, Is.True);
        });
    }

    [Test]
    public void Pure_CreatesSingleBiomeBlend()
    {
        // Arrange & Act
        var blend = TransitionBlend.Pure("catacombs");

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(blend.PrimaryBiomeId, Is.EqualTo("catacombs"));
            Assert.That(blend.SecondaryBiomeId, Is.EqualTo("catacombs"));
            Assert.That(blend.BlendRatio, Is.EqualTo(0f));
            Assert.That(blend.IsPure, Is.True);
        });
    }

    [Test]
    public void SelectBiomeForSpawn_WithBlend_SelectsBasedOnWeights()
    {
        // Arrange
        var blend = TransitionBlend.ForPosition("catacombs", "sewers", 1, 4); // 25% ratio
        var random = new Random(42); // Seeded for reproducibility

        // Act - run multiple selections
        var selections = Enumerable.Range(0, 100)
            .Select(_ => blend.SelectBiomeForSpawn(random))
            .ToList();

        // Assert - should have both biomes, with primary more common
        Assert.Multiple(() =>
        {
            Assert.That(selections, Contains.Item("catacombs"));
            Assert.That(selections, Contains.Item("sewers"));
            Assert.That(selections.Count(s => s == "catacombs"), Is.GreaterThan(50));
        });
    }
}
```

### 14.4 BiomeProgress Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/BiomeProgressTests.cs`

```csharp
namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class BiomeProgressTests
{
    [Test]
    public void DiscoverBiome_NewBiome_AddsToDiscovered()
    {
        // Arrange
        var progress = new BiomeProgress();

        // Act
        var updated = progress.DiscoverBiome("catacombs");

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(updated.HasDiscovered("catacombs"), Is.True);
            Assert.That(updated.TotalDiscovered, Is.EqualTo(1));
            Assert.That(updated.GetDiscoveryDate("catacombs"), Is.Not.Null);
        });
    }

    [Test]
    public void DiscoverBiome_AlreadyDiscovered_ReturnsUnchanged()
    {
        // Arrange
        var progress = new BiomeProgress().DiscoverBiome("catacombs");

        // Act
        var updated = progress.DiscoverBiome("catacombs");

        // Assert
        Assert.That(updated, Is.SameAs(progress));
    }

    [Test]
    public void RecordRoomVisit_IncrementsCountAndDiscoversBiome()
    {
        // Arrange
        var progress = new BiomeProgress();

        // Act
        var updated = progress
            .RecordRoomVisit("catacombs")
            .RecordRoomVisit("catacombs");

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(updated.HasDiscovered("catacombs"), Is.True);
            Assert.That(updated.GetRoomsVisited("catacombs"), Is.EqualTo(2));
        });
    }

    [Test]
    public void UpdateDeepestDepth_DeeperDepth_Updates()
    {
        // Arrange
        var progress = new BiomeProgress()
            .UpdateDeepestDepth("catacombs", 3);

        // Act
        var updated = progress.UpdateDeepestDepth("catacombs", 5);

        // Assert
        Assert.That(updated.GetDeepestDepth("catacombs"), Is.EqualTo(5));
    }

    [Test]
    public void UpdateDeepestDepth_ShallowerDepth_DoesNotUpdate()
    {
        // Arrange
        var progress = new BiomeProgress()
            .UpdateDeepestDepth("catacombs", 5);

        // Act
        var updated = progress.UpdateDeepestDepth("catacombs", 3);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(updated.GetDeepestDepth("catacombs"), Is.EqualTo(5));
            Assert.That(updated, Is.SameAs(progress));
        });
    }
}
```

### 14.5 TransitionService Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/TransitionServiceTests.cs`

```csharp
namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class TransitionServiceTests
{
    private Mock<IBiomeService> _biomeServiceMock;
    private Mock<IConfigurationProvider> _configMock;
    private Mock<SeededRandomService> _randomMock;
    private Mock<ILogger<TransitionService>> _loggerMock;
    private TransitionService _service;

    [SetUp]
    public void SetUp()
    {
        _biomeServiceMock = new Mock<IBiomeService>();
        _configMock = new Mock<IConfigurationProvider>();
        _randomMock = new Mock<SeededRandomService>();
        _loggerMock = new Mock<ILogger<TransitionService>>();

        _service = new TransitionService(
            _biomeServiceMock.Object,
            _configMock.Object,
            _randomMock.Object,
            _loggerMock.Object);
    }

    [Test]
    public void GetTransition_ExistingTransition_ReturnsTransition()
    {
        // Arrange
        var transition = BiomeTransition.Create("catacombs", "sewers");
        _configMock.Setup(c => c.GetBiomeTransitions())
            .Returns(new List<BiomeTransition> { transition });

        // Act
        var result = _service.GetTransition("catacombs", "sewers");

        // Assert
        Assert.That(result, Is.Not.Null);
        Assert.That(result!.FromBiomeId, Is.EqualTo("catacombs"));
    }

    [Test]
    public void GetConnectableBiomes_WithValidTransitions_ReturnsConnectableBiomes()
    {
        // Arrange
        var transitions = new List<BiomeTransition>
        {
            BiomeTransition.Create("catacombs", "sewers"),
            BiomeTransition.Create("catacombs", "mines", requiredDepth: 5)
        };
        _configMock.Setup(c => c.GetBiomeTransitions()).Returns(transitions);

        // Act
        var result = _service.GetConnectableBiomes("catacombs", depth: 2);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result, Contains.Item("sewers"));
            Assert.That(result, Does.Not.Contain("mines")); // Depth requirement not met
        });
    }

    [Test]
    public void IsTransitionAllowed_AllowedTransition_ReturnsTrue()
    {
        // Arrange
        var transition = BiomeTransition.Create("catacombs", "sewers");
        _configMock.Setup(c => c.GetBiomeTransitions())
            .Returns(new List<BiomeTransition> { transition });

        // Act
        var result = _service.IsTransitionAllowed("catacombs", "sewers", depth: 1);

        // Assert
        Assert.That(result, Is.True);
    }

    [Test]
    public void IsTransitionAllowed_DisallowedTransition_ReturnsFalse()
    {
        // Arrange
        var transition = BiomeTransition.Create("frozen-depths", "volcanic-caverns", isAllowed: false);
        _configMock.Setup(c => c.GetBiomeTransitions())
            .Returns(new List<BiomeTransition> { transition });

        // Act
        var result = _service.IsTransitionAllowed("frozen-depths", "volcanic-caverns", depth: 1);

        // Assert
        Assert.That(result, Is.False);
    }

    [Test]
    public void GetMixedSpawnTable_WithBlend_CombinesTables()
    {
        // Arrange
        var primaryTable = new BiomeSpawnTable
        {
            BiomeId = "catacombs",
            MonsterPool = new List<SpawnEntry>
            {
                new SpawnEntry { EntityId = "skeleton", Weight = 100 }
            }
        };
        var secondaryTable = new BiomeSpawnTable
        {
            BiomeId = "sewers",
            MonsterPool = new List<SpawnEntry>
            {
                new SpawnEntry { EntityId = "rat-swarm", Weight = 100 }
            }
        };
        var blend = TransitionBlend.ForPosition("catacombs", "sewers", 1, 2);

        _biomeServiceMock.Setup(b => b.GetSpawnTable("catacombs")).Returns(primaryTable);
        _biomeServiceMock.Setup(b => b.GetSpawnTable("sewers")).Returns(secondaryTable);

        // Act
        var result = _service.GetMixedSpawnTable(blend);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.MonsterPool, Has.Count.EqualTo(2));
            Assert.That(result.MonsterPool.Any(e => e.EntityId == "skeleton"), Is.True);
            Assert.That(result.MonsterPool.Any(e => e.EntityId == "rat-swarm"), Is.True);
        });
    }
}
```

### 14.6 Player Biome Integration Tests

**File:** `tests/RuneAndRust.Domain.UnitTests/Entities/PlayerBiomeTests.cs`

```csharp
namespace RuneAndRust.Domain.UnitTests.Entities;

[TestFixture]
public class PlayerBiomeTests
{
    [Test]
    public void EnterBiome_NewBiome_ReturnsDiscoveryResult()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var result = player.EnterBiome("catacombs", depth: 1);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsNewDiscovery, Is.True);
            Assert.That(result.BiomeId, Is.EqualTo("catacombs"));
            Assert.That(result.TotalRoomsVisited, Is.EqualTo(1));
            Assert.That(result.DeepestDepth, Is.EqualTo(1));
            Assert.That(result.ShouldUnlockCodex, Is.True);
        });
    }

    [Test]
    public void EnterBiome_AlreadyDiscoveredBiome_ReturnsNonDiscoveryResult()
    {
        // Arrange
        var player = CreateTestPlayer();
        player.EnterBiome("catacombs", depth: 1);

        // Act
        var result = player.EnterBiome("catacombs", depth: 2);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.IsNewDiscovery, Is.False);
            Assert.That(result.TotalRoomsVisited, Is.EqualTo(2));
            Assert.That(result.DeepestDepth, Is.EqualTo(2));
            Assert.That(result.ShouldUnlockCodex, Is.False);
        });
    }

    [Test]
    public void RecordMonsterDefeatInBiome_UpdatesBiomeProgress()
    {
        // Arrange
        var player = CreateTestPlayer();
        player.EnterBiome("catacombs", depth: 1);

        // Act
        player.RecordMonsterDefeatInBiome("catacombs");
        player.RecordMonsterDefeatInBiome("catacombs");

        // Assert
        Assert.That(player.BiomeProgress.GetMonstersDefeated("catacombs"), Is.EqualTo(2));
    }

    private Player CreateTestPlayer()
    {
        // Create player with required parameters
        return Player.Create("TestPlayer", Guid.NewGuid());
    }
}
```

---

## 15. Use Cases

### UC-001: Player Enters Transitional Zone

**Actor:** Player
**Trigger:** Moving from a room in one biome to a transitional room
**Flow:**
1. Player moves from Catacombs room → Transition room (Catacombs→Sewers)
2. TransitionService.CreateBlend() calculates blend ratio based on position
3. GetTransitionalDescriptors() generates mixed atmospheric text
4. Room displays blended descriptions from both biomes
5. Player sees: "The dusty tombs give way to damp stone as water begins dripping..."

### UC-002: Player Discovers New Biome

**Actor:** Player
**Trigger:** Entering a biome for the first time
**Flow:**
1. Player enters Sewers biome for first time
2. Player.EnterBiome() checks BiomeProgress.HasDiscovered("sewers") → false
3. BiomeProgress.DiscoverBiome() records discovery with timestamp
4. BiomeDiscoveryResult.IsNewDiscovery = true
5. CodexService.UnlockBiomeEntry() adds Sewers lore
6. Notification displayed: "You have discovered the Sewers!"

### UC-003: System Generates Mixed Encounter

**Actor:** System
**Trigger:** Monster spawn in transitional zone
**Flow:**
1. Room generation identifies transitional zone (blend ratio 0.5)
2. TransitionService.GetMixedSpawnTable() combines both biome tables
3. Skeleton (50 weight) and Rat Swarm (50 weight) both in pool
4. Random selection from combined pool
5. Spawned monster appropriate to the blended environment

### UC-004: System Validates Biome Connection

**Actor:** System
**Trigger:** Dungeon generation connecting rooms
**Flow:**
1. RoomGenerator needs to connect Frozen Depths to new room
2. TransitionService.GetConnectableBiomes("frozen-depths", depth: 6)
3. System returns valid targets: Ancient Ruins (Portal), Catacombs (Gradual)
4. Volcanic Caverns excluded (IsAllowed: false)
5. Generator selects valid connection

### UC-005: Player Views Biome Statistics

**Actor:** Player
**Trigger:** Opening codex/stats screen
**Flow:**
1. Player opens Codex → Locations
2. System queries Player.BiomeProgress
3. Display shows discovered biomes with stats:
   - Catacombs: Discovered 2024-01-15, 47 rooms, 23 monsters, depth 8
   - Sewers: Discovered 2024-01-16, 12 rooms, 8 monsters, depth 4
4. Undiscovered biomes shown as "???"

---

## 16. Deliverable Checklist

### BiomeTransition Entity
- [ ] `BiomeTransition.cs` with all properties
- [ ] `BiomeTransition.Create()` factory method
- [ ] `AppliesTo()` method
- [ ] `IsValidAtDepth()` method

### TransitionStyle Enum
- [ ] `TransitionStyle.cs` with Gradual, Abrupt, Portal, Vertical

### TransitionBlend Value Object
- [ ] `TransitionBlend.cs` with all properties
- [ ] `ForPosition()` factory method
- [ ] `Pure()` factory method
- [ ] `SelectBiomeForSpawn()` method
- [ ] `GetBlendedDescriptor()` method

### BiomeProgress Value Object
- [ ] `BiomeProgress.cs` with dictionary properties
- [ ] `HasDiscovered()` method
- [ ] `DiscoverBiome()` method
- [ ] `RecordRoomVisit()` method
- [ ] `RecordMonsterDefeat()` method
- [ ] `UpdateDeepestDepth()` method

### TransitionService
- [ ] `ITransitionService.cs` interface
- [ ] `TransitionService.cs` implementation
- [ ] `GetTransition()` method
- [ ] `GetConnectableBiomes()` method
- [ ] `CreateBlend()` method
- [ ] `GetTransitionalDescriptors()` method
- [ ] `GetMixedSpawnTable()` method
- [ ] `IsTransitionAllowed()` method

### Player Integration
- [ ] `Player.BiomeProgress` property
- [ ] `Player.EnterBiome()` method
- [ ] `Player.RecordMonsterDefeatInBiome()` method
- [ ] `BiomeDiscoveryResult.cs` DTO

### Room Updates
- [ ] `Room.TransitionBlend` property
- [ ] `Room.IsTransitional` computed property
- [ ] `Room.SetTransitionBlend()` method

### Codex Integration
- [ ] `CodexService.UnlockBiomeEntry()` method

### Configuration Files
- [ ] `config/biome-transitions.json` created
- [ ] `config/schemas/biome-transitions-schema.json` created
- [ ] `BiomeTransitionConfigurationDto.cs` created
- [ ] `IConfigurationProvider.GetBiomeTransitions()` implemented

### Testing
- [ ] ~22 unit tests implemented
- [ ] All tests passing

---

## 17. Acceptance Criteria

### Functional
- [ ] BiomeTransition entity defines connection rules between biomes
- [ ] TransitionBlend calculates blended state for any position in transition
- [ ] TransitionService creates transitional rooms with blended content
- [ ] Descriptors blend proportionally between biomes
- [ ] Spawn tables mix based on blend weights
- [ ] Transition configuration loads from JSON
- [ ] Player tracks BiomeProgress for all discovered biomes
- [ ] Biome discovery triggers notifications on first visit
- [ ] Codex entries unlock on biome discovery
- [ ] Invalid transitions (IsAllowed: false) are blocked
- [ ] Depth requirements are enforced for transitions
- [ ] Bidirectional transitions work in both directions

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~22 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on all public members
- [ ] Code follows .editorconfig conventions
- [ ] No new code analysis warnings

---

## 18. Future Considerations

### Deferred to v0.1.3+
- **Custom biome creation UI**: Allow players to define custom biomes (future modding support)
- **Biome-specific quests**: Quests that require visiting or completing objectives in specific biomes
- **Biome affinity system**: Player stats affected by time spent in biomes
- **Seasonal biome changes**: Biomes that change characteristics based on game time

### Out of Scope
- **Procedural biome generation**: Creating new biome definitions at runtime
- **Biome weather systems**: Weather effects within biomes (separate feature)
- **Biome NPCs**: NPCs specific to biomes (NPC system not yet implemented)

---

## Dependencies

### Requires (Prerequisites)
- v0.1.2a: `BiomeDefinition`, `BiomeDescriptors`, `BiomeService`, `IBiomeService`
- v0.1.2b: `BiomeSpawnTable`, `SpawnEntry`, `LootModifiers`
- v0.1.2c: `BiomeHazard`, `HazardService` (for complete biome experience)
- v0.1.1: `SeededRandomService`, `Position3D`, `DescriptorService`
- v0.0.x: `Player` entity, `Room` entity, `CodexService`

### Provides (For Future Versions)
- `BiomeTransition`: Foundation for dungeon graph generation
- `TransitionBlend`: Reusable blending calculations
- `BiomeProgress`: Player statistics for achievements
- `ITransitionService`: Service interface for transition management

---

*Document Version: 1.0*
*Last Updated: 2026-01-09*
*Author: Claude (AI Assistant)*
