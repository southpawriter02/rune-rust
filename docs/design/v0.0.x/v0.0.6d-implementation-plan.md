# v0.0.6d Implementation Plan: Status Effect Integration & Polish

**Version:** 0.0.6d
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a, v0.0.6b, v0.0.6c Complete
**Status:** Ready for Implementation
**Target Tests:** ~261 -> ~281 (+20 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
   - [Domain Layer](#domain-layer)
   - [Application Layer](#application-layer)
   - [Infrastructure Layer](#infrastructure-layer)
   - [Presentation Layer](#presentation-layer)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Integrate the status effect framework (v0.0.6c) with combat, implementing effect interactions, cleanse mechanics, AI behavior modification based on effects, and UI display. This phase completes the v0.0.6 Enhanced Combat System by making status effects tactically meaningful during combat.

### Scope

**In Scope:**
- `EffectTrigger` enum for when effects apply
- `CombatEffectService` for combat/effect integration
- `EffectInteractionService` for effect combos (Wet + Lightning, etc.)
- `EffectInteraction` record for interaction definitions
- `CleanseType` enum and `CleanseService` for effect removal
- `CleanseItem` record for cleanse consumables
- `EffectAwareAIService` wrapping AI with effect considerations
- `TurnStartEffectResult` and `AttackEffectResult` value objects
- `ActiveEffectDto` and `CombatantStatusDto` for UI display
- Renderer methods for effect display
- JSON configuration for interactions and cleanse items
- Combat log integration for effect events

**Out of Scope:**
- New status effects (uses existing 28 from v0.0.6c)
- Equipment with effect application (v0.0.7)
- Passive effect auras
- Complex environmental spreading

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Effect tick timing | Start of turn | Predictable, matches initiative flow |
| Critical hit effect | 30% chance to apply Bleeding | Adds tactical depth without complexity |
| Interaction data source | JSON configuration | Data-driven, easily adjustable |
| AI effect priorities | Feared > Stunned > others | Clear hierarchy of forced behaviors |
| Resistance/vulnerability | 50% reduction/increase | Simple, meaningful impact |
| Cleanse item consumption | On successful use | Prevents waste on failed attempts |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.6a (Multi-Monster Combat)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `CombatEncounter` | `Domain/Entities/CombatEncounter.cs` | Combat context, turn management |
| `Combatant` | `Domain/Entities/Combatant.cs` | Participant wrapper, effect target access |
| `CombatState` | `Domain/Enums/CombatState.cs` | Combat state checks |
| `TargetResolver` | `Application/Services/TargetResolver.cs` | Target validation for cleanse items |

### Dependencies from v0.0.6b (Monster AI & Flee)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `MonsterAIService` | `Application/Services/MonsterAIService.cs` | Base AI to wrap with effect awareness |
| `AIContext` | `Domain/ValueObjects/AIContext.cs` | AI decision context |
| `AIDecision` | `Domain/ValueObjects/AIDecision.cs` | AI decision result |
| `AIAction` | `Domain/Enums/AIAction.cs` | Action types |
| `CombatLogService` | `Application/Services/CombatLogService.cs` | Effect event logging |
| `CombatLogType` | `Domain/Enums/CombatLogType.cs` | StatusApplied, StatusExpired types |

### Dependencies from v0.0.6c (Status Effect Framework)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `StatusEffectDefinition` | `Domain/Definitions/StatusEffectDefinition.cs` | Effect metadata |
| `ActiveStatusEffect` | `Domain/Entities/ActiveStatusEffect.cs` | Effect instances |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Core effect operations |
| `IEffectTarget` | `Domain/Interfaces/IEffectTarget.cs` | Target interface |
| `EffectApplicationResult` | `Domain/ValueObjects/EffectApplicationResult.cs` | Application results |
| `EffectTickResult` | `Domain/ValueObjects/EffectTickResult.cs` | Tick results |
| `EffectCategory` | `Domain/Enums/EffectCategory.cs` | Buff/Debuff/Environmental |
| `StatModifier` | `Domain/ValueObjects/StatModifier.cs` | Stat modification |

---

## Current System Analysis

### Existing Combat Flow (from v0.0.6a-c)

```
COMBAT TURN (v0.0.6a-c)
    ├── Combatant's turn starts
    │   └── (No effect processing)
    │
    ├── If Player's turn:
    │   ├── Wait for command
    │   └── Execute command
    │
    ├── If Monster's turn:
    │   ├── MonsterAIService.DecideAction()
    │   └── Execute action
    │
    └── Advance turn
```

### New Effect-Integrated Combat Flow

```
COMBAT TURN (v0.0.6d)
    │
    ├─► 1. START OF TURN - Process Effects
    │   ├── CombatEffectService.ProcessTurnStart()
    │   │   ├── Tick all DoT/HoT effects
    │   │   ├── Decrement durations
    │   │   ├── Remove expired effects
    │   │   └── Log effect results
    │   │
    │   ├── Check if combatant died from DoT
    │   │   └── Yes → End combat / advance turn
    │   │
    │   └── Check action prevention
    │       ├── Stunned → Log skip, advance turn
    │       ├── Feared → Force flee attempt
    │       └── Other → Continue
    │
    ├─► 2. EXECUTE ACTION
    │   │
    │   ├── If Player's turn:
    │   │   ├── Wait for command
    │   │   ├── If "use <item>":
    │   │   │   └── CleanseService.Cleanse() if cleanse item
    │   │   └── If "attack":
    │   │       ├── Calculate damage (with effect modifiers)
    │   │       └── CombatEffectService.ProcessAttackHit()
    │   │
    │   └── If Monster's turn:
    │       ├── EffectAwareAIService.GetEffectAwareDecision()
    │       │   ├── Check forced behaviors (Feared, Stunned)
    │       │   ├── Modify decision for effects (Cursed, Silenced, etc.)
    │       │   └── Return final decision
    │       │
    │       └── Execute action
    │           └── If Attack → ProcessAttackHit()
    │
    ├─► 3. PROCESS ATTACK RESULTS (if attack occurred)
    │   ├── Get on-hit effects from attacker
    │   ├── Apply on-hit effects to target
    │   ├── Check for damage type interactions
    │   │   └── EffectInteractionService.ProcessDamageInteractions()
    │   ├── Apply interaction results (bonus damage, new effects)
    │   └── Log all effect events
    │
    └─► 4. ADVANCE TURN
```

---

## Detailed Implementation

### Domain Layer

#### 1. EffectTrigger.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/EffectTrigger.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines when a status effect can be applied.
/// </summary>
/// <remarks>
/// <para>Triggers are used by weapons, abilities, and combat events to determine
/// when effects should be applied to targets.</para>
/// </remarks>
public enum EffectTrigger
{
    /// <summary>Applied when an attack hits.</summary>
    OnHit,

    /// <summary>Applied when damage is dealt.</summary>
    OnDamage,

    /// <summary>Applied when taking damage.</summary>
    OnDamageTaken,

    /// <summary>Applied at the start of turn.</summary>
    OnTurnStart,

    /// <summary>Applied at the end of turn.</summary>
    OnTurnEnd,

    /// <summary>Applied when using an ability.</summary>
    OnAbilityUse,

    /// <summary>Applied when entering combat.</summary>
    OnCombatStart,

    /// <summary>Applied manually (items, abilities).</summary>
    Manual
}
```

#### 2. CleanseType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/CleanseType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines what types of effects a cleanse removes.
/// </summary>
/// <remarks>
/// <para>Different cleanse sources target different effect categories.</para>
/// </remarks>
public enum CleanseType
{
    /// <summary>Removes all negative effects (debuffs).</summary>
    AllNegative,

    /// <summary>Removes all positive effects (dispel).</summary>
    AllPositive,

    /// <summary>Removes physical debuffs (Bleeding, Poisoned, Exhausted, Knocked Down).</summary>
    Physical,

    /// <summary>Removes magical debuffs (Cursed, Silenced, Feared, Weakened).</summary>
    Magical,

    /// <summary>Removes elemental effects (Burning, Frozen, Wet, Chilled, On Fire, Electrified).</summary>
    Elemental,

    /// <summary>Removes a specific named effect.</summary>
    Specific
}
```

#### 3. EffectInteraction.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectInteraction.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an interaction between an existing effect and a trigger (damage type or new effect).
/// </summary>
/// <remarks>
/// <para>Effect interactions create tactical depth through elemental combinations:</para>
/// <list type="bullet">
/// <item>Wet + Lightning → +50% damage, apply Stunned</item>
/// <item>Wet + Ice → Apply Frozen, remove Wet</item>
/// <item>Burning + Wet → Remove Burning</item>
/// </list>
/// </remarks>
/// <param name="Id">Unique identifier for this interaction.</param>
/// <param name="TriggerEffectId">The existing effect on the target.</param>
/// <param name="WithTrigger">The incoming trigger (damage type or effect ID).</param>
/// <param name="BonusDamagePercent">Additional damage as percentage of base (0-100+).</param>
/// <param name="BonusDamageType">Damage type for bonus damage (if any).</param>
/// <param name="ApplyEffect">Effect ID to apply as result (if any).</param>
/// <param name="RemoveEffect">Effect ID to remove as result (if any).</param>
/// <param name="Message">Display message when interaction triggers.</param>
public readonly record struct EffectInteraction(
    string Id,
    string TriggerEffectId,
    string WithTrigger,
    int BonusDamagePercent,
    string? BonusDamageType,
    string? ApplyEffect,
    string? RemoveEffect,
    string Message)
{
    /// <summary>
    /// Whether this interaction deals bonus damage.
    /// </summary>
    public bool HasBonusDamage => BonusDamagePercent > 0;

    /// <summary>
    /// Whether this interaction applies a new effect.
    /// </summary>
    public bool AppliesEffect => !string.IsNullOrEmpty(ApplyEffect);

    /// <summary>
    /// Whether this interaction removes an effect.
    /// </summary>
    public bool RemovesEffect => !string.IsNullOrEmpty(RemoveEffect);
}
```

#### 4. EffectInteractionResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectInteractionResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of an effect interaction being triggered.
/// </summary>
/// <param name="InteractionId">The interaction that triggered.</param>
/// <param name="Message">Display message for the interaction.</param>
/// <param name="BonusDamage">Additional damage dealt.</param>
/// <param name="AppliedEffects">Effect IDs that were applied.</param>
/// <param name="RemovedEffects">Effect IDs that were removed.</param>
public readonly record struct EffectInteractionResult(
    string InteractionId,
    string Message,
    int BonusDamage,
    IReadOnlyList<string> AppliedEffects,
    IReadOnlyList<string> RemovedEffects)
{
    /// <summary>
    /// Creates a result with only bonus damage.
    /// </summary>
    public static EffectInteractionResult WithBonusDamage(
        string interactionId,
        string message,
        int damage) =>
        new(interactionId, message, damage,
            Array.Empty<string>(), Array.Empty<string>());

    /// <summary>
    /// Creates a result with effect changes.
    /// </summary>
    public static EffectInteractionResult WithEffectChanges(
        string interactionId,
        string message,
        IReadOnlyList<string> applied,
        IReadOnlyList<string> removed) =>
        new(interactionId, message, 0, applied, removed);

    /// <summary>
    /// Creates a full result.
    /// </summary>
    public static EffectInteractionResult Full(
        string interactionId,
        string message,
        int bonusDamage,
        IReadOnlyList<string> applied,
        IReadOnlyList<string> removed) =>
        new(interactionId, message, bonusDamage, applied, removed);
}
```

#### 5. TurnStartEffectResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TurnStartEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of processing effects at the start of a combatant's turn.
/// </summary>
/// <param name="TotalDamage">Total DoT damage dealt.</param>
/// <param name="TotalHealing">Total HoT healing done.</param>
/// <param name="ExpiredEffects">Effect IDs that expired this turn.</param>
/// <param name="CanAct">Whether the combatant can take actions.</param>
/// <param name="MustFlee">Whether the combatant is forced to flee.</param>
/// <param name="PreventionReason">Message explaining why actions are prevented.</param>
public readonly record struct TurnStartEffectResult(
    int TotalDamage,
    int TotalHealing,
    IReadOnlyList<string> ExpiredEffects,
    bool CanAct,
    bool MustFlee,
    string? PreventionReason)
{
    /// <summary>
    /// Creates a result for a combatant with no effects.
    /// </summary>
    public static TurnStartEffectResult NoEffects() =>
        new(0, 0, Array.Empty<string>(), true, false, null);

    /// <summary>
    /// Creates a result where the combatant can act normally.
    /// </summary>
    public static TurnStartEffectResult CanActNormally(
        int damage,
        int healing,
        IReadOnlyList<string> expired) =>
        new(damage, healing, expired, true, false, null);

    /// <summary>
    /// Creates a result where actions are prevented.
    /// </summary>
    public static TurnStartEffectResult ActionsPrevented(
        int damage,
        int healing,
        IReadOnlyList<string> expired,
        string reason,
        bool mustFlee = false) =>
        new(damage, healing, expired, false, mustFlee, reason);

    /// <summary>
    /// Whether any DoT/HoT occurred.
    /// </summary>
    public bool HadTickEffects => TotalDamage > 0 || TotalHealing > 0;

    /// <summary>
    /// Whether any effects expired.
    /// </summary>
    public bool HadExpirations => ExpiredEffects.Count > 0;
}
```

#### 6. AttackEffectResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AttackEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of processing effects triggered by an attack.
/// </summary>
/// <param name="AppliedEffects">Effects that were applied to the target.</param>
/// <param name="Interactions">Effect interactions that triggered.</param>
/// <param name="BonusDamage">Additional damage from interactions.</param>
public readonly record struct AttackEffectResult(
    IReadOnlyList<EffectApplicationResult> AppliedEffects,
    IReadOnlyList<EffectInteractionResult> Interactions,
    int BonusDamage)
{
    /// <summary>
    /// Creates an empty result (no effects or interactions).
    /// </summary>
    public static AttackEffectResult None() =>
        new(Array.Empty<EffectApplicationResult>(),
            Array.Empty<EffectInteractionResult>(), 0);

    /// <summary>
    /// Whether any effects were applied.
    /// </summary>
    public bool HadAppliedEffects => AppliedEffects.Count > 0;

    /// <summary>
    /// Whether any interactions triggered.
    /// </summary>
    public bool HadInteractions => Interactions.Count > 0;

    /// <summary>
    /// Gets all effect IDs that were successfully applied.
    /// </summary>
    public IEnumerable<string> GetAppliedEffectIds() =>
        AppliedEffects.Where(e => e.Applied).Select(e => e.EffectId);
}
```

#### 7. CleanseResult.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CleanseResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of a cleanse operation.
/// </summary>
/// <param name="Success">Whether any effects were removed.</param>
/// <param name="RemovedEffects">Effect IDs that were removed.</param>
/// <param name="Message">Display message for the result.</param>
public readonly record struct CleanseResult(
    bool Success,
    IReadOnlyList<string> RemovedEffects,
    string Message)
{
    /// <summary>
    /// Creates a successful cleanse result.
    /// </summary>
    public static CleanseResult Succeeded(IReadOnlyList<string> removed) =>
        new(true, removed, BuildMessage(removed));

    /// <summary>
    /// Creates a failed cleanse result (no matching effects).
    /// </summary>
    public static CleanseResult NoEffectsRemoved() =>
        new(false, Array.Empty<string>(), "No effects to cleanse.");

    private static string BuildMessage(IReadOnlyList<string> removed)
    {
        if (removed.Count == 0)
            return "No effects to cleanse.";
        if (removed.Count == 1)
            return $"Cleansed {removed[0]}.";
        return $"Cleansed {removed.Count} effects.";
    }
}
```

#### 8. CleanseItem.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CleanseItem.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Definition of an item that can cleanse effects.
/// </summary>
/// <param name="Id">Unique item identifier.</param>
/// <param name="Name">Display name.</param>
/// <param name="Description">Item description.</param>
/// <param name="CleanseType">What type of effects this removes.</param>
/// <param name="SpecificEffect">Specific effect ID if CleanseType is Specific.</param>
public readonly record struct CleanseItem(
    string Id,
    string Name,
    string Description,
    CleanseType CleanseType,
    string? SpecificEffect = null)
{
    /// <summary>
    /// Antidote - removes Poisoned.
    /// </summary>
    public static CleanseItem Antidote() =>
        new("antidote", "Antidote", "Cures poison afflictions.",
            CleanseType.Specific, "poisoned");

    /// <summary>
    /// Bandage - removes Bleeding.
    /// </summary>
    public static CleanseItem Bandage() =>
        new("bandage", "Bandage", "Stops bleeding wounds.",
            CleanseType.Specific, "bleeding");

    /// <summary>
    /// Panacea - removes all negative effects.
    /// </summary>
    public static CleanseItem Panacea() =>
        new("panacea", "Panacea", "A miracle cure for all ailments.",
            CleanseType.AllNegative);

    /// <summary>
    /// Smelling Salts - removes mental effects.
    /// </summary>
    public static CleanseItem SmellingSalts() =>
        new("smelling_salts", "Smelling Salts", "Clears the mind of magical influences.",
            CleanseType.Magical);

    /// <summary>
    /// Fire Resistance Potion - removes Burning.
    /// </summary>
    public static CleanseItem FireResistancePotion() =>
        new("fire_resistance_potion", "Fire Resistance Potion", "Extinguishes flames.",
            CleanseType.Specific, "burning");
}
```

---

### Application Layer

#### 1. IEffectInteractionRepository.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IEffectInteractionRepository.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Repository for loading effect interaction definitions.
/// </summary>
public interface IEffectInteractionRepository
{
    /// <summary>
    /// Gets all defined effect interactions.
    /// </summary>
    /// <returns>Collection of effect interactions.</returns>
    IReadOnlyList<EffectInteraction> GetAll();

    /// <summary>
    /// Gets interactions triggered by a specific existing effect.
    /// </summary>
    /// <param name="triggerEffectId">The effect ID on the target.</param>
    /// <returns>Interactions that can be triggered.</returns>
    IReadOnlyList<EffectInteraction> GetByTriggerEffect(string triggerEffectId);

    /// <summary>
    /// Gets a specific interaction by ID.
    /// </summary>
    /// <param name="interactionId">The interaction ID.</param>
    /// <returns>The interaction if found.</returns>
    EffectInteraction? GetById(string interactionId);
}
```

#### 2. ICleanseItemRepository.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/ICleanseItemRepository.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Repository for loading cleanse item definitions.
/// </summary>
public interface ICleanseItemRepository
{
    /// <summary>
    /// Gets a cleanse item by its ID.
    /// </summary>
    /// <param name="itemId">The item ID.</param>
    /// <returns>The cleanse item if found.</returns>
    CleanseItem? GetById(string itemId);

    /// <summary>
    /// Checks if an item ID is a cleanse item.
    /// </summary>
    /// <param name="itemId">The item ID.</param>
    /// <returns>True if this is a cleanse item.</returns>
    bool IsCleanseItem(string itemId);

    /// <summary>
    /// Gets all cleanse items.
    /// </summary>
    /// <returns>Collection of cleanse items.</returns>
    IReadOnlyList<CleanseItem> GetAll();
}
```

#### 3. CombatEffectService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/CombatEffectService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Integrates status effects with combat flow.
/// </summary>
/// <remarks>
/// <para>Handles effect processing at turn boundaries and during combat actions:</para>
/// <list type="bullet">
/// <item>Turn start: Process DoT/HoT, decrement durations, check action prevention</item>
/// <item>Attack hit: Apply on-hit effects, check interactions</item>
/// <item>Damage dealt: Process damage-triggered effects</item>
/// </list>
/// </remarks>
public class CombatEffectService
{
    private readonly StatusEffectService _statusEffectService;
    private readonly EffectInteractionService _interactionService;
    private readonly CombatLogService _combatLogService;
    private readonly ILogger<CombatEffectService> _logger;

    /// <summary>
    /// Creates a new combat effect service.
    /// </summary>
    public CombatEffectService(
        StatusEffectService statusEffectService,
        EffectInteractionService interactionService,
        CombatLogService combatLogService,
        ILogger<CombatEffectService> logger)
    {
        _statusEffectService = statusEffectService;
        _interactionService = interactionService;
        _combatLogService = combatLogService;
        _logger = logger;
    }

    /// <summary>
    /// Processes effects at the start of a combatant's turn.
    /// </summary>
    /// <param name="combatant">The combatant whose turn is starting.</param>
    /// <returns>Result containing DoT/HoT totals and action prevention status.</returns>
    public TurnStartEffectResult ProcessTurnStart(Combatant combatant)
    {
        ArgumentNullException.ThrowIfNull(combatant);

        var target = combatant.EffectTarget;
        if (target == null || target.ActiveEffects.Count == 0)
        {
            return TurnStartEffectResult.NoEffects();
        }

        _logger.LogDebug("Processing turn start effects for {Name}", combatant.Name);

        var totalDamage = 0;
        var totalHealing = 0;
        var expiredEffects = new List<string>();

        // Process each active effect
        foreach (var effect in target.ActiveEffects.ToList())
        {
            var tickResult = _statusEffectService.ProcessEffectTick(target, effect.EffectId);

            if (tickResult.DamageDealt > 0)
            {
                totalDamage += tickResult.DamageDealt;
                _combatLogService.LogStatusDamage(combatant.Name, effect.EffectId, tickResult.DamageDealt);
            }

            if (tickResult.HealingDone > 0)
            {
                totalHealing += tickResult.HealingDone;
                _combatLogService.LogStatusHealing(combatant.Name, effect.EffectId, tickResult.HealingDone);
            }

            if (tickResult.Expired)
            {
                expiredEffects.Add(effect.EffectId);
                _combatLogService.LogStatusExpired(combatant.Name, effect.EffectId);
            }
        }

        // Check action prevention
        var (canAct, mustFlee, reason) = CheckActionPrevention(target);

        if (!canAct)
        {
            _logger.LogDebug("{Name} cannot act: {Reason}", combatant.Name, reason);
            return TurnStartEffectResult.ActionsPrevented(
                totalDamage, totalHealing, expiredEffects, reason!, mustFlee);
        }

        return TurnStartEffectResult.CanActNormally(totalDamage, totalHealing, expiredEffects);
    }

    /// <summary>
    /// Processes effects triggered by an attack hitting.
    /// </summary>
    /// <param name="attacker">The attacker.</param>
    /// <param name="target">The target.</param>
    /// <param name="damageType">The damage type of the attack.</param>
    /// <param name="baseDamage">The base damage dealt.</param>
    /// <param name="isCritical">Whether the attack was a critical hit.</param>
    /// <returns>Result containing applied effects and interactions.</returns>
    public AttackEffectResult ProcessAttackHit(
        Combatant attacker,
        Combatant target,
        string? damageType,
        int baseDamage,
        bool isCritical = false)
    {
        ArgumentNullException.ThrowIfNull(attacker);
        ArgumentNullException.ThrowIfNull(target);

        var targetEffects = target.EffectTarget;
        if (targetEffects == null)
        {
            return AttackEffectResult.None();
        }

        _logger.LogDebug("Processing attack effects: {Attacker} -> {Target}",
            attacker.Name, target.Name);

        var appliedEffects = new List<EffectApplicationResult>();
        var interactions = new List<EffectInteractionResult>();
        var bonusDamage = 0;

        // Check for critical hit effect (30% chance to apply Bleeding)
        if (isCritical && Random.Shared.Next(100) < 30)
        {
            var bleedResult = _statusEffectService.ApplyEffect(targetEffects, "bleeding", attacker.Name);
            appliedEffects.Add(bleedResult);
            if (bleedResult.Applied)
            {
                _combatLogService.LogStatusApplied(target.Name, "bleeding", "critical hit");
            }
        }

        // Process damage type interactions
        if (!string.IsNullOrEmpty(damageType))
        {
            var interactionResults = _interactionService.ProcessDamageInteractions(
                targetEffects, damageType, baseDamage);

            foreach (var interaction in interactionResults)
            {
                interactions.Add(interaction);
                bonusDamage += interaction.BonusDamage;

                if (interaction.AppliedEffects.Count > 0)
                {
                    foreach (var effectId in interaction.AppliedEffects)
                    {
                        _combatLogService.LogStatusApplied(target.Name, effectId, interaction.Message);
                    }
                }

                if (interaction.RemovedEffects.Count > 0)
                {
                    foreach (var effectId in interaction.RemovedEffects)
                    {
                        _combatLogService.LogStatusExpired(target.Name, effectId);
                    }
                }
            }
        }

        return new AttackEffectResult(appliedEffects, interactions, bonusDamage);
    }

    /// <summary>
    /// Checks if a combatant's actions are prevented by effects.
    /// </summary>
    private (bool CanAct, bool MustFlee, string? Reason) CheckActionPrevention(IEffectTarget target)
    {
        // Check for Stunned - prevents all actions
        if (target.HasEffect("stunned"))
        {
            return (false, false, "Stunned - turn skipped");
        }

        // Check for Knocked Down - prevents all actions
        if (target.HasEffect("knocked_down"))
        {
            return (false, false, "Knocked down - turn skipped");
        }

        // Check for Feared - forces flee attempt
        if (target.HasEffect("feared"))
        {
            return (false, true, "Feared - must attempt to flee");
        }

        return (true, false, null);
    }

    /// <summary>
    /// Checks if a combatant can use abilities (not Silenced or Disarmed).
    /// </summary>
    /// <param name="target">The effect target.</param>
    /// <returns>True if abilities can be used.</returns>
    public bool CanUseAbilities(IEffectTarget target)
    {
        ArgumentNullException.ThrowIfNull(target);
        return !target.HasEffect("silenced");
    }

    /// <summary>
    /// Checks if a combatant can heal (not Cursed).
    /// </summary>
    /// <param name="target">The effect target.</param>
    /// <returns>True if healing is allowed.</returns>
    public bool CanHeal(IEffectTarget target)
    {
        ArgumentNullException.ThrowIfNull(target);
        return !target.HasEffect("cursed");
    }

    /// <summary>
    /// Checks if a combatant can attack (not Disarmed).
    /// </summary>
    /// <param name="target">The effect target.</param>
    /// <returns>True if attacks are allowed.</returns>
    public bool CanAttack(IEffectTarget target)
    {
        ArgumentNullException.ThrowIfNull(target);
        return !target.HasEffect("disarmed");
    }
}
```

#### 4. EffectInteractionService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/EffectInteractionService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Handles effect interactions (elemental combos).
/// </summary>
/// <remarks>
/// <para>Processes interactions when damage is dealt to targets with existing effects:</para>
/// <list type="bullet">
/// <item>Wet + Lightning → +50% damage, apply Stunned</item>
/// <item>Wet + Ice → Apply Frozen, remove Wet</item>
/// <item>Burning + Wet → Remove Burning (extinguish)</item>
/// <item>Chilled + Ice → Apply Frozen</item>
/// <item>On Fire + Wet → Remove On Fire</item>
/// </list>
/// </remarks>
public class EffectInteractionService
{
    private readonly IEffectInteractionRepository _repository;
    private readonly StatusEffectService _statusEffectService;
    private readonly ILogger<EffectInteractionService> _logger;

    /// <summary>
    /// Creates a new effect interaction service.
    /// </summary>
    public EffectInteractionService(
        IEffectInteractionRepository repository,
        StatusEffectService statusEffectService,
        ILogger<EffectInteractionService> logger)
    {
        _repository = repository;
        _statusEffectService = statusEffectService;
        _logger = logger;
    }

    /// <summary>
    /// Processes all applicable interactions for incoming damage.
    /// </summary>
    /// <param name="target">The target with active effects.</param>
    /// <param name="damageType">The type of damage being dealt.</param>
    /// <param name="baseDamage">The base damage amount.</param>
    /// <returns>List of interaction results.</returns>
    public IReadOnlyList<EffectInteractionResult> ProcessDamageInteractions(
        IEffectTarget target,
        string damageType,
        int baseDamage)
    {
        ArgumentNullException.ThrowIfNull(target);
        ArgumentException.ThrowIfNullOrWhiteSpace(damageType);

        var results = new List<EffectInteractionResult>();
        var normalizedDamageType = damageType.ToLowerInvariant();

        _logger.LogDebug("Checking interactions for {DamageType} damage on target with {Count} effects",
            normalizedDamageType, target.ActiveEffects.Count);

        // Check each active effect for interactions with the damage type
        foreach (var activeEffect in target.ActiveEffects.ToList())
        {
            var interactions = _repository.GetByTriggerEffect(activeEffect.EffectId);

            foreach (var interaction in interactions)
            {
                if (!interaction.WithTrigger.Equals(normalizedDamageType, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                _logger.LogDebug("Interaction triggered: {Id}", interaction.Id);

                var appliedEffects = new List<string>();
                var removedEffects = new List<string>();
                var bonusDamage = 0;

                // Calculate bonus damage
                if (interaction.HasBonusDamage)
                {
                    bonusDamage = (int)(baseDamage * interaction.BonusDamagePercent / 100.0);
                    _logger.LogDebug("Bonus damage: {Damage}", bonusDamage);
                }

                // Apply new effect
                if (interaction.AppliesEffect)
                {
                    var applyResult = _statusEffectService.ApplyEffect(
                        target, interaction.ApplyEffect!, "interaction");
                    if (applyResult.Applied)
                    {
                        appliedEffects.Add(interaction.ApplyEffect!);
                    }
                }

                // Remove effect
                if (interaction.RemovesEffect)
                {
                    var removed = _statusEffectService.RemoveEffect(target, interaction.RemoveEffect!);
                    if (removed)
                    {
                        removedEffects.Add(interaction.RemoveEffect!);
                    }
                }

                results.Add(EffectInteractionResult.Full(
                    interaction.Id,
                    interaction.Message,
                    bonusDamage,
                    appliedEffects,
                    removedEffects));
            }
        }

        return results;
    }

    /// <summary>
    /// Processes interactions when a new effect is applied.
    /// </summary>
    /// <param name="target">The target.</param>
    /// <param name="newEffectId">The newly applied effect ID.</param>
    /// <returns>List of interaction results.</returns>
    public IReadOnlyList<EffectInteractionResult> ProcessEffectApplication(
        IEffectTarget target,
        string newEffectId)
    {
        ArgumentNullException.ThrowIfNull(target);
        ArgumentException.ThrowIfNullOrWhiteSpace(newEffectId);

        var results = new List<EffectInteractionResult>();
        var normalizedEffectId = newEffectId.ToLowerInvariant();

        // Check if any existing effect interacts with the new effect
        foreach (var activeEffect in target.ActiveEffects.ToList())
        {
            var interactions = _repository.GetByTriggerEffect(activeEffect.EffectId);

            foreach (var interaction in interactions)
            {
                if (!interaction.WithTrigger.Equals(normalizedEffectId, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                var appliedEffects = new List<string>();
                var removedEffects = new List<string>();

                if (interaction.AppliesEffect)
                {
                    var applyResult = _statusEffectService.ApplyEffect(
                        target, interaction.ApplyEffect!, "interaction");
                    if (applyResult.Applied)
                    {
                        appliedEffects.Add(interaction.ApplyEffect!);
                    }
                }

                if (interaction.RemovesEffect)
                {
                    var removed = _statusEffectService.RemoveEffect(target, interaction.RemoveEffect!);
                    if (removed)
                    {
                        removedEffects.Add(interaction.RemoveEffect!);
                    }
                }

                results.Add(EffectInteractionResult.WithEffectChanges(
                    interaction.Id,
                    interaction.Message,
                    appliedEffects,
                    removedEffects));
            }
        }

        return results;
    }
}
```

#### 5. CleanseService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/CleanseService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Handles cleansing of status effects.
/// </summary>
/// <remarks>
/// <para>Supports multiple cleanse types:</para>
/// <list type="bullet">
/// <item>AllNegative - removes all debuffs</item>
/// <item>AllPositive - removes all buffs (dispel)</item>
/// <item>Physical - removes Bleeding, Poisoned, Exhausted, Knocked Down</item>
/// <item>Magical - removes Cursed, Silenced, Feared, Weakened</item>
/// <item>Elemental - removes Burning, Frozen, Wet, Chilled, On Fire, Electrified</item>
/// <item>Specific - removes a single named effect</item>
/// </list>
/// </remarks>
public class CleanseService
{
    private readonly StatusEffectService _statusEffectService;
    private readonly IStatusEffectRepository _effectRepository;
    private readonly ICleanseItemRepository _cleanseItemRepository;
    private readonly ILogger<CleanseService> _logger;

    // Effect categories for cleanse targeting
    private static readonly HashSet<string> PhysicalEffects = new(StringComparer.OrdinalIgnoreCase)
    {
        "bleeding", "poisoned", "exhausted", "knocked_down"
    };

    private static readonly HashSet<string> MagicalEffects = new(StringComparer.OrdinalIgnoreCase)
    {
        "cursed", "silenced", "feared", "weakened"
    };

    private static readonly HashSet<string> ElementalEffects = new(StringComparer.OrdinalIgnoreCase)
    {
        "burning", "frozen", "wet", "chilled", "on_fire", "electrified"
    };

    /// <summary>
    /// Creates a new cleanse service.
    /// </summary>
    public CleanseService(
        StatusEffectService statusEffectService,
        IStatusEffectRepository effectRepository,
        ICleanseItemRepository cleanseItemRepository,
        ILogger<CleanseService> logger)
    {
        _statusEffectService = statusEffectService;
        _effectRepository = effectRepository;
        _cleanseItemRepository = cleanseItemRepository;
        _logger = logger;
    }

    /// <summary>
    /// Attempts to cleanse effects using a cleanse item.
    /// </summary>
    /// <param name="target">The target to cleanse.</param>
    /// <param name="itemId">The cleanse item ID.</param>
    /// <returns>Result of the cleanse attempt.</returns>
    public CleanseResult CleansewithItem(IEffectTarget target, string itemId)
    {
        ArgumentNullException.ThrowIfNull(target);
        ArgumentException.ThrowIfNullOrWhiteSpace(itemId);

        var item = _cleanseItemRepository.GetById(itemId);
        if (item == null)
        {
            _logger.LogWarning("Unknown cleanse item: {ItemId}", itemId);
            return CleanseResult.NoEffectsRemoved();
        }

        return Cleanse(target, item.Value.CleanseType, item.Value.SpecificEffect);
    }

    /// <summary>
    /// Cleanses effects from a target based on cleanse type.
    /// </summary>
    /// <param name="target">The target to cleanse.</param>
    /// <param name="cleanseType">The type of cleanse.</param>
    /// <param name="specificEffect">Specific effect ID if type is Specific.</param>
    /// <returns>Result of the cleanse attempt.</returns>
    public CleanseResult Cleanse(
        IEffectTarget target,
        CleanseType cleanseType,
        string? specificEffect = null)
    {
        ArgumentNullException.ThrowIfNull(target);

        _logger.LogDebug("Cleansing {Type} effects from target", cleanseType);

        var effectsToRemove = GetEffectsToRemove(target, cleanseType, specificEffect);

        if (effectsToRemove.Count == 0)
        {
            return CleanseResult.NoEffectsRemoved();
        }

        var removedEffects = new List<string>();
        foreach (var effectId in effectsToRemove)
        {
            if (_statusEffectService.RemoveEffect(target, effectId))
            {
                removedEffects.Add(effectId);
                _logger.LogDebug("Removed effect: {EffectId}", effectId);
            }
        }

        if (removedEffects.Count == 0)
        {
            return CleanseResult.NoEffectsRemoved();
        }

        return CleanseResult.Succeeded(removedEffects);
    }

    /// <summary>
    /// Gets the list of effects that would be removed by a cleanse.
    /// </summary>
    private List<string> GetEffectsToRemove(
        IEffectTarget target,
        CleanseType cleanseType,
        string? specificEffect)
    {
        var effectsToRemove = new List<string>();

        foreach (var effect in target.ActiveEffects)
        {
            var definition = _effectRepository.GetById(effect.EffectId);
            if (definition == null) continue;

            var shouldRemove = cleanseType switch
            {
                CleanseType.AllNegative => definition.Category == EffectCategory.Debuff,
                CleanseType.AllPositive => definition.Category == EffectCategory.Buff,
                CleanseType.Physical => PhysicalEffects.Contains(effect.EffectId),
                CleanseType.Magical => MagicalEffects.Contains(effect.EffectId),
                CleanseType.Elemental => ElementalEffects.Contains(effect.EffectId),
                CleanseType.Specific => effect.EffectId.Equals(specificEffect,
                    StringComparison.OrdinalIgnoreCase),
                _ => false
            };

            if (shouldRemove)
            {
                effectsToRemove.Add(effect.EffectId);
            }
        }

        return effectsToRemove;
    }

    /// <summary>
    /// Checks if a cleanse would remove any effects.
    /// </summary>
    /// <param name="target">The target.</param>
    /// <param name="cleanseType">The cleanse type.</param>
    /// <param name="specificEffect">Specific effect if applicable.</param>
    /// <returns>True if any effects would be removed.</returns>
    public bool WouldCleanse(
        IEffectTarget target,
        CleanseType cleanseType,
        string? specificEffect = null)
    {
        ArgumentNullException.ThrowIfNull(target);
        return GetEffectsToRemove(target, cleanseType, specificEffect).Count > 0;
    }
}
```

#### 6. EffectAwareAIService.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/EffectAwareAIService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Wraps MonsterAIService to modify decisions based on active effects.
/// </summary>
/// <remarks>
/// <para>Effect-based behavior modifications:</para>
/// <list type="bullet">
/// <item>Feared → Force flee attempt</item>
/// <item>Stunned/Knocked Down → Skip turn (handled by CombatEffectService)</item>
/// <item>Cursed → Cannot use healing abilities</item>
/// <item>Silenced → Can only use physical attacks</item>
/// <item>Disarmed → Can only defend</item>
/// <item>Blinded → Reduced accuracy (affects target selection)</item>
/// <item>Weakened → Prefers defensive actions</item>
/// </list>
/// </remarks>
public class EffectAwareAIService
{
    private readonly MonsterAIService _baseAIService;
    private readonly ILogger<EffectAwareAIService> _logger;

    /// <summary>
    /// Creates a new effect-aware AI service.
    /// </summary>
    public EffectAwareAIService(
        MonsterAIService baseAIService,
        ILogger<EffectAwareAIService> logger)
    {
        _baseAIService = baseAIService;
        _logger = logger;
    }

    /// <summary>
    /// Gets an AI decision modified by the monster's active effects.
    /// </summary>
    /// <param name="monster">The monster making a decision.</param>
    /// <param name="context">The combat context.</param>
    /// <returns>The modified AI decision.</returns>
    public AIDecision GetEffectAwareDecision(Monster monster, AIContext context)
    {
        ArgumentNullException.ThrowIfNull(monster);
        ArgumentNullException.ThrowIfNull(context);

        var target = monster as IEffectTarget;

        // Check forced behaviors first
        if (target != null)
        {
            // Feared forces flee
            if (target.HasEffect("feared"))
            {
                _logger.LogDebug("{Name} is Feared, forcing flee", monster.Name);
                return AIDecision.Flee($"{monster.Name} flees in terror!");
            }

            // Disarmed forces defend
            if (target.HasEffect("disarmed"))
            {
                _logger.LogDebug("{Name} is Disarmed, forcing defend", monster.Name);
                return AIDecision.Defend($"{monster.Name} is disarmed and defends.");
            }
        }

        // Get base decision from AI service
        var baseDecision = _baseAIService.DecideAction(monster, context);

        // Modify decision based on effects
        if (target != null)
        {
            baseDecision = ModifyDecisionForEffects(monster, target, baseDecision);
        }

        return baseDecision;
    }

    /// <summary>
    /// Modifies an AI decision based on active effects.
    /// </summary>
    private AIDecision ModifyDecisionForEffects(
        Monster monster,
        IEffectTarget target,
        AIDecision baseDecision)
    {
        // Cursed: Cannot heal
        if (target.HasEffect("cursed") && baseDecision.Action == AIAction.Heal)
        {
            _logger.LogDebug("{Name} is Cursed, cannot heal - switching to attack", monster.Name);
            return AIDecision.Attack(baseDecision.TargetId, $"{monster.Name} attacks (curse prevents healing)");
        }

        // Silenced: Cannot use abilities (magic)
        if (target.HasEffect("silenced") && baseDecision.Action == AIAction.UseAbility)
        {
            _logger.LogDebug("{Name} is Silenced, cannot use ability - switching to attack", monster.Name);
            return AIDecision.Attack(baseDecision.TargetId, $"{monster.Name} attacks (silenced)");
        }

        // Weakened: Prefers defensive actions when health is low
        if (target.HasEffect("weakened") && monster.Health < monster.Stats.MaxHealth * 0.5)
        {
            if (baseDecision.Action == AIAction.Attack)
            {
                _logger.LogDebug("{Name} is Weakened and low health, preferring defend", monster.Name);
                return AIDecision.Defend($"{monster.Name} defends (weakened)");
            }
        }

        // Blinded: Random target selection (modify existing target)
        if (target.HasEffect("blinded") && baseDecision.Action == AIAction.Attack)
        {
            _logger.LogDebug("{Name} is Blinded, may miss target", monster.Name);
            // Blinded affects accuracy - handled in damage calculation
            // Keep decision but note the condition
            return baseDecision with { Reasoning = baseDecision.Reasoning + " (blinded)" };
        }

        return baseDecision;
    }

    /// <summary>
    /// Checks if a monster can use a specific ability considering effects.
    /// </summary>
    /// <param name="monster">The monster.</param>
    /// <param name="abilityType">The type of ability.</param>
    /// <returns>True if the ability can be used.</returns>
    public bool CanUseAbility(Monster monster, string abilityType)
    {
        ArgumentNullException.ThrowIfNull(monster);

        var target = monster as IEffectTarget;
        if (target == null) return true;

        // Silenced blocks all special abilities
        if (target.HasEffect("silenced"))
        {
            return false;
        }

        // Cursed blocks healing abilities
        if (target.HasEffect("cursed") &&
            abilityType.Contains("heal", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        return true;
    }
}
```

#### 7. CombatLogService Extensions (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Services/CombatLogService.cs`

Add new methods for effect-related logging:

```csharp
/// <summary>
/// Logs when a status effect is applied.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectId">The effect that was applied.</param>
/// <param name="source">What caused the effect.</param>
public void LogStatusApplied(string targetName, string effectId, string source)
{
    var entry = new CombatLogEntry(
        CombatLogType.StatusApplied,
        $"{targetName} is now {FormatEffectName(effectId)} ({source}).");
    AddEntry(entry);
}

/// <summary>
/// Logs when a status effect expires.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectId">The effect that expired.</param>
public void LogStatusExpired(string targetName, string effectId)
{
    var entry = new CombatLogEntry(
        CombatLogType.StatusExpired,
        $"{targetName} is no longer {FormatEffectName(effectId)}.");
    AddEntry(entry);
}

/// <summary>
/// Logs damage over time from a status effect.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectId">The effect dealing damage.</param>
/// <param name="damage">The damage dealt.</param>
public void LogStatusDamage(string targetName, string effectId, int damage)
{
    var entry = new CombatLogEntry(
        CombatLogType.StatusDamage,
        $"{targetName} takes {damage} damage from {FormatEffectName(effectId)}.");
    AddEntry(entry);
}

/// <summary>
/// Logs healing over time from a status effect.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectId">The effect providing healing.</param>
/// <param name="healing">The healing done.</param>
public void LogStatusHealing(string targetName, string effectId, int healing)
{
    var entry = new CombatLogEntry(
        CombatLogType.StatusHealing,
        $"{targetName} heals {healing} HP from {FormatEffectName(effectId)}.");
    AddEntry(entry);
}

/// <summary>
/// Logs an effect interaction.
/// </summary>
/// <param name="message">The interaction message.</param>
public void LogEffectInteraction(string message)
{
    var entry = new CombatLogEntry(
        CombatLogType.EffectInteraction,
        message);
    AddEntry(entry);
}

/// <summary>
/// Logs a cleanse action.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="result">The cleanse result.</param>
public void LogCleanse(string targetName, CleanseResult result)
{
    var entry = new CombatLogEntry(
        CombatLogType.Cleanse,
        $"{targetName}: {result.Message}");
    AddEntry(entry);
}

private static string FormatEffectName(string effectId)
{
    // Convert snake_case to Title Case
    return string.Join(" ", effectId.Split('_')
        .Select(word => char.ToUpper(word[0]) + word[1..]));
}
```

#### 8. CombatLogType Extensions (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Enums/CombatLogType.cs`

Add new log types:

```csharp
/// <summary>Damage from a status effect (DoT).</summary>
StatusDamage,

/// <summary>Healing from a status effect (HoT).</summary>
StatusHealing,

/// <summary>An effect interaction triggered.</summary>
EffectInteraction,

/// <summary>A cleanse action occurred.</summary>
Cleanse
```

---

### Infrastructure Layer

#### 1. JsonEffectInteractionRepository.cs (NEW)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/JsonEffectInteractionRepository.cs`

```csharp
using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Infrastructure.Repositories;

/// <summary>
/// Loads effect interactions from JSON configuration.
/// </summary>
public class JsonEffectInteractionRepository : IEffectInteractionRepository
{
    private readonly Dictionary<string, EffectInteraction> _interactions = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<EffectInteraction>> _byTriggerEffect = new(StringComparer.OrdinalIgnoreCase);
    private readonly ILogger<JsonEffectInteractionRepository> _logger;

    /// <summary>
    /// Creates a new JSON effect interaction repository.
    /// </summary>
    public JsonEffectInteractionRepository(
        string configPath,
        ILogger<JsonEffectInteractionRepository> logger)
    {
        _logger = logger;
        LoadInteractions(configPath);
    }

    private void LoadInteractions(string configPath)
    {
        try
        {
            var json = File.ReadAllText(configPath);
            var interactions = JsonSerializer.Deserialize<List<EffectInteractionDto>>(json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (interactions == null)
            {
                _logger.LogWarning("No interactions found in {Path}", configPath);
                return;
            }

            foreach (var dto in interactions)
            {
                var interaction = new EffectInteraction(
                    dto.Id,
                    dto.TriggerEffectId,
                    dto.WithTrigger,
                    dto.BonusDamagePercent,
                    dto.BonusDamageType,
                    dto.ApplyEffect,
                    dto.RemoveEffect,
                    dto.Message);

                _interactions[dto.Id] = interaction;

                if (!_byTriggerEffect.TryGetValue(dto.TriggerEffectId, out var list))
                {
                    list = new List<EffectInteraction>();
                    _byTriggerEffect[dto.TriggerEffectId] = list;
                }
                list.Add(interaction);
            }

            _logger.LogInformation("Loaded {Count} effect interactions", _interactions.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load effect interactions from {Path}", configPath);
            throw;
        }
    }

    /// <inheritdoc />
    public IReadOnlyList<EffectInteraction> GetAll() => _interactions.Values.ToList();

    /// <inheritdoc />
    public IReadOnlyList<EffectInteraction> GetByTriggerEffect(string triggerEffectId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(triggerEffectId);
        return _byTriggerEffect.TryGetValue(triggerEffectId.ToLowerInvariant(), out var list)
            ? list
            : Array.Empty<EffectInteraction>();
    }

    /// <inheritdoc />
    public EffectInteraction? GetById(string interactionId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(interactionId);
        return _interactions.TryGetValue(interactionId, out var interaction)
            ? interaction
            : null;
    }

    private record EffectInteractionDto(
        string Id,
        string TriggerEffectId,
        string WithTrigger,
        int BonusDamagePercent,
        string? BonusDamageType,
        string? ApplyEffect,
        string? RemoveEffect,
        string Message);
}
```

#### 2. JsonCleanseItemRepository.cs (NEW)

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Repositories/JsonCleanseItemRepository.cs`

```csharp
using System.Text.Json;
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Infrastructure.Repositories;

/// <summary>
/// Loads cleanse items from JSON configuration.
/// </summary>
public class JsonCleanseItemRepository : ICleanseItemRepository
{
    private readonly Dictionary<string, CleanseItem> _items = new(StringComparer.OrdinalIgnoreCase);
    private readonly ILogger<JsonCleanseItemRepository> _logger;

    /// <summary>
    /// Creates a new JSON cleanse item repository.
    /// </summary>
    public JsonCleanseItemRepository(
        string configPath,
        ILogger<JsonCleanseItemRepository> logger)
    {
        _logger = logger;
        LoadItems(configPath);
    }

    private void LoadItems(string configPath)
    {
        try
        {
            var json = File.ReadAllText(configPath);
            var items = JsonSerializer.Deserialize<List<CleanseItemDto>>(json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (items == null)
            {
                _logger.LogWarning("No cleanse items found in {Path}", configPath);
                return;
            }

            foreach (var dto in items)
            {
                if (!Enum.TryParse<CleanseType>(dto.CleanseType, true, out var cleanseType))
                {
                    _logger.LogWarning("Invalid cleanse type: {Type} for item {Id}", dto.CleanseType, dto.Id);
                    continue;
                }

                var item = new CleanseItem(
                    dto.Id,
                    dto.Name,
                    dto.Description,
                    cleanseType,
                    dto.SpecificEffect);

                _items[dto.Id] = item;
            }

            _logger.LogInformation("Loaded {Count} cleanse items", _items.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load cleanse items from {Path}", configPath);
            throw;
        }
    }

    /// <inheritdoc />
    public CleanseItem? GetById(string itemId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(itemId);
        return _items.TryGetValue(itemId, out var item) ? item : null;
    }

    /// <inheritdoc />
    public bool IsCleanseItem(string itemId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(itemId);
        return _items.ContainsKey(itemId);
    }

    /// <inheritdoc />
    public IReadOnlyList<CleanseItem> GetAll() => _items.Values.ToList();

    private record CleanseItemDto(
        string Id,
        string Name,
        string Description,
        string CleanseType,
        string? SpecificEffect);
}
```

---

### Presentation Layer

#### 1. DTOs for UI Display

**File:** `src/Core/RuneAndRust.Application/DTOs/ActiveEffectDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying an active status effect.
/// </summary>
/// <param name="EffectId">The effect identifier.</param>
/// <param name="Name">Display name.</param>
/// <param name="IconChar">Unicode character for display (e.g., '🔥' for Burning).</param>
/// <param name="IsDebuff">Whether this is a negative effect.</param>
/// <param name="RemainingDuration">Turns remaining, or null if permanent.</param>
/// <param name="StackCount">Current stack count.</param>
public record ActiveEffectDto(
    string EffectId,
    string Name,
    char IconChar,
    bool IsDebuff,
    int? RemainingDuration,
    int StackCount)
{
    /// <summary>
    /// Gets a short display string (e.g., "🔥2" for Burning with 2 turns).
    /// </summary>
    public string ShortDisplay => RemainingDuration.HasValue
        ? $"{IconChar}{RemainingDuration}"
        : $"{IconChar}";
}
```

**File:** `src/Core/RuneAndRust.Application/DTOs/CombatantStatusDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying a combatant's status including effects.
/// </summary>
/// <param name="Id">Combatant identifier.</param>
/// <param name="Name">Display name.</param>
/// <param name="Health">Current health.</param>
/// <param name="MaxHealth">Maximum health.</param>
/// <param name="IsPlayer">Whether this is the player.</param>
/// <param name="ActiveEffects">List of active effects.</param>
/// <param name="CanAct">Whether the combatant can take actions.</param>
public record CombatantStatusDto(
    Guid Id,
    string Name,
    int Health,
    int MaxHealth,
    bool IsPlayer,
    IReadOnlyList<ActiveEffectDto> ActiveEffects,
    bool CanAct)
{
    /// <summary>
    /// Gets the health percentage (0-100).
    /// </summary>
    public int HealthPercent => MaxHealth > 0 ? (Health * 100 / MaxHealth) : 0;

    /// <summary>
    /// Gets whether the combatant has any debuffs.
    /// </summary>
    public bool HasDebuffs => ActiveEffects.Any(e => e.IsDebuff);

    /// <summary>
    /// Gets whether the combatant has any buffs.
    /// </summary>
    public bool HasBuffs => ActiveEffects.Any(e => !e.IsDebuff);

    /// <summary>
    /// Gets the effect summary string (e.g., "🔥2 ❄️3").
    /// </summary>
    public string EffectSummary => string.Join(" ", ActiveEffects.Select(e => e.ShortDisplay));
}
```

#### 2. IGameRenderer Extensions (MODIFY)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs`

Add new methods:

```csharp
/// <summary>
/// Renders a combatant's status with active effects.
/// </summary>
/// <param name="status">The combatant status DTO.</param>
void RenderCombatantStatus(CombatantStatusDto status);

/// <summary>
/// Renders an effect application notification.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectName">The effect name.</param>
/// <param name="isDebuff">Whether it's a debuff.</param>
void RenderEffectApplied(string targetName, string effectName, bool isDebuff);

/// <summary>
/// Renders an effect expiration notification.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectName">The effect name.</param>
void RenderEffectExpired(string targetName, string effectName);

/// <summary>
/// Renders an effect interaction result.
/// </summary>
/// <param name="message">The interaction message.</param>
void RenderEffectInteraction(string message);

/// <summary>
/// Renders DoT/HoT tick damage/healing.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="effectName">The effect name.</param>
/// <param name="amount">The damage or healing amount.</param>
/// <param name="isHealing">Whether it's healing (true) or damage (false).</param>
void RenderEffectTick(string targetName, string effectName, int amount, bool isHealing);

/// <summary>
/// Renders a cleanse result.
/// </summary>
/// <param name="targetName">The target's name.</param>
/// <param name="result">The cleanse result.</param>
void RenderCleanse(string targetName, CleanseResult result);
```

#### 3. SpectreGameRenderer Implementation (MODIFY)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

Add implementations:

```csharp
/// <inheritdoc />
public void RenderCombatantStatus(CombatantStatusDto status)
{
    var healthColor = status.HealthPercent switch
    {
        >= 75 => "green",
        >= 50 => "yellow",
        >= 25 => "orange3",
        _ => "red"
    };

    var healthBar = $"[{healthColor}]{status.Health}/{status.MaxHealth}[/]";
    var effectsDisplay = status.ActiveEffects.Count > 0
        ? $" [{(status.HasDebuffs ? "red" : "green")}]{status.EffectSummary}[/]"
        : "";

    var canActMark = status.CanAct ? "" : " [dim](cannot act)[/]";

    AnsiConsole.MarkupLine($"  {status.Name}: {healthBar}{effectsDisplay}{canActMark}");
}

/// <inheritdoc />
public void RenderEffectApplied(string targetName, string effectName, bool isDebuff)
{
    var color = isDebuff ? "red" : "green";
    var symbol = isDebuff ? "▼" : "▲";
    AnsiConsole.MarkupLine($"[{color}]{symbol}[/] {targetName} is now [{color}]{effectName}[/]!");
}

/// <inheritdoc />
public void RenderEffectExpired(string targetName, string effectName)
{
    AnsiConsole.MarkupLine($"[dim]○[/] {targetName} is no longer [dim]{effectName}[/].");
}

/// <inheritdoc />
public void RenderEffectInteraction(string message)
{
    AnsiConsole.MarkupLine($"[yellow]⚡[/] {message}");
}

/// <inheritdoc />
public void RenderEffectTick(string targetName, string effectName, int amount, bool isHealing)
{
    if (isHealing)
    {
        AnsiConsole.MarkupLine($"[green]+{amount}[/] {targetName} heals from {effectName}.");
    }
    else
    {
        AnsiConsole.MarkupLine($"[red]-{amount}[/] {targetName} takes damage from {effectName}!");
    }
}

/// <inheritdoc />
public void RenderCleanse(string targetName, CleanseResult result)
{
    if (result.Success)
    {
        var effects = string.Join(", ", result.RemovedEffects);
        AnsiConsole.MarkupLine($"[aqua]✦[/] {targetName} is cleansed of {effects}!");
    }
    else
    {
        AnsiConsole.MarkupLine($"[dim]No effects to cleanse from {targetName}.[/]");
    }
}
```

#### 4. Effect Icon Mapping

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Helpers/EffectIconMapper.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.Helpers;

/// <summary>
/// Maps effect IDs to display icons.
/// </summary>
public static class EffectIconMapper
{
    private static readonly Dictionary<string, char> Icons = new(StringComparer.OrdinalIgnoreCase)
    {
        // Debuffs
        ["bleeding"] = '🩸',
        ["poisoned"] = '☠',
        ["burning"] = '🔥',
        ["frozen"] = '❄',
        ["stunned"] = '💫',
        ["knocked_down"] = '⬇',
        ["weakened"] = '↓',
        ["blinded"] = '👁',
        ["slowed"] = '🐌',
        ["feared"] = '😱',
        ["silenced"] = '🤐',
        ["cursed"] = '💀',
        ["exhausted"] = '😩',
        ["disarmed"] = '🔓',

        // Buffs
        ["fortified"] = '🛡',
        ["hasted"] = '⚡',
        ["regenerating"] = '💚',
        ["strengthened"] = '💪',
        ["shielded"] = '🔰',
        ["invisible"] = '👻',
        ["blessed"] = '✨',
        ["inspired"] = '🌟',
        ["protected"] = '🛡',
        ["enraged"] = '😤',

        // Environmental
        ["wet"] = '💧',
        ["on_fire"] = '🔥',
        ["chilled"] = '❄',
        ["electrified"] = '⚡'
    };

    /// <summary>
    /// Gets the icon for an effect.
    /// </summary>
    /// <param name="effectId">The effect ID.</param>
    /// <returns>The icon character, or '?' if unknown.</returns>
    public static char GetIcon(string effectId)
    {
        return Icons.TryGetValue(effectId, out var icon) ? icon : '?';
    }

    /// <summary>
    /// Checks if an effect has a known icon.
    /// </summary>
    public static bool HasIcon(string effectId) => Icons.ContainsKey(effectId);
}
```

---

### Configuration Files

#### 1. effect-interactions.json (NEW)

**File:** `config/effect-interactions.json`

```json
[
  {
    "id": "wet_lightning",
    "triggerEffectId": "wet",
    "withTrigger": "lightning",
    "bonusDamagePercent": 50,
    "bonusDamageType": "lightning",
    "applyEffect": "stunned",
    "removeEffect": null,
    "message": "Lightning conducts through water!"
  },
  {
    "id": "wet_ice",
    "triggerEffectId": "wet",
    "withTrigger": "ice",
    "bonusDamagePercent": 0,
    "bonusDamageType": null,
    "applyEffect": "frozen",
    "removeEffect": "wet",
    "message": "The water freezes solid!"
  },
  {
    "id": "burning_wet",
    "triggerEffectId": "burning",
    "withTrigger": "wet",
    "bonusDamagePercent": 0,
    "bonusDamageType": null,
    "applyEffect": null,
    "removeEffect": "burning",
    "message": "The flames are extinguished!"
  },
  {
    "id": "chilled_ice",
    "triggerEffectId": "chilled",
    "withTrigger": "ice",
    "bonusDamagePercent": 25,
    "bonusDamageType": "ice",
    "applyEffect": "frozen",
    "removeEffect": "chilled",
    "message": "The cold intensifies into ice!"
  },
  {
    "id": "on_fire_wet",
    "triggerEffectId": "on_fire",
    "withTrigger": "wet",
    "bonusDamagePercent": 0,
    "bonusDamageType": null,
    "applyEffect": null,
    "removeEffect": "on_fire",
    "message": "The fire is doused!"
  }
]
```

#### 2. cleanse-items.json (NEW)

**File:** `config/cleanse-items.json`

```json
[
  {
    "id": "antidote",
    "name": "Antidote",
    "description": "Cures poison afflictions.",
    "cleanseType": "Specific",
    "specificEffect": "poisoned"
  },
  {
    "id": "bandage",
    "name": "Bandage",
    "description": "Stops bleeding wounds.",
    "cleanseType": "Specific",
    "specificEffect": "bleeding"
  },
  {
    "id": "panacea",
    "name": "Panacea",
    "description": "A miracle cure for all ailments.",
    "cleanseType": "AllNegative",
    "specificEffect": null
  },
  {
    "id": "smelling_salts",
    "name": "Smelling Salts",
    "description": "Clears the mind of magical influences.",
    "cleanseType": "Magical",
    "specificEffect": null
  },
  {
    "id": "fire_resistance_potion",
    "name": "Fire Resistance Potion",
    "description": "Extinguishes flames.",
    "cleanseType": "Specific",
    "specificEffect": "burning"
  }
]
```

---

## Flow Diagrams

### Turn Start Effect Processing

```
ProcessTurnStart(combatant)
    │
    ├─► Get IEffectTarget from combatant
    │   └── null? → Return NoEffects()
    │
    ├─► For each active effect:
    │   │
    │   ├── ProcessEffectTick()
    │   │   ├── Get definition
    │   │   ├── Apply DoT damage if any
    │   │   ├── Apply HoT healing if any
    │   │   ├── Decrement duration
    │   │   └── Check if expired
    │   │
    │   ├── Log damage/healing to combat log
    │   │
    │   └── If expired:
    │       ├── Add to expiredEffects
    │       └── Log expiration
    │
    ├─► Check action prevention:
    │   ├── HasEffect("stunned")? → ActionsPrevented("Stunned")
    │   ├── HasEffect("knocked_down")? → ActionsPrevented("Knocked Down")
    │   └── HasEffect("feared")? → ActionsPrevented("Feared", mustFlee=true)
    │
    └─► Return TurnStartEffectResult
```

### Attack Effect Processing

```
ProcessAttackHit(attacker, target, damageType, baseDamage, isCritical)
    │
    ├─► Get IEffectTarget from target
    │   └── null? → Return None()
    │
    ├─► Check critical hit bleeding (30% chance)
    │   └── Apply "bleeding" → Add to appliedEffects
    │
    ├─► If damageType not null:
    │   │
    │   └── ProcessDamageInteractions()
    │       │
    │       ├── For each active effect on target:
    │       │   │
    │       │   ├── Get interactions for effect
    │       │   │
    │       │   └── For each interaction matching damageType:
    │       │       │
    │       │       ├── Calculate bonus damage
    │       │       ├── Apply new effect (if any)
    │       │       ├── Remove effect (if any)
    │       │       └── Add to interactions list
    │       │
    │       └── Log all interaction results
    │
    └─► Return AttackEffectResult
```

### Cleanse Flow

```
CleanseWithItem(target, itemId)
    │
    ├─► Get CleanseItem from repository
    │   └── null? → Return NoEffectsRemoved()
    │
    └─► Cleanse(target, cleanseType, specificEffect)
        │
        ├─► GetEffectsToRemove():
        │   │
        │   └── For each active effect:
        │       │
        │       ├── Get definition
        │       │
        │       └── Check cleanseType:
        │           ├── AllNegative → Is Debuff?
        │           ├── AllPositive → Is Buff?
        │           ├── Physical → In PhysicalEffects set?
        │           ├── Magical → In MagicalEffects set?
        │           ├── Elemental → In ElementalEffects set?
        │           └── Specific → Matches specificEffect?
        │
        ├─► If no effects to remove:
        │   └── Return NoEffectsRemoved()
        │
        ├─► For each effect to remove:
        │   └── StatusEffectService.RemoveEffect()
        │
        └─► Return Succeeded(removedEffects)
```

### Effect-Aware AI Decision Flow

```
GetEffectAwareDecision(monster, context)
    │
    ├─► Cast monster to IEffectTarget
    │
    ├─► Check forced behaviors:
    │   ├── HasEffect("feared")? → Return AIDecision.Flee()
    │   └── HasEffect("disarmed")? → Return AIDecision.Defend()
    │
    ├─► Get base decision from MonsterAIService
    │
    └─► Modify for effects:
        │
        ├── HasEffect("cursed") && action == Heal?
        │   └── Switch to Attack
        │
        ├── HasEffect("silenced") && action == UseAbility?
        │   └── Switch to Attack
        │
        ├── HasEffect("weakened") && low health && action == Attack?
        │   └── Switch to Defend
        │
        └── HasEffect("blinded") && action == Attack?
            └── Keep decision, append "(blinded)" to reasoning
```

---

## Testing Strategy

### Test Categories

#### 1. CombatEffectService Tests (~6 tests)

| Test | Description |
|------|-------------|
| `ProcessTurnStart_WithNoEffects_ReturnsNoEffects` | Target with no effects returns empty result |
| `ProcessTurnStart_WithDoT_DealsDamageAndLogs` | Bleeding/Burning deals damage at turn start |
| `ProcessTurnStart_WithHoT_HealsAndLogs` | Regenerating heals at turn start |
| `ProcessTurnStart_WithStunned_PreventsAction` | Stunned combatant cannot act |
| `ProcessTurnStart_WithFeared_MustFlee` | Feared combatant must flee |
| `ProcessAttackHit_Critical_MayApplyBleeding` | 30% chance on crit to apply Bleeding |

#### 2. EffectInteractionService Tests (~5 tests)

| Test | Description |
|------|-------------|
| `ProcessDamageInteractions_WetWithLightning_BonusDamageAndStun` | Wet + Lightning = +50% damage, Stunned |
| `ProcessDamageInteractions_WetWithIce_FrozenAndRemovesWet` | Wet + Ice = Frozen, removes Wet |
| `ProcessDamageInteractions_BurningWithWet_ExtinguishesBurning` | Burning + Wet = removes Burning |
| `ProcessDamageInteractions_NoMatchingInteraction_ReturnsEmpty` | Non-matching damage type returns empty |
| `ProcessEffectApplication_ChilledWithIce_BecomesFrozen` | Chilled + Ice effect = Frozen |

#### 3. CleanseService Tests (~5 tests)

| Test | Description |
|------|-------------|
| `Cleanse_AllNegative_RemovesAllDebuffs` | Panacea removes all debuffs |
| `Cleanse_Physical_RemovesPhysicalOnly` | Removes Bleeding, Poisoned, etc. |
| `Cleanse_Specific_RemovesNamedEffect` | Antidote removes only Poisoned |
| `Cleanse_NoMatchingEffects_ReturnsFailure` | No effects to cleanse returns failure |
| `WouldCleanse_ChecksWithoutRemoving` | Preview cleanse without side effects |

#### 4. EffectAwareAIService Tests (~4 tests)

| Test | Description |
|------|-------------|
| `GetEffectAwareDecision_Feared_ForcesFlee` | Feared monster always flees |
| `GetEffectAwareDecision_Cursed_CannotHeal` | Cursed monster switches heal to attack |
| `GetEffectAwareDecision_Silenced_CannotUseAbility` | Silenced monster uses attack instead |
| `GetEffectAwareDecision_Disarmed_ForcesDefend` | Disarmed monster only defends |

### Test Data Setup

```csharp
// Test fixture for effect integration tests
public class EffectIntegrationTestFixture
{
    public StatusEffectService StatusEffectService { get; }
    public EffectInteractionService InteractionService { get; }
    public CombatEffectService CombatEffectService { get; }
    public CleanseService CleanseService { get; }

    public EffectIntegrationTestFixture()
    {
        var loggerFactory = new NullLoggerFactory();

        // Set up repositories with test data
        var effectRepo = new InMemoryStatusEffectRepository(GetTestEffects());
        var interactionRepo = new InMemoryEffectInteractionRepository(GetTestInteractions());
        var cleanseItemRepo = new InMemoryCleanseItemRepository(GetTestCleanseItems());

        StatusEffectService = new StatusEffectService(effectRepo, loggerFactory.CreateLogger<StatusEffectService>());
        InteractionService = new EffectInteractionService(interactionRepo, StatusEffectService,
            loggerFactory.CreateLogger<EffectInteractionService>());

        var combatLogService = new CombatLogService(loggerFactory.CreateLogger<CombatLogService>());
        CombatEffectService = new CombatEffectService(StatusEffectService, InteractionService,
            combatLogService, loggerFactory.CreateLogger<CombatEffectService>());

        CleanseService = new CleanseService(StatusEffectService, effectRepo, cleanseItemRepo,
            loggerFactory.CreateLogger<CleanseService>());
    }

    private static IEnumerable<StatusEffectDefinition> GetTestEffects()
    {
        yield return StatusEffectDefinition.Create("wet", "Wet", EffectCategory.Environmental)
            .WithDuration(DurationType.Turns, 3)
            .Build();

        yield return StatusEffectDefinition.Create("stunned", "Stunned", EffectCategory.Debuff)
            .WithDuration(DurationType.Turns, 1)
            .PreventsActions()
            .Build();

        yield return StatusEffectDefinition.Create("frozen", "Frozen", EffectCategory.Debuff)
            .WithDuration(DurationType.Turns, 2)
            .PreventsActions()
            .Build();

        yield return StatusEffectDefinition.Create("burning", "Burning", EffectCategory.Debuff)
            .WithDuration(DurationType.Turns, 3)
            .WithDamagePerTurn(5)
            .Build();

        yield return StatusEffectDefinition.Create("poisoned", "Poisoned", EffectCategory.Debuff)
            .WithDuration(DurationType.Turns, 5)
            .WithDamagePerTurn(3)
            .Build();

        yield return StatusEffectDefinition.Create("regenerating", "Regenerating", EffectCategory.Buff)
            .WithDuration(DurationType.Turns, 3)
            .WithHealingPerTurn(5)
            .Build();

        yield return StatusEffectDefinition.Create("feared", "Feared", EffectCategory.Debuff)
            .WithDuration(DurationType.Turns, 2)
            .ForcesFlee()
            .Build();
    }

    private static IEnumerable<EffectInteraction> GetTestInteractions()
    {
        yield return new EffectInteraction(
            "wet_lightning", "wet", "lightning", 50, "lightning", "stunned", null,
            "Lightning conducts through water!");

        yield return new EffectInteraction(
            "wet_ice", "wet", "ice", 0, null, "frozen", "wet",
            "The water freezes solid!");

        yield return new EffectInteraction(
            "burning_wet", "burning", "wet", 0, null, null, "burning",
            "The flames are extinguished!");
    }

    private static IEnumerable<CleanseItem> GetTestCleanseItems()
    {
        yield return CleanseItem.Antidote();
        yield return CleanseItem.Panacea();
        yield return CleanseItem.Bandage();
    }
}
```

---

## Logging Strategy

### Log Levels

| Level | Usage |
|-------|-------|
| Debug | Effect tick processing, AI decision modifications |
| Information | Configuration loaded, effect interactions triggered |
| Warning | Unknown item IDs, missing effect definitions |
| Error | Configuration load failures, invalid state |

### Log Messages

```csharp
// CombatEffectService
_logger.LogDebug("Processing turn start effects for {Name}", combatant.Name);
_logger.LogDebug("{Name} cannot act: {Reason}", combatant.Name, reason);
_logger.LogDebug("Processing attack effects: {Attacker} -> {Target}", attacker.Name, target.Name);

// EffectInteractionService
_logger.LogDebug("Checking interactions for {DamageType} damage on target with {Count} effects",
    damageType, target.ActiveEffects.Count);
_logger.LogDebug("Interaction triggered: {Id}", interaction.Id);
_logger.LogDebug("Bonus damage: {Damage}", bonusDamage);

// CleanseService
_logger.LogDebug("Cleansing {Type} effects from target", cleanseType);
_logger.LogDebug("Removed effect: {EffectId}", effectId);
_logger.LogWarning("Unknown cleanse item: {ItemId}", itemId);

// EffectAwareAIService
_logger.LogDebug("{Name} is Feared, forcing flee", monster.Name);
_logger.LogDebug("{Name} is Cursed, cannot heal - switching to attack", monster.Name);
_logger.LogDebug("{Name} is Silenced, cannot use ability - switching to attack", monster.Name);

// Repositories
_logger.LogInformation("Loaded {Count} effect interactions", _interactions.Count);
_logger.LogInformation("Loaded {Count} cleanse items", _items.Count);
_logger.LogError(ex, "Failed to load effect interactions from {Path}", configPath);
```

---

## Implementation Checklist

### Phase 1: Domain Layer Types
- [ ] Create `EffectTrigger.cs` enum
- [ ] Create `CleanseType.cs` enum
- [ ] Create `EffectInteraction.cs` value object
- [ ] Create `EffectInteractionResult.cs` value object
- [ ] Create `TurnStartEffectResult.cs` value object
- [ ] Create `AttackEffectResult.cs` value object
- [ ] Create `CleanseResult.cs` value object
- [ ] Create `CleanseItem.cs` value object
- [ ] Add new `CombatLogType` enum values

### Phase 2: Application Layer Interfaces
- [ ] Create `IEffectInteractionRepository.cs`
- [ ] Create `ICleanseItemRepository.cs`

### Phase 3: Application Layer Services
- [ ] Create `CombatEffectService.cs`
- [ ] Create `EffectInteractionService.cs`
- [ ] Create `CleanseService.cs`
- [ ] Create `EffectAwareAIService.cs`
- [ ] Add logging methods to `CombatLogService.cs`

### Phase 4: Infrastructure Layer
- [ ] Create `JsonEffectInteractionRepository.cs`
- [ ] Create `JsonCleanseItemRepository.cs`

### Phase 5: Presentation Layer
- [ ] Create `ActiveEffectDto.cs`
- [ ] Create `CombatantStatusDto.cs`
- [ ] Add methods to `IGameRenderer.cs`
- [ ] Implement methods in `SpectreGameRenderer.cs`
- [ ] Create `EffectIconMapper.cs`

### Phase 6: Configuration Files
- [ ] Create `config/effect-interactions.json`
- [ ] Create `config/cleanse-items.json`

### Phase 7: Testing
- [ ] `CombatEffectServiceTests.cs` (~6 tests)
- [ ] `EffectInteractionServiceTests.cs` (~5 tests)
- [ ] `CleanseServiceTests.cs` (~5 tests)
- [ ] `EffectAwareAIServiceTests.cs` (~4 tests)

### Phase 8: Integration
- [ ] Register services in DI container
- [ ] Wire up combat flow to use CombatEffectService
- [ ] Wire up AI to use EffectAwareAIService
- [ ] Add cleanse command support

---

## Acceptance Criteria

### Effect Integration
- [ ] DoT effects deal damage at turn start
- [ ] HoT effects heal at turn start
- [ ] Effect durations decrement each turn
- [ ] Expired effects are removed automatically
- [ ] Stunned/Knocked Down combatants skip their turn
- [ ] Feared combatants must attempt to flee

### Effect Interactions
- [ ] Wet + Lightning damage = +50% damage + Stunned
- [ ] Wet + Ice damage = Frozen (removes Wet)
- [ ] Burning + Wet = Burning extinguished
- [ ] Chilled + Ice damage = Frozen (removes Chilled)
- [ ] On Fire + Wet = On Fire extinguished

### Cleanse Mechanics
- [ ] Antidote removes Poisoned only
- [ ] Bandage removes Bleeding only
- [ ] Panacea removes all debuffs
- [ ] Smelling Salts removes magical debuffs
- [ ] Fire Resistance Potion removes Burning
- [ ] Cleanse items only consumed on successful cleanse

### AI Behavior with Effects
- [ ] Feared monsters always flee
- [ ] Disarmed monsters only defend
- [ ] Cursed monsters cannot heal
- [ ] Silenced monsters cannot use abilities
- [ ] Weakened monsters prefer defensive actions when low health

### UI Display
- [ ] Active effects shown with icons and duration
- [ ] Effect application shows notification
- [ ] Effect expiration shows notification
- [ ] DoT/HoT ticks shown during turn processing
- [ ] Effect interactions have distinct visual feedback

### Combat Log
- [ ] Status applied events logged
- [ ] Status expired events logged
- [ ] DoT damage events logged
- [ ] HoT healing events logged
- [ ] Effect interaction events logged
- [ ] Cleanse events logged

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Circular dependencies between services | Medium | High | Use interfaces, constructor injection |
| Performance with many effects | Low | Medium | Limit active effects, optimize iteration |
| Effect interaction order issues | Medium | Medium | Process interactions in defined order |
| Missing effect definitions | Low | Medium | Validate on load, provide fallbacks |
| AI behavior becomes too predictable | Low | Low | Add randomness to some decisions |

---

## File Summary

### New Files (18)

| Layer | File | Purpose |
|-------|------|---------|
| Domain | `Enums/EffectTrigger.cs` | When effects apply |
| Domain | `Enums/CleanseType.cs` | Cleanse categories |
| Domain | `ValueObjects/EffectInteraction.cs` | Interaction definition |
| Domain | `ValueObjects/EffectInteractionResult.cs` | Interaction result |
| Domain | `ValueObjects/TurnStartEffectResult.cs` | Turn start processing result |
| Domain | `ValueObjects/AttackEffectResult.cs` | Attack effect result |
| Domain | `ValueObjects/CleanseResult.cs` | Cleanse operation result |
| Domain | `ValueObjects/CleanseItem.cs` | Cleanse item definition |
| Application | `Interfaces/IEffectInteractionRepository.cs` | Interaction data access |
| Application | `Interfaces/ICleanseItemRepository.cs` | Cleanse item data access |
| Application | `Services/CombatEffectService.cs` | Combat/effect integration |
| Application | `Services/EffectInteractionService.cs` | Effect combos |
| Application | `Services/CleanseService.cs` | Cleanse mechanics |
| Application | `Services/EffectAwareAIService.cs` | AI with effect awareness |
| Application | `DTOs/ActiveEffectDto.cs` | Effect display DTO |
| Application | `DTOs/CombatantStatusDto.cs` | Status display DTO |
| Infrastructure | `Repositories/JsonEffectInteractionRepository.cs` | JSON interaction loader |
| Infrastructure | `Repositories/JsonCleanseItemRepository.cs` | JSON cleanse item loader |
| Presentation | `Helpers/EffectIconMapper.cs` | Effect icon mapping |
| Config | `config/effect-interactions.json` | Interaction data |
| Config | `config/cleanse-items.json` | Cleanse item data |

### Modified Files (5)

| Layer | File | Changes |
|-------|------|---------|
| Domain | `Enums/CombatLogType.cs` | Add StatusDamage, StatusHealing, EffectInteraction, Cleanse |
| Application | `Services/CombatLogService.cs` | Add effect logging methods |
| Application | `Interfaces/IGameRenderer.cs` | Add effect rendering methods |
| Presentation | `Adapters/SpectreGameRenderer.cs` | Implement effect rendering |
| - | DI Container | Register new services |

### Test Files (4)

| File | Test Count |
|------|------------|
| `CombatEffectServiceTests.cs` | ~6 |
| `EffectInteractionServiceTests.cs` | ~5 |
| `CleanseServiceTests.cs` | ~5 |
| `EffectAwareAIServiceTests.cs` | ~4 |
| **Total** | **~20** |
