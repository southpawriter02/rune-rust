# v0.10.0a Design Specification: Status Effect Definitions

**Version:** 0.10.0a
**Parent:** v0.10.0 (Status Effects System)
**Prerequisites:** v0.9.2c Complete (UI & Interaction Sounds)
**Status:** Design Complete
**Estimated Unit Tests:** ~15

---

## 1. Overview

### Purpose

Define the core status effect entities and configuration. This includes `StatusEffectDefinition` entity that serves as a template for effects, `ActiveStatusEffect` entity that tracks applied instances, supporting enums for effect types and stacking rules, value objects for stat modifiers and triggers, and the JSON configuration for defining effects.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `StatusEffectDefinition`, `ActiveStatusEffect` |
| **Domain Enums** | `EffectType`, `StackingRule`, `ModifierOperation` |
| **Value Objects** | `StatModifier`, `EffectTriggerAction` |
| **Interfaces** | `IStatusEffectProvider` |
| **Infrastructure** | `StatusEffectProvider` |
| **Configuration** | `status-effects.json` |
| **Tests** | ~15 unit tests |

---

## 2. Feature Overview

```
v0.10.0a Features
├── StatusEffectDefinition Entity
│   ├── EffectId (string key)
│   ├── Name, Description
│   ├── Type (EffectType enum)
│   ├── IsBuff (bool)
│   ├── BaseDuration (turns)
│   ├── Stacking (StackingRule enum)
│   ├── MaxStacks
│   ├── StatModifiers (list)
│   ├── Triggers (list)
│   ├── ImmunityIds (list)
│   ├── PreventsActions (list)
│   └── IconPath
│
├── ActiveStatusEffect Entity
│   ├── DefinitionId (reference)
│   ├── TargetId, SourceId (Guid)
│   ├── RemainingDuration
│   ├── CurrentStacks
│   ├── AppliedAt, TickCount
│   ├── Tick() method
│   ├── AddStacks() method
│   ├── RefreshDuration() method
│   └── IsExpired property
│
├── EffectType Enum
│   ├── StatModifier
│   ├── DamageOverTime
│   ├── HealOverTime
│   ├── ActionPrevention
│   ├── Movement
│   └── Special
│
├── StackingRule Enum
│   ├── None (refresh duration only)
│   ├── Stack (add stacks)
│   ├── Replace (remove and reapply)
│   └── Refresh (refresh duration)
│
├── StatModifier Value Object
│   ├── StatId (string)
│   ├── Operation (Add, Multiply, Set)
│   ├── Value (int)
│   └── PerStack (bool)
│
├── EffectTriggerAction Value Object
│   ├── Timing (OnApply, OnTurnStart, OnTurnEnd, OnExpire)
│   ├── Action (Damage, Heal, Apply, Remove)
│   ├── Value (dice notation)
│   ├── DamageType (optional)
│   └── PerStack (bool)
│
└── Configuration (status-effects.json)
    ├── poison, burning (DoT)
    ├── regeneration (HoT)
    ├── blessed, strength-up (StatModifier)
    ├── stunned (ActionPrevention)
    ├── slowed, haste (Movement/Special)
    └── Effect definitions with triggers
```

---

## 3. Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                 STATUS EFFECT DEFINITION ARCHITECTURE                   │
└─────────────────────────────────────────────────────────────────────────┘

     Configuration                    Domain                    
     ─────────────                    ──────                    

   status-effects.json          ┌─────────────────────────┐
   ┌─────────────────┐          │  StatusEffectDefinition │
   │ {                │          ├─────────────────────────┤
   │   "id": "poison",│  ─────▶  │ + EffectId: string      │
   │   "name": "...", │          │ + Name: string          │
   │   "type": "DoT", │          │ + Type: EffectType      │
   │   "duration": 5, │          │ + IsBuff: bool          │
   │   "stacking": ..│          │ + BaseDuration: int     │
   │ }                │          │ + Stacking: StackingRule│
   └─────────────────┘          │ + MaxStacks: int        │
                                 │ + StatModifiers: list   │
                                 │ + Triggers: list        │
                                 │ + ImmunityIds: list     │
                                 └─────────────────────────┘
                                              │
                                              │ instantiates
                                              ▼
                                 ┌─────────────────────────┐
                                 │   ActiveStatusEffect    │
                                 ├─────────────────────────┤
                                 │ + DefinitionId: string  │
                                 │ + TargetId: Guid        │
                                 │ + SourceId: Guid        │
                                 │ + RemainingDuration: int│
                                 │ + CurrentStacks: int    │
                                 │ + AppliedAt: DateTime   │
                                 │ + TickCount: int        │
                                 └─────────────────────────┘
```

---

## 4. EffectType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/EffectType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of status effects determining their behavior.
/// </summary>
public enum EffectType
{
    /// <summary>Modifies one or more stats.</summary>
    StatModifier,

    /// <summary>Deals damage each turn (poison, burning, bleeding).</summary>
    DamageOverTime,

    /// <summary>Heals each turn (regeneration).</summary>
    HealOverTime,

    /// <summary>Prevents certain actions (stun, freeze, silence).</summary>
    ActionPrevention,

    /// <summary>Affects movement (slow, haste, root).</summary>
    Movement,

    /// <summary>Custom/special effects (extra actions, reflect, etc.).</summary>
    Special
}
```

---

## 5. StackingRule Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/StackingRule.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Rules for how status effects stack when reapplied.
/// </summary>
public enum StackingRule
{
    /// <summary>Cannot stack, new application refreshes duration only.</summary>
    None,

    /// <summary>Stacks up to MaxStacks, each stack has full effect.</summary>
    Stack,

    /// <summary>New effect replaces existing one entirely.</summary>
    Replace,

    /// <summary>Refreshes duration without adding stacks.</summary>
    Refresh
}
```

---

## 6. ModifierOperation Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/ModifierOperation.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Mathematical operations for stat modifiers.
/// </summary>
public enum ModifierOperation
{
    /// <summary>Stat + Value</summary>
    Add,

    /// <summary>Stat * (1 + Value/100)</summary>
    Multiply,

    /// <summary>Stat = Value (override)</summary>
    Set
}
```

---

## 7. StatModifier Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/StatModifier.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a stat modification applied by a status effect.
/// </summary>
public readonly record struct StatModifier
{
    /// <summary>The stat being modified (e.g., "strength", "defense").</summary>
    public string StatId { get; init; }

    /// <summary>The operation to apply.</summary>
    public ModifierOperation Operation { get; init; }

    /// <summary>The value for the operation.</summary>
    public int Value { get; init; }

    /// <summary>Whether the value scales per stack.</summary>
    public bool PerStack { get; init; }

    /// <summary>Creates an additive modifier.</summary>
    public static StatModifier Add(string statId, int value, bool perStack = false)
        => new() { StatId = statId, Operation = ModifierOperation.Add, Value = value, PerStack = perStack };

    /// <summary>Creates a multiplicative modifier (percentage bonus).</summary>
    public static StatModifier Multiply(string statId, int percentBonus, bool perStack = false)
        => new() { StatId = statId, Operation = ModifierOperation.Multiply, Value = percentBonus, PerStack = perStack };

    /// <summary>Creates a set modifier (override).</summary>
    public static StatModifier Set(string statId, int value)
        => new() { StatId = statId, Operation = ModifierOperation.Set, Value = value };

    /// <summary>Calculates effective value based on stack count.</summary>
    public int GetEffectiveValue(int stackCount)
        => PerStack ? Value * stackCount : Value;

    public override string ToString()
        => $"{StatId} {Operation} {Value}{(PerStack ? "/stack" : "")}";
}
```

---

## 8. EffectTriggerAction Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/EffectTriggerAction.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an action that triggers at specific effect timings.
/// </summary>
public readonly record struct EffectTriggerAction
{
    /// <summary>When the trigger activates.</summary>
    public TriggerTiming Timing { get; init; }

    /// <summary>The action to perform.</summary>
    public TriggerActionType Action { get; init; }

    /// <summary>Value in dice notation (e.g., "1d4", "2d6+2").</summary>
    public string Value { get; init; }

    /// <summary>Damage type for damage actions.</summary>
    public string? DamageType { get; init; }

    /// <summary>Whether the value scales per stack.</summary>
    public bool PerStack { get; init; }

    public override string ToString()
        => $"{Timing}: {Action} {Value}{(DamageType != null ? $" ({DamageType})" : "")}";
}

/// <summary>
/// When an effect trigger activates.
/// </summary>
public enum TriggerTiming
{
    OnApply,
    OnTurnStart,
    OnTurnEnd,
    OnExpire,
    OnDamageReceived,
    OnDamageDealt,
    OnHeal
}

/// <summary>
/// What action a trigger performs.
/// </summary>
public enum TriggerActionType
{
    Damage,
    Heal,
    ApplyEffect,
    RemoveEffect,
    Custom
}
```

---

## 9. StatusEffectDefinition Entity

**File:** `src/Core/RuneAndRust.Domain/Definitions/StatusEffectDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Data-driven status effect template loaded from configuration.
/// </summary>
public class StatusEffectDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string EffectId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public EffectType Type { get; private set; }
    public bool IsBuff { get; private set; }
    public int BaseDuration { get; private set; }
    public StackingRule Stacking { get; private set; }
    public int MaxStacks { get; private set; } = 1;
    public IReadOnlyList<StatModifier> StatModifiers { get; private set; } = [];
    public IReadOnlyList<EffectTriggerAction> Triggers { get; private set; } = [];
    public IReadOnlyList<string> ImmunityIds { get; private set; } = [];
    public IReadOnlyList<string> PreventsActions { get; private set; } = [];
    public string? IconPath { get; private set; }

    // Private constructor for EF Core
    private StatusEffectDefinition() { }

    public static StatusEffectDefinition Create(
        string effectId,
        string name,
        string description,
        EffectType type,
        bool isBuff,
        int baseDuration,
        StackingRule stacking = StackingRule.None,
        int maxStacks = 1)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(effectId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);
        ArgumentOutOfRangeException.ThrowIfNegative(baseDuration);

        return new StatusEffectDefinition
        {
            Id = Guid.NewGuid(),
            EffectId = effectId.ToLowerInvariant(),
            Name = name,
            Description = description,
            Type = type,
            IsBuff = isBuff,
            BaseDuration = baseDuration,
            Stacking = stacking,
            MaxStacks = Math.Max(1, maxStacks)
        };
    }

    /// <summary>Sets stat modifiers for this effect.</summary>
    public StatusEffectDefinition WithStatModifiers(IReadOnlyList<StatModifier> modifiers)
    {
        StatModifiers = modifiers;
        return this;
    }

    /// <summary>Sets triggers for this effect.</summary>
    public StatusEffectDefinition WithTriggers(IReadOnlyList<EffectTriggerAction> triggers)
    {
        Triggers = triggers;
        return this;
    }

    /// <summary>Sets immunity IDs for this effect.</summary>
    public StatusEffectDefinition WithImmunities(IReadOnlyList<string> immunityIds)
    {
        ImmunityIds = immunityIds;
        return this;
    }

    /// <summary>Sets prevented actions for this effect.</summary>
    public StatusEffectDefinition WithPreventedActions(IReadOnlyList<string> actions)
    {
        PreventsActions = actions;
        return this;
    }

    /// <summary>Sets icon path for this effect.</summary>
    public StatusEffectDefinition WithIcon(string iconPath)
    {
        IconPath = iconPath;
        return this;
    }

    /// <summary>Gets whether this effect deals damage over time.</summary>
    public bool IsDoT => Type == EffectType.DamageOverTime;

    /// <summary>Gets whether this effect heals over time.</summary>
    public bool IsHoT => Type == EffectType.HealOverTime;

    /// <summary>Gets whether this effect prevents any actions.</summary>
    public bool PreventsAnyAction => PreventsActions.Count > 0;

    /// <summary>Checks if this effect prevents a specific action.</summary>
    public bool PreventsAction(string actionType)
        => PreventsActions.Contains(actionType.ToLowerInvariant());
}
```

---

## 10. ActiveStatusEffect Entity

**File:** `src/Core/RuneAndRust.Domain/Entities/ActiveStatusEffect.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// An active status effect instance applied to a combatant.
/// </summary>
public class ActiveStatusEffect : IEntity
{
    public Guid Id { get; private set; }
    public string DefinitionId { get; private set; } = null!;
    public Guid TargetId { get; private set; }
    public Guid SourceId { get; private set; }
    public int RemainingDuration { get; private set; }
    public int CurrentStacks { get; private set; }
    public DateTime AppliedAt { get; private set; }
    public int TickCount { get; private set; }

    // Private constructor for EF Core
    private ActiveStatusEffect() { }

    public static ActiveStatusEffect Create(
        StatusEffectDefinition definition,
        Guid targetId,
        Guid sourceId)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new ActiveStatusEffect
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.EffectId,
            TargetId = targetId,
            SourceId = sourceId,
            RemainingDuration = definition.BaseDuration,
            CurrentStacks = 1,
            AppliedAt = DateTime.UtcNow,
            TickCount = 0
        };
    }

    /// <summary>Decrements duration by one turn. Returns true if expired.</summary>
    public bool Tick()
    {
        TickCount++;
        RemainingDuration--;
        return RemainingDuration <= 0;
    }

    /// <summary>Adds stacks up to max.</summary>
    public void AddStacks(int count, int maxStacks)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(count);
        CurrentStacks = Math.Min(CurrentStacks + count, maxStacks);
    }

    /// <summary>Removes stacks (cannot go below 1 unless removing effect).</summary>
    public void RemoveStacks(int count)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(count);
        CurrentStacks = Math.Max(1, CurrentStacks - count);
    }

    /// <summary>Refreshes duration to the base value.</summary>
    public void RefreshDuration(int baseDuration)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(baseDuration);
        RemainingDuration = baseDuration;
    }

    /// <summary>Gets whether this effect has expired.</summary>
    public bool IsExpired => RemainingDuration <= 0;

    /// <summary>Gets how long the effect has been active in turns.</summary>
    public int TurnsActive => TickCount;
}
```

---

## 11. IStatusEffectProvider Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IStatusEffectProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides access to status effect definitions.
/// </summary>
public interface IStatusEffectProvider
{
    /// <summary>Gets a status effect definition by ID.</summary>
    StatusEffectDefinition? GetEffect(string effectId);

    /// <summary>Gets all status effect definitions.</summary>
    IReadOnlyList<StatusEffectDefinition> GetAllEffects();

    /// <summary>Gets all buff definitions.</summary>
    IReadOnlyList<StatusEffectDefinition> GetBuffs();

    /// <summary>Gets all debuff definitions.</summary>
    IReadOnlyList<StatusEffectDefinition> GetDebuffs();

    /// <summary>Gets effects by type.</summary>
    IReadOnlyList<StatusEffectDefinition> GetEffectsByType(EffectType type);

    /// <summary>Gets effect IDs.</summary>
    IReadOnlyList<string> GetEffectIds();
}
```

---

## 12. StatusEffectProvider Implementation

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/Services/StatusEffectProvider.cs`

```csharp
namespace RuneAndRust.Infrastructure.Services;

public class StatusEffectProvider : IStatusEffectProvider
{
    private readonly Dictionary<string, StatusEffectDefinition> _effects = new();
    private readonly ILogger<StatusEffectProvider> _logger;

    public StatusEffectProvider(IConfigurationProvider configProvider,
        ILogger<StatusEffectProvider> logger)
    {
        _logger = logger;
        LoadEffects(configProvider);
    }

    private void LoadEffects(IConfigurationProvider configProvider)
    {
        var json = configProvider.LoadConfig<StatusEffectsJson>("status-effects.json");

        foreach (var effectJson in json.StatusEffects)
        {
            var type = Enum.Parse<EffectType>(effectJson.Type, ignoreCase: true);
            var stacking = Enum.Parse<StackingRule>(effectJson.Stacking, ignoreCase: true);

            var definition = StatusEffectDefinition.Create(
                effectJson.Id,
                effectJson.Name,
                effectJson.Description,
                type,
                effectJson.IsBuff,
                effectJson.BaseDuration,
                stacking,
                effectJson.MaxStacks);

            // Load stat modifiers
            if (effectJson.StatModifiers?.Count > 0)
            {
                var modifiers = effectJson.StatModifiers.Select(m =>
                    new StatModifier
                    {
                        StatId = m.Stat,
                        Operation = Enum.Parse<ModifierOperation>(m.Operation, ignoreCase: true),
                        Value = m.Value,
                        PerStack = m.PerStack
                    }).ToList();
                definition.WithStatModifiers(modifiers);
            }

            // Load triggers
            if (effectJson.Triggers?.Count > 0)
            {
                var triggers = effectJson.Triggers.Select(t =>
                    new EffectTriggerAction
                    {
                        Timing = Enum.Parse<TriggerTiming>(t.Timing, ignoreCase: true),
                        Action = Enum.Parse<TriggerActionType>(t.Action, ignoreCase: true),
                        Value = t.Value,
                        DamageType = t.DamageType,
                        PerStack = t.PerStack
                    }).ToList();
                definition.WithTriggers(triggers);
            }

            // Load immunities and prevented actions
            if (effectJson.ImmunityIds?.Count > 0)
                definition.WithImmunities(effectJson.ImmunityIds);
            if (effectJson.PreventsActions?.Count > 0)
                definition.WithPreventedActions(effectJson.PreventsActions);
            if (!string.IsNullOrEmpty(effectJson.Icon))
                definition.WithIcon(effectJson.Icon);

            _effects[definition.EffectId] = definition;
        }

        _logger.LogInformation("Loaded {Count} status effect definitions", _effects.Count);
    }

    public StatusEffectDefinition? GetEffect(string effectId)
        => _effects.GetValueOrDefault(effectId.ToLowerInvariant());

    public IReadOnlyList<StatusEffectDefinition> GetAllEffects()
        => _effects.Values.ToList();

    public IReadOnlyList<StatusEffectDefinition> GetBuffs()
        => _effects.Values.Where(e => e.IsBuff).ToList();

    public IReadOnlyList<StatusEffectDefinition> GetDebuffs()
        => _effects.Values.Where(e => !e.IsBuff).ToList();

    public IReadOnlyList<StatusEffectDefinition> GetEffectsByType(EffectType type)
        => _effects.Values.Where(e => e.Type == type).ToList();

    public IReadOnlyList<string> GetEffectIds()
        => _effects.Keys.ToList();
}
```

---

## 13. Configuration File

**File:** `config/status-effects.json`

```json
{
  "$schema": "./schemas/status-effects.schema.json",
  "statusEffects": [
    {
      "id": "poison",
      "name": "Poison",
      "description": "Taking damage each turn from poison.",
      "type": "DamageOverTime",
      "isBuff": false,
      "baseDuration": 5,
      "stacking": "Stack",
      "maxStacks": 3,
      "triggers": [
        {
          "timing": "OnTurnStart",
          "action": "Damage",
          "value": "1d4",
          "damageType": "poison",
          "perStack": true
        }
      ],
      "icon": "icons/effects/poison.png"
    },
    {
      "id": "burning",
      "name": "Burning",
      "description": "On fire, taking fire damage.",
      "type": "DamageOverTime",
      "isBuff": false,
      "baseDuration": 3,
      "stacking": "Refresh",
      "maxStacks": 1,
      "triggers": [
        {
          "timing": "OnTurnEnd",
          "action": "Damage",
          "value": "2d6",
          "damageType": "fire",
          "perStack": false
        }
      ],
      "icon": "icons/effects/burning.png"
    },
    {
      "id": "regeneration",
      "name": "Regeneration",
      "description": "Healing each turn.",
      "type": "HealOverTime",
      "isBuff": true,
      "baseDuration": 5,
      "stacking": "None",
      "maxStacks": 1,
      "triggers": [
        {
          "timing": "OnTurnStart",
          "action": "Heal",
          "value": "1d8+2",
          "perStack": false
        }
      ],
      "icon": "icons/effects/regeneration.png"
    },
    {
      "id": "blessed",
      "name": "Blessed",
      "description": "+2 to all saving throws.",
      "type": "StatModifier",
      "isBuff": true,
      "baseDuration": 10,
      "stacking": "None",
      "maxStacks": 1,
      "statModifiers": [
        { "stat": "fortitudeSave", "operation": "Add", "value": 2, "perStack": false },
        { "stat": "reflexSave", "operation": "Add", "value": 2, "perStack": false },
        { "stat": "willSave", "operation": "Add", "value": 2, "perStack": false }
      ],
      "icon": "icons/effects/blessed.png"
    },
    {
      "id": "stunned",
      "name": "Stunned",
      "description": "Cannot take actions.",
      "type": "ActionPrevention",
      "isBuff": false,
      "baseDuration": 1,
      "stacking": "None",
      "maxStacks": 1,
      "preventsActions": ["attack", "move", "ability", "item"],
      "immunityIds": ["stunned"],
      "icon": "icons/effects/stunned.png"
    },
    {
      "id": "slowed",
      "name": "Slowed",
      "description": "Movement reduced by 50%.",
      "type": "Movement",
      "isBuff": false,
      "baseDuration": 3,
      "stacking": "Refresh",
      "maxStacks": 1,
      "statModifiers": [
        { "stat": "movementSpeed", "operation": "Multiply", "value": -50, "perStack": false }
      ],
      "icon": "icons/effects/slowed.png"
    },
    {
      "id": "haste",
      "name": "Haste",
      "description": "Move and act faster.",
      "type": "Movement",
      "isBuff": true,
      "baseDuration": 3,
      "stacking": "Refresh",
      "maxStacks": 1,
      "statModifiers": [
        { "stat": "movementSpeed", "operation": "Multiply", "value": 50, "perStack": false }
      ],
      "icon": "icons/effects/haste.png"
    },
    {
      "id": "strength-up",
      "name": "Strength Up",
      "description": "+2 Strength per stack.",
      "type": "StatModifier",
      "isBuff": true,
      "baseDuration": 5,
      "stacking": "Stack",
      "maxStacks": 3,
      "statModifiers": [
        { "stat": "strength", "operation": "Add", "value": 2, "perStack": true }
      ],
      "icon": "icons/effects/strength-up.png"
    }
  ]
}
```

---

## 14. Effect Summary Table

| Effect ID | Type | Buff? | Duration | Stacking | Description |
|-----------|------|-------|----------|----------|-------------|
| `poison` | DoT | No | 5 | Stack (3) | 1d4 poison/stack/turn |
| `burning` | DoT | No | 3 | Refresh | 2d6 fire/turn |
| `regeneration` | HoT | Yes | 5 | None | 1d8+2 heal/turn |
| `blessed` | Stat | Yes | 10 | None | +2 all saves |
| `stunned` | Prevent | No | 1 | None | Cannot act |
| `slowed` | Move | No | 3 | Refresh | -50% speed |
| `haste` | Move | Yes | 3 | Refresh | +50% speed |
| `strength-up` | Stat | Yes | 5 | Stack (3) | +2 STR/stack |

---

## 15. Unit Testing Requirements (~15 tests)

| Feature | Tests |
|---------|-------|
| StatusEffectDefinition.Create validation | 2 |
| ActiveStatusEffect.Create sets properties | 1 |
| ActiveStatusEffect.Tick decrements duration | 1 |
| ActiveStatusEffect.Tick returns true when expired | 1 |
| ActiveStatusEffect.AddStacks respects max | 1 |
| ActiveStatusEffect.RefreshDuration resets | 1 |
| StatModifier.GetEffectiveValue with stacks | 1 |
| StatusEffectProvider loads from JSON | 1 |
| StatusEffectProvider.GetEffect returns definition | 1 |
| StatusEffectProvider.GetBuffs filters correctly | 1 |
| StatusEffectProvider.GetDebuffs filters correctly | 1 |
| StatusEffectProvider.GetEffectsByType filters | 1 |
| EffectType enum parsing works | 1 |
| StackingRule enum parsing works | 1 |

---

## 16. Acceptance Criteria

- [ ] StatusEffectDefinition loads from JSON
- [ ] All effect types are supported (6 types)
- [ ] All stacking rules are defined (4 rules)
- [ ] StatModifier supports add/multiply/set
- [ ] StatModifier.GetEffectiveValue scales per stack
- [ ] EffectTriggerAction supports all timings
- [ ] ActiveStatusEffect tracks state
- [ ] Duration tracking via Tick() works
- [ ] Stack counting via AddStacks() works
- [ ] TickCount increments correctly
- [ ] Effect expiration detected via IsExpired
- [ ] IStatusEffectProvider loads definitions
- [ ] GetBuffs/GetDebuffs filter correctly
- [ ] GetEffectsByType filter correctly
- [ ] ~15 unit tests pass

---

## 17. Dependencies

| From | Required |
|------|----------|
| Domain | `IEntity` interface |
| Infrastructure | `IConfigurationProvider` |
| Prior versions | Stats system |

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
