# v0.16.5d Design Specification: Myth-Forged Drop Integration

## Document Information

| Field               | Value                                                                          |
| ------------------- | ------------------------------------------------------------------------------ |
| **Version**         | v0.16.5d                                                                       |
| **Feature**         | Myth-Forged Drop Integration                                                   |
| **Status**          | Draft                                                                          |
| **Dependencies**    | v0.16.5a (UniqueItem), v0.16.5b (SpecialEffect), v0.16.5c (UniqueItemRegistry) |
| **Estimated Tests** | 18                                                                             |

---

## 1. Executive Summary

Version 0.16.5d integrates Myth-Forged (unique item) generation into the existing loot system. This phase establishes the `IMythForgedService` interface with the `TryGenerateMythForged()` method, implements class affinity filtering (60% bias toward player's class), defines drop chances by source type, and provides fallback logic when the unique pool is exhausted. The service coordinates with the `UniqueItemRegistry` to ensure one-per-run uniqueness.

### 1.1 Feature Overview

```
v0.16.5d: Myth-Forged Drop Integration
├── Application Layer
│   ├── IMythForgedService Interface
│   │   ├── TryGenerateMythForged()
│   │   │   ├── Source-based drop chance
│   │   │   ├── Class affinity filter (60%)
│   │   │   ├── Registry integration
│   │   │   └── Fallback to null (Tier 3)
│   │   ├── GetDropChance(sourceType) → decimal
│   │   └── ShouldAttemptMythForged(sourceType, tier) → bool
│   └── MythForgedResult Value Object
│       ├── Success flag
│       ├── UniqueItem (if success)
│       ├── FallbackReason (if failed)
│       └── AppliedAffinityBonus
├── Configuration
│   ├── myth-forged-config.json
│   │   ├── Drop chances by source
│   │   ├── Affinity bias percentage
│   │   └── Fallback behavior
│   └── myth-forged-config.schema.json
└── Integration Points
    ├── ContainerLootGenerator (v0.16.4d)
    ├── UniqueItemRegistry (v0.16.5c)
    └── Smart Loot Service (v0.16.3)
```

### 1.2 Goals

1. Define `IMythForgedService` interface for unique item generation
2. Implement `TryGenerateMythForged()` with source-based drop chances
3. Apply 60% class affinity filter when generating
4. Integrate with `UniqueItemRegistry` for duplicate prevention
5. Provide clean fallback when pool is empty

### 1.3 Non-Goals (Deferred)

- Visual presentation of legendary drops (v0.16.5e)
- Achievement tracking integration (v0.16.5f)
- Audio effects for legendary drops (future)

---

## 2. Architecture

### 2.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                    CONFIGURATION LAYER                          │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                  myth-forged-config.json                    ││
│  │  ┌─────────────────────────────────────────────────────────┐││
│  │  │ dropChances: { boss: 0.70, elite: 0.10, ... }           │││
│  │  │ affinityBiasPercent: 60                                 │││
│  │  │ fallbackTier: 3                                         │││
│  │  └─────────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    APPLICATION LAYER                            │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │                  IMythForgedService                         ││
│  │  ┌─────────────────────────────────────────────────────────┐││
│  │  │ TryGenerateMythForged(context) → MythForgedResult       │││
│  │  │ GetDropChance(sourceType) → decimal                     │││
│  │  │ ShouldAttemptMythForged(sourceType, tier) → bool        │││
│  │  │ GetAvailableForSource(sourceType, sourceId) → List<>    │││
│  │  └─────────────────────────────────────────────────────────┘││
│  └─────────────────────────────────────────────────────────────┘│
│                              │                                  │
│             ┌────────────────┼────────────────┐                 │
│             ▼                ▼                ▼                 │
│  ┌──────────────────┐ ┌─────────────┐ ┌──────────────────────┐  │
│  │ IUniqueItem      │ │ IUniqueItem │ │ Configuration        │  │
│  │ Registry         │ │ Repository  │ │ Loader               │  │
│  │ (v0.16.5c)       │ │ (new)       │ │                      │  │
│  └──────────────────┘ └─────────────┘ └──────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      DOMAIN LAYER                               │
│  ┌─────────────────────────┐  ┌─────────────────────────────┐   │
│  │ MythForgedResult (VO)   │  │ MythForgedContext (VO)      │   │
│  │ ┌───────────────────┐   │  │ ┌───────────────────────┐   │   │
│  │ │ Success: bool     │   │  │ │ SourceType            │   │   │
│  │ │ Item: UniqueItem? │   │  │ │ SourceId: string      │   │   │
│  │ │ FallbackReason    │   │  │ │ PlayerClassId: string │   │   │
│  │ │ AffinityApplied   │   │  │ │ PlayerLevel: int      │   │   │
│  │ └───────────────────┘   │  │ │ RandomSeed: int?      │   │   │
│  └─────────────────────────┘  │ └───────────────────────┘   │   │
│                               └─────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │              FallbackReason (Enum)                      │    │
│  │  ┌─────────────────────────────────────────────────┐    │    │
│  │  │ None = 0           (successful drop)            │    │    │
│  │  │ PoolExhausted = 1  (all uniques already dropped)│    │    │
│  │  │ NoMatchingSource=2 (no uniques for this source) │    │    │
│  │  │ DropChanceFailed=3 (RNG didn't trigger drop)    │    │    │
│  │  │ TierTooLow = 4     (tier doesn't qualify)       │    │    │
│  │  └─────────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Generation Flow

```
┌─────────────────────────────────────────────────────────────────┐
│              TryGenerateMythForged() FLOW                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  INPUT: MythForgedContext                                       │
│       │ (sourceType, sourceId, playerClassId, playerLevel)      │
│       │                                                         │
│       ▼                                                         │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 1: Check Drop Chance                                │   │
│  │                                                          │   │
│  │  dropChance = GetDropChance(sourceType)                  │   │
│  │  roll = random.NextDouble()                              │   │
│  │                                                          │   │
│  │  if (roll > dropChance)                                  │   │
│  │      → Return MythForgedResult.Failed(DropChanceFailed)  │   │
│  └────────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 2: Get Available Uniques                            │   │
│  │                                                          │   │
│  │  pool = registry.GetAvailableUniques(                    │   │
│  │             sourceType, sourceId, playerClassId?)        │   │
│  │                                                          │   │
│  │  if (pool.Count == 0)                                    │   │
│  │      → Return MythForgedResult.Failed(PoolExhausted)     │   │
│  └────────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 3: Apply Class Affinity Filter (60% chance)         │   │
│  │                                                          │   │
│  │  affinityRoll = random.NextDouble()                      │   │
│  │  applyAffinity = (affinityRoll < 0.60)                   │   │
│  │                                                          │   │
│  │  if (applyAffinity && playerClassId != null)             │   │
│  │  {                                                       │   │
│  │      affinityPool = pool.Where(                          │   │
│  │          i => i.HasAffinityFor(playerClassId))           │   │
│  │                                                          │   │
│  │      if (affinityPool.Any())                             │   │
│  │          pool = affinityPool                             │   │
│  │  }                                                       │   │
│  └────────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 4: Select Random Item                               │   │
│  │                                                          │   │
│  │  selectedItem = pool[random.Next(pool.Count)]            │   │
│  │                                                          │   │
│  └────────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 5: Register Drop                                    │   │
│  │                                                          │   │
│  │  registry.RegisterDrop(                                  │   │
│  │      selectedItem.ItemId, sourceType, sourceId)          │   │
│  │                                                          │   │
│  └────────────────────────────┬─────────────────────────────┘   │
│                               │                                 │
│                               ▼                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ STEP 6: Return Success                                   │   │
│  │                                                          │   │
│  │  → Return MythForgedResult.Success(                      │   │
│  │        selectedItem, affinityApplied: applyAffinity)     │   │
│  │                                                          │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 Integration with Loot System

```
┌─────────────────────────────────────────────────────────────────┐
│              LOOT SYSTEM INTEGRATION                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │            ContainerLootGenerator (v0.16.4d)              │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ GenerateLoot(container, biome, player):             │  │  │
│  │  │                                                     │  │  │
│  │  │  1. Apply biome modifiers                           │  │  │
│  │  │  2. Calculate item count                            │  │  │
│  │  │  3. Generate currency                               │  │  │
│  │  │  4. For each item slot:                             │  │  │
│  │  │     a. Roll tier (SmartLootService)                 │  │  │
│  │  │     b. IF tier == 4 (Legendary):          ◄─────────┼──┤  │
│  │  │        ┌─────────────────────────────────┐          │  │  │
│  │  │        │ TRY MYTH-FORGED                 │          │  │  │
│  │  │        │                                 │          │  │  │
│  │  │        │ result = mythForgedService      │          │  │  │
│  │  │        │   .TryGenerateMythForged(ctx)   │          │  │  │
│  │  │        │                                 │          │  │  │
│  │  │        │ if (result.Success)             │          │  │  │
│  │  │        │   → Add result.Item to loot     │          │  │  │
│  │  │        │ else                            │          │  │  │
│  │  │        │   → Fallback to Tier 3 item     │          │  │  │
│  │  │        └─────────────────────────────────┘          │  │  │
│  │  │     c. ELSE: Generate normal tiered item            │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                  IMythForgedService                       │  │
│  │  ┌─────────────────────────────────────────────────────┐  │  │
│  │  │ Dependencies:                                       │  │  │
│  │  │   - IUniqueItemRegistry (tracking)                  │  │  │
│  │  │   - IUniqueItemRepository (loading definitions)     │  │  │
│  │  │   - ILogger                                         │  │  │
│  │  │   - MythForgedConfig (drop chances, bias)           │  │  │
│  │  └─────────────────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Data Model

### 3.1 FallbackReason Enum

**Location:** `src/Core/RuneAndRust.Domain/Enums/FallbackReason.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Reasons why Myth-Forged generation failed and fell back to normal loot.
/// </summary>
public enum FallbackReason
{
    /// <summary>No fallback - successful Myth-Forged drop.</summary>
    None = 0,

    /// <summary>All available unique items have already dropped this run.</summary>
    PoolExhausted = 1,

    /// <summary>No unique items are configured for this source.</summary>
    NoMatchingSource = 2,

    /// <summary>Random drop chance roll failed.</summary>
    DropChanceFailed = 3,

    /// <summary>Item tier doesn't qualify for Myth-Forged (must be tier 4).</summary>
    TierTooLow = 4
}
```

### 3.2 MythForgedContext Value Object

**Location:** `src/Core/RuneAndRust.Domain/ValueObjects/MythForgedContext.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Context for Myth-Forged generation, capturing all relevant parameters.
/// </summary>
public readonly record struct MythForgedContext
{
    /// <summary>Type of source triggering the drop.</summary>
    public DropSourceType SourceType { get; }

    /// <summary>Specific source identifier (boss ID, container type, etc.).</summary>
    public string SourceId { get; }

    /// <summary>Player's current class ID for affinity filtering.</summary>
    public string? PlayerClassId { get; }

    /// <summary>Player's current level for requirement filtering.</summary>
    public int PlayerLevel { get; }

    /// <summary>Optional random seed for deterministic testing.</summary>
    public int? RandomSeed { get; }

    private MythForgedContext(
        DropSourceType sourceType,
        string sourceId,
        string? playerClassId,
        int playerLevel,
        int? randomSeed)
    {
        SourceType = sourceType;
        SourceId = sourceId;
        PlayerClassId = playerClassId;
        PlayerLevel = playerLevel;
        RandomSeed = randomSeed;
    }

    /// <summary>
    /// Creates a new MythForgedContext with validation.
    /// </summary>
    public static MythForgedContext Create(
        DropSourceType sourceType,
        string sourceId,
        string? playerClassId = null,
        int playerLevel = 1,
        int? randomSeed = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceId, nameof(sourceId));
        ArgumentOutOfRangeException.ThrowIfLessThan(playerLevel, 1, nameof(playerLevel));

        return new MythForgedContext(
            sourceType,
            sourceId.ToLowerInvariant(),
            playerClassId?.ToLowerInvariant(),
            playerLevel,
            randomSeed);
    }

    public override string ToString() =>
        $"MythForgedContext[{SourceType}:{SourceId}, Class:{PlayerClassId ?? "none"}, Lv:{PlayerLevel}]";
}
```

### 3.3 MythForgedResult Value Object

**Location:** `src/Core/RuneAndRust.Domain/ValueObjects/MythForgedResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Result of a Myth-Forged generation attempt.
/// </summary>
public readonly record struct MythForgedResult
{
    /// <summary>Whether a unique item was successfully generated.</summary>
    public bool Success { get; }

    /// <summary>The generated unique item, if successful.</summary>
    public UniqueItem? Item { get; }

    /// <summary>Reason for fallback, if unsuccessful.</summary>
    public FallbackReason FallbackReason { get; }

    /// <summary>Whether class affinity filtering was applied.</summary>
    public bool AffinityApplied { get; }

    /// <summary>Number of items available in pool before selection.</summary>
    public int PoolSize { get; }

    private MythForgedResult(
        bool success,
        UniqueItem? item,
        FallbackReason fallbackReason,
        bool affinityApplied,
        int poolSize)
    {
        Success = success;
        Item = item;
        FallbackReason = fallbackReason;
        AffinityApplied = affinityApplied;
        PoolSize = poolSize;
    }

    /// <summary>Creates a successful result with a unique item.</summary>
    public static MythForgedResult Succeeded(
        UniqueItem item,
        bool affinityApplied,
        int poolSize)
    {
        ArgumentNullException.ThrowIfNull(item, nameof(item));

        return new MythForgedResult(
            success: true,
            item: item,
            fallbackReason: FallbackReason.None,
            affinityApplied: affinityApplied,
            poolSize: poolSize);
    }

    /// <summary>Creates a failed result with a fallback reason.</summary>
    public static MythForgedResult Failed(FallbackReason reason, int poolSize = 0)
    {
        if (reason == FallbackReason.None)
        {
            throw new ArgumentException(
                "Failed result must have a fallback reason.", nameof(reason));
        }

        return new MythForgedResult(
            success: false,
            item: null,
            fallbackReason: reason,
            affinityApplied: false,
            poolSize: poolSize);
    }

    public override string ToString() =>
        Success
            ? $"MythForgedResult[Success: {Item!.ItemId}, Affinity:{AffinityApplied}]"
            : $"MythForgedResult[Failed: {FallbackReason}]";
}
```

### 3.4 IMythForgedService Interface

**Location:** `src/Core/RuneAndRust.Application/Interfaces/IMythForgedService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for generating Myth-Forged (unique) items during loot generation.
/// Coordinates with the unique item registry for duplicate prevention.
/// </summary>
public interface IMythForgedService
{
    /// <summary>
    /// Attempts to generate a Myth-Forged item for the given context.
    /// </summary>
    /// <param name="context">Generation context with source and player info.</param>
    /// <returns>Result containing the item or fallback reason.</returns>
    MythForgedResult TryGenerateMythForged(MythForgedContext context);

    /// <summary>
    /// Gets the drop chance for a given source type.
    /// </summary>
    /// <param name="sourceType">The type of drop source.</param>
    /// <returns>Drop chance as decimal (0.0 to 1.0).</returns>
    decimal GetDropChance(DropSourceType sourceType);

    /// <summary>
    /// Determines if a Myth-Forged attempt should be made.
    /// </summary>
    /// <param name="sourceType">The type of drop source.</param>
    /// <param name="tier">The rolled quality tier.</param>
    /// <returns>True if Myth-Forged should be attempted.</returns>
    bool ShouldAttemptMythForged(DropSourceType sourceType, int tier);

    /// <summary>
    /// Gets available unique items for a source (excludes already-dropped).
    /// </summary>
    /// <param name="sourceType">The type of drop source.</param>
    /// <param name="sourceId">Specific source identifier.</param>
    /// <param name="classId">Optional class for affinity info.</param>
    /// <returns>List of available unique items.</returns>
    IReadOnlyList<UniqueItem> GetAvailableForSource(
        DropSourceType sourceType,
        string sourceId,
        string? classId = null);

    /// <summary>
    /// Gets the configured affinity bias percentage.
    /// </summary>
    decimal AffinityBiasPercent { get; }
}
```

---

## 4. Configuration

### 4.1 myth-forged-config.json

**Location:** `config/myth-forged-config.json`

```json
{
    "$schema": "./myth-forged-config.schema.json",
    "dropChances": {
        "boss": 0.7,
        "elite": 0.1,
        "bossChest": 0.5,
        "hiddenCache": 0.15,
        "questReward": 1.0,
        "monster": 0.01,
        "container": 0.02,
        "vendor": 0.0
    },
    "affinityBiasPercent": 60,
    "fallbackTier": 3,
    "minimumTierForMythForged": 4,
    "requiresLegendaryRoll": true
}
```

### 4.2 myth-forged-config.schema.json

**Location:** `config/myth-forged-config.schema.json`

```json
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$id": "myth-forged-config.schema.json",
    "title": "Myth-Forged Configuration",
    "description": "Configuration for Myth-Forged item generation",
    "type": "object",
    "required": ["dropChances", "affinityBiasPercent", "fallbackTier"],
    "properties": {
        "$schema": { "type": "string" },
        "dropChances": {
            "type": "object",
            "description": "Drop chances by source type (0.0 to 1.0)",
            "properties": {
                "boss": { "type": "number", "minimum": 0, "maximum": 1 },
                "elite": { "type": "number", "minimum": 0, "maximum": 1 },
                "bossChest": { "type": "number", "minimum": 0, "maximum": 1 },
                "hiddenCache": { "type": "number", "minimum": 0, "maximum": 1 },
                "questReward": { "type": "number", "minimum": 0, "maximum": 1 },
                "monster": { "type": "number", "minimum": 0, "maximum": 1 },
                "container": { "type": "number", "minimum": 0, "maximum": 1 },
                "vendor": { "type": "number", "minimum": 0, "maximum": 1 }
            },
            "additionalProperties": false
        },
        "affinityBiasPercent": {
            "type": "integer",
            "minimum": 0,
            "maximum": 100,
            "description": "Percentage chance to apply class affinity filter"
        },
        "fallbackTier": {
            "type": "integer",
            "minimum": 0,
            "maximum": 3,
            "description": "Tier to fall back to when Myth-Forged fails"
        },
        "minimumTierForMythForged": {
            "type": "integer",
            "minimum": 1,
            "maximum": 4,
            "default": 4,
            "description": "Minimum tier roll required to attempt Myth-Forged"
        },
        "requiresLegendaryRoll": {
            "type": "boolean",
            "default": true,
            "description": "If true, only Tier 4 rolls can become Myth-Forged"
        }
    }
}
```

---

## 5. Decision Tree

### 5.1 Should Attempt Myth-Forged

```
┌─────────────────────────────────────────────────────────────────┐
│           ShouldAttemptMythForged() DECISION TREE               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  INPUT: sourceType, tier                                        │
│       │                                                         │
│       ▼                                                         │
│  ┌────────────────────────────────────────────┐                 │
│  │ Q1: Is tier >= minimumTierForMythForged?   │                 │
│  │     (default: tier == 4)                   │                 │
│  └────────────────────┬───────────────────────┘                 │
│                       │                                         │
│          ┌────────────┴────────────┐                            │
│          │                         │                            │
│          ▼                         ▼                            │
│        [No]                      [Yes]                          │
│          │                         │                            │
│          ▼                         ▼                            │
│       RETURN                ┌───────────────────┐               │
│       FALSE                 │ Q2: Is drop       │               │
│                             │ chance > 0 for    │               │
│                             │ this sourceType?  │               │
│                             └─────────┬─────────┘               │
│                                       │                         │
│                      ┌────────────────┴────────────────┐        │
│                      │                                 │        │
│                      ▼                                 ▼        │
│                    [No]                              [Yes]      │
│                      │                                 │        │
│                      ▼                                 ▼        │
│                   RETURN                            RETURN      │
│                   FALSE                             TRUE        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 Class Affinity Application

```
┌─────────────────────────────────────────────────────────────────┐
│              CLASS AFFINITY DECISION TREE                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  INPUT: pool (list of UniqueItems), playerClassId, affinityBias │
│       │                                                         │
│       ▼                                                         │
│  ┌────────────────────────────────────────────┐                 │
│  │ Q1: Is playerClassId provided?             │                 │
│  └────────────────────┬───────────────────────┘                 │
│                       │                                         │
│          ┌────────────┴────────────┐                            │
│          │                         │                            │
│          ▼                         ▼                            │
│        [No]                      [Yes]                          │
│          │                         │                            │
│          ▼                         ▼                            │
│       Use full             ┌───────────────────┐                │
│       pool                 │ Q2: Roll affinity │                │
│                            │ chance (60%)      │                │
│                            └─────────┬─────────┘                │
│                                      │                          │
│                     ┌────────────────┴────────────┐             │
│                     │                             │             │
│                     ▼                             ▼             │
│               [Failed roll]               [Passed roll]         │
│                 (40%)                       (60%)               │
│                     │                             │             │
│                     ▼                             ▼             │
│                  Use full          ┌────────────────────────┐   │
│                  pool              │ Q3: Filter to items    │   │
│                                    │ with class affinity    │   │
│                                    └───────────┬────────────┘   │
│                                                │                │
│                               ┌────────────────┴────────────┐   │
│                               │                             │   │
│                               ▼                             ▼   │
│                         [Empty result]             [Has items]  │
│                               │                             │   │
│                               ▼                             ▼   │
│                          Use full              Use filtered     │
│                          pool                  pool             │
│                               │                             │   │
│                               └──────────────┬──────────────┘   │
│                                              │                  │
│                                              ▼                  │
│                                     SELECT RANDOM               │
│                                     FROM POOL                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. Logging Specification

### 6.1 Log Events

| Event              | Level       | Template                                                                     |
| ------------------ | ----------- | ---------------------------------------------------------------------------- |
| Generation attempt | Debug       | `"Attempting Myth-Forged generation for {SourceType}:{SourceId}"`            |
| Drop chance roll   | Debug       | `"Drop chance for {SourceType}: {Chance}%, rolled: {Roll}"`                  |
| Pool retrieved     | Debug       | `"Retrieved {Count} available uniques for {SourceType}:{SourceId}"`          |
| Affinity applied   | Debug       | `"Applied class affinity filter for {ClassId}, pool: {Before} → {After}"`    |
| Generation success | Information | `"Generated Myth-Forged item {ItemId} from {SourceType}:{SourceId}"`         |
| Generation failed  | Debug       | `"Myth-Forged generation failed: {Reason}"`                                  |
| Pool exhausted     | Information | `"Unique item pool exhausted for {SourceType}, falling back to Tier {Tier}"` |
| Fallback triggered | Debug       | `"Falling back to Tier {Tier} item generation"`                              |

---

## 7. Unit Testing

### 7.1 Test Classes

| Test Class               | Location                          | Tests |
| ------------------------ | --------------------------------- | ----- |
| `FallbackReasonTests`    | `Domain.UnitTests/Enums/`         | 2     |
| `MythForgedContextTests` | `Domain.UnitTests/ValueObjects/`  | 4     |
| `MythForgedResultTests`  | `Domain.UnitTests/ValueObjects/`  | 5     |
| `MythForgedServiceTests` | `Application.UnitTests/Services/` | 7     |

### 7.2 MythForgedContextTests

```csharp
[TestFixture]
public class MythForgedContextTests
{
    [Test]
    public void Create_WithValidData_CreatesContext()
    {
        // Arrange & Act
        var context = MythForgedContext.Create(
            DropSourceType.Boss,
            "shadow-lord",
            "warrior",
            10);

        // Assert
        context.SourceType.Should().Be(DropSourceType.Boss);
        context.SourceId.Should().Be("shadow-lord");
        context.PlayerClassId.Should().Be("warrior");
        context.PlayerLevel.Should().Be(10);
    }

    [Test]
    public void Create_NormalizesIds()
    {
        // Arrange & Act
        var context = MythForgedContext.Create(
            DropSourceType.Boss,
            "SHADOW-LORD",
            "WARRIOR",
            10);

        // Assert
        context.SourceId.Should().Be("shadow-lord");
        context.PlayerClassId.Should().Be("warrior");
    }

    [Test]
    public void Create_WithNullPlayerClass_Allowed()
    {
        // Arrange & Act
        var context = MythForgedContext.Create(
            DropSourceType.Container,
            "chest",
            playerClassId: null);

        // Assert
        context.PlayerClassId.Should().BeNull();
    }

    [Test]
    public void Create_WithInvalidLevel_ThrowsArgumentOutOfRangeException()
    {
        // Arrange & Act
        var act = () => MythForgedContext.Create(
            DropSourceType.Boss,
            "boss",
            "warrior",
            playerLevel: 0);

        // Assert
        act.Should().Throw<ArgumentOutOfRangeException>();
    }
}
```

### 7.3 MythForgedResultTests

```csharp
[TestFixture]
public class MythForgedResultTests
{
    [Test]
    public void Succeeded_WithItem_CreatesSuccessResult()
    {
        // Arrange
        var item = CreateTestUniqueItem();

        // Act
        var result = MythForgedResult.Succeeded(item, affinityApplied: true, poolSize: 5);

        // Assert
        result.Success.Should().BeTrue();
        result.Item.Should().Be(item);
        result.AffinityApplied.Should().BeTrue();
        result.FallbackReason.Should().Be(FallbackReason.None);
        result.PoolSize.Should().Be(5);
    }

    [Test]
    public void Failed_WithReason_CreatesFailedResult()
    {
        // Arrange & Act
        var result = MythForgedResult.Failed(FallbackReason.PoolExhausted, poolSize: 0);

        // Assert
        result.Success.Should().BeFalse();
        result.Item.Should().BeNull();
        result.FallbackReason.Should().Be(FallbackReason.PoolExhausted);
    }

    [Test]
    public void Failed_WithNoneReason_ThrowsArgumentException()
    {
        // Arrange & Act
        var act = () => MythForgedResult.Failed(FallbackReason.None);

        // Assert
        act.Should().Throw<ArgumentException>()
            .WithMessage("*fallback reason*");
    }

    [Test]
    public void Succeeded_WithNullItem_ThrowsArgumentNullException()
    {
        // Arrange & Act
        var act = () => MythForgedResult.Succeeded(null!, false, 0);

        // Assert
        act.Should().Throw<ArgumentNullException>();
    }

    private static UniqueItem CreateTestUniqueItem() =>
        UniqueItem.Create(
            "test-item",
            "Test Item",
            "Description",
            "Flavor",
            ItemCategory.Weapon,
            ItemStats.Empty,
            new[] { DropSource.Create(DropSourceType.Boss, "test-boss", 5.0m) });
}
```

### 7.4 MythForgedServiceTests

```csharp
[TestFixture]
public class MythForgedServiceTests
{
    private Mock<IUniqueItemRegistry> _registryMock = null!;
    private Mock<IUniqueItemRepository> _repositoryMock = null!;
    private MythForgedService _service = null!;

    [SetUp]
    public void SetUp()
    {
        _registryMock = new Mock<IUniqueItemRegistry>();
        _repositoryMock = new Mock<IUniqueItemRepository>();
        _service = new MythForgedService(
            _registryMock.Object,
            _repositoryMock.Object,
            CreateTestConfig(),
            Mock.Of<ILogger<MythForgedService>>());
    }

    [Test]
    public void GetDropChance_ForBoss_Returns70Percent()
    {
        // Arrange & Act
        var chance = _service.GetDropChance(DropSourceType.Boss);

        // Assert
        chance.Should().Be(0.70m);
    }

    [Test]
    public void ShouldAttemptMythForged_TierBelow4_ReturnsFalse()
    {
        // Arrange & Act
        var result = _service.ShouldAttemptMythForged(DropSourceType.Boss, tier: 3);

        // Assert
        result.Should().BeFalse();
    }

    [Test]
    public void ShouldAttemptMythForged_Tier4WithBoss_ReturnsTrue()
    {
        // Arrange & Act
        var result = _service.ShouldAttemptMythForged(DropSourceType.Boss, tier: 4);

        // Assert
        result.Should().BeTrue();
    }

    [Test]
    public void TryGenerateMythForged_WithEmptyPool_ReturnsPoolExhausted()
    {
        // Arrange
        _registryMock
            .Setup(r => r.GetAvailableUniques(It.IsAny<DropSourceType>(), It.IsAny<string>(), It.IsAny<string?>()))
            .Returns(Array.Empty<UniqueItem>());

        var context = MythForgedContext.Create(DropSourceType.Boss, "boss", "warrior", 10, randomSeed: 42);

        // Act
        var result = _service.TryGenerateMythForged(context);

        // Assert
        result.Success.Should().BeFalse();
        result.FallbackReason.Should().Be(FallbackReason.PoolExhausted);
    }

    [Test]
    public void TryGenerateMythForged_WithAvailableItems_ReturnsSuccess()
    {
        // Arrange
        var testItem = CreateTestUniqueItem();
        _registryMock
            .Setup(r => r.GetAvailableUniques(It.IsAny<DropSourceType>(), It.IsAny<string>(), It.IsAny<string?>()))
            .Returns(new[] { testItem });

        // Use seed that will pass the 70% drop chance
        var context = MythForgedContext.Create(DropSourceType.Boss, "boss", "warrior", 10, randomSeed: 1);

        // Act
        var result = _service.TryGenerateMythForged(context);

        // Assert
        result.Success.Should().BeTrue();
        result.Item.Should().Be(testItem);
    }

    [Test]
    public void TryGenerateMythForged_RegistersDropOnSuccess()
    {
        // Arrange
        var testItem = CreateTestUniqueItem();
        _registryMock
            .Setup(r => r.GetAvailableUniques(It.IsAny<DropSourceType>(), It.IsAny<string>(), It.IsAny<string?>()))
            .Returns(new[] { testItem });

        var context = MythForgedContext.Create(DropSourceType.Boss, "boss", "warrior", 10, randomSeed: 1);

        // Act
        _service.TryGenerateMythForged(context);

        // Assert
        _registryMock.Verify(
            r => r.RegisterDrop(testItem.ItemId, DropSourceType.Boss, "boss"),
            Times.Once);
    }

    [Test]
    public void AffinityBiasPercent_ReturnsConfiguredValue()
    {
        // Assert
        _service.AffinityBiasPercent.Should().Be(60m);
    }

    private static MythForgedConfig CreateTestConfig() => new()
    {
        DropChances = new Dictionary<string, decimal>
        {
            ["boss"] = 0.70m,
            ["elite"] = 0.10m,
            ["bossChest"] = 0.50m,
            ["hiddenCache"] = 0.15m,
            ["questReward"] = 1.00m
        },
        AffinityBiasPercent = 60,
        FallbackTier = 3,
        MinimumTierForMythForged = 4
    };
}
```

---

## 8. Acceptance Criteria

| #   | Criterion                                     | Verification  |
| --- | --------------------------------------------- | ------------- |
| 1   | Myth-Forged only attempted at Tier 4          | Unit test     |
| 2   | Boss has 70% drop chance                      | Unit test     |
| 3   | Elite has 10% drop chance                     | Unit test     |
| 4   | Class affinity applied 60% of the time        | Unit test     |
| 5   | Empty pool returns `PoolExhausted`            | Unit test     |
| 6   | Successful generation registers drop          | Unit test     |
| 7   | Failed drop chance returns `DropChanceFailed` | Unit test     |
| 8   | Quest reward has 100% drop chance             | Unit test     |
| 9   | Fallback tier is configurable (default 3)     | Configuration |

---

## 9. Deliverable Checklist

### 9.1 Domain Layer

- [ ] `FallbackReason.cs` - Enum for failure reasons
- [ ] `MythForgedContext.cs` - Value object for generation context
- [ ] `MythForgedResult.cs` - Value object for generation result

### 9.2 Application Layer

- [ ] `IMythForgedService.cs` - Interface for Myth-Forged generation
- [ ] `MythForgedService.cs` - Implementation with full logic

### 9.3 Configuration

- [ ] `config/myth-forged-config.json` - Drop chances and settings
- [ ] `config/myth-forged-config.schema.json` - JSON Schema

### 9.4 Tests

- [ ] `FallbackReasonTests.cs` - Enum tests
- [ ] `MythForgedContextTests.cs` - Context value object tests
- [ ] `MythForgedResultTests.cs` - Result value object tests
- [ ] `MythForgedServiceTests.cs` - Service tests

---

## 10. Dependencies

### 10.1 Required

| Dependency             | Version  | Purpose              |
| ---------------------- | -------- | -------------------- |
| UniqueItem             | v0.16.5a | Items to generate    |
| SpecialEffect          | v0.16.5b | Effects on items     |
| UniqueItemRegistry     | v0.16.5c | Duplicate prevention |
| ContainerLootGenerator | v0.16.4d | Integration point    |

### 10.2 Dependents

| Feature                 | Version  | Relationship    |
| ----------------------- | -------- | --------------- |
| Legendary Presentation  | v0.16.5e | Displays result |
| Achievement Integration | v0.16.5f | Tracks drops    |

---

## 11. Future Considerations

### 11.1 Deferred to v0.16.5e

- `MythForgedDropEvent` for presentation layer
- Visual feedback and announcement formatting

### 11.2 Deferred to Later Versions

- Pity system (increasing chances after failed attempts)
- Boss-specific unique items (only from certain bosses)
- Seasonal/event unique items
- Trading unique items between players
