# v0.3.23c: The Mouse (TUI Mouse Support) - Expanded Implementation Plan

## Overview

Add experimental mouse support to the TUI, enabling click-to-select and hover interactions in combat and exploration screens. This requires VT mouse reporting (SGR Extended mode) and careful escape sequence parsing in the input layer.

**Parent Plan:** [v0.3.23](./v0.3.23.md)
**Status:** Planned
**Dependencies:** `v0.3.23a` (IInputService), `v0.3.23b` (Non-blocking loop)

---

## Architecture Summary

### Key Design Decisions

1. **SGR Extended Mouse Mode** - Use `\x1b[?1006h` (SGR) instead of legacy X10/VT200 for full coordinate support (terminals > 223 columns)
2. **MouseEvent Record** - Extend `InputEvent` union to include mouse data with screen coordinates
3. **Hit-Testing System** - Screen-to-grid coordinate mapping for combat/exploration grids
4. **Graceful Fallback** - Detect terminal capability; disable mouse if not supported
5. **Cleanup Guarantee** - Always restore terminal state on exit (normal or crash)

### Mouse Event Flow

```mermaid
sequenceDiagram
    participant Terminal
    participant InputService
    participant GameLoop
    participant HitTestService
    participant Handler

    Terminal->>InputService: VT Sequence (ESC[<0;10;5M)
    InputService->>InputService: ParseMouseSequence()
    InputService->>GameLoop: MouseEvent(Click, 10, 5, Left)
    GameLoop->>HitTestService: GetHitTarget(10, 5)
    HitTestService->>Handler: TargetType.CombatGridCell(row=2, col=3)
    Handler->>Handler: SelectCombatant(row, col)
```

---

## Terminal Compatibility Matrix

| Terminal | Mouse Support | SGR Extended | Notes |
|----------|---------------|--------------|-------|
| **Windows Terminal** | ✅ | ✅ | Full support |
| **iTerm2** | ✅ | ✅ | Full support |
| **Alacritty** | ✅ | ✅ | Full support |
| **Kitty** | ✅ | ✅ | Full support |
| **VS Code Terminal** | ✅ | ✅ | Full support |
| **cmd.exe (legacy)** | ❌ | ❌ | Fallback to keyboard only |
| **PowerShell (legacy)** | ⚠️ | ❌ | Partial, unreliable |
| **macOS Terminal.app** | ✅ | ✅ | Full support |
| **Linux Console (tty)** | ❌ | ❌ | No mouse support |

---

## Files to Create (4 new files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Input/MouseEvent.cs` | Mouse event data record |
| `RuneAndRust.Core/Interfaces/IHitTestService.cs` | Hit-testing interface |
| `RuneAndRust.Engine/Services/HitTestService.cs` | Screen-to-game coordinate mapping |
| `RuneAndRust.Tests/Terminal/MouseInputTests.cs` | Mouse parsing and hit-testing tests |

## Files to Modify (5 existing files)

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Models/Input/InputEvent.cs` | Add `MouseEvent` case to union |
| `RuneAndRust.Terminal/Services/InputService.cs` | Add VT mouse sequence parsing |
| `RuneAndRust.Terminal/Services/TerminalService.cs` | Enable/disable mouse mode |
| `RuneAndRust.Terminal/Program.cs` | Wire up mouse mode lifecycle |
| `RuneAndRust.Engine/Services/GameService.cs` | Handle mouse events in phase handlers |

---

## Implementation Order

1. Create `MouseEvent` record
2. Update `InputEvent` union with mouse case
3. Implement `TerminalService.EnableMouseMode()` / `DisableMouseMode()`
4. Implement VT sequence parsing in `InputService`
5. Create `IHitTestService` interface
6. Implement `HitTestService` with combat grid hit-testing
7. Update `GameService` phase handlers for mouse events
8. Wire up mouse enable/disable in `Program.cs`
9. Create unit tests
10. Verify with manual testing

---

## Detailed Code Specifications

### 1. MouseEvent Record

**File:** `RuneAndRust.Core/Models/Input/MouseEvent.cs`

```csharp
namespace RuneAndRust.Core.Models.Input;

/// <summary>
/// Mouse button identifier.
/// </summary>
public enum MouseButton
{
    Left = 0,
    Middle = 1,
    Right = 2,
    ScrollUp = 64,
    ScrollDown = 65,
    None = 3
}

/// <summary>
/// Type of mouse event.
/// </summary>
public enum MouseEventType
{
    /// <summary>Mouse button pressed down.</summary>
    ButtonDown,
    /// <summary>Mouse button released.</summary>
    ButtonUp,
    /// <summary>Mouse moved (if tracking enabled).</summary>
    Move,
    /// <summary>Mouse wheel scrolled.</summary>
    Scroll
}

/// <summary>
/// Represents a mouse event from the terminal.
/// Uses 1-based screen coordinates (column, row).
/// </summary>
/// <remarks>
/// See: SPEC-INPUT-002 for Mouse Support System design.
/// v0.3.23c: Initial implementation.
/// </remarks>
/// <param name="EventType">The type of mouse event.</param>
/// <param name="Button">The mouse button involved.</param>
/// <param name="ScreenX">1-based column (X coordinate).</param>
/// <param name="ScreenY">1-based row (Y coordinate).</param>
/// <param name="Modifiers">Keyboard modifiers held during event (Shift, Ctrl, Alt).</param>
public record MouseEvent(
    MouseEventType EventType,
    MouseButton Button,
    int ScreenX,
    int ScreenY,
    ConsoleModifiers Modifiers = ConsoleModifiers.None
)
{
    /// <summary>
    /// Creates a click event (button down).
    /// </summary>
    public static MouseEvent Click(int x, int y, MouseButton button = MouseButton.Left)
        => new(MouseEventType.ButtonDown, button, x, y);

    /// <summary>
    /// Creates a scroll event.
    /// </summary>
    public static MouseEvent Scroll(int x, int y, bool up)
        => new(MouseEventType.Scroll, up ? MouseButton.ScrollUp : MouseButton.ScrollDown, x, y);

    /// <summary>
    /// Checks if this event is a left click.
    /// </summary>
    public bool IsLeftClick => EventType == MouseEventType.ButtonDown && Button == MouseButton.Left;

    /// <summary>
    /// Checks if this event is a right click.
    /// </summary>
    public bool IsRightClick => EventType == MouseEventType.ButtonDown && Button == MouseButton.Right;
}
```

### 2. InputEvent Union Update

**File:** `RuneAndRust.Core/Models/Input/InputEvent.cs`

```csharp
// Update existing InputEvent to support mouse:

/// <summary>
/// Unified input event that can represent keyboard actions or mouse events.
/// v0.3.23c: Added MouseEvent support.
/// </summary>
public abstract record InputEvent
{
    /// <summary>
    /// Keyboard action mapped from key press.
    /// </summary>
    public sealed record ActionEvent(GameAction Action, ConsoleModifiers Modifiers = default) : InputEvent;

    /// <summary>
    /// Raw key press for text input or unmapped keys.
    /// </summary>
    public sealed record RawKeyEvent(ConsoleKeyInfo KeyInfo) : InputEvent;

    /// <summary>
    /// Mouse event (click, scroll, move).
    /// v0.3.23c: New.
    /// </summary>
    public sealed record MouseInputEvent(MouseEvent Mouse) : InputEvent;

    /// <summary>
    /// No input available (used for polling results).
    /// </summary>
    public sealed record NoInput : InputEvent;

    /// <summary>
    /// Singleton for no input.
    /// </summary>
    public static readonly NoInput None = new();
}
```

### 3. TerminalService Mouse Mode

**File:** `RuneAndRust.Terminal/Services/TerminalService.cs`

```csharp
public class TerminalService : ITerminalService
{
    private bool _mouseEnabled = false;

    /// <summary>
    /// Enables SGR Extended mouse mode for VT-compatible terminals.
    /// Must be paired with DisableMouseMode() on exit.
    /// </summary>
    public void EnableMouseMode()
    {
        if (_mouseEnabled) return;

        // Enable SGR Extended Mouse Mode (supports coordinates > 223)
        // Mode 1006 = SGR Extended
        // Mode 1003 = Report all events (including movement)
        // Mode 1000 = Report button events only
        Console.Write("\x1b[?1000h"); // Enable button tracking
        Console.Write("\x1b[?1006h"); // Enable SGR extended coordinates

        _mouseEnabled = true;
        _logger.LogDebug("[Terminal] Mouse mode enabled (SGR Extended)");
    }

    /// <summary>
    /// Disables mouse mode and restores terminal state.
    /// </summary>
    public void DisableMouseMode()
    {
        if (!_mouseEnabled) return;

        Console.Write("\x1b[?1006l"); // Disable SGR extended
        Console.Write("\x1b[?1000l"); // Disable button tracking

        _mouseEnabled = false;
        _logger.LogDebug("[Terminal] Mouse mode disabled");
    }

    /// <summary>
    /// Checks if the current terminal likely supports mouse.
    /// </summary>
    public bool IsMouseSupported()
    {
        // Check for known compatible terminals
        var term = Environment.GetEnvironmentVariable("TERM") ?? "";
        var wtSession = Environment.GetEnvironmentVariable("WT_SESSION");

        // Windows Terminal always supports mouse
        if (!string.IsNullOrEmpty(wtSession)) return true;

        // xterm-compatible terminals support mouse
        if (term.Contains("xterm") || term.Contains("screen") ||
            term.Contains("tmux") || term.Contains("alacritty") ||
            term.Contains("kitty"))
            return true;

        // iTerm2
        var termProgram = Environment.GetEnvironmentVariable("TERM_PROGRAM");
        if (termProgram == "iTerm.app" || termProgram == "vscode")
            return true;

        return false;
    }
}
```

### 4. InputService Mouse Parsing

**File:** `RuneAndRust.Terminal/Services/InputService.cs`

```csharp
// Add to InputService class:

/// <summary>
/// Buffer for collecting escape sequences.
/// </summary>
private readonly StringBuilder _escapeBuffer = new();
private const int EscapeSequenceTimeoutMs = 50;

/// <inheritdoc/>
public InputEvent ReadNext()
{
    if (!Console.KeyAvailable)
        return InputEvent.None;

    var key = Console.ReadKey(intercept: true);

    // Check for escape sequence start
    if (key.Key == ConsoleKey.Escape)
    {
        return ParseEscapeSequence(key);
    }

    // Normal key - map to GameAction
    return MapKeyToAction(key);
}

/// <summary>
/// Parses VT escape sequences for mouse events or special keys.
/// </summary>
private InputEvent ParseEscapeSequence(ConsoleKeyInfo escapeKey)
{
    _escapeBuffer.Clear();

    // Wait briefly to see if more characters follow
    var deadline = DateTime.UtcNow.AddMilliseconds(EscapeSequenceTimeoutMs);

    while (DateTime.UtcNow < deadline)
    {
        if (Console.KeyAvailable)
        {
            var nextKey = Console.ReadKey(intercept: true);
            _escapeBuffer.Append(nextKey.KeyChar);

            // Check for complete SGR mouse sequence
            if (TryParseSgrMouseSequence(_escapeBuffer.ToString(), out var mouseEvent))
            {
                _logger.LogTrace("[Input] Parsed mouse event: {Type} at ({X}, {Y})",
                    mouseEvent.EventType, mouseEvent.ScreenX, mouseEvent.ScreenY);
                return new InputEvent.MouseInputEvent(mouseEvent);
            }

            // Reset deadline on each character
            deadline = DateTime.UtcNow.AddMilliseconds(EscapeSequenceTimeoutMs);
        }
        else
        {
            Thread.Sleep(1);
        }
    }

    // No complete sequence found - treat as escape key
    if (_escapeBuffer.Length == 0)
    {
        return new InputEvent.ActionEvent(GameAction.Cancel);
    }

    // Unknown escape sequence - log and ignore
    _logger.LogDebug("[Input] Unknown escape sequence: ESC{Seq}", _escapeBuffer.ToString());
    return InputEvent.None;
}

/// <summary>
/// Attempts to parse an SGR extended mouse sequence.
/// Format: CSI < Cb ; Cx ; Cy M (button down) or m (button up)
/// Example: ESC[<0;10;5M = Left click at column 10, row 5
/// </summary>
private static bool TryParseSgrMouseSequence(string sequence, out MouseEvent mouseEvent)
{
    mouseEvent = null!;

    // SGR format: [<Cb;Cx;Cy{M|m}
    // Must start with '[<' and end with 'M' or 'm'
    if (sequence.Length < 6 || !sequence.StartsWith("[<"))
        return false;

    var lastChar = sequence[^1];
    if (lastChar != 'M' && lastChar != 'm')
        return false;

    // Parse: [<button;x;y{M|m}
    var content = sequence[2..^1]; // Remove "[<" prefix and "M/m" suffix
    var parts = content.Split(';');

    if (parts.Length != 3)
        return false;

    if (!int.TryParse(parts[0], out var buttonCode) ||
        !int.TryParse(parts[1], out var x) ||
        !int.TryParse(parts[2], out var y))
        return false;

    // Decode button (lower 2 bits)
    var button = (buttonCode & 0x03) switch
    {
        0 => MouseButton.Left,
        1 => MouseButton.Middle,
        2 => MouseButton.Right,
        _ => MouseButton.None
    };

    // Check for scroll
    if ((buttonCode & 64) != 0)
    {
        button = (buttonCode & 1) == 0 ? MouseButton.ScrollUp : MouseButton.ScrollDown;
    }

    // Decode modifiers (bits 2-4)
    var modifiers = ConsoleModifiers.None;
    if ((buttonCode & 4) != 0) modifiers |= ConsoleModifiers.Shift;
    if ((buttonCode & 8) != 0) modifiers |= ConsoleModifiers.Alt;
    if ((buttonCode & 16) != 0) modifiers |= ConsoleModifiers.Control;

    // Decode event type
    var eventType = lastChar == 'M' ? MouseEventType.ButtonDown : MouseEventType.ButtonUp;
    if ((buttonCode & 32) != 0) eventType = MouseEventType.Move;
    if ((buttonCode & 64) != 0) eventType = MouseEventType.Scroll;

    mouseEvent = new MouseEvent(eventType, button, x, y, modifiers);
    return true;
}
```

### 5. HitTestService Interface

**File:** `RuneAndRust.Core/Interfaces/IHitTestService.cs`

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Models.Input;

/// <summary>
/// Target types for hit-testing.
/// </summary>
public enum HitTargetType
{
    None,
    CombatGridCell,
    TurnOrderEntry,
    AbilityButton,
    MenuOption,
    LogEntry
}

/// <summary>
/// Result of a hit-test operation.
/// </summary>
/// <param name="TargetType">The type of UI element hit.</param>
/// <param name="Index">Index within the element (e.g., turn order position).</param>
/// <param name="Row">Grid row if applicable.</param>
/// <param name="Column">Grid column if applicable.</param>
/// <param name="Data">Additional context data.</param>
public record HitTestResult(
    HitTargetType TargetType,
    int? Index = null,
    int? Row = null,
    int? Column = null,
    object? Data = null
)
{
    public static readonly HitTestResult None = new(HitTargetType.None);
}

/// <summary>
/// Service for mapping screen coordinates to game elements.
/// </summary>
public interface IHitTestService
{
    /// <summary>
    /// Performs a hit-test at the given screen coordinates.
    /// </summary>
    /// <param name="screenX">1-based screen column.</param>
    /// <param name="screenY">1-based screen row.</param>
    /// <param name="currentPhase">Current game phase for context.</param>
    /// <returns>The hit-test result identifying what was clicked.</returns>
    HitTestResult HitTest(int screenX, int screenY, GamePhase currentPhase);

    /// <summary>
    /// Registers a clickable region for the current frame.
    /// Called by renderers to define interactive areas.
    /// </summary>
    void RegisterRegion(
        HitTargetType type,
        int left, int top, int right, int bottom,
        int? index = null, int? row = null, int? column = null,
        object? data = null);

    /// <summary>
    /// Clears all registered regions. Called before each render.
    /// </summary>
    void ClearRegions();
}
```

### 6. HitTestService Implementation

**File:** `RuneAndRust.Engine/Services/HitTestService.cs`

```csharp
namespace RuneAndRust.Engine.Services;

using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using Microsoft.Extensions.Logging;

/// <summary>
/// Manages screen-to-game coordinate mapping for mouse interaction.
/// </summary>
public class HitTestService : IHitTestService
{
    private readonly ILogger<HitTestService> _logger;
    private readonly List<ClickableRegion> _regions = new();

    private record ClickableRegion(
        HitTargetType Type,
        int Left, int Top, int Right, int Bottom,
        int? Index, int? Row, int? Column,
        object? Data);

    public HitTestService(ILogger<HitTestService> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc/>
    public HitTestResult HitTest(int screenX, int screenY, GamePhase currentPhase)
    {
        // Search regions in reverse order (last registered = on top)
        for (int i = _regions.Count - 1; i >= 0; i--)
        {
            var region = _regions[i];
            if (screenX >= region.Left && screenX <= region.Right &&
                screenY >= region.Top && screenY <= region.Bottom)
            {
                _logger.LogTrace("[HitTest] Hit at ({X}, {Y}): {Type}",
                    screenX, screenY, region.Type);

                return new HitTestResult(
                    region.Type,
                    region.Index,
                    region.Row,
                    region.Column,
                    region.Data);
            }
        }

        _logger.LogTrace("[HitTest] Miss at ({X}, {Y})", screenX, screenY);
        return HitTestResult.None;
    }

    /// <inheritdoc/>
    public void RegisterRegion(
        HitTargetType type,
        int left, int top, int right, int bottom,
        int? index = null, int? row = null, int? column = null,
        object? data = null)
    {
        _regions.Add(new ClickableRegion(type, left, top, right, bottom, index, row, column, data));
    }

    /// <inheritdoc/>
    public void ClearRegions()
    {
        _regions.Clear();
    }
}
```

### 7. Combat Grid Registration Example

**File:** `RuneAndRust.Terminal/Rendering/CombatGridRenderer.cs` (Update)

```csharp
// In RenderCombatGrid method, after drawing each cell:

// Register clickable region for each combatant cell
// Assuming grid starts at (gridLeft, gridTop) with cellWidth and cellHeight
for (int row = 0; row < gridRows; row++)
{
    for (int col = 0; col < gridCols; col++)
    {
        var combatant = GetCombatantAt(row, col);
        if (combatant != null)
        {
            var cellLeft = gridLeft + (col * cellWidth);
            var cellTop = gridTop + (row * cellHeight);
            var cellRight = cellLeft + cellWidth - 1;
            var cellBottom = cellTop + cellHeight - 1;

            _hitTestService.RegisterRegion(
                HitTargetType.CombatGridCell,
                cellLeft, cellTop, cellRight, cellBottom,
                row: row, column: col, data: combatant);
        }
    }
}
```

### 8. GameService Mouse Handling

**File:** `RuneAndRust.Engine/Services/GameService.cs` (Update)

```csharp
// In ProcessInputEventAsync:

private async Task ProcessInputEventAsync(InputEvent input)
{
    switch (input)
    {
        case InputEvent.MouseInputEvent mouseInput:
            await HandleMouseEventAsync(mouseInput.Mouse);
            break;

        case InputEvent.ActionEvent actionInput:
            await HandleActionEventAsync(actionInput.Action);
            break;

        case InputEvent.RawKeyEvent:
            // Handle text input for commands
            break;
    }
}

private async Task HandleMouseEventAsync(MouseEvent mouse)
{
    if (!mouse.IsLeftClick && !mouse.IsRightClick)
        return; // Ignore move/release for now

    var hitResult = _hitTestService.HitTest(mouse.ScreenX, mouse.ScreenY, _state.Phase);

    switch (hitResult.TargetType)
    {
        case HitTargetType.CombatGridCell:
            await HandleCombatGridClickAsync(hitResult.Row!.Value, hitResult.Column!.Value, mouse.IsRightClick);
            break;

        case HitTargetType.TurnOrderEntry:
            // Select combatant from turn order
            SelectCombatantByIndex(hitResult.Index!.Value);
            break;

        case HitTargetType.AbilityButton:
            // Activate ability
            await ActivateAbilityAsync(hitResult.Index!.Value);
            break;

        default:
            _logger.LogTrace("[Input] Mouse click on non-interactive area");
            break;
    }
}

private async Task HandleCombatGridClickAsync(int row, int col, bool isRightClick)
{
    var combatant = _combatService.GetCombatantAt(row, col);
    if (combatant == null) return;

    if (isRightClick)
    {
        // Right-click = Inspect (v0.3.22b)
        await ShowInspectionAsync(combatant);
    }
    else
    {
        // Left-click = Select/Target
        _combatService.SelectTarget(combatant);
        _logger.LogDebug("[Combat] Mouse selected target: {Name}", combatant.Name);
    }
}
```

---

## Logging Requirements

| Component | Event | Level | Template | Properties |
|-----------|-------|-------|----------|------------|
| `TerminalService` | Enable Mouse | Debug | `[Terminal] Mouse mode enabled (SGR Extended)` | - |
| `TerminalService` | Disable Mouse | Debug | `[Terminal] Mouse mode disabled` | - |
| `InputService` | Mouse Parsed | Trace | `[Input] Parsed mouse event: {Type} at ({X}, {Y})` | Type, X, Y |
| `InputService` | Unknown Sequence | Debug | `[Input] Unknown escape sequence: ESC{Seq}` | Seq |
| `HitTestService` | Hit | Trace | `[HitTest] Hit at ({X}, {Y}): {Type}` | X, Y, Type |
| `HitTestService` | Miss | Trace | `[HitTest] Miss at ({X}, {Y})` | X, Y |
| `GameService` | Grid Click | Debug | `[Combat] Mouse selected target: {Name}` | Name |

---

## Testing Strategy

### Unit Tests

**File:** `RuneAndRust.Tests/Terminal/MouseInputTests.cs` (New)

| Test Method | Scenario | Input | Expected |
|-------------|----------|-------|----------|
| `ParseSgrSequence_LeftClick_ReturnsCorrectEvent` | Left click | `[<0;10;5M` | MouseEvent(ButtonDown, Left, 10, 5) |
| `ParseSgrSequence_RightClick_ReturnsCorrectEvent` | Right click | `[<2;20;15M` | MouseEvent(ButtonDown, Right, 20, 15) |
| `ParseSgrSequence_ButtonUp_ReturnsReleaseEvent` | Button release | `[<0;10;5m` | MouseEvent(ButtonUp, Left, 10, 5) |
| `ParseSgrSequence_ScrollUp_ReturnsScrollEvent` | Scroll up | `[<64;10;5M` | MouseEvent(Scroll, ScrollUp, 10, 5) |
| `ParseSgrSequence_WithShift_IncludesModifier` | Shift+click | `[<4;10;5M` | MouseEvent(..., Shift) |
| `ParseSgrSequence_WithCtrl_IncludesModifier` | Ctrl+click | `[<16;10;5M` | MouseEvent(..., Control) |
| `ParseSgrSequence_InvalidFormat_ReturnsFalse` | Bad input | `[<invalid` | false |
| `ParseSgrSequence_LargeCoordinates_Works` | Wide terminal | `[<0;250;100M` | MouseEvent(_, _, 250, 100) |

**File:** `RuneAndRust.Tests/Engine/HitTestServiceTests.cs` (New)

| Test Method | Scenario | Setup | Expected |
|-------------|----------|-------|----------|
| `HitTest_InsideRegion_ReturnsHit` | Click inside | Register(10, 10, 20, 20) | HitTestResult with data |
| `HitTest_OutsideRegion_ReturnsNone` | Click outside | Register(10, 10, 20, 20), click (5, 5) | HitTestResult.None |
| `HitTest_OverlappingRegions_ReturnsTopmost` | Overlapping | Register A, Register B | B returned |
| `ClearRegions_RemovesAll` | Clear | Register 3, Clear | All hits return None |

### Verification Commands

**Run mouse input tests:**
```bash
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~MouseInputTests"
```

**Run hit-test tests:**
```bash
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~HitTestServiceTests"
```

### Manual Verification

#### 1. Mouse Click Test
1. Launch game in a supported terminal (Windows Terminal, iTerm2).
2. Enter combat mode.
3. Click on an enemy in the combat grid.
4. **Expected:** Enemy is selected/targeted.

#### 2. Right-Click Inspect
1. In combat, right-click on an enemy.
2. **Expected:** Inspection panel opens (v0.3.22b integration).

#### 3. Terminal Fallback Test
1. Launch game in legacy cmd.exe.
2. Try to use mouse.
3. **Expected:** Mouse is disabled, keyboard works normally.

#### 4. Mouse Mode Cleanup Test
1. Launch game with mouse enabled.
2. Force-quit (Ctrl+C or crash).
3. Reopen terminal.
4. **Expected:** Terminal mouse behavior is normal (not stuck in mouse mode).

---

## Work Breakdown

- [ ] **Core:** Create `MouseEvent.cs` record
- [ ] **Core:** Update `InputEvent.cs` with `MouseInputEvent` case
- [ ] **Core:** Create `IHitTestService.cs` interface
- [ ] **Engine:** Create `HitTestService.cs` implementation
- [ ] **Terminal:** Update `TerminalService.cs` with mouse mode
- [ ] **Terminal:** Update `InputService.cs` with VT sequence parsing
- [ ] **Terminal:** Update renderers to register clickable regions
- [ ] **Engine:** Update `GameService.cs` with mouse event handling
- [ ] **Terminal:** Update `Program.cs` with mouse lifecycle
- [ ] **Tests:** Create `MouseInputTests.cs`
- [ ] **Tests:** Create `HitTestServiceTests.cs`

---

## Estimated Metrics

| Metric | Value |
|--------|-------|
| New Files | 4 |
| Modified Files | 5 |
| New Lines (Services) | ~400 |
| New Lines (Tests) | ~200 |
| New Unit Tests | ~12 |

---

## Pre-Commit Checks

- [ ] Verify mouse mode cleanup on normal exit
- [ ] Verify mouse mode cleanup on Ctrl+C
- [ ] Test in Windows Terminal, iTerm2, and VS Code terminal
- [ ] Verify keyboard still works when mouse is enabled
- [ ] Check that legacy terminals gracefully fall back
- [ ] Verify no escape sequences leak to terminal output

---

## Future Extensions

### v0.3.24+ Considerations
- **Hover Effects:** Show tooltips on mouse hover
- **Drag-and-Drop:** Drag items in inventory
- **Context Menus:** Right-click menus with options

**End of Plan**

