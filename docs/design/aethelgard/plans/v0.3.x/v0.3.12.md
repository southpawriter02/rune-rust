# v0.3.12: The Gauntlet (Automated User Journeys)

> **Status:** Planned
> **Milestone:** 4.7 - Automated Testing
> **Theme:** End-to-End Integration Testing Framework

## Table of Contents

- [Overview](#overview)
- [Phase A: The Explorer's Path (Exploration Loop)](#phase-a-the-explorers-path-exploration-loop)
  - [Architecture & Data Flow](#1-architecture--data-flow)
  - [Logic Decision Trees](#2-logic-decision-trees)
  - [Code Implementation](#3-code-implementation)
  - [Logging Requirements](#4-logging-requirements)
  - [Testing Requirements](#5-testing-requirements)
  - [Deliverable Checklist](#6-deliverable-checklist)
- [Phase B: The Warrior's Trial (Combat Loop)](#phase-b-the-warriors-trial-combat-loop)
  - [Architecture & Data Flow](#1-architecture--data-flow-1)
  - [Logic Decision Trees](#2-logic-decision-trees-1)
  - [Code Implementation](#3-code-implementation-1)
  - [Logging Requirements](#4-logging-requirements-1)
  - [Testing Requirements](#5-testing-requirements-1)
  - [Deliverable Checklist](#6-deliverable-checklist-1)
- [Phase C: The Survivor's Cycle (Persistence Loop)](#phase-c-the-survivors-cycle-persistence-loop)
  - [Architecture & Data Flow](#1-architecture--data-flow-2)
  - [Logic Decision Trees](#2-logic-decision-trees-2)
  - [Code Implementation](#3-code-implementation-2)
  - [Logging Requirements](#4-logging-requirements-2)
  - [Testing Requirements](#5-testing-requirements-2)
  - [Deliverable Checklist](#6-deliverable-checklist-2)
- [Testing Strategy](#testing-strategy)
- [Changelog: v0.3.12 - The Gauntlet](#changelog-v0312---the-gauntlet)

---

## Overview

This milestone shifts focus from unit testing to **End-to-End (E2E) Integration Testing**. We will simulate full player sessions ("Journeys") to ensure that the disparate systems—Movement, Interaction, Inventory, Combat, and Persistence—work cohesively without regression.

The Gauntlet framework introduces `ScriptedInputHandler` infrastructure that replaces human input with a queue of predetermined commands, allowing us to script entire gameplay sessions and verify the resulting state. Combined with deterministic seeding for RNG systems, this ensures tests are reproducible and debuggable.

To manage the complexity of testing different gameplay loops, this version is split into three sub-versions:

| Phase | Codename | Focus |
|-------|----------|-------|
| A | The Explorer's Path | Exploration Loop - Navigation, Interaction, Inventory |
| B | The Warrior's Trial | Combat Loop - Battle Resolution, Loot, XP |
| C | The Survivor's Cycle | Persistence Loop - Save/Load State Integrity |

---

## Phase A: The Explorer's Path (Exploration Loop)

**Goal:** Implement the `ScriptedInputHandler` and `TestHost` infrastructure to automate the "Walking Simulator" aspect of the game. Verify that a scripted sequence of inputs results in the correct final `GameState` (position, inventory, flags) without crashing.

### 1. Architecture & Data Flow

**The Automation Pipeline:**

1. **Bootstrap:** The `TestHost` initializes the DI container but replaces `TerminalInputHandler` with `ScriptedInputHandler`.
2. **Seeding:** The `DungeonGenerator` and `LootService` are initialized with a Fixed Seed (e.g., `12345`). This ensures the dungeon layout and item drops are identical for every test run.
3. **Execution:**
   - `GameService.StartAsync()` calls `IInputHandler.GetInput()`.
   - `ScriptedInputHandler` dequeues the next command from its list.
   - `CommandParser` executes the command, modifying `GameState`.
   - The loop repeats until the script issues a `quit` command or runs out of instructions.
4. **Assertion:** The test inspects the final `GameState` properties (`CurrentRoomId`, Inventory contents, History log) against expected values.

**Components:**

- **ScriptedInputHandler (Test):** Mock input provider that feeds commands from a `Queue<string>`
- **TestGameHost (Test):** DI container wrapper that configures the game for automated testing
- **DungeonGenerator (Engine):** Extended to accept seed for deterministic world generation

### 2. Logic Decision Trees

#### A. Scripted Input Logic

**Input:** GameService requests input

1. **Check Queue:** Is there a command in the queue?
   - Yes: Dequeue command → Log `"Bot Input: [Command]"` → Return command.
   - No: Log `"Queue Empty, forcing quit"` → Return `"quit"`.
2. **Delay Simulation (Optional):** If `SimulateThinkingTime` is true, `Thread.Sleep(10ms)` to stress-test async synchronization.

#### B. Deterministic Generation Logic

**Input:** `DungeonGenerator.Generate(Seed)`

1. **Seed PRNG:** Initialize `System.Random` with specific integer.
2. **Generate Layout:** Create rooms based on seed (guaranteed layout).
3. **Populate:** Spawn items/enemies based on seed (guaranteed contents).
4. **Result:** Room `(0,1,0)` always contains `"Iron Sword"` in `"Old Chest"`.

### 3. Code Implementation

#### A. Scripted Input Handler

**File:** `RuneAndRust.Tests/Infrastructure/ScriptedInputHandler.cs`

```csharp
public class ScriptedInputHandler : IInputHandler
{
    private readonly Queue<string> _commandQueue;
    private readonly ILogger _logger;

    public ScriptedInputHandler(IEnumerable<string> commands, ILogger logger)
    {
        _commandQueue = new Queue<string>(commands);
        _logger = logger;
    }

    public string GetInput(string prompt)
    {
        if (_commandQueue.TryDequeue(out var command))
        {
            _logger.LogInformation("[Auto-Player] Input: {Command}", command);
            return command;
        }

        _logger.LogWarning("[Auto-Player] Queue empty. Forcing 'quit'.");
        return "quit";
    }

    // Mock output methods to capture game feedback for assertions
    public List<string> OutputBuffer { get; } = new();
    public void DisplayMessage(string message) => OutputBuffer.Add(message);
    public void DisplayError(string message) => OutputBuffer.Add($"ERROR: {message}");
}
```

#### B. Test Game Host

**File:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs`

```csharp
public class TestGameHost : IDisposable
{
    public GameService GameService { get; }
    public GameState GameState { get; }
    private readonly IServiceProvider _serviceProvider;

    public static TestGameHost Create(int seed, IEnumerable<string> script)
    {
        // DI setup with ScriptedInputHandler and seeded generators
        // ...
    }

    public void Dispose()
    {
        // Cleanup resources
    }
}
```

#### C. The Explorer's Test

**File:** `RuneAndRust.Tests/Integration/ExplorationJourneyTests.cs`

```csharp
[Fact]
public async Task Journey_LootAndEquip_ChangesStats()
{
    // Arrange: A script that creates a char, finds loot, and equips it
    var script = new[]
    {
        "new", "TestHero", "Warrior", // Char Creation
        "look",
        "search chest",               // Finding items
        "take Iron Sword",            // Looting
        "equip Iron Sword",           // State change
        "quit"                        // End loop
    };

    // Act: Run the Gauntlet with Fixed Seed 42
    using var host = TestGameHost.Create(seed: 42, script);
    await host.GameService.StartAsync();

    // Assert: Check final state
    var hero = host.GameState.CurrentCharacter;

    // Verify Inventory
    hero.Inventory.Should().Contain(i => i.Item.Name == "Iron Sword" && i.IsEquipped);

    // Verify Stats (Iron Sword gives +Damage)
    // Assuming Warrior Base Might 5 + Sword 2 = 7
    // host.CombatService.GetWeaponDamage(hero).Should().BeGreaterThan(2);
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| TestHost | Start | Info | `"Starting Automated Journey with Seed {Seed}"` | Seed |
| Input | Step | Info | `"[Auto-Player] Executing: {Command}"` | Command |
| Game | State | Debug | `"Post-Command State: Room {Room}, Burden {Burden}"` | Room, Burden |
| TestHost | End | Info | `"Journey Complete. Steps executed: {Count}"` | Count |

### 5. Testing Requirements

**Test Strategy:**

- **Deterministic Failure:** If a test fails, the seed ensures it fails the exact same way every time. This allows step-by-step debugging of the logic flaw rather than chasing RNG ghosts.
- **Fail Fast:** The `ScriptedInputHandler` logs warnings if the game asks for input but the queue is empty, indicating a logic divergence (e.g., an unexpected menu popped up).

**Unit Tests (ExplorationJourneyTests.cs):**

- **Journey_NewGame_To_FirstRoom:** Validates character creation and initial movement.
- **Journey_Loot_And_Equip:** Validates `search` → `take` → `equip` flow.
- **Journey_Navigation_Loop:** Validates moving N → E → S → W returns to start.
- **Journey_Invalid_Commands:** Validates stability when sending garbage input.

### 6. Deliverable Checklist

- **Infrastructure:**
  - [ ] Create `Infrastructure/ScriptedInputHandler.cs`
  - [ ] Create `Infrastructure/TestGameHost.cs` (DI Container wrapper)
  - [ ] Implement `Seed` property in `DungeonGenerator` configuration
- **Integration Tests:**
  - [ ] `Journey_NewGame_To_FirstRoom`
  - [ ] `Journey_Loot_And_Equip`
  - [ ] `Journey_Navigation_Loop`
  - [ ] `Journey_Invalid_Commands`

---

## Phase B: The Warrior's Trial (Combat Loop)

**Goal:** Implement `CombatJourneyTests` using `ScriptedInputHandler` and a fixed RNG seed to simulate complete combat encounters. Verify that commands like `attack`, `defend`, and `flee` function correctly within the game loop and that the post-combat state (Health, Loot, XP) is consistent.

### 1. Architecture & Data Flow

**The Deterministic Combat Pipeline:**

1. **Seed Injection:** The `TestHost` initializes `DiceService` with a specific integer seed (e.g., `999`). This forces the `Random` instance to produce the same sequence of die rolls every time.
2. **Combat Trigger:** The script uses `debug-combat` (from v0.2.0a) or enters a known hostile room to trigger `StartCombat()`.
3. **Turn Execution:**
   - **Scripted Input:** `attack` command is dequeued.
   - **Deterministic Roll:** `DiceService` rolls a known value (e.g., a hit).
   - **Enemy AI:** The enemy takes its turn using the same seeded RNG, resulting in a predictable action.
4. **Resolution:** Combat ends. The test verifies the final `GameState` (Player HP reduced, XP increased, Loot in inventory).

**Components:**

- **DiceService (Engine):** Extended to accept optional seed in constructor
- **TestHost (Test):** Updated to support combat service configuration

### 2. Logic Decision Trees

#### A. Combat Verification Logic

**Input:** GameState (Post-Combat)

1. **Check Phase:** Is `Phase == Exploration`? (Combat ended successfully).
2. **Check Resources:**
   - Is `CurrentHP < MaxHP`? (Player took damage).
   - Is `CurrentHP > 0`? (Player survived).
3. **Check Rewards:**
   - Is `ExperiencePoints > Initial`? (XP awarded).
   - Does Inventory contain `"Training Dummy Scrap"`? (Loot received).

#### B. Deterministic Dice Logic

**Input:** Seed `12345`

1. **Roll 1:** Player Initiative (Result: 8).
2. **Roll 2:** Enemy Initiative (Result: 4).
3. **Roll 3:** Player Attack (Result: 19 - Hit).
4. **Roll 4:** Enemy Damage Soak (Result: 2).

**Result:** Test asserts Player goes first and deals X damage.

### 3. Code Implementation

#### A. Dice Service Seed Injection

**File:** `RuneAndRust.Engine/Services/DiceService.cs`

```csharp
public class DiceService : IDiceService
{
    private readonly Random _random;

    // Constructor injection allows TestHost to provide a seeded Random
    public DiceService(ILogger logger, int? seed = null)
    {
        _random = seed.HasValue ? new Random(seed.Value) : Random.Shared;
        // ...
    }
}
```

#### B. The Warrior's Test

**File:** `RuneAndRust.Tests/Integration/CombatJourneyTests.cs`

```csharp
[Fact]
public async Task Journey_CombatVictory_GrantsLoot()
{
    // Arrange: Seed 777 guarantees Player wins initiative and lands hits
    var script = new[]
    {
        "new", "Warrior",    // Create Char
        "debug-combat",      // Trigger dummy fight (HP: 30)
        "attack",            // Turn 1: Hit
        "attack",            // Turn 2: Hit
        "attack",            // Turn 3: Hit (Kill)
        "loot scrap",        // Post-combat cleanup
        "i",                 // Check inventory
        "status",            // Check XP
        "quit"
    };

    using var host = TestGameHost.Create(seed: 777, script);

    // Act
    await host.GameService.StartAsync();

    // Assert
    var hero = host.GameState.CurrentCharacter;

    // Verify Phase returned to Exploration
    host.GameState.Phase.Should().Be(GamePhase.Exploration);

    // Verify Loot
    hero.Inventory.Should().Contain(i => i.Item.Name.Contains("Scrap"));

    // Verify XP (Training dummy gives 10 XP)
    hero.ExperiencePoints.Should().Be(10);

    // Verify Damage Taken (Enemy acted at least once)
    hero.CurrentHP.Should().BeLessThan(hero.MaxHP);
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| TestHost | Seed | Info | `"Initialized DiceService with deterministic seed: {Seed}"` | Seed |
| Combat | Log | Debug | `"Combat Test: Player HP {HP}, Enemy HP {EnemyHP}"` | HP, EnemyHP |
| Dice | Roll | Debug | `"Deterministic Roll: {Result} (Context: {Context})"` | Result, Context |

### 5. Testing Requirements

**Test Strategy:**

- **Seed Calibration:** You may need to run the test once with logging enabled to find a seed where the player doesn't miss 5 times in a row. Once found, hardcode that seed (e.g., `777`) into the test to ensure it passes forever.
- **Strict Order:** The test assumes the player goes first. If the seed causes the enemy to go first, the attack command might be processed out of order. The seed ensures the order of events is locked.

**Unit Tests (CombatJourneyTests.cs):**

- **Combat_Victory_Standard:** Enter combat, attack until win, loot.
- **Combat_Flee_Success:** Enter combat, flee, verify return to exploration.
- **Combat_Defeat_Death:** (Optional) Verify game over state on loss.

### 6. Deliverable Checklist

- **Test Infrastructure:**
  - [ ] Update `TestHost.cs` to allow injecting a seed into `DiceService`
  - [ ] Create `CombatJourneyTests.cs`
- **Engine Updates:**
  - [ ] Ensure `DiceService` constructor accepts an optional seed (already supported by `System.Random`, expose via DI)
- **Scenarios:**
  - [ ] `Combat_Victory_Standard`
  - [ ] `Combat_Flee_Success`
  - [ ] `Combat_Defeat_Death` (Optional)

---

## Phase C: The Survivor's Cycle (Persistence Loop)

**Goal:** Implement `PersistenceJourneyTests` to verify that `SaveGame` data is correctly serialized, persisted to storage, and deserialized into an identical `GameState` upon reloading a new application instance.

### 1. Architecture & Data Flow

**The Resurrection Pipeline:**

Unlike previous tests which run in a single scope, this test simulates an application restart.

1. **Session A (The Life):**
   - Initialize `TestHost` (Scope A).
   - Execute actions that mutate state (Move, Loot, Take Damage, Apply Status).
   - Execute `save` command.
   - **Terminate:** Dispose `TestHost` (Scope A). This simulates closing the game.
2. **The Void:**
   - The database/file remains on disk (or in a shared DB container).
3. **Session B (The Afterlife):**
   - Initialize new `TestHost` (Scope B) connecting to the same database.
   - Execute `load` command.
   - **Verification:** Compare Session B's initial state against Session A's final state.

**Components:**

- **TestHost (Test):** Extended to support "rebooting" (re-initializing services against an existing DB)
- **SaveManager (Engine):** Ensure all buffers flush to disk/DB immediately on save

### 2. Logic Decision Trees

#### A. State Verification Logic

**Input:** Original State (A), Loaded State (B)

1. **Position Check:** Does `B.CurrentRoomId == A.CurrentRoomId`?
2. **Inventory Integrity:**
   - Does `B.Inventory.Count == A.Inventory.Count`?
   - Do all Item IDs and Quantities match?
   - Are equipped items still equipped?
3. **Vitals Check:**
   - Is `B.CurrentHP == A.CurrentHP`?
   - Is `B.PsychicStress == A.PsychicStress`?
4. **World State:**
   - Are looted containers in `B.CurrentRoom` still empty/open?
   - Are visited rooms in `B.VisitedRoomIds` preserved (Fog of War)?

### 3. Code Implementation

#### A. Test Infrastructure Update

**File:** `RuneAndRust.Tests/Infrastructure/TestGameHost.cs`

We need a way to reuse the database connection string between two different `GameService` instances.

```csharp
public class TestHost : IDisposable
{
    private readonly string _dbConnectionString;
    public GameService GameService { get; private set; }
    public string ConnectionString => _dbConnectionString;
    // ... other services ...

    // Constructor creates a fresh DB
    public TestHost()
    {
        _dbConnectionString = dbFixture.CreateDatabase();
        InitializeServices();
    }

    // Constructor connecting to EXISTING DB
    public TestHost(string existingConnectionString)
    {
        _dbConnectionString = existingConnectionString;
        InitializeServices();
    }

    // ... Implementation ...
}
```

#### B. The Persistence Test

**File:** `RuneAndRust.Tests/Integration/PersistenceJourneyTests.cs`

```csharp
[Fact]
public async Task Journey_SurvivorCycle_RetainsStateAfterRestart()
{
    string dbConnection;
    Guid expectedRoomId;
    int expectedHp;
    int expectedItemCount;

    // --- SESSION A: The Life ---
    using (var hostA = new TestHost())
    {
        dbConnection = hostA.ConnectionString;

        var script = new[] {
            "new Warrior",
            "go north",      // Change location
            "take Dagger",   // Change inventory
            "save",          // Persist
            "quit"           // Exit loop
        };

        hostA.RunScript(script);

        // Capture State for verification
        expectedRoomId = hostA.GameState.CurrentRoomId;
        expectedItemCount = hostA.GameState.CurrentCharacter.Inventory.Count;
        expectedHp = hostA.GameState.CurrentCharacter.CurrentHP;
    }
    // hostA is Disposed here (Simulating App Shutdown)

    // --- SESSION B: The Afterlife ---
    using (var hostB = new TestHost(dbConnection))
    {
        var script = new[] {
            "load",          // Restore state
            "status",        // Verify output
            "quit"
        };

        await hostB.RunScriptAsync(script);

        // Assert: State survived the reboot
        var charB = hostB.GameState.CurrentCharacter;

        charB.Should().NotBeNull();
        hostB.GameState.CurrentRoomId.Should().Be(expectedRoomId);
        charB.Inventory.Count.Should().Be(expectedItemCount);
        charB.CurrentHP.Should().Be(expectedHp);
    }
}
```

### 4. Logging Requirements

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Test | Phase Change | Info | `"--- END SESSION A ---"` | - |
| Test | Phase Change | Info | `"--- START SESSION B ---"` | - |
| SaveManager | Serialization | Debug | `"Serialized GameState size: {Bytes} bytes"` | Bytes |
| SaveManager | Integrity | Warning | `"Loaded state checksum mismatch"` | - |

### 5. Testing Requirements

**Test Strategy:**

- **Database Isolation:** Use the `PostgreSqlTestFixture` (from v0.3.1e) to ensure real DB constraints (foreign keys, JSONB serialization) are tested. InMemory DBs often mask serialization errors.
- **Deep Object Graph:** Ensure nested objects (like `InventoryItem.Item.Stats`) are fully hydrated on load. Simple property checks might miss deep detachment issues.

**Unit Tests (PersistenceJourneyTests.cs):**

- **Journey_SaveLoad_PreservesLocation:** Move to non-start room → Save/Load → Verify Room.
- **Journey_SaveLoad_PreservesLoot:** Pickup item → Save/Load → Verify Inventory & Room State (Container empty).
- **Journey_SaveLoad_PreservesTrauma:** Accrue stress → Save/Load → Verify Stress value.

### 6. Deliverable Checklist

- **Test Infrastructure:**
  - [ ] Update `TestHost` to support "rebooting" (re-initializing services against an existing DB)
  - [ ] Create `PersistenceJourneyTests.cs`
- **Engine Updates:**
  - [ ] Ensure `SaveManager` flushes all buffers to disk/DB immediately on save (critical for test reliability)
- **Scenarios:**
  - [ ] `Journey_SaveLoad_PreservesLocation`
  - [ ] `Journey_SaveLoad_PreservesLoot`
  - [ ] `Journey_SaveLoad_PreservesTrauma`

---

## Testing Strategy

### Unit Tests

| Test Class | Focus | Key Scenarios |
|------------|-------|---------------|
| ExplorationJourneyTests | Navigation, Interaction, Inventory | NewGame, Loot & Equip, Navigation Loop, Invalid Commands |
| CombatJourneyTests | Battle Resolution, Rewards | Victory Standard, Flee Success, Defeat Death |
| PersistenceJourneyTests | Save/Load Integrity | Preserve Location, Loot, Trauma |

### Integration Tests

| Scenario | Components | Validation |
|----------|------------|------------|
| Full Exploration Journey | ScriptedInputHandler, GameService, DungeonGenerator | Final room position, inventory state |
| Complete Combat Cycle | DiceService (seeded), CombatService, LootService | XP gained, loot received, HP reduced |
| Save/Load Cycle | SaveManager, PostgreSQL, TestHost (dual instance) | State equality across restart |

### Test Infrastructure

| Component | Purpose | Key Methods |
|-----------|---------|-------------|
| ScriptedInputHandler | Mock human input | `GetInput()`, `OutputBuffer` |
| TestGameHost | DI container wrapper | `Create(seed, script)`, `RunScript()` |
| PostgreSqlTestFixture | Real DB for persistence tests | `CreateDatabase()`, `ConnectionString` |

---

## Changelog: v0.3.12 - The Gauntlet

**Release Date:** TBD

### Summary

This release introduces **The Gauntlet**, an automated integration testing framework for Rune & Rust. By replacing human input with scripted command queues and seeding RNG systems for deterministic outcomes, we can now simulate full player sessions to verify that exploration, combat, and persistence systems work together without regression.

### Features

- **Automated Journeys:** The game can now be run in "Headless Mode" driven by command scripts.
- **Deterministic World Generation:** Added seeding support to `DungeonGenerator` and `LootService` for reproducible test worlds.
- **Deterministic Combat Testing:** Added ability to seed `DiceService` for reproducible combat outcomes.
- **Persistence Automation:** Integration tests now simulate full application shutdowns and restarts to verify save integrity.

### Technical Changes

- Added `ScriptedInputHandler` for test automation.
- Refactored `GameService` to accept `IInputHandler` injection for easier testing.
- Refactored `DiceService` to accept an optional seed in constructor.
- Refactored `TestHost` to support connecting to existing test databases.
- Hardened `SaveManager` JSON serialization to ensure deep object graphs are preserved.

### Test Coverage

- Added `ExplorationJourneyTests` covering creation, movement, and looting.
- Added `CombatJourneyTests` covering the full "Start → Fight → Win → Loot" loop.
- Added `PersistenceJourneyTests` covering the Save/Load loop.

---

*Generated by The Architect - Rune & Rust Development*
