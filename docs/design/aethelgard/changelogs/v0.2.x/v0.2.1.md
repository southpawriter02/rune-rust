# Changelog: v0.2.1 - The Gear, The Affliction, and The Visuals

**Versions:** v0.2.1a through v0.2.1c
**Release Dates:** 2025-12-19 (a), 2025-12-20 (b, c)

## Table of Contents

- [Overview](#overview)
- [Part A: The Gear (Equipment Integration)](#part-a-the-gear-equipment-integration)
  - [Summary](#summary)
  - [New Files Created](#new-files-created)
  - [Files Modified](#files-modified)
  - [Code Implementation Details](#code-implementation-details)
  - [Damage Calculation Examples](#damage-calculation-examples)
  - [Logging Matrix (v0.2.1a)](#logging-matrix-v021a)
  - [Test Coverage](#test-coverage)
  - [DI Registration Changes](#di-registration-changes)
  - [Build Verification](#build-verification)
  - [Directory Structure Changes](#directory-structure-changes)
  - [Breaking Changes](#breaking-changes)
  - [Running Tests](#running-tests)
  - [Test Summary by Category](#test-summary-by-category)
  - [Next Steps (v0.2.1b: The Data-Slate - Enemy AI)](#next-steps-v021b-the-data-slate---enemy-ai)
- [Part B: The Affliction (Status Effects)](#part-b-the-affliction-status-effects)
  - [Summary](#summary-1)
  - [Files Created](#files-created)
  - [Files Modified](#files-modified-1)
  - [Code Implementation Details](#code-implementation-details-1)
  - [Damage Calculation Examples](#damage-calculation-examples-1)
  - [Logging Matrix](#logging-matrix)
  - [Test Coverage](#test-coverage-1)
  - [DI Registration](#di-registration)
  - [Breaking Changes](#breaking-changes-1)
  - [Directory Structure Changes](#directory-structure-changes-1)
  - [Future Considerations](#future-considerations)
  - [Build Verification](#build-verification-1)
- [Part C: The Visuals (Combat UI Updates)](#part-c-the-visuals-combat-ui-updates)
  - [Summary](#summary-2)
  - [Files Created](#files-created-1)
  - [Files Modified](#files-modified-2)
  - [Code Implementation Details](#code-implementation-details-2)
  - [UI Examples](#ui-examples)
  - [Logging Matrix](#logging-matrix-1)
  - [Test Coverage](#test-coverage-2)
  - [DI Registration](#di-registration-1)
  - [Breaking Changes](#breaking-changes-2)
  - [Directory Structure Changes](#directory-structure-changes-2)
  - [Build Verification](#build-verification-2)
  - [Upgrade Notes](#upgrade-notes)
  - [Related Releases](#related-releases)

---

## Overview

Version 0.2.1 represents a three-part release cycle that transforms the combat system from a debug-mode prototype into a fully-featured tactical experience. This consolidated changelog documents the complete journey from equipment integration through status effects to UI visualization.

**Part A (The Gear)** connects the inventory system to combat, transitioning from hardcoded damage calculations to equipment-driven mechanics with weapon damage dice, armor soak, and post-combat loot generation.

**Part B (The Affliction)** introduces a comprehensive status effect system supporting damage-over-time effects (Bleeding, Poisoned), crowd control (Stunned), and combat stat modifiers (Vulnerable, Fortified).

**Part C (The Visuals)** updates the Terminal UI to display status effects in the turn order table and introduces a dedicated victory screen showing loot drops and XP rewards.

**Combined Impact:**
- Test Coverage: 1292 → 1343 tests (+51 tests)
- New Interfaces: 2 (IStatusEffectService, IVictoryScreenRenderer)
- New Models: 3 (CombatResult, ActiveStatusEffect, StatusEffectType enum)
- Breaking Changes: 3 constructor signatures (CombatService, AttackResolutionService, CommandParser)

---

## Part A: The Gear (Equipment Integration)

**Release Date:** 2025-12-19
**Total Tests:** 1292 (6 new tests, 5 updated tests)

### Summary

This release connects the inventory system to the combat engine, transitioning combat from "Debug Mode" (hardcoded damage dice and Sturdiness-based soak) to "Live Mode" (variable damage from equipped weapons and soak from armor). The implementation introduces equipment snapshotting on Combatant creation, refactors AttackResolutionService to use combatant-cached equipment stats, adds a CombatResult record for end-of-combat rewards, and integrates the LootService for victory loot generation. Key architectural changes include replacing the hardcoded `WeaponDice` dictionary with `Combatant.WeaponDamageDie`, changing soak calculation from `Sturdiness` attribute to `Combatant.ArmorSoak`, and transitioning attack types from die-size modifiers to flat damage bonuses (+0/+2/+4).

---

### New Files Created

#### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Combat/CombatResult.cs` | Record encapsulating combat outcome including victory state, XP earned, loot found, and summary message |

---

### Files Modified

#### Core Layer

| File | Change |
|------|--------|
| `RuneAndRust.Core/Entities/Enemy.cs` | Added equipment properties: `WeaponDamageDie` (default 4), `WeaponAccuracyBonus` (default 0), `ArmorSoak` (default 0), `WeaponName` (default "Claws") |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added equipment snapshot properties; updated `FromCharacter` factory to query equipped MainHand weapon and sum armor SoakBonus; updated `FromEnemy` factory to copy enemy equipment stats |
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Changed `EndCombat()` return type from `void` to `CombatResult?` |

#### Engine Layer

| File | Change |
|------|--------|
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `ILootService` dependency; implemented loot generation on victory in `EndCombat`; returns `CombatResult` with XP and loot |
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Replaced `WeaponDice` dictionary with `DamageBonuses`; refactored damage calculation to use `attacker.WeaponDamageDie` and `defender.ArmorSoak`; attack types now add damage bonuses instead of changing die size |

#### Test Layer

| File | Change |
|------|--------|
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `ILootService` mock to constructor with default `LootResult.Empty()` setup |
| `RuneAndRust.Tests/Engine/AttackResolutionServiceTests.cs` | Updated helper methods with equipment parameters; updated 5 damage/soak tests for new mechanics; added 3 new equipment integration tests |

---

### Code Implementation Details

#### CombatResult Record

**File:** `RuneAndRust.Core/Models/Combat/CombatResult.cs`

```csharp
public record CombatResult(
    bool Victory,
    int XpEarned,
    List<Item> LootFound,
    string Summary
);
```

**Properties:**
- `Victory`: Whether the player won the combat encounter
- `XpEarned`: Experience points earned (placeholder: 50 XP)
- `LootFound`: Items dropped by defeated enemies via LootService
- `Summary`: Human-readable outcome message

#### Enemy Equipment Properties

**File:** `RuneAndRust.Core/Entities/Enemy.cs`

```csharp
#region Equipment Stats (Snapshot for Combat)

public int WeaponDamageDie { get; set; } = 4;      // Default d4 (claws/unarmed)
public int WeaponAccuracyBonus { get; set; } = 0;
public int ArmorSoak { get; set; } = 0;
public string WeaponName { get; set; } = "Claws";

#endregion
```

**Purpose:** Provides equipment stats for enemy combatants without requiring the full Equipment entity system.

#### Combatant Equipment Snapshot

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

**New Properties:**
```csharp
#region Equipment Snapshot

public int WeaponDamageDie { get; set; } = 4;      // Default unarmed d4
public int WeaponAccuracyBonus { get; set; } = 0;
public int ArmorSoak { get; set; } = 0;
public string WeaponName { get; set; } = "Fists";

#endregion
```

**Updated FromCharacter Factory:**
```csharp
public static Combatant FromCharacter(CharacterEntity c)
{
    // Find equipped weapon (MainHand slot)
    var weapon = c.Inventory?
        .Where(i => i.IsEquipped && i.Item is Equipment eq && eq.Slot == EquipmentSlot.MainHand)
        .Select(i => i.Item as Equipment)
        .FirstOrDefault();

    // Calculate total soak from all equipped armor pieces
    var totalSoak = c.Inventory?
        .Where(i => i.IsEquipped && i.Item is Equipment)
        .Sum(i => ((Equipment)i.Item!).SoakBonus) ?? 0;

    return new Combatant
    {
        Name = c.Name,
        IsPlayer = true,
        CharacterSource = c,
        CurrentHp = c.CurrentHP,
        MaxHp = c.MaxHP,
        CurrentStamina = c.CurrentStamina,
        MaxStamina = c.MaxStamina,
        // Equipment snapshot
        WeaponDamageDie = weapon?.DamageDie ?? 4,
        WeaponAccuracyBonus = 0,
        ArmorSoak = totalSoak,
        WeaponName = weapon?.Name ?? "Fists"
    };
}
```

**Updated FromEnemy Factory:**
```csharp
public static Combatant FromEnemy(Enemy e) => new()
{
    Name = e.Name,
    IsPlayer = false,
    EnemySource = e,
    CurrentHp = e.CurrentHp,
    MaxHp = e.MaxHp,
    CurrentStamina = e.CurrentStamina,
    MaxStamina = e.MaxStamina,
    // Enemy equipment stats
    WeaponDamageDie = e.WeaponDamageDie,
    WeaponAccuracyBonus = e.WeaponAccuracyBonus,
    ArmorSoak = e.ArmorSoak,
    WeaponName = e.WeaponName
};
```

**Equipment Priority Logic:**
- Weapon: MainHand equipped item → Unarmed fallback (d4, "Fists")
- Armor Soak: Sum of all equipped items' SoakBonus

#### AttackResolutionService Refactoring

**File:** `RuneAndRust.Engine/Services/AttackResolutionService.cs`

**Old Configuration (Removed):**
```csharp
// REMOVED: Attack type determined weapon die
private static readonly Dictionary<AttackType, int> WeaponDice = new()
{
    { AttackType.Light, 4 },    // d4
    { AttackType.Standard, 6 }, // d6
    { AttackType.Heavy, 8 }     // d8
};
```

**New Configuration (Added):**
```csharp
// NEW: Attack type adds damage bonus
private static readonly Dictionary<AttackType, int> DamageBonuses = new()
{
    { AttackType.Light, 0 },    // No bonus
    { AttackType.Standard, 2 }, // +2 damage
    { AttackType.Heavy, 4 }     // +4 damage
};
```

**Updated Attack Type Properties:**

| Type | Stamina Cost | Weapon Die | Damage Bonus | Hit Modifier |
|------|--------------|------------|--------------|--------------|
| Light | 15 | From Combatant | +0 | +1 |
| Standard | 25 | From Combatant | +2 | 0 |
| Heavy | 40 | From Combatant | +4 | -1 |

**Updated Damage Calculation:**
```csharp
// Roll weapon damage using attacker's equipped weapon die
var weaponDamage = _dice.RollSingle(attacker.WeaponDamageDie,
    $"{attacker.Name} Weapon ({attacker.WeaponName})");

// Raw damage = Might + Weapon Roll + Attack Type Bonus
var damageBonus = DamageBonuses[attackType];
rawDamage = attacker.GetAttribute(CharacterAttribute.Might) + weaponDamage + damageBonus;

// Apply outcome modifiers (glancing halves, critical doubles)
rawDamage = ApplyDamageModifier(rawDamage, outcome);

// Calculate soak from defender's armor (was: Sturdiness attribute)
var soak = defender.ArmorSoak;

// Final damage (minimum 1 on hit)
finalDamage = Math.Max(1, rawDamage - soak);
```

**Damage Formula Comparison:**

| Version | Raw Damage Formula | Soak Source |
|---------|-------------------|-------------|
| v0.2.0b | `Might + WeaponDice[AttackType]` | `Sturdiness` attribute |
| v0.2.1a | `Might + WeaponDamageDie + DamageBonus[AttackType]` | `ArmorSoak` property |

#### CombatService EndCombat Update

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

**New Dependency:**
```csharp
private readonly ILootService _lootService;
```

**Updated EndCombat Implementation:**
```csharp
public CombatResult? EndCombat()
{
    if (_gameState.CombatState == null)
    {
        _logger.LogWarning("EndCombat called but no combat is active");
        return null;
    }

    var victory = CheckVictoryCondition();
    var loot = new List<Item>();
    var xp = 0;

    if (victory)
    {
        var character = _gameState.CurrentCharacter;
        var witsBonus = character?.GetEffectiveAttribute(CharacterAttribute.Wits) ?? 0;

        xp = 50; // Placeholder XP

        var lootContext = new LootGenerationContext(
            BiomeType: BiomeType.Industrial,
            DangerLevel: DangerLevel.Unstable,
            LootTier: null,
            WitsBonus: witsBonus
        );

        var lootResult = _lootService.GenerateLoot(lootContext);
        loot = lootResult.Items.ToList();

        _logger.LogInformation("Combat Victory! XP: {Xp}, Loot: {Count} items", xp, loot.Count);
    }

    _gameState.Phase = GamePhase.Exploration;
    _gameState.CombatState = null;

    return new CombatResult(
        Victory: victory,
        XpEarned: xp,
        LootFound: loot,
        Summary: victory ? "Victory! All enemies defeated." : "Combat ended."
    );
}
```

---

### Damage Calculation Examples

#### Example 1: Standard Attack with Equipped Sword (d6)

**Setup:**
- Attacker: Might 5, Sword (d6)
- Defender: ArmorSoak 2
- Attack Type: Standard (+2 damage bonus)
- Weapon Roll: 4

**Calculation:**
```
Raw = Might(5) + Weapon(4) + StandardBonus(2) = 11
Final = Max(1, 11 - 2) = 9 damage
```

#### Example 2: Heavy Attack with Greataxe (d8)

**Setup:**
- Attacker: Might 5, Greataxe (d8)
- Defender: ArmorSoak 5
- Attack Type: Heavy (+4 damage bonus)
- Weapon Roll: 6

**Calculation:**
```
Raw = Might(5) + Weapon(6) + HeavyBonus(4) = 15
Final = Max(1, 15 - 5) = 10 damage
```

#### Example 3: Unarmed Light Attack

**Setup:**
- Attacker: Might 3, Fists (d4)
- Defender: ArmorSoak 10
- Attack Type: Light (+0 damage bonus)
- Weapon Roll: 2

**Calculation:**
```
Raw = Might(3) + Weapon(2) + LightBonus(0) = 5
Final = Max(1, 5 - 10) = 1 damage (minimum enforced)
```

---

### Logging Matrix (v0.2.1a)

#### AttackResolutionService Logs

| Event | Level | Template |
|-------|-------|----------|
| Raw damage calculation | Debug | `"Raw damage: Might {Might} + {WeaponName} d{Die} ({Roll}) + Bonus {Bonus} = {Raw}"` |
| Soak application | Debug | `"Damage reduced by soak: {Raw} - {Soak} = {Final}"` |
| Minimum damage enforced | Debug | `"Minimum damage enforced: {Calculated} -> 1"` |

#### CombatService Logs

| Event | Level | Template |
|-------|-------|----------|
| Combat victory rewards | Information | `"Combat Victory! XP: {Xp}, Loot: {Count} items"` |
| EndCombat no combat | Warning | `"EndCombat called but no combat is active"` |
| EndCombat non-victory | Information | `"Combat Ended (non-victory)"` |

---

### Test Coverage

#### New Tests Added

##### AttackResolutionServiceTests - Equipment Integration (3 tests)

| Test Name | Description |
|-----------|-------------|
| `ResolveMeleeAttack_UsesAttackerWeaponDamageDie` | Validates d8 weapon uses d8 die, not default d6 |
| `ResolveMeleeAttack_AppliesDefenderArmorSoak` | Validates ArmorSoak reduces damage (11 - 10 = 1) |
| `ResolveMeleeAttack_SoakCannotReduceBelowOne` | Validates 100 soak still results in 1 minimum damage |

#### Updated Tests

##### AttackResolutionServiceTests - Updated for New Mechanics (5 tests)

| Test Name | Change |
|-----------|--------|
| `ResolveMeleeAttack_GlancingBlow_HalvesDamage` | Updated formula to include +2 standard bonus; expects 5 damage (was 4) |
| `ResolveMeleeAttack_SolidHit_FullDamage` | Updated to use ArmorSoak instead of Sturdiness; expects 9 damage (was 7) |
| `ResolveMeleeAttack_CriticalHit_DoublesDamage` | Updated with new damage formula; expects 20 damage (was 16) |
| `ResolveMeleeAttack_LightAttack_NoDamageBonus` (renamed) | Changed from `UsesD4AndBonusToHit`; now validates weapon die not attack type |
| `ResolveMeleeAttack_HeavyAttack_AddsDamageBonus` (renamed) | Changed from `UsesD8AndPenaltyToHit`; now validates +4 damage bonus |
| `ResolveMeleeAttack_StandardAttack_UsesWeaponDieAndDamageBonus` (renamed) | Changed from `UsesD6AndNoModifier`; now validates weapon die + +2 bonus |
| `ResolveMeleeAttack_ArmorSoakReducesDamage` (renamed) | Changed from `SoakReducesDamage`; uses ArmorSoak property |
| `ResolveMeleeAttack_MinimumOneDamage_WhenHit` | Updated to use ArmorSoak instead of Sturdiness |
| `ResolveMeleeAttack_LowMightWithHeavyPenalty_MinimumOneDie` | Updated to use ArmorSoak instead of Sturdiness |

#### Updated Helper Methods

```csharp
private static Combatant CreatePlayerCombatant(
    int might = 5,
    int finesse = 5,
    int sturdiness = 5,
    int stamina = 60,
    int weaponDamageDie = 6,    // NEW
    int armorSoak = 0,          // NEW
    string weaponName = "Sword" // NEW
)

private static Combatant CreateEnemyCombatant(
    int might = 5,
    int finesse = 3,
    int sturdiness = 5,
    int hp = 50,
    int stamina = 35,
    int weaponDamageDie = 4,    // NEW
    int armorSoak = 0,          // NEW
    string weaponName = "Claws" // NEW
)
```

---

### DI Registration Changes

**File:** `RuneAndRust.Terminal/Program.cs`

No new registrations required - `ILootService` was already registered in v0.1.2c.

---

### Build Verification

```
Build succeeded.
    0 Warning(s)
    0 Error(s)

Test run:
  Passed: 1292
  Failed: 0
  Skipped: 0
```

---

### Directory Structure Changes

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Entities/
│   │   └── Enemy.cs                         [MODIFIED - Equipment stats]
│   ├── Interfaces/
│   │   └── ICombatService.cs                [MODIFIED - EndCombat returns CombatResult]
│   └── Models/
│       └── Combat/
│           ├── Combatant.cs                 [MODIFIED - Equipment snapshot]
│           └── CombatResult.cs              [NEW]
├── RuneAndRust.Engine/
│   └── Services/
│       ├── AttackResolutionService.cs       [MODIFIED - Uses Combatant stats]
│       └── CombatService.cs                 [MODIFIED - LootService, EndCombat]
└── RuneAndRust.Tests/
    └── Engine/
        ├── AttackResolutionServiceTests.cs  [MODIFIED - Equipment tests]
        └── CombatServiceTests.cs            [MODIFIED - ILootService mock]
```

---

### Breaking Changes

#### ICombatService.EndCombat Signature

**Before:**
```csharp
void EndCombat();
```

**After:**
```csharp
CombatResult? EndCombat();
```

Consumers of `EndCombat()` must handle the new return type.

#### Damage Calculation Semantics

**Before (v0.2.0b):**
- Attack type determines weapon die (Light=d4, Standard=d6, Heavy=d8)
- Soak comes from Sturdiness attribute

**After (v0.2.1a):**
- Weapon die comes from `Combatant.WeaponDamageDie` (equipped weapon or default d4)
- Attack type adds flat damage bonus (Light=+0, Standard=+2, Heavy=+4)
- Soak comes from `Combatant.ArmorSoak` (sum of equipped armor SoakBonus)

---

### Running Tests

```bash
# Run all tests
dotnet test RuneAndRust.Tests

# Run only v0.2.1a affected tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~AttackResolutionServiceTests|FullyQualifiedName~CombatServiceTests"

# Run only equipment integration tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~Equipment"
```

---

### Test Summary by Category

| Category | Test Count |
|----------|------------|
| AttackResolutionServiceTests | 31 (3 new, 5 updated) |
| CombatServiceTests | 70 |
| Other combat tests | 101 (total combat-related) |
| Other tests | 1191 |
| **Total** | **1292** |

---

### Next Steps (v0.2.1b: The Data-Slate - Enemy AI)

Planned features for the next release:
- Enemy AI turn execution with attack selection
- Threat assessment for target selection
- Enemy attack type preference based on stamina
- Enemy turn messaging in combat log

---

## Part B: The Affliction (Status Effects)

**Release Date:** 2025-12-20
**Codename:** The Affliction
**Test Coverage:** 1327 tests passing
**Build Status:** SUCCESS

---

### Summary

This release implements a comprehensive status effect system for combat. The system supports damage-over-time effects (Bleeding, Poisoned), crowd control (Stunned), and stat modifiers (Vulnerable, Fortified). Effects integrate with the existing combat turn lifecycle and attack resolution system.

#### Key Features
- **7 Status Effect Types**: 4 debuffs (Bleeding, Poisoned, Stunned, Vulnerable) and 3 buffs (Fortified, Hasted, Inspired)
- **Stacking System**: Intensify stacking for DoT effects (up to 5 stacks) vs duration refresh for control effects
- **Turn Lifecycle Integration**: DoT damage at turn start, stun skip, duration decrement at turn end
- **Combat Stat Modifiers**: Fortified adds soak, Vulnerable amplifies damage taken
- **UI Display**: Status effect icons in combat view

#### Architectural Overview

```
┌─────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│   CombatService │────▶│  StatusEffectService │────▶│   Combatant         │
│   (NextTurn)    │     │  (ProcessTurnStart)  │     │   .StatusEffects[]  │
└─────────────────┘     └──────────────────────┘     └─────────────────────┘
         │                        │
         │                        ▼
         │              ┌──────────────────────┐
         │              │   AttackResolution   │
         │              │   (GetSoakModifier)  │
         └─────────────▶└──────────────────────┘
```

---

### Files Created

| File Path | Description |
|-----------|-------------|
| `RuneAndRust.Core/Enums/StatusEffectType.cs` | Enum defining 7 status effect types (debuffs 0-99, buffs 100+) |
| `RuneAndRust.Core/Models/Combat/ActiveStatusEffect.cs` | Model tracking effect state: type, stacks, duration, source |
| `RuneAndRust.Core/Interfaces/IStatusEffectService.cs` | Service contract with 11 methods for effect lifecycle |
| `RuneAndRust.Engine/Services/StatusEffectService.cs` | Full implementation with Serilog logging |
| `RuneAndRust.Tests/Engine/StatusEffectServiceTests.cs` | 35 unit and integration tests |

---

### Files Modified

| File Path | Changes |
|-----------|---------|
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Added `StatusEffects` list property for combat-volatile effect tracking |
| `RuneAndRust.Engine/Services/CombatService.cs` | Added `IStatusEffectService` dependency; integrated DoT damage, stun check, and duration processing into turn lifecycle; updated `MapToView` for effect display |
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Added `IStatusEffectService` dependency; integrated soak modifier (Fortified) and damage multiplier (Vulnerable) into damage calculation |
| `RuneAndRust.Terminal/Program.cs` | Registered `IStatusEffectService` and `ILootService` in DI container |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Added `IStatusEffectService` mock with default behavior |
| `RuneAndRust.Tests/Engine/AttackResolutionServiceTests.cs` | Added `IStatusEffectService` mock with default behavior |

---

### Code Implementation Details

#### StatusEffectType Enum

```csharp
public enum StatusEffectType
{
    // Debuffs (0-99)
    Bleeding = 0,    // Physical DoT, ignores soak, stacks to 5
    Poisoned = 1,    // Poison DoT, applies soak, stacks to 5
    Stunned = 2,     // Skip turn, no stacking
    Vulnerable = 3,  // +50% damage taken

    // Buffs (100+)
    Fortified = 100, // +2 soak per stack
    Hasted = 101,    // Future: extra action
    Inspired = 102   // Future: +1 damage die
}
```

#### ActiveStatusEffect Model

```csharp
public class ActiveStatusEffect
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public StatusEffectType Type { get; set; }
    public int Stacks { get; set; } = 1;
    public int DurationRemaining { get; set; }
    public Guid SourceId { get; set; }

    public static int GetMaxStacks(StatusEffectType type) => type switch
    {
        StatusEffectType.Bleeding => 5,
        StatusEffectType.Poisoned => 5,
        StatusEffectType.Fortified => 5,
        _ => 1
    };

    public static bool CanStack(StatusEffectType type) => type switch
    {
        StatusEffectType.Bleeding => true,
        StatusEffectType.Poisoned => true,
        StatusEffectType.Fortified => true,
        _ => false
    };
}
```

#### IStatusEffectService Interface

```csharp
public interface IStatusEffectService
{
    void ApplyEffect(Combatant target, StatusEffectType type, int duration, Guid sourceId);
    void RemoveEffect(Combatant target, StatusEffectType type);
    void ClearAllEffects(Combatant target);
    int ProcessTurnStart(Combatant combatant);
    bool CanAct(Combatant combatant);
    void ProcessTurnEnd(Combatant combatant);
    int GetSoakModifier(Combatant combatant);
    float GetDamageMultiplier(Combatant combatant);
    IReadOnlyList<ActiveStatusEffect> GetActiveEffects(Combatant combatant);
    bool HasEffect(Combatant combatant, StatusEffectType type);
    int GetEffectStacks(Combatant combatant, StatusEffectType type);
}
```

#### StatusEffectService Implementation Highlights

##### Effect Application with Stacking Logic

```csharp
public void ApplyEffect(Combatant target, StatusEffectType type, int duration, Guid sourceId)
{
    var existing = target.StatusEffects.FirstOrDefault(e => e.Type == type);

    if (existing != null)
    {
        if (ActiveStatusEffect.CanStack(type))
        {
            var maxStacks = ActiveStatusEffect.GetMaxStacks(type);
            if (existing.Stacks < maxStacks)
            {
                existing.Stacks++;
            }
            existing.DurationRemaining = duration;
        }
        else
        {
            existing.DurationRemaining = duration;
        }
    }
    else
    {
        target.StatusEffects.Add(new ActiveStatusEffect
        {
            Type = type,
            Stacks = 1,
            DurationRemaining = duration,
            SourceId = sourceId
        });
    }
}
```

##### DoT Processing at Turn Start

```csharp
public int ProcessTurnStart(Combatant combatant)
{
    var totalDamage = 0;

    // Bleeding: ignores soak
    var bleeding = combatant.StatusEffects.FirstOrDefault(e => e.Type == StatusEffectType.Bleeding);
    if (bleeding != null)
    {
        var damage = 0;
        for (var i = 0; i < bleeding.Stacks; i++)
        {
            damage += _dice.RollSingle(6, $"Bleeding Tick ({i + 1}/{bleeding.Stacks})");
        }
        totalDamage += damage;
    }

    // Poisoned: applies soak
    var poisoned = combatant.StatusEffects.FirstOrDefault(e => e.Type == StatusEffectType.Poisoned);
    if (poisoned != null)
    {
        var rawDamage = 0;
        for (var i = 0; i < poisoned.Stacks; i++)
        {
            rawDamage += _dice.RollSingle(6, $"Poison Tick ({i + 1}/{poisoned.Stacks})");
        }
        var soak = combatant.ArmorSoak + GetSoakModifier(combatant);
        var finalDamage = rawDamage > 0 ? Math.Max(1, rawDamage - soak) : 0;
        totalDamage += finalDamage;
    }

    return totalDamage;
}
```

#### CombatService NextTurn Integration

```csharp
public void NextTurn()
{
    // ... existing validation and turn index logic ...

    var active = state.ActiveCombatant;
    if (active != null)
    {
        // Process turn start: apply DoT damage
        var dotDamage = _statusEffects.ProcessTurnStart(active);
        if (dotDamage > 0)
        {
            active.CurrentHp -= dotDamage;
            LogCombatEvent($"[yellow]{active.Name}[/] takes [red]{dotDamage}[/] damage from status effects!");

            if (active.CurrentHp <= 0)
            {
                LogCombatEvent($"[red]{active.Name}[/] has fallen to their wounds!");
                RemoveDefeatedCombatant(active);
                if (CheckVictoryCondition()) return;
                NextTurn();
                return;
            }
        }

        // Check if stunned
        if (!_statusEffects.CanAct(active))
        {
            LogCombatEvent($"[yellow]{active.Name}[/] is [purple]stunned[/] and loses their turn!");
            _statusEffects.ProcessTurnEnd(active);
            NextTurn();
            return;
        }
    }
}
```

#### AttackResolutionService Damage Calculation

```csharp
// Apply damage multiplier from status effects (e.g., Vulnerable)
var damageMultiplier = _statusEffects.GetDamageMultiplier(defender);
var modifiedDamage = (int)(rawDamage * damageMultiplier);

// Calculate soak from defender's armor + status effects (e.g., Fortified)
var baseSoak = defender.ArmorSoak;
var soakModifier = _statusEffects.GetSoakModifier(defender);
var totalSoak = baseSoak + soakModifier;

// Final damage (minimum 1 on hit)
finalDamage = Math.Max(1, modifiedDamage - totalSoak);
```

#### Combat UI Status Effect Display

```csharp
var effectIcons = string.Join(" ", combatant.StatusEffects.Select(e => e.Type switch
{
    StatusEffectType.Bleeding => $"[red]BLD×{e.Stacks}[/]",
    StatusEffectType.Poisoned => $"[green]PSN×{e.Stacks}[/]",
    StatusEffectType.Stunned => "[purple]STUN[/]",
    StatusEffectType.Vulnerable => "[orange1]VULN[/]",
    StatusEffectType.Fortified => $"[blue]FRT×{e.Stacks}[/]",
    StatusEffectType.Hasted => "[cyan]HAST[/]",
    StatusEffectType.Inspired => "[yellow]INSP[/]",
    _ => ""
}));
```

---

### Damage Calculation Examples

#### Example 1: Bleeding DoT (3 Stacks)

```
Turn Start:
  Bleeding Stacks: 3
  Dice Rolls: d6=4, d6=3, d6=5
  Total Damage: 4 + 3 + 5 = 12 (ignores soak)
```

#### Example 2: Poisoned DoT with Soak

```
Turn Start:
  Poisoned Stacks: 2
  Dice Rolls: d6=5, d6=4
  Raw Damage: 9
  Armor Soak: 3
  Final Damage: max(1, 9 - 3) = 6
```

#### Example 3: Vulnerable Target Taking Attack

```
Attack Resolution:
  Raw Damage: 10
  Vulnerable Multiplier: 1.5
  Modified Damage: 10 × 1.5 = 15
  Defender Soak: 4
  Final Damage: max(1, 15 - 4) = 11
```

#### Example 4: Fortified Defender

```
Attack Resolution:
  Raw Damage: 8
  Defender Armor Soak: 2
  Fortified Stacks: 3
  Fortified Bonus: 3 × 2 = +6
  Total Soak: 2 + 6 = 8
  Final Damage: max(1, 8 - 8) = 1 (minimum)
```

---

### Logging Matrix

| Event | Level | Template |
|-------|-------|----------|
| Effect applied | Information | `"Applied {Type} to {Target} (Stacks: {Stacks}, Duration: {Duration})"` |
| Effect stacked | Debug | `"Stacked {Type} on {Target}: {OldStacks} -> {NewStacks}"` |
| Effect refreshed | Debug | `"Refreshed {Type} duration on {Target}: {Duration} turns"` |
| DoT tick | Information | `"{Target} takes {Damage} {Type} damage (Stacks: {Stacks})"` |
| DoT soak applied | Debug | `"Poisoned damage reduced by soak: {Raw} - {Soak} = {Final}"` |
| Effect expired | Information | `"{Type} expired on {Target}"` |
| Turn skipped | Information | `"{Target} is stunned and loses their turn"` |
| Soak modifier | Debug | `"Soak modifier for {Target}: +{Modifier} from Fortified (×{Stacks})"` |
| Damage multiplier | Debug | `"Damage multiplier for {Target}: ×{Multiplier} from Vulnerable"` |

---

### Test Coverage

#### StatusEffectServiceTests.cs (35 tests)

##### Apply Effect Tests
- `ApplyEffect_NewEffect_AddsToList`
- `ApplyEffect_StackableEffect_IncreasesStacks`
- `ApplyEffect_AtMaxStacks_RefreshesDurationOnly`
- `ApplyEffect_NonStackable_RefreshesDurationOnly`
- `ApplyEffect_DifferentTypes_AddsSeparateEffects`
- `ApplyEffect_Fortified_StacksCorrectly`

##### Remove Effect Tests
- `RemoveEffect_ExistingEffect_RemovesFromList`
- `RemoveEffect_NonExistentEffect_NoException`
- `ClearAllEffects_RemovesAllEffects`

##### DoT Processing Tests
- `ProcessTurnStart_Bleeding_DealsDamage`
- `ProcessTurnStart_BleedingMultiStack_MultipliesDamage`
- `ProcessTurnStart_Poisoned_AppliesSoak`
- `ProcessTurnStart_PoisonedWithHighSoak_MinimumOneDamage`
- `ProcessTurnStart_NoDoTEffects_ReturnsZero`
- `ProcessTurnStart_BleedingAndPoisoned_DealsCombinedDamage`

##### Can Act Tests
- `CanAct_WhenStunned_ReturnsFalse`
- `CanAct_WhenNotStunned_ReturnsTrue`
- `CanAct_NoEffects_ReturnsTrue`

##### Turn End Tests
- `ProcessTurnEnd_DecrementsAllDurations`
- `ProcessTurnEnd_RemovesExpiredEffects`
- `ProcessTurnEnd_AllEffectsExpire_ListBecomesEmpty`
- `ProcessTurnEnd_NoEffects_NoException`

##### Modifier Tests
- `GetSoakModifier_NoFortified_ReturnsZero`
- `GetSoakModifier_Fortified_ReturnsStackBonus`
- `GetSoakModifier_FortifiedMultiStack_ReturnsScaledBonus`
- `GetDamageMultiplier_NoVulnerable_ReturnsOne`
- `GetDamageMultiplier_Vulnerable_ReturnsOnePointFive`

##### Query Tests
- `HasEffect_WithEffect_ReturnsTrue`
- `HasEffect_WithoutEffect_ReturnsFalse`
- `GetEffectStacks_ExistingEffect_ReturnsStackCount`
- `GetEffectStacks_NoEffect_ReturnsZero`
- `GetActiveEffects_ReturnsReadOnlyList`

##### Integration Tests
- `Integration_StunLoop_ProcessesCorrectly`
- `Integration_BleedDeath_AccumulatesDamage`
- `Integration_FortifiedPoisoned_SoakApplies`

---

### DI Registration

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<IStatusEffectService, StatusEffectService>();  // NEW
services.AddSingleton<IAttackResolutionService, AttackResolutionService>();
services.AddScoped<ILootService, LootService>();
services.AddSingleton<ICombatService, CombatService>();
services.AddSingleton<ICombatScreenRenderer, CombatScreenRenderer>();
```

---

### Breaking Changes

#### Constructor Signature Changes

**CombatService** - Added `IStatusEffectService` parameter:
```csharp
// Before
public CombatService(GameState, IInitiativeService, IAttackResolutionService, ILootService, ILogger<CombatService>)

// After
public CombatService(GameState, IInitiativeService, IAttackResolutionService, ILootService, IStatusEffectService, ILogger<CombatService>)
```

**AttackResolutionService** - Added `IStatusEffectService` parameter:
```csharp
// Before
public AttackResolutionService(IDiceService, ILogger<AttackResolutionService>)

// After
public AttackResolutionService(IDiceService, IStatusEffectService, ILogger<AttackResolutionService>)
```

---

### Directory Structure Changes

```
RuneAndRust.Core/
├── Enums/
│   ├── StatusEffectType.cs          [NEW]
│   ├── AttackType.cs
│   └── AttackOutcome.cs
├── Models/Combat/
│   ├── ActiveStatusEffect.cs        [NEW]
│   ├── Combatant.cs                 [MODIFIED - StatusEffects list]
│   ├── CombatState.cs
│   ├── CombatResult.cs
│   └── AttackResult.cs
└── Interfaces/
    ├── IStatusEffectService.cs      [NEW]
    ├── ICombatService.cs
    └── IAttackResolutionService.cs

RuneAndRust.Engine/Services/
├── StatusEffectService.cs           [NEW]
├── CombatService.cs                 [MODIFIED - status integration]
└── AttackResolutionService.cs       [MODIFIED - modifier queries]

RuneAndRust.Tests/Engine/
├── StatusEffectServiceTests.cs      [NEW - 35 tests]
├── CombatServiceTests.cs            [MODIFIED - mock setup]
└── AttackResolutionServiceTests.cs  [MODIFIED - mock setup]
```

---

### Future Considerations

#### Reserved Effect Types (Not Yet Implemented)
- **Hasted**: Extra action per turn
- **Inspired**: +1 bonus die to damage rolls

#### Potential Expansions
- Effect immunity system (e.g., Skeleton vs Bleeding)
- Effect stacking from multiple sources
- Effect dispel/cleanse mechanics
- Status effect triggers from weapon enchantments

---

### Build Verification

```bash
$ dotnet build
Build succeeded.
63 Warning(s) - Pre-existing xUnit async warnings
0 Error(s)

$ dotnet test
Passed!  - Failed: 0, Passed: 1327, Skipped: 0, Total: 1327, Duration: 560 ms
```

---

**v0.2.1b Codename: The Affliction**
*"Wounds that fester, poisons that spread, and the cold grip of paralysis."*

---

## Part C: The Visuals (Combat UI Updates)

**Release Date:** 2025-12-20
**Codename:** The Visuals
**Test Coverage:** 1343 tests passing (+16 from v0.2.1b)
**Build Status:** SUCCESS

---

### Summary

This release updates the Terminal UI to visualize the mechanics introduced in v0.2.1a (Equipment/Loot) and v0.2.1b (Status Effects). The combat turn order table now displays a Status column showing active debuffs and buffs. A new VictoryScreen displays loot drops and XP rewards after successful combat before returning to exploration mode.

#### Key Features
- **Status Column in Combat**: 4th column in turn order table showing effect icons (BLD, PSN, STUN, VULN, FRT, HAST, INSP)
- **Victory Screen**: Dedicated post-combat screen displaying XP earned and loot found
- **Quality-Based Loot Coloring**: Items colored by quality tier (grey→white→green→blue→magenta)
- **Seamless Integration**: Victory screen triggers automatically on combat victory

#### Architectural Overview

```
┌─────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│   GameService   │────▶│   CommandParser      │────▶│   CombatService     │
│   (Game Loop)   │     │   (ExecuteAttack)    │     │   (EndCombat)       │
└─────────────────┘     └──────────────────────┘     └─────────────────────┘
         │                        │                            │
         ▼                        ▼                            ▼
┌─────────────────┐     ┌──────────────────────┐     ┌─────────────────────┐
│ CombatScreen    │     │  VictoryScreen       │     │   CombatResult      │
│ Renderer        │     │  Renderer            │◄────│   (Victory/Loot)    │
│ (+Status Col)   │     │  (Loot + XP)         │     └─────────────────────┘
└─────────────────┘     └──────────────────────┘
```

---

### Files Created

| File Path | Description |
|-----------|-------------|
| `RuneAndRust.Core/Interfaces/IVictoryScreenRenderer.cs` | Interface defining the victory screen contract |
| `RuneAndRust.Terminal/Services/VictoryScreenRenderer.cs` | Implementation rendering loot/XP with Spectre.Console |
| `RuneAndRust.Tests/Terminal/VictoryScreenRendererTests.cs` | 16 unit tests for color mapping and validation |

---

### Files Modified

| File Path | Changes |
|-----------|---------|
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Added "Status" column to `RenderTurnOrder` table |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `IVictoryScreenRenderer` field and constructor parameter; triggers victory screen on combat end |
| `RuneAndRust.Terminal/Program.cs` | Registered `IVictoryScreenRenderer` in DI container |
| `RuneAndRust.Tests/RuneAndRust.Tests.csproj` | Added project reference to `RuneAndRust.Terminal` |

---

### Code Implementation Details

#### IVictoryScreenRenderer Interface

```csharp
namespace RuneAndRust.Core.Interfaces;

using RuneAndRust.Core.Models.Combat;

/// <summary>
/// Defines the contract for rendering the post-combat victory screen.
/// </summary>
public interface IVictoryScreenRenderer
{
    /// <summary>
    /// Renders the victory screen with loot and XP rewards.
    /// Blocks until the player acknowledges the screen.
    /// </summary>
    void Render(CombatResult result);
}
```

#### VictoryScreenRenderer Implementation

```csharp
public class VictoryScreenRenderer : IVictoryScreenRenderer
{
    private readonly ILogger<VictoryScreenRenderer> _logger;

    public void Render(CombatResult result)
    {
        _logger.LogInformation(
            "Rendering victory screen. Victory: {Victory}, XP: {Xp}, Loot: {Count}",
            result.Victory, result.XpEarned, result.LootFound.Count);

        AnsiConsole.Clear();

        // Victory Banner
        RenderVictoryBanner();

        // XP Earned
        RenderXpSection(result.XpEarned);

        // Loot Table
        if (result.LootFound.Count > 0)
        {
            RenderLootTable(result.LootFound);
        }
        else
        {
            AnsiConsole.MarkupLine("\n[grey]No loot found.[/]");
        }

        // Continue prompt
        AnsiConsole.MarkupLine("[grey]Press any key to continue...[/]");
        Console.ReadKey(true);

        _logger.LogTrace("Victory screen rendered and dismissed");
    }
}
```

#### Quality Tier Color Mapping

```csharp
public static string GetQualityColor(QualityTier quality) => quality switch
{
    QualityTier.JuryRigged => "grey",    // Lowest tier - scrap
    QualityTier.Scavenged => "white",    // Common finds
    QualityTier.ClanForged => "green",   // Quality crafted
    QualityTier.Optimized => "blue",     // Rare/enhanced
    QualityTier.MythForged => "magenta", // Legendary tier
    _ => "white"
};
```

#### Updated RenderTurnOrder with Status Column

```csharp
private static void RenderTurnOrder(List<CombatantView> turnOrder)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .BorderColor(Color.Grey)
        .Expand();

    table.AddColumn(new TableColumn("[grey]Init[/]").Centered().Width(6));
    table.AddColumn(new TableColumn("[grey]Name[/]").Width(20));
    table.AddColumn(new TableColumn("[grey]Condition[/]").Width(12));
    table.AddColumn(new TableColumn("[grey]Status[/]").Width(18));  // NEW

    foreach (var combatant in turnOrder)
    {
        var turnMarker = combatant.IsActive ? "[bold yellow]>[/] " : "  ";
        var nameColor = combatant.IsPlayer ? "cyan" : "red";
        var nameMarkup = $"{turnMarker}[{nameColor}]{EscapeMarkup(combatant.Name)}[/]";

        var healthDisplay = combatant.IsPlayer
            ? $"[green]{combatant.HealthStatus}[/]"
            : combatant.HealthStatus;

        // StatusEffects already contain Spectre markup from MapToView
        var statusDisplay = combatant.StatusEffects;

        table.AddRow(
            $"[grey]{combatant.InitiativeDisplay}[/]",
            nameMarkup,
            healthDisplay,
            statusDisplay  // NEW
        );
    }

    AnsiConsole.Write(table);
}
```

#### CommandParser Victory Screen Integration

```csharp
// Field
private readonly IVictoryScreenRenderer? _victoryRenderer;

// Constructor
public CommandParser(
    ILogger<CommandParser> logger,
    IInputHandler inputHandler,
    GameState gameState,
    IJournalService? journalService = null,
    ICombatService? combatService = null,
    IVictoryScreenRenderer? victoryRenderer = null)  // NEW
{
    // ... existing assignments ...
    _victoryRenderer = victoryRenderer;
}

// ExecuteCombatAttack victory handling
if (_gameState.CombatState == null || _combatService.CheckVictoryCondition())
{
    var combatResult = _combatService.EndCombat();

    // Display victory screen with loot/XP if victory and renderer available
    if (combatResult != null && combatResult.Victory && _victoryRenderer != null)
    {
        _victoryRenderer.Render(combatResult);
    }
    else
    {
        _inputHandler.DisplayMessage("");
        _inputHandler.DisplayMessage("Combat has ended. Returning to exploration.");
    }

    return new ParseResult { RequiresLook = true };
}
```

---

### UI Examples

#### Combat Turn Order Table (with Status Column)

```
╭──────┬──────────────────────┬──────────────┬──────────────────╮
│ Init │ Name                 │ Condition    │ Status           │
├──────┼──────────────────────┼──────────────┼──────────────────┤
│  18  │ > Player             │ Healthy      │ FRT×2            │
│  15  │   Goblin Warrior     │ Wounded      │ BLD×3            │
│  12  │   Rusty Automaton    │ Critical     │ PSN×1 VULN       │
╰──────┴──────────────────────┴──────────────┴──────────────────╯
```

#### Victory Screen

```
────────────────────── VICTORY ──────────────────────

  Experience Earned: +75 XP

  Loot Found:

╭─────────────────────────┬────────────┬──────────┬────────╮
│ Item                    │ Quality    │ Type     │ Value  │
├─────────────────────────┼────────────┼──────────┼────────┤
│ Rusty Iron Sword        │ JuryRigged │ Weapon   │   15   │
│ Clan-Forged Shield      │ ClanForged │ Armor    │   45   │
│ Blight-Touched Amulet   │ Optimized  │ Trinket  │   80   │
╰─────────────────────────┴────────────┴──────────┴────────╯

Press any key to continue...
```

---

### Logging Matrix

| Event | Level | Template |
|-------|-------|----------|
| Victory screen start | Information | `"Rendering victory screen. Victory: {Victory}, XP: {Xp}, Loot: {Count}"` |
| Loot item rendered | Debug | `"Rendered loot: {Name} ({Quality})"` |
| Screen dismissed | Trace | `"Victory screen rendered and dismissed"` |
| Combat screen render | Trace | `"Rendered combat screen"` |

---

### Test Coverage

#### VictoryScreenRendererTests.cs (16 tests)

##### GetQualityColor Tests
- `GetQualityColor_JuryRigged_ReturnsGrey`
- `GetQualityColor_Scavenged_ReturnsWhite`
- `GetQualityColor_ClanForged_ReturnsGreen`
- `GetQualityColor_Optimized_ReturnsBlue`
- `GetQualityColor_MythForged_ReturnsMagenta`
- `GetQualityColor_UndefinedValue_ReturnsWhite`
- `GetQualityColor_AllTiers_ReturnExpectedColors` (Theory with 5 cases)

##### Constructor Tests
- `Constructor_WithValidLogger_CreatesInstance`

##### CombatResult Validation Tests
- `CombatResult_WithEmptyLoot_IsValid`
- `CombatResult_WithLoot_ContainsItems`

##### Color Consistency Tests
- `GetQualityColor_SameTier_ReturnsSameColor`
- `GetQualityColor_DifferentTiers_ReturnDifferentColors`

---

### DI Registration

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<IStatusEffectService, StatusEffectService>();
services.AddSingleton<IAttackResolutionService, AttackResolutionService>();
services.AddScoped<ILootService, LootService>();
services.AddSingleton<ICombatService, CombatService>();
services.AddSingleton<ICombatScreenRenderer, CombatScreenRenderer>();
services.AddSingleton<IVictoryScreenRenderer, VictoryScreenRenderer>();  // NEW
```

---

### Breaking Changes

#### Constructor Signature Changes

**CommandParser** - Added `IVictoryScreenRenderer` parameter:
```csharp
// Before
public CommandParser(
    ILogger<CommandParser> logger,
    IInputHandler inputHandler,
    GameState gameState,
    IJournalService? journalService = null,
    ICombatService? combatService = null)

// After
public CommandParser(
    ILogger<CommandParser> logger,
    IInputHandler inputHandler,
    GameState gameState,
    IJournalService? journalService = null,
    ICombatService? combatService = null,
    IVictoryScreenRenderer? victoryRenderer = null)  // NEW
```

---

### Directory Structure Changes

```
RuneAndRust.Core/Interfaces/
├── IVictoryScreenRenderer.cs          [NEW]
├── ICombatScreenRenderer.cs
├── ICombatService.cs
└── ...

RuneAndRust.Terminal/Services/
├── VictoryScreenRenderer.cs           [NEW]
├── CombatScreenRenderer.cs            [MODIFIED - Status column]
├── TerminalInputHandler.cs
└── ...

RuneAndRust.Engine/Services/
├── CommandParser.cs                   [MODIFIED - Victory trigger]
├── CombatService.cs
└── ...

RuneAndRust.Tests/
├── Terminal/                          [NEW FOLDER]
│   └── VictoryScreenRendererTests.cs  [NEW - 16 tests]
├── Engine/
└── ...
```

---

### Build Verification

```bash
$ dotnet build
Build succeeded.
63 Warning(s) - Pre-existing xUnit async warnings
0 Error(s)

$ dotnet test
Passed!  - Failed: 0, Passed: 1343, Skipped: 0, Total: 1343, Duration: 573 ms
```

---

### Upgrade Notes

1. **DI Container**: If manually constructing `CommandParser`, add the optional `IVictoryScreenRenderer` parameter or pass `null`.

2. **Test Projects**: Add project reference to `RuneAndRust.Terminal` if testing Terminal components:
   ```xml
   <ProjectReference Include="..\RuneAndRust.Terminal\RuneAndRust.Terminal.csproj" />
   ```

3. **Combat Flow**: Victory screen now displays automatically after defeating all enemies. No action required from calling code.

---

### Related Releases

- **v0.2.1a** (The Armory): Equipment and Loot systems
- **v0.2.1b** (The Affliction): Status Effect system
- **v0.2.1c** (The Visuals): UI display for both systems

---

**v0.2.1c Codename: The Visuals**
*"See the battle unfold. Watch the loot gleam."*
