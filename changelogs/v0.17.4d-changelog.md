# Changelog: v0.17.4d - Specialization Provider Service

**Release Date:** 2026-01-30
**Phase:** Specialization System (4/5)
**Status:** Complete

---

## Overview

Implements the `ISpecializationProvider` interface and `SpecializationProvider` service, providing the infrastructure for loading, caching, and querying all 17 specialization definitions from `specializations.json`. The provider uses lazy initialization with double-checked locking, multiple O(1) lookup dictionaries, and pre-filtered caches for efficient access by specialization ID, archetype, path type, and special resource. A complete set of configuration DTOs maps the JSON structure to domain entities.

This phase builds on v0.17.4a-c (enums, definitions, ability tiers) to establish the data access layer for specialization data, enabling the application service in v0.17.4e and the character creation workflow in v0.17.5.

**Provider Cache Structure:**

| Cache | Type | Lookup | Contents |
| --- | --- | --- | --- |
| `_byId` | `Dictionary<SpecializationId, SpecializationDefinition>` | O(1) | All 17 definitions |
| `_byArchetype` | `Dictionary<Archetype, List<SpecializationDefinition>>` | O(1) | Grouped by parent archetype |
| `_heretical` | `List<SpecializationDefinition>` | O(1) | 5 Heretical specializations |
| `_coherent` | `List<SpecializationDefinition>` | O(1) | 12 Coherent specializations |
| `_withSpecialResource` | `List<SpecializationDefinition>` | O(1) | 5 with special resources |
| `_all` | `List<SpecializationDefinition>` | O(1) | Complete list of 17 |

---

## Added

### Application Layer

#### Interfaces

- **`ISpecializationProvider`** (`Interfaces/ISpecializationProvider.cs`)
    - `public interface` with 9 members:
        - `GetBySpecializationId(SpecializationId)` → `SpecializationDefinition?`: O(1) dictionary lookup
        - `GetByArchetype(Archetype)` → `IReadOnlyList<SpecializationDefinition>`: O(1) pre-grouped lookup
        - `GetHereticalSpecializations()` → `IReadOnlyList<SpecializationDefinition>`: Cached 5 Heretical
        - `GetCoherentSpecializations()` → `IReadOnlyList<SpecializationDefinition>`: Cached 12 Coherent
        - `GetAll()` → `IReadOnlyList<SpecializationDefinition>`: All 17 definitions
        - `Count` → `int`: Total loaded count (17)
        - `Exists(SpecializationId)` → `bool`: Existence check
        - `GetWithSpecialResource()` → `IReadOnlyList<SpecializationDefinition>`: Cached 5 with resources
        - `GetAbility(string abilityId)` → `(SpecializationDefinition, SpecializationAbility)?`: Cross-specialization ability lookup
    - Comprehensive XML documentation with `<summary>`, `<param>`, `<returns>`, `<remarks>`, `<example>`, `<seealso>`
    - Cross-references to `SpecializationDefinition`, `SpecializationAbilityTier`, `SpecializationAbility`, `SpecialResourceDefinition`

#### DTOs

- **`SpecializationsConfigDto`** (`DTOs/SpecializationConfigDto.cs`) — 6 DTO classes:
    - `SpecializationsConfigDto`: Root DTO with `Schema`, `PathTypes`, `Definitions` properties
    - `SpecializationPathTypeEntryDto`: Maps `pathTypes` array entries (SpecializationId, PathType, CorruptionRisk)
    - `SpecializationDefinitionDto`: Maps definition entries (10 properties including nested SpecialResource and AbilityTiers)
    - `SpecialResourceDto`: Maps optional special resource sub-object (8 properties)
    - `AbilityTierDto`: Maps ability tier sub-object (6 properties including nested Abilities list)
    - `SpecializationAbilityDto`: Maps individual ability entries (8 properties)
    - All properties auto-initialize with defaults for safe JSON deserialization
    - Full XML documentation on all classes and properties

#### Exceptions

- **`SpecializationConfigurationException`** (`Exceptions/SpecializationConfigurationException.cs`)
    - `public class` extending `Exception` with 2 constructors
    - Thrown by `SpecializationProvider` on configuration loading or validation failure
    - XML documentation listing all potential failure causes
    - Pattern matches `ArchetypeConfigurationException`, `LineageConfigurationException`, etc.

### Infrastructure Layer

#### Services

- **`SpecializationProvider`** (`Services/SpecializationProvider.cs`)
    - `public class SpecializationProvider : ISpecializationProvider`
    - Constructor: `(ILogger<SpecializationProvider> logger, string? configPath = null)`
    - Default config path: `"config/specializations.json"`
    - Lazy initialization with double-checked locking (`EnsureInitialized()` pattern)
    - 6 private cache dictionaries/lists populated on first access
    - Private methods:
        - `EnsureInitialized()` — Thread-safe initialization with double-checked locking
        - `LoadConfiguration()` — File.Exists check, File.ReadAllText, JsonSerializer.Deserialize with PropertyNameCaseInsensitive
        - `ValidateConfiguration()` — Validates 17 definitions, enum parsing, duplicates, missing specializations
        - `BuildCache()` — Iterates definitions, maps each to domain entity, registers in all caches
        - `MapToDefinition()` — Enum.Parse for SpecializationId/Archetype/PathType, maps special resource and ability tiers
        - `MapSpecialResource()` — Maps SpecialResourceDto to SpecialResourceDefinition.Create()
        - `MapAbilityTiers()` — Maps AbilityTierDto list to SpecializationAbilityTier.Create() list
        - `MapAbilities()` — Maps SpecializationAbilityDto list to SpecializationAbility.Create() list
        - `RegisterDefinition()` — Populates all 6 cache collections
    - Section separators: `═══════` pattern matching ArchetypeProvider
    - Comprehensive XML documentation with cross-references

### Unit Tests

- **`SpecializationProviderTests`** (`Providers/SpecializationProviderTests.cs`) — 29 test methods
    - **Constructor Tests (2):**
        - `Constructor_NullLogger_ThrowsArgumentNullException`
        - `Constructor_WithValidParameters_CreatesInstance`
    - **GetAll Tests (2):**
        - `GetAll_ReturnsSeventeenSpecializations`
        - `GetAll_AllHaveRequiredData` (non-empty DisplayName, Tagline, Description, SelectionText)
    - **GetBySpecializationId Tests (3):**
        - `GetBySpecializationId_Berserkr_ReturnsHereticalWarriorWithRage`
        - `GetBySpecializationId_Skjaldmaer_ReturnsCoherentWarrior`
        - `GetBySpecializationId_Skald_ReturnsCoherentAdeptWithoutResource`
    - **GetByArchetype Tests (6):**
        - `GetByArchetype_Warrior_ReturnsSixSpecializations`
        - `GetByArchetype_Skirmisher_ReturnsFourSpecializations`
        - `GetByArchetype_Mystic_ReturnsTwoHereticalSpecializations`
        - `GetByArchetype_Adept_ReturnsFiveCoherentSpecializations`
        - `GetByArchetype_AllArchetypes_HaveCorrectParentArchetypes`
        - `GetByArchetype_TotalAcrossAllArchetypes_EqualsSeventeen`
    - **Path Type Filter Tests (3):**
        - `GetHereticalSpecializations_ReturnsFiveSpecializations`
        - `GetHereticalSpecializations_ContainsExpectedSpecializations`
        - `GetCoherentSpecializations_ReturnsTwelveSpecializations`
    - **Count & Exists Tests (2):**
        - `Count_ReturnsSeventeen`
        - `Exists_ValidId_ReturnsTrue`
    - **GetWithSpecialResource Tests (2):**
        - `GetWithSpecialResource_ReturnsFiveSpecializations`
        - `GetWithSpecialResource_ContainsExpectedSpecializations`
    - **GetAbility Tests (3):**
        - `GetAbility_ValidAbilityId_ReturnsAbilityAndSpecialization`
        - `GetAbility_InvalidAbilityId_ReturnsNull`
        - `GetAbility_NullOrWhitespace_ThrowsArgumentException`
    - **Berserkr Ability Tier Tests (2):**
        - `GetBySpecializationId_Berserkr_HasThreeAbilityTiers`
        - `GetBySpecializationId_Berserkr_Tier1IsFreeWithThreeAbilities`
    - **Special Resource Detail Tests (2):**
        - `GetBySpecializationId_Berserkr_RageResourceHasCorrectValues`
        - `GetBySpecializationId_Skjaldmaer_BlockChargesResourceHasCorrectValues`
    - **Error Handling Tests (1):**
        - `GetAll_WithMissingFile_ThrowsSpecializationConfigurationException`
    - **Caching Tests (1):**
        - `GetBySpecializationId_ReturnsSameInstanceOnRepeatedCalls`

### Glossary

- **`config/glossary.json`** — Added 2 glossary entries
    - `specialization-provider`: Provider service for loading/caching specialization definitions (sortOrder: 44)
    - `specialization-config-dto`: DTO classes for deserializing specializations.json (sortOrder: 45)

---

## Changed

### Infrastructure Layer

- **`DependencyInjection.cs`** — Added singleton registration for ISpecializationProvider
    - `services.AddSingleton<ISpecializationProvider>(sp => { ... })` using `Path.Combine(configPath, "specializations.json")`
    - Follows established pattern from IArchetypeProvider, ILineageProvider, IBackgroundProvider registrations

### Documentation

- **`docs/design/v0.17.x/v0.17.4-scope-breakdown.md`** — Checked off v0.17.4d unit test items
    - `[x] GetSpecializationsForArchetype returns correct specializations`
    - `[x] IsHeretical correctly identifies Heretical paths`

- **`docs/design/v0.17.x/v0.17.x-overview.md`** — Checked off v0.17.4 deliverables
    - `[x] ISpecializationProvider interface`
    - `[x] SpecializationProvider with JSON loading`

---

## Design Decisions

### Provider in Infrastructure/Services (Not Application/Services)

The v0.17.4d design specification places `SpecializationProvider` in `Application/Services`. However, all existing providers in the codebase (ArchetypeProvider, LineageProvider, BackgroundProvider, AttributeProvider, StanceProvider, etc.) are in `Infrastructure/Services`. The codebase convention was followed to maintain consistency. The interface remains in `Application/Interfaces` per the standard layered architecture pattern.

### Direct JSON Loading (Not IConfigurationLoader)

The design specification references `IConfigurationLoader` for JSON loading. This interface does not exist in the codebase. All existing providers use `System.Text.Json` directly with `File.ReadAllText` and `JsonSerializer.Deserialize<T>` with `PropertyNameCaseInsensitive = true`. This pattern was followed for consistency.

### Lazy Initialization (Not Eager Constructor Loading)

The design specification loads configuration eagerly in the constructor. The codebase convention (ArchetypeProvider, LineageProvider, etc.) uses lazy initialization with double-checked locking via an `EnsureInitialized()` method. This was followed for:
- Faster application startup (deferred file I/O)
- Thread-safe initialization
- Consistent pattern across all providers

### SpecializationConfigurationException

The design specification does not include an exception class. However, the established pattern includes a dedicated exception per provider (ArchetypeConfigurationException, LineageConfigurationException, BackgroundConfigurationException, AttributeConfigurationException). `SpecializationConfigurationException` was created to follow this convention, providing specific error messages for configuration failures.

### SpecializationPathTypeEntryDto Included

The DTOs include `SpecializationPathTypeEntryDto` to map the `pathTypes` array in the JSON, even though the provider primarily uses the `definitions` array. This ensures complete deserialization of the JSON structure without data loss and maintains forward compatibility.

### Comprehensive Test Coverage

The design specification estimates ~3 tests. 29 test methods were implemented for comprehensive coverage matching the established codebase test density. Tests verify all 9 interface methods, archetype distribution counts, path type classifications, special resource details, ability tier structure, error handling, and caching behavior.

### Fail-Fast Validation

Unlike the design specification's approach of continuing on individual definition failures, the provider fails fast when any definition cannot be mapped. This is because all 17 specializations are required for a valid game state, and partial loading would cause runtime errors in the character creation workflow. This matches the ArchetypeProvider pattern which also fails fast on validation errors.

---

## Dependencies

### Prerequisites

| Type | Phase | Usage |
| --- | --- | --- |
| `SpecializationId` | v0.17.4a | Enum key for dictionary lookups and parsing |
| `SpecializationPathType` | v0.17.4a | Path type filtering for Heretical/Coherent caches |
| `SpecializationIdExtensions` | v0.17.4a | Cross-validation in SpecializationDefinition.Create() |
| `SpecializationDefinition` | v0.17.4b | Domain entity loaded and cached by provider |
| `SpecialResourceDefinition` | v0.17.4b | Value object mapped from SpecialResourceDto |
| `SpecializationAbilityTier` | v0.17.4c | Value object mapped from AbilityTierDto |
| `SpecializationAbility` | v0.17.4c | Value object mapped from SpecializationAbilityDto |
| `Archetype` | v0.17.3a | Parent archetype key for _byArchetype cache |

### Provides to Future Phases

| Type | Phase | Usage |
| --- | --- | --- |
| `ISpecializationProvider` | v0.17.4e | Application service dependency for specialization selection |
| `GetByArchetype()` | v0.17.5 | Character creation shows available specializations per archetype |
| `GetBySpecializationId()` | Combat | Ability lookup during combat execution |
| `GetAbility()` | Combat | Cross-specialization ability detail lookup |
| `GetWithSpecialResource()` | Combat | Initialize special resource tracking for combat |

---

## Logging Strategy

| Level | When |
|---|---|
| Information | Provider initialization started and completed with full cache statistics |
| Debug | Individual method calls with results, definition mapping steps, ability mapping, cache registration, validation steps |
| Warning | Unknown archetype requested in GetByArchetype, count mismatch (defensive) |
| Error | Configuration file not found, JSON parse failure, definition mapping failure, validation failures |

All public interface methods log at Debug level for diagnostic tracing. The constructor logs at Debug level. Initialization (first access) logs at Information level with complete cache statistics.

---

## Files Created

| Path | Description |
|---|---|
| `src/Core/RuneAndRust.Application/Interfaces/ISpecializationProvider.cs` | Interface with 9 query methods |
| `src/Core/RuneAndRust.Application/DTOs/SpecializationConfigDto.cs` | 6 DTO classes for JSON deserialization |
| `src/Core/RuneAndRust.Application/Exceptions/SpecializationConfigurationException.cs` | Configuration exception class |
| `src/Infrastructure/RuneAndRust.Infrastructure/Services/SpecializationProvider.cs` | Provider implementation with caching and loading |
| `tests/RuneAndRust.Application.UnitTests/Providers/SpecializationProviderTests.cs` | 29 test methods |
| `changelogs/v0.17.4d-changelog.md` | This changelog |

## Files Modified

| Path | Description |
|---|---|
| `src/Infrastructure/RuneAndRust.Infrastructure/DependencyInjection.cs` | Added singleton registration for ISpecializationProvider |
| `config/glossary.json` | Added 2 glossary entries (sortOrder 44-45) |
| `docs/design/v0.17.x/v0.17.4-scope-breakdown.md` | Checked off v0.17.4d deliverables |
| `docs/design/v0.17.x/v0.17.x-overview.md` | Updated v0.17.4 deliverable checkboxes |

---

## Notes

- Total unit tests for v0.17.4d: 29 test methods
- Total test suite after v0.17.4d: 9,834 tests (all passing, 0 regressions)
- Build: 0 errors, 0 warnings
- The design specification estimated ~3 tests; 29 methods were implemented for comprehensive coverage
- Provider loads all 17 specializations from existing config/specializations.json (no configuration changes needed)
- 6 cache collections provide O(1) access for all common query patterns
- GetAbility() is O(n) where n = total abilities, acceptable for ~153 max abilities
- Lazy initialization defers file I/O until first access, consistent with ArchetypeProvider pattern
- SpecializationProvider is in Infrastructure/Services (not Application/Services as design spec indicates) per codebase convention
- The SpecializationPathTypeEntryDto maps the pathTypes array for complete JSON deserialization even though the provider primarily uses the definitions array
- All DTO properties auto-initialize with defaults for safe System.Text.Json deserialization with PropertyNameCaseInsensitive = true
