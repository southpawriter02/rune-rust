# v0.15.4h Design Specification: Alternative Bypass Methods

**Version:** 0.15.4h
**Theme:** Alternative Bypass Methods (Non-Skill Approaches to Obstacles)
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0 Complete (Dice Pool Refactor), v0.15.1 Complete (Skill Infrastructure), v0.15.4a Complete (Lockpicking System), v0.15.4b Complete (Terminal Hacking System), v0.15.4c Complete (ICE Countermeasures), v0.15.4d Complete (Trap Disarmament System), v0.15.4e Complete (Jury-Rigging System), v0.15.4f Complete (Glitch Exploitation System), v0.15.4g Complete (Improvised Tool Crafting)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [BruteForceOption Value Object](#4-bruteforceoption-value-object)
5. [AlternativeMethod Value Object](#5-alternativemethod-value-object)
6. [BruteForceResult Value Object](#6-bruteforceresult-value-object)
7. [AlternativeBypassService](#7-alternativebypassservice-implementation)
8. [Consequence System](#8-consequence-system)
9. [Obstacle-Specific Alternatives](#9-obstacle-specific-alternatives)
10. [Data Model Changes](#10-data-model-changes)
11. [Configuration Files](#11-configuration-files)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Dependencies](#17-dependencies)
18. [Future Considerations](#18-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

The Alternative Bypass Methods system provides non-skill-based approaches to obstacles when lockpicking, hacking, or disarmament are unavailable or undesirable. In Aethelgard's unforgiving world, not every character has the finesse for delicate manipulation—sometimes the answer is brute force, creative problem-solving, or accepting partial success.

This phase implements MIGHT-based brute force options with appropriate consequences, as well as documenting alternative approaches for each obstacle type. When System Bypass skill checks aren't viable, characters can still progress through physical force, environmental solutions, or tactical sacrifices.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | `BruteForceOption`, `AlternativeMethod`, `BruteForceResult`, `BruteForceConsequence` |
| **Enums** | `BruteForceTargetType`, `ConsequenceType`, `AlternativeType` |
| **Services** | `AlternativeBypassService` |
| **Configuration** | `brute-force-options.json`, `alternative-methods.json` |
| **Tests** | ~2 new unit tests |

### 1.3 Architectural Significance

This version establishes the **Alternative Solution Pattern** that ensures obstacles are never absolute barriers:

- **Multiple Paths**: Every obstacle has at least 2-3 approaches beyond the primary skill check
- **Trade-off Design**: Alternatives have consequences (noise, damage, time, resources)
- **Character Diversity**: MIGHT-focused characters can contribute to bypass challenges
- **Fail Forward**: Even "failures" often produce partial progress

---

## 2. Feature Overview

```
v0.15.4h Alternative Bypass Methods
├── Brute Force System
│   ├── Target Types (Door, Reinforced, Vault, Container)
│   ├── MIGHT-based DC checks
│   ├── Consequence System
│   │   ├── Noise levels (alerts nearby)
│   │   ├── Content damage (may destroy items)
│   │   ├── Exhaustion (stamina cost)
│   │   └── Structural alerts (security triggers)
│   └── Multiple Attempt Handling
├── Alternative Methods by Obstacle
│   ├── Locked Door Alternatives
│   │   ├── Find key
│   │   ├── Brute force
│   │   ├── Runic bypass
│   │   └── Alternate route
│   ├── Secured Terminal Alternatives
│   │   ├── Find codes
│   │   ├── Hotwire to different terminal
│   │   └── Accept partial access
│   └── Active Trap Alternatives
│       ├── Trigger from distance
│       ├── Destroy mechanism
│       └── Sacrifice (shield/item)
└── Integration with Bypass Systems
    ├── Fallback when skill unavailable
    ├── Consequence application
    └── Narrative generation
```

---

## 3. Architecture Diagrams

### 3.1 Brute Force Resolution Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       BRUTE FORCE RESOLUTION FLOW                            │
└─────────────────────────────────────────────────────────────────────────────┘

    Character encounters locked obstacle without bypass skill
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 1: EVALUATE TARGET                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  Determine target type and base DC:                                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Target Type        │ MIGHT DC │ Base Consequences                       ││
│  ├────────────────────┼──────────┼─────────────────────────────────────────┤│
│  │ Simple Door        │ 12       │ Loud (alerts nearby enemies)            ││
│  │ Reinforced Door    │ 16       │ Very loud, may damage contents          ││
│  │ Vault              │ 22       │ Multiple attempts, exhausting           ││
│  │ Container          │ 10-16    │ Contents may be damaged                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Environment Modifiers:                                                      │
│  + Has pry bar or crowbar: -2 DC                                            │
│  + Partially damaged: -4 DC                                                 │
│  - Reinforced hinges: +2 DC                                                 │
│  - Jötun-forged materials: +4 DC                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 2: BRUTE FORCE ATTEMPT                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  Roll MIGHT dice pool vs. target DC                                          │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Dice Pool Composition:                                                   ││
│  │                                                                          ││
│  │ Base: MIGHT attribute dice (typically 2-5d10)                            ││
│  │ + Tool bonus (pry bar, sledgehammer): +1d10 to +2d10                     ││
│  │ + Assistance (ally helps): +1d10 per helper (max 2)                      ││
│  │ - Exhaustion penalty: -1d10 per 2 failed attempts                        ││
│  │ - Injury penalty: Per standard wound rules                               ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
│  Success Counting:                                                           │
│  - 8, 9, 10 = Success                                                       │
│  - 1 = Botch                                                                │
│  - Net Successes = Successes - Botches                                      │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      STEP 3: RESOLVE RESULT                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐                │
│  │ CRITICAL        │ │ SUCCESS         │ │ FAILURE         │                │
│  │ (Net ≥5)        │ │ (Net >0)        │ │ (Net ≤0)        │                │
│  ├─────────────────┤ ├─────────────────┤ ├─────────────────┤                │
│  │ Obstacle        │ │ Obstacle        │ │ Obstacle        │                │
│  │ destroyed       │ │ destroyed       │ │ intact          │                │
│  │                 │ │                 │ │                 │                │
│  │ REDUCED         │ │ NORMAL          │ │ Attempt         │                │
│  │ consequences:   │ │ consequences    │ │ consumed        │                │
│  │ - Quieter       │ │ apply           │ │                 │                │
│  │ - Contents safe │ │                 │ │ May retry       │                │
│  │ - Less tiring   │ │                 │ │ at +1 DC        │                │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘                │
│                                                                              │
│  Special: FUMBLE (0 successes, ≥1 botch)                                    │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ SEVERE consequences:                                                     ││
│  │ - 1d6 damage to character (strained muscle, splinters, etc.)            ││
│  │ - Tool breaks if used                                                   ││
│  │ - Maximum noise alert                                                   ││
│  │ - DC +2 for future attempts                                             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Alternative Methods Decision Tree

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ALTERNATIVE METHODS DECISION TREE                         │
└─────────────────────────────────────────────────────────────────────────────┘

    Character cannot or chooses not to use primary bypass skill
                │
                ▼
        ┌───────────────────┐
        │ OBSTACLE TYPE?    │
        └───────────────────┘
                │
    ┌───────────┼───────────┬───────────────┐
    ▼           ▼           ▼               ▼
┌─────────┐ ┌─────────┐ ┌─────────┐    ┌─────────┐
│ LOCKED  │ │ SECURED │ │ ACTIVE  │    │ OTHER   │
│ DOOR    │ │ TERMINAL│ │ TRAP    │    │ BARRIER │
└────┬────┘ └────┬────┘ └────┬────┘    └────┬────┘
     │           │           │              │
     ▼           ▼           ▼              ▼

┌─────────────────────────────────────────────────────────────────────────────┐
│                        LOCKED DOOR ALTERNATIVES                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 1: FIND KEY                                                       ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Search nearby areas for key holder (Investigation check)              ││
│  │ - Loot fallen enemies (Perception check)                                ││
│  │ - Trade/negotiate for key (Charisma check)                              ││
│  │ Consequences: Time spent, potential encounters                          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 2: BRUTE FORCE                                                    ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - MIGHT check vs. door DC                                               ││
│  │ Consequences: Noise alert, potential damage                             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 3: RUNIC BYPASS                                                   ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Use Runecraft skill to manipulate lock runes                          ││
│  │ - Requires [Rune Sight] or similar ability                              ││
│  │ Consequences: Essence cost, potential corruption                        ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 4: ALTERNATE ROUTE                                                ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Find another way (ventilation, window, collapsed wall)                ││
│  │ - May require Acrobatics, Athletics, or Perception                      ││
│  │ Consequences: Time, potential hazards on alternate path                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                      SECURED TERMINAL ALTERNATIVES                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 1: FIND CODES                                                     ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Search for written passwords (Investigation)                          ││
│  │ - Interrogate/persuade someone who knows (Social)                       ││
│  │ - Find backup credentials in another location                           ││
│  │ Consequences: Time, potential combat/social encounters                  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 2: HOTWIRE TO DIFFERENT TERMINAL                                  ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Bypass this terminal by connecting to less secured one                ││
│  │ - Requires finding secondary terminal                                   ││
│  │ - WITS check DC 14 to hotwire connection                                ││
│  │ Consequences: Reduced access level, potential ICE encounter             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 3: ACCEPT PARTIAL ACCESS                                          ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Stop at User Level instead of pursuing Admin Level                    ││
│  │ - Still get some information/functionality                              ││
│  │ - May miss critical hidden files                                        ││
│  │ Consequences: Incomplete information, may need to return later          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                        ACTIVE TRAP ALTERNATIVES                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 1: TRIGGER FROM DISTANCE                                          ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Throw object to trigger pressure plate                                ││
│  │ - Use ranged attack on tripwire                                         ││
│  │ - FINESSE check DC 12 to trigger precisely                              ││
│  │ Consequences: Noise, trap effects on area, may destroy loot             ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 2: DESTROY MECHANISM                                              ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Attack trap mechanism directly                                        ││
│  │ - Trap has HP based on type (Simple: 10, Complex: 25)                   ││
│  │ - Risk: May trigger if not destroyed in one hit                         ││
│  │ Consequences: Noise, potential triggering, no salvage possible          ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │ Option 3: SACRIFICE (Shield/Item)                                        ││
│  ├─────────────────────────────────────────────────────────────────────────┤│
│  │ - Block trap effect with shield or barrier                              ││
│  │ - Expend consumable item to absorb/neutralize                           ││
│  │ - Shield takes damage, consumable destroyed                             ││
│  │ Consequences: Resource cost, shield damage, still triggers alert        ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Service Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  ConsoleInputHandler          IGameRenderer                                  │
│  - ParseForceCommand()        - RenderBruteForceAttemptAsync()              │
│  - ParseAlternativeCommand()  - RenderAlternativeOptionsAsync()             │
│                               - RenderConsequencesAsync()                    │
│                               - RenderObstacleDestroyedAsync()               │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameEngine                                                                  │
│  - HandleBruteForceAsync()                                                  │
│  - HandleAlternativeBypassAsync()                                           │
│  - GetAvailableAlternatives()                                               │
│  - ApplyBruteForceConsequences()                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN SERVICES                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ AlternativeBypassService                                            │   │
│  ├─────────────────────────────────────────────────────────────────────┤   │
│  │ + GetBruteForceOption(target) → BruteForceOption                   │   │
│  │ + AttemptBruteForce(character, target, diceRoller) → BruteForceResult│  │
│  │ + GetAlternatives(obstacleType) → IEnumerable<AlternativeMethod>   │   │
│  │ + EvaluateAlternative(method, context) → AlternativeResult         │   │
│  │ + ApplyConsequences(result, environment) → ConsequenceOutcome      │   │
│  │ + CanRetry(target, attempts) → bool                                │   │
│  │ + GetRetryDc(baseDc, attempts, fumbles) → int                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  Integration with Existing Services:                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ LockpickingService:                                                  │   │
│  │   When skill unavailable:                                            │   │
│  │     var alternatives = _alternativeService                           │   │
│  │       .GetAlternatives(ObstacleType.LockedDoor);                    │   │
│  │                                                                       │   │
│  │ TerminalHackingService:                                              │   │
│  │   When locked out:                                                   │   │
│  │     var alternatives = _alternativeService                           │   │
│  │       .GetAlternatives(ObstacleType.SecuredTerminal);               │   │
│  │                                                                       │   │
│  │ TrapDisarmamentService:                                              │   │
│  │   When disarm fails:                                                 │   │
│  │     var alternatives = _alternativeService                           │   │
│  │       .GetAlternatives(ObstacleType.ActiveTrap);                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                │                              ▲
                ▼                              │
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN VALUE OBJECTS                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  BruteForceOption          AlternativeMethod          BruteForceResult      │
│  - TargetType              - MethodId                 - Success             │
│  - BaseDc                  - ObstacleType             - IsCritical          │
│  - Consequences            - MethodName               - IsFumble            │
│  - ToolModifiers           - Description              - ObstacleDestroyed   │
│  - CanRetry                - RequiredCheck            - ConsequencesApplied │
│  - RetryPenalty            - Consequences             - DamageToCharacter   │
│                            - TimeRequired             - DamageToContents    │
│                                                       - NoiseLevel          │
│  BruteForceConsequence     ConsequenceOutcome         - NarrativeText       │
│  - ConsequenceType         - AlertsTriggered                                │
│  - NoiseLevel              - DamageDealt                                    │
│  - ContentDamageChance     - ResourcesConsumed                              │
│  - ExhaustionCost          - TimeSpent                                      │
│  - AlertRadius             - NarrativeDescription                           │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. BruteForceOption Value Object

### 4.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BruteForceOption.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the brute force approach to bypassing a physical obstacle.
/// When lockpicking or other finesse-based bypass isn't available,
/// characters can attempt to force their way through using raw MIGHT.
/// </summary>
/// <remarks>
/// Brute force is always an option but comes with consequences:
/// - Noise alerts nearby enemies
/// - Contents may be damaged
/// - Multiple attempts cause exhaustion
/// - Structural damage may trigger security systems
/// </remarks>
/// <param name="TargetType">Classification of the physical obstacle.</param>
/// <param name="BaseDc">Base difficulty class for MIGHT check.</param>
/// <param name="Consequences">List of consequences that apply on success.</param>
/// <param name="ToolModifiers">Available tool modifiers for the attempt.</param>
/// <param name="MaxAttempts">Maximum number of attempts before obstacle is impassable.</param>
/// <param name="RetryPenaltyPerAttempt">DC increase per failed attempt.</param>
/// <param name="TargetHitPoints">HP for the obstacle (for damage-based bypass).</param>
public readonly record struct BruteForceOption(
    BruteForceTargetType TargetType,
    int BaseDc,
    IReadOnlyList<BruteForceConsequence> Consequences,
    IReadOnlyList<ToolModifier> ToolModifiers,
    int MaxAttempts,
    int RetryPenaltyPerAttempt,
    int TargetHitPoints)
{
    /// <summary>
    /// Creates a brute force option for a simple door.
    /// </summary>
    public static BruteForceOption SimpleDoor => new(
        TargetType: BruteForceTargetType.SimpleDoor,
        BaseDc: 12,
        Consequences: new List<BruteForceConsequence>
        {
            BruteForceConsequence.LoudNoise
        }.AsReadOnly(),
        ToolModifiers: new List<ToolModifier>
        {
            new("Crowbar", -2),
            new("Sledgehammer", -4)
        }.AsReadOnly(),
        MaxAttempts: 5,
        RetryPenaltyPerAttempt: 1,
        TargetHitPoints: 20);

    /// <summary>
    /// Creates a brute force option for a reinforced door.
    /// </summary>
    public static BruteForceOption ReinforcedDoor => new(
        TargetType: BruteForceTargetType.ReinforcedDoor,
        BaseDc: 16,
        Consequences: new List<BruteForceConsequence>
        {
            BruteForceConsequence.VeryLoudNoise,
            BruteForceConsequence.ContentDamageRisk
        }.AsReadOnly(),
        ToolModifiers: new List<ToolModifier>
        {
            new("Crowbar", -2),
            new("Sledgehammer", -3),
            new("Breaching Charge", -6)
        }.AsReadOnly(),
        MaxAttempts: 3,
        RetryPenaltyPerAttempt: 2,
        TargetHitPoints: 40);

    /// <summary>
    /// Creates a brute force option for a vault.
    /// </summary>
    public static BruteForceOption Vault => new(
        TargetType: BruteForceTargetType.Vault,
        BaseDc: 22,
        Consequences: new List<BruteForceConsequence>
        {
            BruteForceConsequence.VeryLoudNoise,
            BruteForceConsequence.Exhausting,
            BruteForceConsequence.ContentDamageRisk
        }.AsReadOnly(),
        ToolModifiers: new List<ToolModifier>
        {
            new("Sledgehammer", -2),
            new("Breaching Charge", -4),
            new("Industrial Cutter", -6)
        }.AsReadOnly(),
        MaxAttempts: 2,
        RetryPenaltyPerAttempt: 3,
        TargetHitPoints: 80);

    /// <summary>
    /// Creates a brute force option for a container.
    /// </summary>
    /// <param name="containerStrength">Strength rating 1-5 affecting DC.</param>
    public static BruteForceOption Container(int containerStrength = 3) => new(
        TargetType: BruteForceTargetType.Container,
        BaseDc: 8 + (containerStrength * 2), // DC 10-18
        Consequences: new List<BruteForceConsequence>
        {
            BruteForceConsequence.LoudNoise,
            BruteForceConsequence.ContentDamageRisk
        }.AsReadOnly(),
        ToolModifiers: new List<ToolModifier>
        {
            new("Crowbar", -2),
            new("Knife/Blade", -1)
        }.AsReadOnly(),
        MaxAttempts: 3,
        RetryPenaltyPerAttempt: 1,
        TargetHitPoints: 10 + (containerStrength * 5));

    /// <summary>
    /// Gets the effective DC for an attempt, accounting for previous failures.
    /// </summary>
    /// <param name="previousAttempts">Number of failed attempts.</param>
    /// <param name="hasFumbled">Whether a fumble occurred in previous attempts.</param>
    /// <returns>The adjusted DC for the current attempt.</returns>
    public int GetEffectiveDc(int previousAttempts, bool hasFumbled)
    {
        var dc = BaseDc + (previousAttempts * RetryPenaltyPerAttempt);

        if (hasFumbled)
            dc += 2; // Fumble adds permanent +2 DC

        return dc;
    }

    /// <summary>
    /// Gets the DC modifier from a specific tool.
    /// </summary>
    /// <param name="toolName">Name of the tool being used.</param>
    /// <returns>DC modifier (negative means easier).</returns>
    public int GetToolModifier(string toolName)
    {
        var modifier = ToolModifiers.FirstOrDefault(t =>
            t.ToolName.Equals(toolName, StringComparison.OrdinalIgnoreCase));
        return modifier.Modifier;
    }

    /// <summary>
    /// Determines if more attempts are possible.
    /// </summary>
    /// <param name="attemptsMade">Number of attempts already made.</param>
    public bool CanRetry(int attemptsMade) => attemptsMade < MaxAttempts;

    /// <summary>
    /// Gets the narrative description of this target.
    /// </summary>
    public string GetDescription() => TargetType switch
    {
        BruteForceTargetType.SimpleDoor => "a wooden door with a simple lock",
        BruteForceTargetType.ReinforcedDoor => "a reinforced door with metal bracing",
        BruteForceTargetType.Vault => "a heavy vault door of Old World construction",
        BruteForceTargetType.Container => "a locked container",
        _ => "a physical obstacle"
    };

    /// <summary>
    /// Creates a display string for the brute force option.
    /// </summary>
    public string ToDisplayString()
    {
        var lines = new List<string>
        {
            $"[Brute Force: {TargetType}]",
            $"MIGHT DC: {BaseDc}",
            $"Max Attempts: {MaxAttempts}",
            $"Retry Penalty: +{RetryPenaltyPerAttempt} DC per failure",
            "",
            "Consequences:"
        };

        foreach (var consequence in Consequences)
        {
            lines.Add($"  - {consequence.ToDisplayString()}");
        }

        if (ToolModifiers.Any())
        {
            lines.Add("");
            lines.Add("Tool Modifiers:");
            foreach (var tool in ToolModifiers)
            {
                var sign = tool.Modifier < 0 ? "" : "+";
                lines.Add($"  - {tool.ToolName}: {sign}{tool.Modifier} DC");
            }
        }

        return string.Join(Environment.NewLine, lines);
    }
}

/// <summary>
/// Classification of physical obstacles that can be forced.
/// </summary>
public enum BruteForceTargetType
{
    /// <summary>Standard wooden or light metal door (DC 12).</summary>
    SimpleDoor,

    /// <summary>Metal-reinforced door with heavy construction (DC 16).</summary>
    ReinforcedDoor,

    /// <summary>Heavy vault door, often Jötun-forged (DC 22).</summary>
    Vault,

    /// <summary>Locked container, chest, or safe (DC 10-16).</summary>
    Container
}

/// <summary>
/// A tool that modifies the DC of a brute force attempt.
/// </summary>
/// <param name="ToolName">Name of the tool.</param>
/// <param name="Modifier">DC modifier (negative = easier).</param>
public readonly record struct ToolModifier(string ToolName, int Modifier);
```

---

## 5. AlternativeMethod Value Object

### 5.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/AlternativeMethod.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents an alternative approach to bypassing an obstacle
/// when the primary skill check isn't available or has failed.
/// </summary>
/// <remarks>
/// Every obstacle in Aethelgard has multiple solutions. These
/// alternatives ensure characters aren't completely blocked by
/// any single obstacle, though each comes with trade-offs.
/// </remarks>
/// <param name="MethodId">Unique identifier for the method.</param>
/// <param name="ObstacleType">Type of obstacle this method applies to.</param>
/// <param name="MethodName">Display name of the alternative.</param>
/// <param name="Description">Narrative description of the approach.</param>
/// <param name="RequiredCheck">Skill or attribute check needed.</param>
/// <param name="CheckDc">Difficulty of the required check.</param>
/// <param name="Consequences">Trade-offs for using this method.</param>
/// <param name="TimeRequired">Time cost description.</param>
/// <param name="Prerequisites">Any requirements to attempt this method.</param>
public readonly record struct AlternativeMethod(
    string MethodId,
    ObstacleType ObstacleType,
    string MethodName,
    string Description,
    AlternativeCheckType RequiredCheck,
    int CheckDc,
    IReadOnlyList<string> Consequences,
    string TimeRequired,
    IReadOnlyList<string> Prerequisites)
{
    // ==========================================================================
    // LOCKED DOOR ALTERNATIVES
    // ==========================================================================

    /// <summary>
    /// Find the key by searching or social interaction.
    /// </summary>
    public static AlternativeMethod FindKey => new(
        MethodId: "alt_door_find_key",
        ObstacleType: ObstacleType.LockedDoor,
        MethodName: "Find Key",
        Description: "Search nearby areas or negotiate with someone who has the key.",
        RequiredCheck: AlternativeCheckType.Investigation,
        CheckDc: 14,
        Consequences: new List<string>
        {
            "Time spent searching",
            "May trigger random encounters",
            "Social interaction may require favors or payment"
        }.AsReadOnly(),
        TimeRequired: "10-30 minutes",
        Prerequisites: new List<string>().AsReadOnly());

    /// <summary>
    /// Apply brute force to destroy the door.
    /// </summary>
    public static AlternativeMethod BruteForce => new(
        MethodId: "alt_door_brute_force",
        ObstacleType: ObstacleType.LockedDoor,
        MethodName: "Brute Force",
        Description: "Use raw strength to break down the door.",
        RequiredCheck: AlternativeCheckType.Might,
        CheckDc: 12, // Varies by door type
        Consequences: new List<string>
        {
            "Loud noise alerts nearby",
            "Contents behind door may be damaged",
            "Multiple attempts cause exhaustion"
        }.AsReadOnly(),
        TimeRequired: "1-3 rounds",
        Prerequisites: new List<string>().AsReadOnly());

    /// <summary>
    /// Use Runecraft to manipulate lock runes.
    /// </summary>
    public static AlternativeMethod RunicBypass => new(
        MethodId: "alt_door_runic_bypass",
        ObstacleType: ObstacleType.LockedDoor,
        MethodName: "Runic Bypass",
        Description: "Manipulate the lock's runic bindings to release the mechanism.",
        RequiredCheck: AlternativeCheckType.Runecraft,
        CheckDc: 16,
        Consequences: new List<string>
        {
            "Essence cost (1-3 points)",
            "Potential corruption exposure",
            "May trigger runic alarms"
        }.AsReadOnly(),
        TimeRequired: "1 round",
        Prerequisites: new List<string>
        {
            "[Rune Sight] ability or equivalent",
            "Runecraft skill trained"
        }.AsReadOnly());

    /// <summary>
    /// Find another way around the door.
    /// </summary>
    public static AlternativeMethod AlternateRoute => new(
        MethodId: "alt_door_alternate_route",
        ObstacleType: ObstacleType.LockedDoor,
        MethodName: "Alternate Route",
        Description: "Find another path: ventilation shaft, window, or collapsed wall.",
        RequiredCheck: AlternativeCheckType.Perception,
        CheckDc: 14,
        Consequences: new List<string>
        {
            "Time spent exploring",
            "Alternate paths may have their own hazards",
            "May not be accessible for all party members"
        }.AsReadOnly(),
        TimeRequired: "5-20 minutes",
        Prerequisites: new List<string>().AsReadOnly());

    // ==========================================================================
    // SECURED TERMINAL ALTERNATIVES
    // ==========================================================================

    /// <summary>
    /// Find access codes through investigation.
    /// </summary>
    public static AlternativeMethod FindCodes => new(
        MethodId: "alt_terminal_find_codes",
        ObstacleType: ObstacleType.SecuredTerminal,
        MethodName: "Find Codes",
        Description: "Search for written passwords or credentials in the area.",
        RequiredCheck: AlternativeCheckType.Investigation,
        CheckDc: 16,
        Consequences: new List<string>
        {
            "Time spent searching",
            "Codes may be expired or single-use",
            "May find partial codes only"
        }.AsReadOnly(),
        TimeRequired: "5-15 minutes",
        Prerequisites: new List<string>().AsReadOnly());

    /// <summary>
    /// Hotwire connection to a less secured terminal.
    /// </summary>
    public static AlternativeMethod HotwireTerminal => new(
        MethodId: "alt_terminal_hotwire",
        ObstacleType: ObstacleType.SecuredTerminal,
        MethodName: "Hotwire to Different Terminal",
        Description: "Bypass this terminal by connecting to a less secured access point.",
        RequiredCheck: AlternativeCheckType.Wits,
        CheckDc: 14,
        Consequences: new List<string>
        {
            "Reduced access level (User instead of Admin)",
            "Connection may be unstable",
            "May trigger ICE on secondary terminal"
        }.AsReadOnly(),
        TimeRequired: "2-5 rounds",
        Prerequisites: new List<string>
        {
            "Secondary terminal must exist in area",
            "Wire or cable available"
        }.AsReadOnly());

    /// <summary>
    /// Accept partial access instead of full.
    /// </summary>
    public static AlternativeMethod AcceptPartialAccess => new(
        MethodId: "alt_terminal_partial",
        ObstacleType: ObstacleType.SecuredTerminal,
        MethodName: "Accept Partial Access",
        Description: "Stop at User Level access rather than pursuing Admin Level.",
        RequiredCheck: AlternativeCheckType.None,
        CheckDc: 0, // No check required
        Consequences: new List<string>
        {
            "Cannot access hidden or classified files",
            "Limited functionality available",
            "May need to return later with better access"
        }.AsReadOnly(),
        TimeRequired: "Immediate",
        Prerequisites: new List<string>
        {
            "Must have achieved at least User Level access"
        }.AsReadOnly());

    // ==========================================================================
    // ACTIVE TRAP ALTERNATIVES
    // ==========================================================================

    /// <summary>
    /// Trigger the trap from a safe distance.
    /// </summary>
    public static AlternativeMethod TriggerFromDistance => new(
        MethodId: "alt_trap_trigger_distance",
        ObstacleType: ObstacleType.ActiveTrap,
        MethodName: "Trigger from Distance",
        Description: "Throw an object or use ranged attack to safely trigger the trap.",
        RequiredCheck: AlternativeCheckType.Finesse,
        CheckDc: 12,
        Consequences: new List<string>
        {
            "Noise from trap activation",
            "Trap effects apply to area (may destroy loot)",
            "Consumes thrown object"
        }.AsReadOnly(),
        TimeRequired: "1 round",
        Prerequisites: new List<string>
        {
            "Object to throw or ranged weapon",
            "Line of sight to trigger mechanism"
        }.AsReadOnly());

    /// <summary>
    /// Destroy the trap mechanism with direct attack.
    /// </summary>
    public static AlternativeMethod DestroyMechanism => new(
        MethodId: "alt_trap_destroy",
        ObstacleType: ObstacleType.ActiveTrap,
        MethodName: "Destroy Mechanism",
        Description: "Attack the trap mechanism directly to disable it.",
        RequiredCheck: AlternativeCheckType.Attack,
        CheckDc: 0, // Uses attack roll vs trap AC
        Consequences: new List<string>
        {
            "Noise from destruction",
            "Trap may trigger if not destroyed in one hit",
            "No salvageable components"
        }.AsReadOnly(),
        TimeRequired: "1 round",
        Prerequisites: new List<string>
        {
            "Weapon or damaging ability"
        }.AsReadOnly());

    /// <summary>
    /// Use a shield or item to absorb trap effect.
    /// </summary>
    public static AlternativeMethod Sacrifice => new(
        MethodId: "alt_trap_sacrifice",
        ObstacleType: ObstacleType.ActiveTrap,
        MethodName: "Sacrifice (Shield/Item)",
        Description: "Block trap effect with shield or absorb with expendable item.",
        RequiredCheck: AlternativeCheckType.None,
        CheckDc: 0, // Automatic if resources available
        Consequences: new List<string>
        {
            "Shield takes damage (may break)",
            "Consumable item destroyed",
            "Trap still triggers alert systems"
        }.AsReadOnly(),
        TimeRequired: "1 round",
        Prerequisites: new List<string>
        {
            "Shield or expendable item available",
            "Item must be appropriate for trap type"
        }.AsReadOnly());

    /// <summary>
    /// Gets all alternatives for a given obstacle type.
    /// </summary>
    public static IEnumerable<AlternativeMethod> GetAlternativesFor(ObstacleType obstacleType) =>
        obstacleType switch
        {
            ObstacleType.LockedDoor => new[] { FindKey, BruteForce, RunicBypass, AlternateRoute },
            ObstacleType.SecuredTerminal => new[] { FindCodes, HotwireTerminal, AcceptPartialAccess },
            ObstacleType.ActiveTrap => new[] { TriggerFromDistance, DestroyMechanism, Sacrifice },
            _ => Enumerable.Empty<AlternativeMethod>()
        };

    /// <summary>
    /// Creates a display string for this alternative.
    /// </summary>
    public string ToDisplayString()
    {
        var lines = new List<string>
        {
            $"[{MethodName}]",
            Description,
            ""
        };

        if (RequiredCheck != AlternativeCheckType.None)
        {
            lines.Add($"Check: {RequiredCheck} DC {CheckDc}");
        }
        else
        {
            lines.Add("Check: None required");
        }

        lines.Add($"Time: {TimeRequired}");

        if (Prerequisites.Any())
        {
            lines.Add("");
            lines.Add("Prerequisites:");
            foreach (var prereq in Prerequisites)
            {
                lines.Add($"  - {prereq}");
            }
        }

        if (Consequences.Any())
        {
            lines.Add("");
            lines.Add("Consequences:");
            foreach (var consequence in Consequences)
            {
                lines.Add($"  - {consequence}");
            }
        }

        return string.Join(Environment.NewLine, lines);
    }
}

/// <summary>
/// Types of obstacles that have alternative bypass methods.
/// </summary>
public enum ObstacleType
{
    /// <summary>A locked door or gate.</summary>
    LockedDoor,

    /// <summary>A secured terminal requiring hacking.</summary>
    SecuredTerminal,

    /// <summary>An active trap that must be dealt with.</summary>
    ActiveTrap,

    /// <summary>A physical barrier (wall, rubble).</summary>
    PhysicalBarrier,

    /// <summary>An energy field or force barrier.</summary>
    EnergyBarrier
}

/// <summary>
/// Types of checks required for alternative methods.
/// </summary>
public enum AlternativeCheckType
{
    /// <summary>No check required, automatic if prerequisites met.</summary>
    None,

    /// <summary>MIGHT attribute check.</summary>
    Might,

    /// <summary>FINESSE attribute check.</summary>
    Finesse,

    /// <summary>WITS attribute check.</summary>
    Wits,

    /// <summary>Investigation skill check.</summary>
    Investigation,

    /// <summary>Perception skill check.</summary>
    Perception,

    /// <summary>Runecraft skill check.</summary>
    Runecraft,

    /// <summary>Standard attack roll.</summary>
    Attack,

    /// <summary>Social/Charisma-based check.</summary>
    Social
}
```

---

## 6. BruteForceResult Value Object

### 6.1 Value Object Definition

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BruteForceResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the outcome of a brute force bypass attempt.
/// </summary>
/// <param name="Success">Whether the obstacle was overcome.</param>
/// <param name="IsCritical">True if net successes ≥ 5.</param>
/// <param name="IsFumble">True if 0 successes and ≥1 botch.</param>
/// <param name="ObstacleDestroyed">True if the obstacle is now passable.</param>
/// <param name="ConsequencesApplied">List of consequences that occurred.</param>
/// <param name="DamageToCharacter">Any damage taken by the character.</param>
/// <param name="DamageToContents">Any damage to items behind/inside obstacle.</param>
/// <param name="NoiseLevel">How loud the attempt was.</param>
/// <param name="ExhaustionGained">Stamina or exhaustion cost.</param>
/// <param name="ToolBroken">Whether a tool broke during the attempt.</param>
/// <param name="RetryPossible">Whether another attempt can be made.</param>
/// <param name="NewDc">DC for next attempt if retry possible.</param>
/// <param name="NarrativeText">Descriptive text for the outcome.</param>
public readonly record struct BruteForceResult(
    bool Success,
    bool IsCritical,
    bool IsFumble,
    bool ObstacleDestroyed,
    IReadOnlyList<AppliedConsequence> ConsequencesApplied,
    int DamageToCharacter,
    int DamageToContents,
    NoiseLevel NoiseLevel,
    int ExhaustionGained,
    bool ToolBroken,
    bool RetryPossible,
    int NewDc,
    string NarrativeText)
{
    /// <summary>
    /// Creates a successful brute force result.
    /// </summary>
    public static BruteForceResult CreateSuccess(
        bool isCritical,
        IReadOnlyList<AppliedConsequence> consequences,
        NoiseLevel noise,
        string narrative)
    {
        return new BruteForceResult(
            Success: true,
            IsCritical: isCritical,
            IsFumble: false,
            ObstacleDestroyed: true,
            ConsequencesApplied: consequences,
            DamageToCharacter: 0,
            DamageToContents: isCritical ? 0 : CalculateContentDamage(consequences),
            NoiseLevel: isCritical ? ReduceNoise(noise) : noise,
            ExhaustionGained: isCritical ? 0 : CalculateExhaustion(consequences),
            ToolBroken: false,
            RetryPossible: false,
            NewDc: 0,
            NarrativeText: narrative);
    }

    /// <summary>
    /// Creates a failed brute force result.
    /// </summary>
    public static BruteForceResult CreateFailure(
        int attemptNumber,
        int maxAttempts,
        int baseDc,
        int retryPenalty,
        string narrative)
    {
        var canRetry = attemptNumber < maxAttempts;
        var newDc = baseDc + (attemptNumber * retryPenalty);

        return new BruteForceResult(
            Success: false,
            IsCritical: false,
            IsFumble: false,
            ObstacleDestroyed: false,
            ConsequencesApplied: new List<AppliedConsequence>().AsReadOnly(),
            DamageToCharacter: 0,
            DamageToContents: 0,
            NoiseLevel: NoiseLevel.Moderate, // Failed attempts still make noise
            ExhaustionGained: 1, // Some effort expended
            ToolBroken: false,
            RetryPossible: canRetry,
            NewDc: canRetry ? newDc : 0,
            NarrativeText: narrative);
    }

    /// <summary>
    /// Creates a fumble brute force result.
    /// </summary>
    public static BruteForceResult CreateFumble(
        int attemptNumber,
        int maxAttempts,
        int baseDc,
        int retryPenalty,
        bool hadTool,
        string narrative)
    {
        var canRetry = attemptNumber < maxAttempts;
        // Fumble adds +2 permanent DC on top of normal retry penalty
        var newDc = baseDc + (attemptNumber * retryPenalty) + 2;

        var fumbleDamage = new Random().Next(1, 7); // 1d6 damage

        return new BruteForceResult(
            Success: false,
            IsCritical: false,
            IsFumble: true,
            ObstacleDestroyed: false,
            ConsequencesApplied: new List<AppliedConsequence>
            {
                new(ConsequenceType.SelfDamage, $"Took {fumbleDamage} damage from the attempt"),
                new(ConsequenceType.MaxNoise, "Made maximum noise")
            }.AsReadOnly(),
            DamageToCharacter: fumbleDamage,
            DamageToContents: 0,
            NoiseLevel: NoiseLevel.Extreme, // Fumbles are always loud
            ExhaustionGained: 2, // Extra exhaustion from mishap
            ToolBroken: hadTool, // Tool breaks on fumble
            RetryPossible: canRetry,
            NewDc: canRetry ? newDc : 0,
            NarrativeText: narrative);
    }

    private static int CalculateContentDamage(IReadOnlyList<AppliedConsequence> consequences)
    {
        // Check if content damage consequence was applied
        return consequences.Any(c => c.Type == ConsequenceType.ContentDamage)
            ? new Random().Next(1, 11) // 1d10 damage to contents
            : 0;
    }

    private static int CalculateExhaustion(IReadOnlyList<AppliedConsequence> consequences)
    {
        return consequences.Any(c => c.Type == ConsequenceType.Exhaustion) ? 2 : 0;
    }

    private static NoiseLevel ReduceNoise(NoiseLevel original)
    {
        // Critical success reduces noise by one level
        return original switch
        {
            NoiseLevel.Extreme => NoiseLevel.VeryLoud,
            NoiseLevel.VeryLoud => NoiseLevel.Loud,
            NoiseLevel.Loud => NoiseLevel.Moderate,
            NoiseLevel.Moderate => NoiseLevel.Quiet,
            _ => NoiseLevel.Silent
        };
    }

    /// <summary>
    /// Creates a display string for the result.
    /// </summary>
    public string ToDisplayString()
    {
        var lines = new List<string>();

        if (Success)
        {
            lines.Add(IsCritical
                ? "=== CRITICAL SUCCESS ==="
                : "=== SUCCESS ===");
            lines.Add(NarrativeText);
        }
        else if (IsFumble)
        {
            lines.Add("=== FUMBLE! ===");
            lines.Add(NarrativeText);
        }
        else
        {
            lines.Add("=== FAILED ===");
            lines.Add(NarrativeText);
        }

        lines.Add("");

        if (DamageToCharacter > 0)
            lines.Add($"Damage taken: {DamageToCharacter}");

        if (DamageToContents > 0)
            lines.Add($"Contents damaged: {DamageToContents} HP");

        lines.Add($"Noise level: {NoiseLevel}");

        if (ExhaustionGained > 0)
            lines.Add($"Exhaustion: +{ExhaustionGained}");

        if (ToolBroken)
            lines.Add("Tool BROKEN!");

        if (!Success && RetryPossible)
            lines.Add($"May retry at DC {NewDc}");
        else if (!Success && !RetryPossible)
            lines.Add("No more attempts possible.");

        if (ConsequencesApplied.Any())
        {
            lines.Add("");
            lines.Add("Consequences:");
            foreach (var consequence in ConsequencesApplied)
            {
                lines.Add($"  - {consequence.Description}");
            }
        }

        return string.Join(Environment.NewLine, lines);
    }
}

/// <summary>
/// Levels of noise produced by actions.
/// </summary>
public enum NoiseLevel
{
    /// <summary>No sound produced.</summary>
    Silent = 0,

    /// <summary>Barely audible (5 ft radius).</summary>
    Quiet = 1,

    /// <summary>Normal activity level (30 ft radius).</summary>
    Moderate = 2,

    /// <summary>Clearly audible (60 ft radius).</summary>
    Loud = 3,

    /// <summary>Very loud (120 ft radius, alerts guards).</summary>
    VeryLoud = 4,

    /// <summary>Extremely loud (entire area, triggers alarms).</summary>
    Extreme = 5
}

/// <summary>
/// A consequence that was applied during a brute force attempt.
/// </summary>
/// <param name="Type">Category of consequence.</param>
/// <param name="Description">Narrative description of what happened.</param>
public readonly record struct AppliedConsequence(
    ConsequenceType Type,
    string Description);

/// <summary>
/// Types of consequences from brute force attempts.
/// </summary>
public enum ConsequenceType
{
    /// <summary>Noise that may alert nearby creatures.</summary>
    Noise,

    /// <summary>Damage to items behind/inside the obstacle.</summary>
    ContentDamage,

    /// <summary>Physical exhaustion from the effort.</summary>
    Exhaustion,

    /// <summary>Damage to the character attempting.</summary>
    SelfDamage,

    /// <summary>Maximum noise level triggered.</summary>
    MaxNoise,

    /// <summary>Security system alerted.</summary>
    SecurityAlert,

    /// <summary>Structural damage that may affect surroundings.</summary>
    StructuralDamage
}
```

---

## 7. AlternativeBypassService Implementation

### 7.1 Service Definition

**File:** `src/Core/RuneAndRust.Domain/Services/AlternativeBypassService.cs`

```csharp
namespace RuneAndRust.Domain.Services;

/// <summary>
/// Service for handling alternative bypass methods when primary
/// skill-based approaches are unavailable or undesirable.
/// </summary>
/// <remarks>
/// This service ensures that obstacles are never absolute barriers.
/// Every locked door, secured terminal, and active trap has multiple
/// solutions—though each comes with its own trade-offs.
/// </remarks>
public class AlternativeBypassService
{
    private readonly ILogger<AlternativeBypassService> _logger;
    private readonly IDiceRollerService _diceRoller;
    private readonly IConfigurationLoader _config;

    /// <summary>
    /// Initializes a new instance of the AlternativeBypassService.
    /// </summary>
    public AlternativeBypassService(
        ILogger<AlternativeBypassService> logger,
        IDiceRollerService diceRoller,
        IConfigurationLoader config)
    {
        _logger = logger;
        _diceRoller = diceRoller;
        _config = config;
    }

    /// <summary>
    /// Gets the brute force option for a given target.
    /// </summary>
    /// <param name="targetType">Type of physical obstacle.</param>
    /// <param name="targetStrength">Optional strength modifier (1-5) for containers.</param>
    /// <returns>The brute force option with DC and consequences.</returns>
    public BruteForceOption GetBruteForceOption(
        BruteForceTargetType targetType,
        int targetStrength = 3)
    {
        _logger.LogDebug(
            "Getting brute force option for {TargetType} with strength {Strength}",
            targetType, targetStrength);

        return targetType switch
        {
            BruteForceTargetType.SimpleDoor => BruteForceOption.SimpleDoor,
            BruteForceTargetType.ReinforcedDoor => BruteForceOption.ReinforcedDoor,
            BruteForceTargetType.Vault => BruteForceOption.Vault,
            BruteForceTargetType.Container => BruteForceOption.Container(targetStrength),
            _ => throw new ArgumentOutOfRangeException(nameof(targetType))
        };
    }

    /// <summary>
    /// Attempts a brute force bypass of a physical obstacle.
    /// </summary>
    /// <param name="character">Character making the attempt.</param>
    /// <param name="target">The brute force target details.</param>
    /// <param name="context">Context including previous attempts and tools.</param>
    /// <returns>Result of the brute force attempt.</returns>
    public BruteForceResult AttemptBruteForce(
        Character character,
        BruteForceOption target,
        BruteForceContext context)
    {
        _logger.LogInformation(
            "Character {CharacterId} attempting brute force on {TargetType} (attempt {Attempt})",
            character.Id, target.TargetType, context.AttemptNumber);

        // Calculate effective DC
        var effectiveDc = target.GetEffectiveDc(
            context.AttemptNumber - 1,
            context.HasFumbled);

        // Apply tool modifier if available
        if (!string.IsNullOrEmpty(context.ToolUsed))
        {
            var toolMod = target.GetToolModifier(context.ToolUsed);
            effectiveDc += toolMod;
            _logger.LogDebug("Tool {Tool} modifies DC by {Modifier}",
                context.ToolUsed, toolMod);
        }

        // Build dice pool from MIGHT
        var mightDice = character.GetAttribute(AttributeType.Might);
        var dicePool = mightDice;

        // Apply tool bonus dice
        if (!string.IsNullOrEmpty(context.ToolUsed))
        {
            dicePool += GetToolBonusDice(context.ToolUsed);
        }

        // Apply assistance bonus
        if (context.AssistingCharacters > 0)
        {
            dicePool += Math.Min(context.AssistingCharacters, 2); // Max +2d10
        }

        // Apply exhaustion penalty
        if (context.ExhaustionLevel > 0)
        {
            dicePool -= context.ExhaustionLevel / 2;
        }

        dicePool = Math.Max(1, dicePool); // Minimum 1 die

        // Roll the dice
        var rollResult = _diceRoller.RollPool(dicePool);
        var netSuccesses = rollResult.Successes - rollResult.Botches;

        _logger.LogDebug(
            "Brute force roll: {Dice}d10, {Successes} successes, {Botches} botches, net {Net}",
            dicePool, rollResult.Successes, rollResult.Botches, netSuccesses);

        // Determine outcome
        if (rollResult.Successes == 0 && rollResult.Botches > 0)
        {
            // FUMBLE
            return CreateFumbleResult(target, context);
        }
        else if (netSuccesses > 0)
        {
            // SUCCESS
            var isCritical = netSuccesses >= 5;
            return CreateSuccessResult(target, isCritical);
        }
        else
        {
            // FAILURE
            return CreateFailureResult(target, context);
        }
    }

    /// <summary>
    /// Gets all alternative methods for a given obstacle type.
    /// </summary>
    /// <param name="obstacleType">Type of obstacle.</param>
    /// <returns>Available alternative methods.</returns>
    public IEnumerable<AlternativeMethod> GetAlternatives(ObstacleType obstacleType)
    {
        _logger.LogDebug("Getting alternatives for {ObstacleType}", obstacleType);
        return AlternativeMethod.GetAlternativesFor(obstacleType);
    }

    /// <summary>
    /// Evaluates whether a character can attempt an alternative method.
    /// </summary>
    /// <param name="character">Character attempting the method.</param>
    /// <param name="method">The alternative method to evaluate.</param>
    /// <param name="context">Current game context.</param>
    /// <returns>Evaluation result with any missing prerequisites.</returns>
    public AlternativeEvaluationResult EvaluateAlternative(
        Character character,
        AlternativeMethod method,
        GameContext context)
    {
        var missingPrereqs = new List<string>();

        foreach (var prereq in method.Prerequisites)
        {
            if (!MeetsPrerequisite(character, prereq, context))
            {
                missingPrereqs.Add(prereq);
            }
        }

        return new AlternativeEvaluationResult(
            CanAttempt: !missingPrereqs.Any(),
            MissingPrerequisites: missingPrereqs.AsReadOnly(),
            EstimatedDifficulty: GetDifficultyDescription(method.CheckDc),
            RecommendedApproach: missingPrereqs.Any()
                ? "Acquire missing prerequisites first"
                : "Ready to attempt");
    }

    /// <summary>
    /// Determines if a retry is possible for a given target.
    /// </summary>
    public bool CanRetry(BruteForceOption target, int attemptsMade)
    {
        return target.CanRetry(attemptsMade);
    }

    /// <summary>
    /// Gets the DC for a retry attempt.
    /// </summary>
    public int GetRetryDc(
        BruteForceOption target,
        int attemptsMade,
        bool hasFumbled)
    {
        return target.GetEffectiveDc(attemptsMade, hasFumbled);
    }

    // ==========================================================================
    // PRIVATE HELPERS
    // ==========================================================================

    private BruteForceResult CreateSuccessResult(
        BruteForceOption target,
        bool isCritical)
    {
        var consequences = ApplyConsequences(target.Consequences, isCritical);
        var noise = DetermineNoiseLevel(target.Consequences, isCritical);

        var narrative = isCritical
            ? GenerateCriticalSuccessNarrative(target.TargetType)
            : GenerateSuccessNarrative(target.TargetType);

        return BruteForceResult.CreateSuccess(
            isCritical,
            consequences,
            noise,
            narrative);
    }

    private BruteForceResult CreateFailureResult(
        BruteForceOption target,
        BruteForceContext context)
    {
        var narrative = GenerateFailureNarrative(target.TargetType, context.AttemptNumber);

        return BruteForceResult.CreateFailure(
            context.AttemptNumber,
            target.MaxAttempts,
            target.BaseDc,
            target.RetryPenaltyPerAttempt,
            narrative);
    }

    private BruteForceResult CreateFumbleResult(
        BruteForceOption target,
        BruteForceContext context)
    {
        var narrative = GenerateFumbleNarrative(target.TargetType);

        return BruteForceResult.CreateFumble(
            context.AttemptNumber,
            target.MaxAttempts,
            target.BaseDc,
            target.RetryPenaltyPerAttempt,
            !string.IsNullOrEmpty(context.ToolUsed),
            narrative);
    }

    private IReadOnlyList<AppliedConsequence> ApplyConsequences(
        IReadOnlyList<BruteForceConsequence> consequences,
        bool isCritical)
    {
        var applied = new List<AppliedConsequence>();

        foreach (var consequence in consequences)
        {
            // Critical success may avoid some consequences
            if (isCritical && consequence.CanBeAvoidedOnCritical)
                continue;

            // Check probability-based consequences
            if (consequence.Probability < 1.0f)
            {
                if (Random.Shared.NextSingle() > consequence.Probability)
                    continue;
            }

            applied.Add(new AppliedConsequence(
                consequence.Type,
                consequence.GetNarrativeDescription()));
        }

        return applied.AsReadOnly();
    }

    private NoiseLevel DetermineNoiseLevel(
        IReadOnlyList<BruteForceConsequence> consequences,
        bool isCritical)
    {
        var maxNoise = consequences
            .Where(c => c.Type == ConsequenceType.Noise ||
                       c.Type == ConsequenceType.MaxNoise)
            .Select(c => c.NoiseLevel)
            .DefaultIfEmpty(NoiseLevel.Moderate)
            .Max();

        return isCritical ? ReduceNoiseLevel(maxNoise) : maxNoise;
    }

    private static NoiseLevel ReduceNoiseLevel(NoiseLevel level)
    {
        return level switch
        {
            NoiseLevel.Extreme => NoiseLevel.VeryLoud,
            NoiseLevel.VeryLoud => NoiseLevel.Loud,
            NoiseLevel.Loud => NoiseLevel.Moderate,
            _ => level
        };
    }

    private int GetToolBonusDice(string toolName)
    {
        return toolName.ToLowerInvariant() switch
        {
            "crowbar" => 1,
            "sledgehammer" => 2,
            "breaching charge" => 2,
            "industrial cutter" => 2,
            _ => 0
        };
    }

    private bool MeetsPrerequisite(Character character, string prereq, GameContext context)
    {
        // Check common prerequisites
        if (prereq.Contains("[Rune Sight]"))
            return character.HasAbility("Rune Sight");

        if (prereq.Contains("Runecraft skill"))
            return character.HasSkill("Runecraft");

        if (prereq.Contains("Secondary terminal"))
            return context.HasSecondaryTerminal;

        if (prereq.Contains("Wire or cable"))
            return character.HasItem("Wire") || character.HasItem("Cable");

        if (prereq.Contains("User Level access"))
            return context.CurrentAccessLevel >= AccessLevel.UserLevel;

        // Default: assume prerequisite is met if not specifically checked
        return true;
    }

    private string GetDifficultyDescription(int dc) => dc switch
    {
        <= 10 => "Easy",
        <= 14 => "Moderate",
        <= 18 => "Challenging",
        <= 22 => "Hard",
        _ => "Very Hard"
    };

    private string GenerateCriticalSuccessNarrative(BruteForceTargetType target)
    {
        return target switch
        {
            BruteForceTargetType.SimpleDoor =>
                "With a precise strike, the door gives way cleanly. The hinges surrender without protest, and the opening is clear.",
            BruteForceTargetType.ReinforcedDoor =>
                "You find the weak point in the reinforcement. One powerful blow, and the door buckles inward with minimal noise.",
            BruteForceTargetType.Vault =>
                "The vault door groans under your assault, and ancient seals finally give way. The interior appears undisturbed.",
            BruteForceTargetType.Container =>
                "The lock mechanism snaps cleanly, and the container opens without damaging the contents within.",
            _ => "The obstacle yields to your strength."
        };
    }

    private string GenerateSuccessNarrative(BruteForceTargetType target)
    {
        return target switch
        {
            BruteForceTargetType.SimpleDoor =>
                "The door crashes inward with a resounding bang. Splinters scatter across the floor.",
            BruteForceTargetType.ReinforcedDoor =>
                "Metal screeches against metal as the door finally gives way. The noise echoes through the corridors.",
            BruteForceTargetType.Vault =>
                "After tremendous effort, the vault door surrenders. Your muscles ache, but the way is open.",
            BruteForceTargetType.Container =>
                "The container bursts open. Some contents may have shifted roughly.",
            _ => "The obstacle is destroyed."
        };
    }

    private string GenerateFailureNarrative(BruteForceTargetType target, int attempt)
    {
        var attemptText = attempt > 1 ? $"Despite your {attempt} attempts, " : "";

        return target switch
        {
            BruteForceTargetType.SimpleDoor =>
                $"{attemptText}the door holds firm. You'll need to try harder.",
            BruteForceTargetType.ReinforcedDoor =>
                $"{attemptText}the reinforced door refuses to yield. Perhaps a different approach?",
            BruteForceTargetType.Vault =>
                $"{attemptText}the vault door remains sealed. This will require significant effort.",
            BruteForceTargetType.Container =>
                $"{attemptText}the container's lock resists your force.",
            _ => "The obstacle remains intact."
        };
    }

    private string GenerateFumbleNarrative(BruteForceTargetType target)
    {
        return target switch
        {
            BruteForceTargetType.SimpleDoor =>
                "Your strike goes wide! You stumble into the doorframe, taking damage from the impact.",
            BruteForceTargetType.ReinforcedDoor =>
                "The door doesn't budge, but something in your shoulder does. Pain shoots through your arm.",
            BruteForceTargetType.Vault =>
                "A hidden mechanism triggers as you strike wrong—sparks fly and you jerk back, burned.",
            BruteForceTargetType.Container =>
                "Your tool slips, gashing your hand. Blood drips onto the unyielding container.",
            _ => "Something goes wrong. You take damage from your own effort."
        };
    }
}

/// <summary>
/// Context for a brute force attempt.
/// </summary>
/// <param name="AttemptNumber">Which attempt this is (1-based).</param>
/// <param name="HasFumbled">Whether a fumble occurred in previous attempts.</param>
/// <param name="ToolUsed">Name of tool being used, if any.</param>
/// <param name="AssistingCharacters">Number of characters helping.</param>
/// <param name="ExhaustionLevel">Current exhaustion level.</param>
public readonly record struct BruteForceContext(
    int AttemptNumber,
    bool HasFumbled,
    string? ToolUsed,
    int AssistingCharacters,
    int ExhaustionLevel);

/// <summary>
/// Result of evaluating whether an alternative method can be attempted.
/// </summary>
/// <param name="CanAttempt">Whether all prerequisites are met.</param>
/// <param name="MissingPrerequisites">List of unmet prerequisites.</param>
/// <param name="EstimatedDifficulty">Descriptive difficulty level.</param>
/// <param name="RecommendedApproach">Suggestion for the player.</param>
public readonly record struct AlternativeEvaluationResult(
    bool CanAttempt,
    IReadOnlyList<string> MissingPrerequisites,
    string EstimatedDifficulty,
    string RecommendedApproach);
```

---

## 8. Consequence System

### 8.1 BruteForceConsequence Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BruteForceConsequence.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a potential consequence of a brute force attempt.
/// Consequences balance the power of brute force with appropriate trade-offs.
/// </summary>
/// <param name="Type">Category of consequence.</param>
/// <param name="NoiseLevel">Noise level if this is a noise consequence.</param>
/// <param name="Probability">Chance this consequence applies (0.0-1.0).</param>
/// <param name="CanBeAvoidedOnCritical">Whether critical success avoids this.</param>
/// <param name="SeverityRating">How impactful this consequence is (1-5).</param>
public readonly record struct BruteForceConsequence(
    ConsequenceType Type,
    NoiseLevel NoiseLevel,
    float Probability,
    bool CanBeAvoidedOnCritical,
    int SeverityRating)
{
    /// <summary>
    /// Loud noise that alerts nearby (60 ft radius).
    /// </summary>
    public static BruteForceConsequence LoudNoise => new(
        Type: ConsequenceType.Noise,
        NoiseLevel: NoiseLevel.Loud,
        Probability: 1.0f,
        CanBeAvoidedOnCritical: true,
        SeverityRating: 2);

    /// <summary>
    /// Very loud noise that alerts guards (120 ft radius).
    /// </summary>
    public static BruteForceConsequence VeryLoudNoise => new(
        Type: ConsequenceType.Noise,
        NoiseLevel: NoiseLevel.VeryLoud,
        Probability: 1.0f,
        CanBeAvoidedOnCritical: true,
        SeverityRating: 3);

    /// <summary>
    /// Risk of damaging contents (50% chance).
    /// </summary>
    public static BruteForceConsequence ContentDamageRisk => new(
        Type: ConsequenceType.ContentDamage,
        NoiseLevel: NoiseLevel.Silent,
        Probability: 0.5f,
        CanBeAvoidedOnCritical: true,
        SeverityRating: 3);

    /// <summary>
    /// Physical exhaustion from the effort.
    /// </summary>
    public static BruteForceConsequence Exhausting => new(
        Type: ConsequenceType.Exhaustion,
        NoiseLevel: NoiseLevel.Silent,
        Probability: 1.0f,
        CanBeAvoidedOnCritical: true,
        SeverityRating: 2);

    /// <summary>
    /// Gets a narrative description of this consequence.
    /// </summary>
    public string GetNarrativeDescription() => Type switch
    {
        ConsequenceType.Noise when NoiseLevel == NoiseLevel.Loud =>
            "The noise echoes through nearby corridors.",
        ConsequenceType.Noise when NoiseLevel == NoiseLevel.VeryLoud =>
            "The tremendous crash could be heard throughout the building.",
        ConsequenceType.ContentDamage =>
            "Some items behind the obstacle may have been damaged.",
        ConsequenceType.Exhaustion =>
            "The effort leaves you winded.",
        ConsequenceType.SelfDamage =>
            "You hurt yourself in the attempt.",
        ConsequenceType.SecurityAlert =>
            "A security system has been triggered.",
        ConsequenceType.StructuralDamage =>
            "The surrounding structure shows signs of stress.",
        _ => "An unexpected consequence occurred."
    };

    /// <summary>
    /// Creates a display string for this consequence.
    /// </summary>
    public string ToDisplayString()
    {
        var avoidable = CanBeAvoidedOnCritical ? " (avoided on critical)" : "";
        var probability = Probability < 1.0f ? $" ({Probability:P0} chance)" : "";

        return Type switch
        {
            ConsequenceType.Noise => $"{NoiseLevel} noise{avoidable}",
            ConsequenceType.ContentDamage => $"Content damage risk{probability}{avoidable}",
            ConsequenceType.Exhaustion => $"Exhausting{avoidable}",
            _ => $"{Type}{probability}{avoidable}"
        };
    }
}
```

### 8.2 Consequence Resolution Table

| Consequence Type | Trigger | Effect | Can Avoid on Critical |
|-----------------|---------|--------|----------------------|
| Loud Noise | Always on success | Alerts within 60 ft radius | Yes (reduced to Moderate) |
| Very Loud Noise | Always on success | Alerts within 120 ft radius | Yes (reduced to Loud) |
| Content Damage | 50% on success | 1d10 damage to items inside | Yes |
| Exhaustion | Always on vault | +2 exhaustion levels | Yes |
| Self Damage | On fumble | 1d6 damage to character | No |
| Max Noise | On fumble | Extreme noise (entire area) | No |
| Tool Broken | On fumble with tool | Tool destroyed | No |

---

## 9. Obstacle-Specific Alternatives

### 9.1 Locked Door Alternatives

| Method | Check | DC | Time | Primary Consequence |
|--------|-------|-----|------|---------------------|
| Find Key | Investigation | 14 | 10-30 min | Time, encounters |
| Brute Force | MIGHT | 12-22 | 1-3 rounds | Noise |
| Runic Bypass | Runecraft | 16 | 1 round | Essence cost |
| Alternate Route | Perception | 14 | 5-20 min | Path hazards |

### 9.2 Secured Terminal Alternatives

| Method | Check | DC | Time | Primary Consequence |
|--------|-------|-----|------|---------------------|
| Find Codes | Investigation | 16 | 5-15 min | Time, encounters |
| Hotwire Terminal | WITS | 14 | 2-5 rounds | Reduced access |
| Accept Partial | None | — | Immediate | Incomplete info |

### 9.3 Active Trap Alternatives

| Method | Check | DC | Time | Primary Consequence |
|--------|-------|-----|------|---------------------|
| Trigger Distance | FINESSE | 12 | 1 round | Noise, area damage |
| Destroy Mechanism | Attack | AC-based | 1 round | May trigger |
| Sacrifice Item | None | — | 1 round | Resource cost |

---

## 10. Data Model Changes

### 10.1 New Value Objects

| Value Object | Layer | Description |
|-------------|-------|-------------|
| `BruteForceOption` | Domain | Physical obstacle forcing parameters |
| `AlternativeMethod` | Domain | Non-skill bypass approach |
| `BruteForceResult` | Domain | Outcome of brute force attempt |
| `BruteForceConsequence` | Domain | Potential consequence definition |
| `AppliedConsequence` | Domain | Consequence that occurred |
| `BruteForceContext` | Domain | Context for attempt |
| `AlternativeEvaluationResult` | Domain | Prerequisite check result |
| `ToolModifier` | Domain | Tool DC modifier |

### 10.2 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `BruteForceTargetType` | Domain | Physical obstacle classifications |
| `ObstacleType` | Domain | General obstacle types |
| `AlternativeCheckType` | Domain | Types of checks for alternatives |
| `ConsequenceType` | Domain | Categories of consequences |
| `NoiseLevel` | Domain | Sound levels produced |

---

## 11. Configuration Files

### 11.1 brute-force-options.json

**File:** `config/brute-force-options.json`

```json
{
  "$schema": "./schemas/brute-force-options.schema.json",
  "version": "0.15.4h",
  "bruteForceTargets": [
    {
      "targetType": "SimpleDoor",
      "baseDc": 12,
      "maxAttempts": 5,
      "retryPenalty": 1,
      "hitPoints": 20,
      "consequences": [
        {
          "type": "Noise",
          "noiseLevel": "Loud",
          "probability": 1.0,
          "avoidableOnCritical": true
        }
      ],
      "toolModifiers": [
        { "tool": "Crowbar", "dcModifier": -2 },
        { "tool": "Sledgehammer", "dcModifier": -4 }
      ],
      "narratives": {
        "criticalSuccess": "With a precise strike, the door gives way cleanly.",
        "success": "The door crashes inward with a resounding bang.",
        "failure": "The door holds firm. You'll need to try harder.",
        "fumble": "Your strike goes wide! You stumble into the doorframe."
      }
    },
    {
      "targetType": "ReinforcedDoor",
      "baseDc": 16,
      "maxAttempts": 3,
      "retryPenalty": 2,
      "hitPoints": 40,
      "consequences": [
        {
          "type": "Noise",
          "noiseLevel": "VeryLoud",
          "probability": 1.0,
          "avoidableOnCritical": true
        },
        {
          "type": "ContentDamage",
          "probability": 0.5,
          "avoidableOnCritical": true
        }
      ],
      "toolModifiers": [
        { "tool": "Crowbar", "dcModifier": -2 },
        { "tool": "Sledgehammer", "dcModifier": -3 },
        { "tool": "Breaching Charge", "dcModifier": -6 }
      ]
    },
    {
      "targetType": "Vault",
      "baseDc": 22,
      "maxAttempts": 2,
      "retryPenalty": 3,
      "hitPoints": 80,
      "consequences": [
        {
          "type": "Noise",
          "noiseLevel": "VeryLoud",
          "probability": 1.0,
          "avoidableOnCritical": true
        },
        {
          "type": "Exhaustion",
          "probability": 1.0,
          "avoidableOnCritical": true
        },
        {
          "type": "ContentDamage",
          "probability": 0.5,
          "avoidableOnCritical": true
        }
      ],
      "toolModifiers": [
        { "tool": "Sledgehammer", "dcModifier": -2 },
        { "tool": "Breaching Charge", "dcModifier": -4 },
        { "tool": "Industrial Cutter", "dcModifier": -6 }
      ]
    },
    {
      "targetType": "Container",
      "baseDcBase": 8,
      "baseDcPerStrength": 2,
      "maxAttempts": 3,
      "retryPenalty": 1,
      "hitPointsBase": 10,
      "hitPointsPerStrength": 5,
      "consequences": [
        {
          "type": "Noise",
          "noiseLevel": "Loud",
          "probability": 1.0,
          "avoidableOnCritical": true
        },
        {
          "type": "ContentDamage",
          "probability": 0.5,
          "avoidableOnCritical": true
        }
      ],
      "toolModifiers": [
        { "tool": "Crowbar", "dcModifier": -2 },
        { "tool": "Knife", "dcModifier": -1 }
      ]
    }
  ],
  "environmentModifiers": [
    { "condition": "PartiallyDamaged", "dcModifier": -4 },
    { "condition": "ReinforcedHinges", "dcModifier": 2 },
    { "condition": "JotunForged", "dcModifier": 4 }
  ],
  "fumbleEffects": {
    "baseDamage": "1d6",
    "additionalDcPenalty": 2,
    "toolBreaksOnFumble": true,
    "noiseLevel": "Extreme"
  }
}
```

### 11.2 alternative-methods.json

**File:** `config/alternative-methods.json`

```json
{
  "$schema": "./schemas/alternative-methods.schema.json",
  "version": "0.15.4h",
  "alternatives": {
    "LockedDoor": [
      {
        "methodId": "alt_door_find_key",
        "methodName": "Find Key",
        "description": "Search nearby areas or negotiate with someone who has the key.",
        "requiredCheck": "Investigation",
        "checkDc": 14,
        "timeRequired": "10-30 minutes",
        "consequences": [
          "Time spent searching",
          "May trigger random encounters",
          "Social interaction may require favors or payment"
        ],
        "prerequisites": []
      },
      {
        "methodId": "alt_door_brute_force",
        "methodName": "Brute Force",
        "description": "Use raw strength to break down the door.",
        "requiredCheck": "Might",
        "checkDc": 12,
        "timeRequired": "1-3 rounds",
        "consequences": [
          "Loud noise alerts nearby",
          "Contents behind door may be damaged",
          "Multiple attempts cause exhaustion"
        ],
        "prerequisites": []
      },
      {
        "methodId": "alt_door_runic_bypass",
        "methodName": "Runic Bypass",
        "description": "Manipulate the lock's runic bindings to release the mechanism.",
        "requiredCheck": "Runecraft",
        "checkDc": 16,
        "timeRequired": "1 round",
        "consequences": [
          "Essence cost (1-3 points)",
          "Potential corruption exposure",
          "May trigger runic alarms"
        ],
        "prerequisites": [
          "[Rune Sight] ability or equivalent",
          "Runecraft skill trained"
        ]
      },
      {
        "methodId": "alt_door_alternate_route",
        "methodName": "Alternate Route",
        "description": "Find another path: ventilation shaft, window, or collapsed wall.",
        "requiredCheck": "Perception",
        "checkDc": 14,
        "timeRequired": "5-20 minutes",
        "consequences": [
          "Time spent exploring",
          "Alternate paths may have their own hazards",
          "May not be accessible for all party members"
        ],
        "prerequisites": []
      }
    ],
    "SecuredTerminal": [
      {
        "methodId": "alt_terminal_find_codes",
        "methodName": "Find Codes",
        "description": "Search for written passwords or credentials in the area.",
        "requiredCheck": "Investigation",
        "checkDc": 16,
        "timeRequired": "5-15 minutes",
        "consequences": [
          "Time spent searching",
          "Codes may be expired or single-use",
          "May find partial codes only"
        ],
        "prerequisites": []
      },
      {
        "methodId": "alt_terminal_hotwire",
        "methodName": "Hotwire to Different Terminal",
        "description": "Bypass this terminal by connecting to a less secured access point.",
        "requiredCheck": "Wits",
        "checkDc": 14,
        "timeRequired": "2-5 rounds",
        "consequences": [
          "Reduced access level (User instead of Admin)",
          "Connection may be unstable",
          "May trigger ICE on secondary terminal"
        ],
        "prerequisites": [
          "Secondary terminal must exist in area",
          "Wire or cable available"
        ]
      },
      {
        "methodId": "alt_terminal_partial",
        "methodName": "Accept Partial Access",
        "description": "Stop at User Level access rather than pursuing Admin Level.",
        "requiredCheck": "None",
        "checkDc": 0,
        "timeRequired": "Immediate",
        "consequences": [
          "Cannot access hidden or classified files",
          "Limited functionality available",
          "May need to return later with better access"
        ],
        "prerequisites": [
          "Must have achieved at least User Level access"
        ]
      }
    ],
    "ActiveTrap": [
      {
        "methodId": "alt_trap_trigger_distance",
        "methodName": "Trigger from Distance",
        "description": "Throw an object or use ranged attack to safely trigger the trap.",
        "requiredCheck": "Finesse",
        "checkDc": 12,
        "timeRequired": "1 round",
        "consequences": [
          "Noise from trap activation",
          "Trap effects apply to area (may destroy loot)",
          "Consumes thrown object"
        ],
        "prerequisites": [
          "Object to throw or ranged weapon",
          "Line of sight to trigger mechanism"
        ]
      },
      {
        "methodId": "alt_trap_destroy",
        "methodName": "Destroy Mechanism",
        "description": "Attack the trap mechanism directly to disable it.",
        "requiredCheck": "Attack",
        "checkDc": 0,
        "timeRequired": "1 round",
        "consequences": [
          "Noise from destruction",
          "Trap may trigger if not destroyed in one hit",
          "No salvageable components"
        ],
        "prerequisites": [
          "Weapon or damaging ability"
        ]
      },
      {
        "methodId": "alt_trap_sacrifice",
        "methodName": "Sacrifice (Shield/Item)",
        "description": "Block trap effect with shield or absorb with expendable item.",
        "requiredCheck": "None",
        "checkDc": 0,
        "timeRequired": "1 round",
        "consequences": [
          "Shield takes damage (may break)",
          "Consumable item destroyed",
          "Trap still triggers alert systems"
        ],
        "prerequisites": [
          "Shield or expendable item available",
          "Item must be appropriate for trap type"
        ]
      }
    ]
  }
}
```

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `AlternativeBypassService` | Information | Brute force attempts, alternative method usage |
| `AlternativeBypassService` | Debug | DC calculations, dice pool composition, modifier application |
| `AlternativeBypassService` | Warning | Retry limit approached, fumble occurred |
| `AlternativeBypassService` | Error | Invalid target type, configuration errors |

### 12.2 Sample Log Messages

```
[Information] Character char_123 attempting brute force on ReinforcedDoor (attempt 1)
[Debug] Effective DC: 16 (base) + 0 (attempts) - 2 (crowbar) = 14
[Debug] Dice pool: 4 (MIGHT) + 1 (crowbar) + 1 (assist) = 6d10
[Debug] Brute force roll: 6d10, 3 successes, 1 botches, net 2
[Information] Brute force SUCCESS on ReinforcedDoor - consequences applied: VeryLoud noise
[Warning] Character char_123 FUMBLED brute force on Vault - damage 4, tool broken
[Debug] Getting alternatives for SecuredTerminal: 3 methods available
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Brute Force DC Calculation | 1 |
| Consequence Application | 1 |
| **Total** | **~2** |

### 13.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.Tests/Services/AlternativeBypassServiceTests.cs`

```csharp
[TestFixture]
public class AlternativeBypassServiceTests
{
    private AlternativeBypassService _service;
    private Mock<ILogger<AlternativeBypassService>> _logger;
    private Mock<IDiceRollerService> _diceRoller;
    private Mock<IConfigurationLoader> _config;

    [SetUp]
    public void SetUp()
    {
        _logger = new Mock<ILogger<AlternativeBypassService>>();
        _diceRoller = new Mock<IDiceRollerService>();
        _config = new Mock<IConfigurationLoader>();
        _service = new AlternativeBypassService(
            _logger.Object, _diceRoller.Object, _config.Object);
    }

    [Test]
    public void BruteForce_AppliesCorrectDc_BasedOnTargetType()
    {
        // Arrange
        var simpleDoor = _service.GetBruteForceOption(BruteForceTargetType.SimpleDoor);
        var reinforcedDoor = _service.GetBruteForceOption(BruteForceTargetType.ReinforcedDoor);
        var vault = _service.GetBruteForceOption(BruteForceTargetType.Vault);
        var container = _service.GetBruteForceOption(BruteForceTargetType.Container, 3);

        // Assert
        Assert.That(simpleDoor.BaseDc, Is.EqualTo(12));
        Assert.That(reinforcedDoor.BaseDc, Is.EqualTo(16));
        Assert.That(vault.BaseDc, Is.EqualTo(22));
        Assert.That(container.BaseDc, Is.EqualTo(14)); // 8 + (3 * 2)
    }

    [Test]
    public void BruteForceConsequences_ApplyCorrectly_OnSuccess()
    {
        // Arrange
        var character = TestCharacterFactory.CreateWithMight(4);
        var target = BruteForceOption.ReinforcedDoor;
        var context = new BruteForceContext(
            AttemptNumber: 1,
            HasFumbled: false,
            ToolUsed: null,
            AssistingCharacters: 0,
            ExhaustionLevel: 0);

        // Mock dice roll for success
        _diceRoller
            .Setup(d => d.RollPool(It.IsAny<int>()))
            .Returns(new DicePoolResult(Successes: 3, Botches: 0));

        // Act
        var result = _service.AttemptBruteForce(character, target, context);

        // Assert
        Assert.That(result.Success, Is.True);
        Assert.That(result.NoiseLevel, Is.EqualTo(NoiseLevel.VeryLoud));
        Assert.That(result.ConsequencesApplied, Is.Not.Empty);
    }
}
```

---

## 14. Use Cases

### UC-001: Brute Force Simple Door

**Actor:** Player
**Flow:** Encounter locked door → Select brute force option → Roll MIGHT check → Door destroyed → Noise consequence alerts nearby enemies

### UC-002: Brute Force with Tool

**Actor:** Player
**Flow:** Encounter reinforced door → Equip crowbar → Select brute force → Apply -2 DC modifier → Roll MIGHT check → Calculate consequences

### UC-003: Failed Brute Force Retry

**Actor:** Player
**Flow:** First brute force attempt fails → DC increased by +1 → Second attempt → Success or continue retry cycle

### UC-004: Brute Force Fumble

**Actor:** Player
**Flow:** Roll brute force → 0 successes, 1+ botches → Take 1d6 damage → Tool breaks → DC permanently +2 → Maximum noise alert

### UC-005: Alternative Method Selection

**Actor:** Player
**Flow:** View locked door → Check alternatives → See 4 options → Select "Find Key" → Investigation check → Time passes → Key found or continue searching

### UC-006: Accept Partial Terminal Access

**Actor:** Player
**Flow:** Fail terminal hack Layer 2 → Select "Accept Partial Access" → Gain User Level → Access limited files → Note need to return later

---

## 15. Deliverable Checklist

### Value Objects
- [ ] `BruteForceOption` value object created
- [ ] `AlternativeMethod` value object created
- [ ] `BruteForceResult` value object created
- [ ] `BruteForceConsequence` value object created
- [ ] `AppliedConsequence` value object created
- [ ] `BruteForceContext` value object created
- [ ] `AlternativeEvaluationResult` value object created
- [ ] `ToolModifier` value object created

### Enums
- [ ] `BruteForceTargetType` enum created
- [ ] `ObstacleType` enum created
- [ ] `AlternativeCheckType` enum created
- [ ] `ConsequenceType` enum created
- [ ] `NoiseLevel` enum created

### Services
- [ ] `AlternativeBypassService` implemented

### Configuration Files
- [ ] `config/brute-force-options.json` created
- [ ] `config/alternative-methods.json` created
- [ ] `config/schemas/brute-force-options.schema.json` created
- [ ] `config/schemas/alternative-methods.schema.json` created

### Testing
- [ ] ~2 unit tests implemented
- [ ] All tests passing

---

## 16. Acceptance Criteria

### Functional
- [ ] Brute force DC correctly calculated for each target type
- [ ] Tool modifiers reduce DC appropriately
- [ ] Retry penalty increases DC after each failed attempt
- [ ] Fumble adds permanent +2 DC and damages character
- [ ] Critical success reduces noise and avoids some consequences
- [ ] Alternative methods listed for each obstacle type
- [ ] Prerequisites correctly evaluated for alternatives
- [ ] Content damage consequence applies with 50% probability

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~2 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete on all public members

---

## 17. Dependencies

### 17.1 Required from Previous Versions

| Type | Location | Usage |
|------|----------|-------|
| `DicePoolResult` | v0.15.0 | Dice roll results with successes/botches |
| `Character` | Core Domain | Character attributes for checks |
| `LockContext` | v0.15.4a | Integration with lockpicking system |
| `TerminalInfiltrationState` | v0.15.4b | Integration with terminal hacking |
| `TrapDisarmState` | v0.15.4d | Integration with trap disarmament |
| `IDiceRollerService` | Infrastructure | Rolling dice pools |

### 17.2 Provides to Future Versions

| Type | Usage |
|------|-------|
| `BruteForceOption` | Encounter design with forceable obstacles |
| `AlternativeMethod` | Obstacle puzzle variety |
| `NoiseLevel` | Stealth system integration |
| `AlternativeBypassService` | Unified fallback for all bypass attempts |

### 17.3 Integration Points

- **LockpickingService**: When character lacks picks or skill, offers brute force alternative
- **TerminalHackingService**: When locked out, offers find codes or accept partial alternatives
- **TrapDisarmamentService**: When disarm fails, offers trigger from distance or destroy alternatives
- **EncounterSystem**: Noise consequences feed into alert and spawn logic

---

## 18. Future Considerations

### 18.1 Deferred to v0.15.4i

- **Specialization bonuses** for brute force (Brawler archetype)
- **Gantry-Runner's** reduced noise on brute force
- **Integration with party abilities** that modify alternatives

### 18.2 Deferred to Future Versions

- **Environmental destruction** (breaking walls, creating new paths)
- **Stealth brute force** (muffled sledgehammer, controlled demolition)
- **Group brute force** (multiple characters combining strength checks)
- **Equipment durability** from brute force usage

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*
