# v0.3.1c Design Specification: Prerequisites & Distribution

## Overview

**Version:** 0.3.1c
**Parent:** v0.3.1 (Quest Rewards & NPCs)
**Prerequisites:** v0.3.1b Complete (Quest Giver NPCs)
**Status:** Design Complete
**Estimated Unit Tests:** ~20

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Data Models](#5-data-models)
6. [Configuration Schemas](#6-configuration-schemas)
7. [Service Specifications](#7-service-specifications)
8. [User-Facing Changes](#8-user-facing-changes)
9. [Logging Requirements](#9-logging-requirements)
10. [Unit Test Specifications](#10-unit-test-specifications)
11. [Use Cases](#11-use-cases)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

This phase implements quest prerequisites that control when quests become available to players and the reward distribution service that delivers rewards when quests are turned in. Prerequisites support level, reputation, quest completion, and item requirements. The QuestRewardService handles XP, gold, item, and reputation delivery upon quest completion, including support for choice rewards established in v0.3.1a.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Value Objects** | QuestPrerequisite, RewardDistributionResult, RewardChoiceGroup |
| **Enums** | PrerequisiteType |
| **Services** | IQuestRewardService, QuestRewardService |
| **Definition Updates** | QuestDefinition with Prerequisites |
| **Turn-in Flow** | Complete reward delivery with choice handling |
| **Tests** | ~20 new unit tests |

### Architectural Significance

This version establishes the **prerequisite and distribution patterns** that will be extended throughout future versions:
- Prerequisites as configurable value objects with evaluation logic
- Reward distribution service integrating with XP, gold, inventory, and reputation systems
- Choice reward handling during turn-in dialogue
- Foundation for quest chains (v0.3.2) and advanced prerequisites

---

## 2. Feature Overview

```
v0.3.1c Features
├── QuestPrerequisite Value Object
│   ├── Type (PrerequisiteType enum)
│   ├── TargetId (quest ID, faction ID, item ID)
│   ├── RequiredValue (level, reputation, quantity)
│   ├── IsNegated (must NOT have)
│   ├── Description (display text)
│   ├── Factory Methods
│   │   ├── Level(minLevel)
│   │   ├── Reputation(factionId, minRep)
│   │   ├── QuestComplete(questId)
│   │   └── HasItem(itemId, quantity)
│   └── Evaluate(Player) method
├── PrerequisiteType Enum
│   ├── Level
│   ├── Reputation
│   ├── Quest
│   ├── Item
│   ├── Class (future)
│   └── Skill (future)
├── QuestDefinition Updates
│   ├── Prerequisites collection
│   ├── GetUnmetPrerequisites(Player)
│   └── MeetsPrerequisites(Player)
├── IQuestRewardService Interface
│   ├── DistributeRewards(player, quest)
│   ├── DistributeRewards(player, quest, choices)
│   ├── GetPendingChoices(quest)
│   └── CanReceiveRewards(player, quest)
├── RewardDistributionResult Value Object
│   ├── Success flag
│   ├── XPGranted, GoldGranted
│   ├── ItemsGranted collection
│   ├── ReputationChanges dictionary
│   └── ErrorMessage (if failed)
└── Turn-In Flow Updates
    ├── Choice reward selection
    ├── Reward delivery sequence
    └── Completion notification
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    IGameRenderer (updated)                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ RenderQuestTurnInAsync(TurnInResultDto)      // reward display  │   │
│  │ RenderRewardChoiceAsync(ChoicePromptDto)     // choice UI       │   │
│  │ RenderLockedQuestAsync(LockedQuestDto)       // prereq display  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  SERVICES                                                               │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                  IQuestRewardService (new)                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + DistributeRewards(player, quest): RewardDistributionResult    │   │
│  │ + DistributeRewards(player, quest, choices): RewardDistResult   │   │
│  │ + GetPendingChoices(quest): IEnumerable<RewardChoiceGroup>      │   │
│  │ + CanReceiveRewards(player, quest): bool                        │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  DTOs                                                                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    TurnInResultDto (new)                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + QuestName: string                                              │   │
│  │ + XPGranted: int                                                 │   │
│  │ + GoldGranted: int                                               │   │
│  │ + ItemsGranted: IReadOnlyList<ItemGrantDto>                     │   │
│  │ + ReputationChanges: IReadOnlyList<ReputationChangeDto>         │   │
│  │ + BonusRewardsEarned: bool                                       │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    LockedQuestDto (new)                          │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + QuestName: string                                              │   │
│  │ + UnmetPrerequisites: IReadOnlyList<PrerequisiteDto>            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           DOMAIN LAYER                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  VALUE OBJECTS                                                          │
│  ┌────────────────────────────┐  ┌────────────────────────────┐        │
│  │    QuestPrerequisite       │  │  RewardDistributionResult  │        │
│  ├────────────────────────────┤  ├────────────────────────────┤        │
│  │ + Type: PrerequisiteType   │  │ + Success: bool            │        │
│  │ + TargetId: string         │  │ + XPGranted: int           │        │
│  │ + RequiredValue: int       │  │ + GoldGranted: int         │        │
│  │ + IsNegated: bool          │  │ + ItemsGranted: List       │        │
│  │ + Description: string?     │  │ + ReputationChanges: Dict  │        │
│  ├────────────────────────────┤  │ + ErrorMessage: string?    │        │
│  │ + Level(min): static       │  ├────────────────────────────┤        │
│  │ + Reputation(...): static  │  │ + Succeeded(...): static   │        │
│  │ + QuestComplete(...): stat │  │ + Failed(...): static      │        │
│  │ + HasItem(...): static     │  └────────────────────────────┘        │
│  │ + Evaluate(player): bool   │                                        │
│  └────────────────────────────┘                                        │
│                                                                         │
│  ┌────────────────────────────┐                                        │
│  │     RewardChoiceGroup      │                                        │
│  ├────────────────────────────┤                                        │
│  │ + GroupId: string          │                                        │
│  │ + Choices: List<Entry>     │                                        │
│  └────────────────────────────┘                                        │
│                                                                         │
│  ENUMS                                                                  │
│  ┌────────────────────────────┐                                        │
│  │     PrerequisiteType       │                                        │
│  ├────────────────────────────┤                                        │
│  │ Level                      │                                        │
│  │ Reputation                 │                                        │
│  │ Quest                      │                                        │
│  │ Item                       │                                        │
│  │ Class                      │                                        │
│  │ Skill                      │                                        │
│  └────────────────────────────┘                                        │
│                                                                         │
│  DEFINITION UPDATES                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    QuestDefinition (updated)                     │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + Prerequisites: IReadOnlyList<QuestPrerequisite>   // NEW      │   │
│  │ + GetUnmetPrerequisites(Player): IEnumerable        // NEW      │   │
│  │ + MeetsPrerequisites(Player): bool                  // NEW      │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        INFRASTRUCTURE LAYER                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Configuration Files:                                                   │
│  └── config/quests.json (updated with prerequisites)                   │
│                                                                         │
│  DTOs for Deserialization:                                              │
│  └── PrerequisiteConfigDto                                             │
│                                                                         │
│  Service Integrations:                                                  │
│  ├── IExperienceService (XP delivery)                                  │
│  ├── IReputationService (reputation changes)                           │
│  ├── IItemService (item creation and delivery)                         │
│  └── Player.AddGold (gold delivery)                                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Prerequisite Evaluation Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    PREREQUISITE EVALUATION FLOW                         │
└─────────────────────────────────────────────────────────────────────────┘

    NPC.GetAvailableQuests(player, questService)
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                     FOR EACH OFFERED QUEST                       │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │              Check: MeetsPrerequisites(player)                   │
    │                                                                  │
    │  For each QuestPrerequisite in definition.Prerequisites:        │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │  prerequisite.Evaluate(player)                           │    │
    │  │                                                          │    │
    │  │  Type          │ Evaluation                              │    │
    │  │  ──────────────┼────────────────────────────────────────│    │
    │  │  Level         │ player.Level >= RequiredValue          │    │
    │  │  Reputation    │ player.GetReputation(TargetId) >= Req  │    │
    │  │  Quest         │ player.HasCompletedQuest(TargetId)     │    │
    │  │  Item          │ player.Inventory.HasItem(TargetId,Qty) │    │
    │  │                                                          │    │
    │  │  If IsNegated: result = !result                         │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │                                                                  │
    │  Returns: All prerequisites evaluate to true                    │
    └─────────────────────────────────────────────────────────────────┘
           │
           ├─── TRUE  ──▶ Quest available for acceptance [!]
           │
           └─── FALSE ──▶ Quest locked [LOCKED] with prereq display
```

### 3.3 Reward Distribution Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      REWARD DISTRIBUTION FLOW                           │
└─────────────────────────────────────────────────────────────────────────┘

    Player selects [Turn In: Quest Name]
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    VALIDATE TURN-IN                              │
    │  1. quest.CanTurnIn() == true                                   │
    │  2. rewardService.CanReceiveRewards(player, quest) == true      │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    CHECK FOR CHOICES                             │
    │  GetPendingChoices(quest)                                       │
    │                                                                  │
    │  If quest has choice rewards AND no selections provided:        │
    │  └── Return RequiresChoice with available options               │
    └─────────────────────────────────────────────────────────────────┘
           │
           ├─── Has Pending Choices ──▶ Display choice UI
           │                                  │
           │                                  ▼
           │                           Player selects choice
           │                                  │
           │                                  ▼
           │◄─────────────────────── Resubmit with selections
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    DISTRIBUTE REWARDS                            │
    │                                                                  │
    │  1. XP Delivery:                                                │
    │     experienceService.GrantXP(player, quest.Rewards.TotalXP)    │
    │                                                                  │
    │  2. Gold Delivery:                                              │
    │     player.AddGold(quest.Rewards.TotalGold)                     │
    │                                                                  │
    │  3. Item Delivery (for each guaranteed + selected choice):     │
    │     item = itemService.CreateItem(entry.TargetId)               │
    │     player.Inventory.AddItem(item)                              │
    │                                                                  │
    │  4. Reputation Delivery (for each):                             │
    │     reputationService.ModifyReputation(                         │
    │         player, entry.TargetId, entry.Amount)                   │
    │                                                                  │
    │  5. If ShouldGrantBonusRewards():                               │
    │     └── Repeat for BonusRewards entries                         │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    COMPLETE QUEST                                │
    │  quest.Complete()                                                │
    │  player.MoveToCompleted(quest)                                   │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │                    RETURN RESULT                                 │
    │  RewardDistributionResult.Succeeded(xp, gold, items, rep)       │
    └─────────────────────────────────────────────────────────────────┘
```

### 3.4 Choice Reward Selection

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       CHOICE REWARD SELECTION                           │
└─────────────────────────────────────────────────────────────────────────┘

    Quest "A Dangerous Errand" has choice group "weapon":
    ┌─────────────────────────────────────────────────────────────────┐
    │  Guaranteed Rewards:                                             │
    │  ├── 100 XP                                                     │
    │  └── 30 gold                                                    │
    │                                                                  │
    │  Choice Group "weapon" (pick 1):                                │
    │  ├── Iron Sword                                                 │
    │  ├── Iron Axe                                                   │
    │  └── Iron Mace                                                  │
    └─────────────────────────────────────────────────────────────────┘

    Turn-In Flow:
    ┌─────────────────────────────────────────────────────────────────┐
    │  Player: [Turn In: A Dangerous Errand]                          │
    │                                                                  │
    │  System: Detects pending choice group "weapon"                  │
    │                                                                  │
    │  Display:                                                       │
    │  ┌─────────────────────────────────────────────────────────┐    │
    │  │  [QUEST COMPLETE: A Dangerous Errand]                    │    │
    │  │  Choose your reward:                                     │    │
    │  │    [1] Iron Sword                                        │    │
    │  │    [2] Iron Axe                                          │    │
    │  │    [3] Iron Mace                                         │    │
    │  └─────────────────────────────────────────────────────────┘    │
    │                                                                  │
    │  Player: 2                                                      │
    │                                                                  │
    │  System: DistributeRewards(player, quest, {"weapon": "iron-axe"})│
    │                                                                  │
    │  Result:                                                        │
    │  + 100 XP                                                       │
    │  + 30 gold                                                      │
    │  + Iron Axe                                                     │
    └─────────────────────────────────────────────────────────────────┘
```

---

## 4. User Stories

### US-3.1c-1: Check Quest Prerequisites
**As a** player
**I want to** see why a quest is locked
**So that** I know what requirements I need to meet

**Acceptance Criteria:**
- Locked quests display [LOCKED] indicator
- Unmet prerequisites listed with descriptions
- Prerequisites include level, reputation, quest completion, item requirements
- Met prerequisites not shown in lock message

### US-3.1c-2: Evaluate Player Prerequisites
**As a** game system
**I want to** evaluate prerequisites against player state
**So that** only eligible quests are offered

**Acceptance Criteria:**
- Level prerequisite checks player.Level
- Reputation prerequisite checks player reputation with faction
- Quest prerequisite checks player.HasCompletedQuest
- Item prerequisite checks player.Inventory.HasItem
- Negated prerequisites invert the check

### US-3.1c-3: Receive Quest Rewards
**As a** player
**I want to** receive rewards when I turn in a quest
**So that** my character progresses

**Acceptance Criteria:**
- XP granted via experience service
- Gold added to player wallet
- Items added to player inventory
- Reputation modified with appropriate factions
- Rewards displayed in turn-in notification

### US-3.1c-4: Select Choice Rewards
**As a** player
**I want to** choose from reward options when turning in
**So that** I can pick rewards matching my playstyle

**Acceptance Criteria:**
- Choice groups prompt before completing turn-in
- Each group requires one selection
- Selected item granted, others not granted
- Non-choice rewards always granted

### US-3.1c-5: Receive Bonus Rewards
**As a** player
**I want to** receive bonus rewards for completing optional objectives
**So that** I'm rewarded for extra effort

**Acceptance Criteria:**
- Bonus rewards granted when all optional objectives complete
- Bonus rewards displayed separately in notification
- Bonus rewards include XP, gold, items, reputation

### US-3.1c-6: Configure Quest Prerequisites
**As a** game designer
**I want to** define prerequisites in quest configuration
**So that** quests unlock at appropriate times

**Acceptance Criteria:**
- Prerequisites defined in quests.json
- Level, reputation, quest, and item types supported
- Negated prerequisites supported
- Invalid prerequisites produce warnings

---

## 5. Data Models

### 5.1 QuestPrerequisite Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a requirement for a quest to be available.
/// </summary>
/// <remarks>
/// QuestPrerequisite is a value object that defines conditions that must be met
/// before a quest becomes available to a player. Prerequisites are evaluated
/// against player state when determining quest availability.
/// </remarks>
public readonly record struct QuestPrerequisite
{
    /// <summary>
    /// Gets the prerequisite type.
    /// </summary>
    /// <remarks>
    /// Determines which aspect of player state is evaluated.
    /// </remarks>
    public PrerequisiteType Type { get; init; }

    /// <summary>
    /// Gets the target ID for this prerequisite.
    /// </summary>
    /// <remarks>
    /// For Quest: the quest definition ID that must be completed.
    /// For Reputation: the faction ID to check reputation with.
    /// For Item: the item definition ID required.
    /// Empty for Level prerequisites.
    /// </remarks>
    public string TargetId { get; init; }

    /// <summary>
    /// Gets the required value for this prerequisite.
    /// </summary>
    /// <remarks>
    /// For Level: minimum level required.
    /// For Reputation: minimum reputation value.
    /// For Item: quantity required.
    /// For Quest: typically 1 (completed).
    /// </remarks>
    public int RequiredValue { get; init; }

    /// <summary>
    /// Gets whether this prerequisite is negated.
    /// </summary>
    /// <remarks>
    /// When true, the prerequisite is met when the condition is NOT satisfied.
    /// Example: IsNegated=true for Quest means "must NOT have completed quest".
    /// </remarks>
    public bool IsNegated { get; init; }

    /// <summary>
    /// Gets the display description for this prerequisite.
    /// </summary>
    /// <remarks>
    /// Human-readable description shown when the prerequisite is not met.
    /// </remarks>
    public string? Description { get; init; }

    /// <summary>
    /// Creates a level prerequisite.
    /// </summary>
    /// <param name="minLevel">The minimum level required.</param>
    /// <returns>A new QuestPrerequisite for level requirement.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown if minLevel is less than 1.</exception>
    public static QuestPrerequisite Level(int minLevel)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(minLevel, 1);

        return new QuestPrerequisite
        {
            Type = PrerequisiteType.Level,
            TargetId = string.Empty,
            RequiredValue = minLevel,
            Description = $"Requires level {minLevel}"
        };
    }

    /// <summary>
    /// Creates a reputation prerequisite.
    /// </summary>
    /// <param name="factionId">The faction ID to check reputation with.</param>
    /// <param name="minReputation">The minimum reputation required.</param>
    /// <param name="factionName">Optional display name for the faction.</param>
    /// <returns>A new QuestPrerequisite for reputation requirement.</returns>
    /// <exception cref="ArgumentException">Thrown if factionId is null or whitespace.</exception>
    public static QuestPrerequisite Reputation(string factionId, int minReputation, string? factionName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(factionId);

        var displayName = factionName ?? factionId;
        var sign = minReputation >= 0 ? "" : "";

        return new QuestPrerequisite
        {
            Type = PrerequisiteType.Reputation,
            TargetId = factionId.ToLowerInvariant(),
            RequiredValue = minReputation,
            Description = $"Requires {displayName} reputation {minReputation}+"
        };
    }

    /// <summary>
    /// Creates a quest completion prerequisite.
    /// </summary>
    /// <param name="questId">The quest definition ID that must be completed.</param>
    /// <param name="questName">Optional display name for the quest.</param>
    /// <returns>A new QuestPrerequisite for quest completion requirement.</returns>
    /// <exception cref="ArgumentException">Thrown if questId is null or whitespace.</exception>
    public static QuestPrerequisite QuestComplete(string questId, string? questName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(questId);

        return new QuestPrerequisite
        {
            Type = PrerequisiteType.Quest,
            TargetId = questId.ToLowerInvariant(),
            RequiredValue = 1,
            Description = $"Requires completion of \"{questName ?? questId}\""
        };
    }

    /// <summary>
    /// Creates an item prerequisite.
    /// </summary>
    /// <param name="itemId">The item definition ID required.</param>
    /// <param name="quantity">The quantity required (default 1).</param>
    /// <param name="itemName">Optional display name for the item.</param>
    /// <returns>A new QuestPrerequisite for item requirement.</returns>
    /// <exception cref="ArgumentException">Thrown if itemId is null or whitespace.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown if quantity is less than 1.</exception>
    public static QuestPrerequisite HasItem(string itemId, int quantity = 1, string? itemName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(itemId);
        ArgumentOutOfRangeException.ThrowIfLessThan(quantity, 1);

        var displayName = itemName ?? itemId;
        var quantityText = quantity > 1 ? $" (x{quantity})" : "";

        return new QuestPrerequisite
        {
            Type = PrerequisiteType.Item,
            TargetId = itemId.ToLowerInvariant(),
            RequiredValue = quantity,
            Description = $"Requires {displayName}{quantityText}"
        };
    }

    /// <summary>
    /// Creates a negated version of this prerequisite.
    /// </summary>
    /// <returns>A new QuestPrerequisite with IsNegated set to true.</returns>
    /// <remarks>
    /// A negated prerequisite is met when the original condition is NOT satisfied.
    /// </remarks>
    public QuestPrerequisite Negate()
    {
        return this with
        {
            IsNegated = true,
            Description = Description?.Replace("Requires", "Must NOT have") ?? Description
        };
    }

    /// <summary>
    /// Evaluates this prerequisite against a player.
    /// </summary>
    /// <param name="player">The player to evaluate against.</param>
    /// <returns>True if the prerequisite is met, false otherwise.</returns>
    /// <exception cref="ArgumentNullException">Thrown if player is null.</exception>
    public bool Evaluate(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var result = Type switch
        {
            PrerequisiteType.Level => player.Level >= RequiredValue,
            PrerequisiteType.Reputation => player.GetReputation(TargetId) >= RequiredValue,
            PrerequisiteType.Quest => player.HasCompletedQuest(TargetId),
            PrerequisiteType.Item => player.Inventory.HasItem(TargetId, RequiredValue),
            PrerequisiteType.Class => false, // Future implementation
            PrerequisiteType.Skill => false, // Future implementation
            _ => false
        };

        return IsNegated ? !result : result;
    }

    /// <summary>
    /// Gets the display string for this prerequisite.
    /// </summary>
    /// <returns>The description or a generated string.</returns>
    public string ToDisplayString()
    {
        if (!string.IsNullOrEmpty(Description))
            return Description;

        return Type switch
        {
            PrerequisiteType.Level => $"Level {RequiredValue}+",
            PrerequisiteType.Reputation => $"{TargetId} reputation {RequiredValue}+",
            PrerequisiteType.Quest => $"Complete \"{TargetId}\"",
            PrerequisiteType.Item => RequiredValue > 1
                ? $"Have {RequiredValue}x {TargetId}"
                : $"Have {TargetId}",
            _ => $"{Type}: {TargetId}"
        };
    }
}
```

### 5.2 PrerequisiteType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of quest prerequisites.
/// </summary>
/// <remarks>
/// PrerequisiteType determines which aspect of player state is checked
/// when evaluating whether a quest is available.
/// </remarks>
public enum PrerequisiteType
{
    /// <summary>
    /// Player must be at least a certain level.
    /// </summary>
    /// <remarks>
    /// RequiredValue specifies the minimum level.
    /// TargetId is not used.
    /// </remarks>
    Level,

    /// <summary>
    /// Player must have minimum reputation with a faction.
    /// </summary>
    /// <remarks>
    /// TargetId specifies the faction ID.
    /// RequiredValue specifies the minimum reputation.
    /// </remarks>
    Reputation,

    /// <summary>
    /// Player must have completed a specific quest.
    /// </summary>
    /// <remarks>
    /// TargetId specifies the quest definition ID.
    /// RequiredValue is typically 1.
    /// </remarks>
    Quest,

    /// <summary>
    /// Player must have a specific item in inventory.
    /// </summary>
    /// <remarks>
    /// TargetId specifies the item definition ID.
    /// RequiredValue specifies the quantity needed.
    /// </remarks>
    Item,

    /// <summary>
    /// Player must have a specific class or archetype.
    /// </summary>
    /// <remarks>
    /// Future use. TargetId specifies the class ID.
    /// </remarks>
    Class,

    /// <summary>
    /// Player must have a specific skill at a minimum level.
    /// </summary>
    /// <remarks>
    /// Future use. TargetId specifies the skill ID.
    /// RequiredValue specifies the minimum skill level.
    /// </remarks>
    Skill
}
```

### 5.3 RewardDistributionResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of distributing quest rewards to a player.
/// </summary>
/// <remarks>
/// RewardDistributionResult encapsulates the outcome of a reward distribution
/// operation, including all rewards granted and any error that occurred.
/// </remarks>
public readonly record struct RewardDistributionResult
{
    /// <summary>
    /// Gets whether the distribution succeeded.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the XP granted.
    /// </summary>
    public int XPGranted { get; init; }

    /// <summary>
    /// Gets the gold granted.
    /// </summary>
    public int GoldGranted { get; init; }

    /// <summary>
    /// Gets the items granted.
    /// </summary>
    public IReadOnlyList<Item> ItemsGranted { get; init; }

    /// <summary>
    /// Gets the reputation changes.
    /// </summary>
    /// <remarks>
    /// Key is faction ID, value is reputation change amount.
    /// </remarks>
    public IReadOnlyDictionary<string, int> ReputationChanges { get; init; }

    /// <summary>
    /// Gets the error message if distribution failed.
    /// </summary>
    public string? ErrorMessage { get; init; }

    /// <summary>
    /// Gets whether any rewards were granted.
    /// </summary>
    public bool HasRewards =>
        XPGranted > 0 ||
        GoldGranted > 0 ||
        ItemsGranted.Count > 0 ||
        ReputationChanges.Count > 0;

    /// <summary>
    /// Creates a successful distribution result.
    /// </summary>
    /// <param name="xp">XP granted.</param>
    /// <param name="gold">Gold granted.</param>
    /// <param name="items">Items granted.</param>
    /// <param name="reputation">Reputation changes.</param>
    /// <returns>A successful RewardDistributionResult.</returns>
    public static RewardDistributionResult Succeeded(
        int xp,
        int gold,
        IEnumerable<Item> items,
        IDictionary<string, int> reputation)
    {
        return new RewardDistributionResult
        {
            Success = true,
            XPGranted = xp,
            GoldGranted = gold,
            ItemsGranted = items?.ToList() ?? new List<Item>(),
            ReputationChanges = reputation != null
                ? new Dictionary<string, int>(reputation)
                : new Dictionary<string, int>()
        };
    }

    /// <summary>
    /// Creates a failed distribution result.
    /// </summary>
    /// <param name="message">The error message.</param>
    /// <returns>A failed RewardDistributionResult.</returns>
    public static RewardDistributionResult Failed(string message)
    {
        return new RewardDistributionResult
        {
            Success = false,
            ErrorMessage = message,
            XPGranted = 0,
            GoldGranted = 0,
            ItemsGranted = Array.Empty<Item>(),
            ReputationChanges = new Dictionary<string, int>()
        };
    }

    /// <summary>
    /// Creates an empty successful result (no rewards).
    /// </summary>
    public static RewardDistributionResult Empty => new()
    {
        Success = true,
        XPGranted = 0,
        GoldGranted = 0,
        ItemsGranted = Array.Empty<Item>(),
        ReputationChanges = new Dictionary<string, int>()
    };

    /// <summary>
    /// Gets a formatted display string summarizing the rewards.
    /// </summary>
    public string ToDisplayString()
    {
        if (!Success)
            return $"Failed: {ErrorMessage}";

        var parts = new List<string>();

        if (XPGranted > 0)
            parts.Add($"+{XPGranted} XP");

        if (GoldGranted > 0)
            parts.Add($"+{GoldGranted} gold");

        foreach (var item in ItemsGranted)
            parts.Add($"+{item.Name}");

        foreach (var (factionId, amount) in ReputationChanges)
        {
            var sign = amount >= 0 ? "+" : "";
            parts.Add($"{sign}{amount} {factionId} reputation");
        }

        return parts.Count > 0 ? string.Join(", ", parts) : "No rewards";
    }
}
```

### 5.4 RewardChoiceGroup Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// A group of choice rewards that the player must select from.
/// </summary>
/// <remarks>
/// RewardChoiceGroup represents a set of mutually exclusive rewards where
/// the player picks one. Multiple choice groups can exist per quest.
/// </remarks>
public readonly record struct RewardChoiceGroup
{
    /// <summary>
    /// Gets the group ID.
    /// </summary>
    /// <remarks>
    /// Used to identify which group a selection belongs to.
    /// </remarks>
    public string GroupId { get; init; }

    /// <summary>
    /// Gets the available choices.
    /// </summary>
    public IReadOnlyList<RewardEntry> Choices { get; init; }

    /// <summary>
    /// Gets the display name for this group.
    /// </summary>
    /// <remarks>
    /// Optional name like "Weapon" or "Armor" for display.
    /// </remarks>
    public string? DisplayName { get; init; }

    /// <summary>
    /// Gets whether the player must make a selection.
    /// </summary>
    public bool RequiresSelection => Choices.Count > 1;

    /// <summary>
    /// Creates a reward choice group.
    /// </summary>
    /// <param name="groupId">The group ID.</param>
    /// <param name="choices">The available choices.</param>
    /// <param name="displayName">Optional display name.</param>
    /// <returns>A new RewardChoiceGroup.</returns>
    public static RewardChoiceGroup Create(
        string groupId,
        IEnumerable<RewardEntry> choices,
        string? displayName = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(groupId);
        ArgumentNullException.ThrowIfNull(choices);

        return new RewardChoiceGroup
        {
            GroupId = groupId.ToLowerInvariant(),
            Choices = choices.ToList(),
            DisplayName = displayName
        };
    }

    /// <summary>
    /// Gets a choice by target ID.
    /// </summary>
    /// <param name="targetId">The target ID to find.</param>
    /// <returns>The matching choice, or null if not found.</returns>
    public RewardEntry? GetChoice(string targetId)
    {
        if (string.IsNullOrWhiteSpace(targetId))
            return null;

        var normalizedId = targetId.ToLowerInvariant();
        return Choices.FirstOrDefault(c =>
            c.TargetId.Equals(normalizedId, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Gets whether a target ID is a valid choice.
    /// </summary>
    /// <param name="targetId">The target ID to check.</param>
    /// <returns>True if the ID is a valid choice.</returns>
    public bool IsValidChoice(string targetId)
    {
        return GetChoice(targetId) != null;
    }
}
```

### 5.5 QuestDefinition Updates

```csharp
// Additions to existing QuestDefinition class in RuneAndRust.Domain.Definitions

/// <summary>
/// Gets the prerequisites for this quest.
/// </summary>
/// <remarks>
/// All prerequisites must be met for the quest to be available.
/// Empty collection means no prerequisites.
/// </remarks>
public IReadOnlyList<QuestPrerequisite> Prerequisites { get; private set; }
    = Array.Empty<QuestPrerequisite>();

// Update the Create method signature:
public static QuestDefinition Create(
    string id,
    string name,
    string description,
    IEnumerable<ObjectiveDefinition> objectives,
    string? giverNpcId = null,
    string? turnInNpcId = null,
    string? hint = null,
    bool autoActivate = true,
    QuestReward? rewards = null,
    QuestReward? bonusRewards = null,
    IEnumerable<QuestPrerequisite>? prerequisites = null)   // NEW
{
    ArgumentException.ThrowIfNullOrWhiteSpace(id);
    ArgumentException.ThrowIfNullOrWhiteSpace(name);
    ArgumentException.ThrowIfNullOrWhiteSpace(description);
    ArgumentNullException.ThrowIfNull(objectives);

    var definition = new QuestDefinition
    {
        Id = id.ToLowerInvariant(),
        Name = name,
        Description = description,
        GiverNpcId = giverNpcId?.ToLowerInvariant(),
        TurnInNpcId = turnInNpcId?.ToLowerInvariant(),
        Hint = hint,
        AutoActivate = autoActivate,
        Rewards = rewards ?? QuestReward.Empty,
        BonusRewards = bonusRewards,
        Prerequisites = prerequisites?.ToList() ?? new List<QuestPrerequisite>()  // NEW
    };

    definition._objectives.AddRange(objectives);

    return definition;
}

/// <summary>
/// Gets whether this quest has prerequisites.
/// </summary>
public bool HasPrerequisites => Prerequisites.Count > 0;

/// <summary>
/// Gets whether a player meets all prerequisites.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>True if all prerequisites are met.</returns>
/// <exception cref="ArgumentNullException">Thrown if player is null.</exception>
public bool MeetsPrerequisites(Player player)
{
    ArgumentNullException.ThrowIfNull(player);

    return Prerequisites.All(p => p.Evaluate(player));
}

/// <summary>
/// Gets the prerequisites not met by a player.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>Prerequisites that evaluate to false for this player.</returns>
/// <exception cref="ArgumentNullException">Thrown if player is null.</exception>
public IEnumerable<QuestPrerequisite> GetUnmetPrerequisites(Player player)
{
    ArgumentNullException.ThrowIfNull(player);

    return Prerequisites.Where(p => !p.Evaluate(player));
}
```

### 5.6 NPC Updates for Prerequisites

```csharp
// Updates to NPC.GetAvailableQuests to include prerequisite checking

/// <summary>
/// Gets available quests for a player, considering prerequisites.
/// </summary>
/// <param name="player">The player to check availability for.</param>
/// <param name="questService">The quest service for quest lookups.</param>
/// <param name="configProvider">The configuration provider for definitions.</param>
/// <returns>Quest definition IDs available to the player.</returns>
/// <remarks>
/// Returns quests that:
/// - Player has not started
/// - Player has not completed
/// - Player meets all prerequisites for
/// </remarks>
public IEnumerable<string> GetAvailableQuests(
    Player player,
    IQuestService questService,
    IConfigurationProvider configProvider)
{
    ArgumentNullException.ThrowIfNull(player);
    ArgumentNullException.ThrowIfNull(questService);
    ArgumentNullException.ThrowIfNull(configProvider);

    return OfferedQuestIds.Where(id =>
    {
        // Check not already active or completed
        if (questService.HasActiveQuest(player.Id, id) || player.HasCompletedQuest(id))
            return false;

        // Check prerequisites
        var definition = configProvider.GetQuestDefinition(id);
        return definition != null && definition.MeetsPrerequisites(player);
    });
}

/// <summary>
/// Gets locked quests for a player (offered but prerequisites not met).
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="questService">The quest service for quest lookups.</param>
/// <param name="configProvider">The configuration provider for definitions.</param>
/// <returns>Tuples of quest ID and unmet prerequisites.</returns>
public IEnumerable<(string QuestId, IEnumerable<QuestPrerequisite> UnmetPrereqs)> GetLockedQuests(
    Player player,
    IQuestService questService,
    IConfigurationProvider configProvider)
{
    ArgumentNullException.ThrowIfNull(player);
    ArgumentNullException.ThrowIfNull(questService);
    ArgumentNullException.ThrowIfNull(configProvider);

    foreach (var id in OfferedQuestIds)
    {
        // Skip active or completed quests
        if (questService.HasActiveQuest(player.Id, id) || player.HasCompletedQuest(id))
            continue;

        var definition = configProvider.GetQuestDefinition(id);
        if (definition == null)
            continue;

        var unmet = definition.GetUnmetPrerequisites(player).ToList();
        if (unmet.Count > 0)
            yield return (id, unmet);
    }
}
```

---

## 6. Configuration Schemas

### 6.1 Updated quests.json with Prerequisites

```json
{
  "$schema": "../schemas/quests.schema.json",
  "quests": [
    {
      "id": "goblin-menace",
      "name": "The Goblin Menace",
      "description": "The dungeon entrance is overrun with goblins. Clear them out to make the area safe for other adventurers.",
      "giverNpcId": "guard-captain",
      "turnInNpcId": "guard-captain",
      "hint": "Goblins are commonly found in the upper dungeon levels.",
      "autoActivate": true,
      "prerequisites": [],
      "objectives": [
        {
          "type": "Kill",
          "description": "Defeat goblins",
          "target": {
            "targetType": "goblin",
            "displayName": "Goblins",
            "anyOfType": true
          },
          "requiredCount": 5
        }
      ],
      "rewards": {
        "entries": [
          { "type": "XP", "amount": 50 },
          { "type": "Gold", "amount": 25 },
          { "type": "Reputation", "targetId": "city-guard", "amount": 100, "displayName": "City Guard" }
        ]
      }
    },
    {
      "id": "eliminate-goblin-chief",
      "name": "Eliminate the Goblin Chief",
      "description": "The goblin raids are being coordinated by a cunning chief. Find and eliminate him to end the threat.",
      "giverNpcId": "guard-captain",
      "turnInNpcId": "guard-captain",
      "hint": "The chief is said to lurk in the deepest goblin warrens.",
      "autoActivate": true,
      "prerequisites": [
        {
          "type": "Quest",
          "targetId": "goblin-menace",
          "displayName": "The Goblin Menace"
        },
        {
          "type": "Level",
          "requiredValue": 5
        }
      ],
      "objectives": [
        {
          "type": "Kill",
          "description": "Defeat the Goblin Chief",
          "target": {
            "targetId": "goblin-chief",
            "displayName": "Goblin Chief"
          },
          "requiredCount": 1
        }
      ],
      "rewards": {
        "entries": [
          { "type": "XP", "amount": 150 },
          { "type": "Gold", "amount": 100 },
          { "type": "Item", "targetId": "goblin-slayer-medal", "displayName": "Goblin Slayer Medal" },
          { "type": "Reputation", "targetId": "city-guard", "amount": 250, "displayName": "City Guard" }
        ]
      }
    },
    {
      "id": "guild-initiation",
      "name": "Guild Initiation",
      "description": "The Adventurer's Guild is always looking for promising new members. Prove your worth.",
      "giverNpcId": "guild-master",
      "turnInNpcId": "guild-master",
      "autoActivate": true,
      "prerequisites": [
        {
          "type": "Level",
          "requiredValue": 3
        },
        {
          "type": "Reputation",
          "targetId": "adventurers-guild",
          "requiredValue": 50,
          "displayName": "Adventurer's Guild"
        }
      ],
      "objectives": [
        {
          "type": "Explore",
          "description": "Clear the Trial Dungeon",
          "target": {
            "targetId": "trial-dungeon-exit",
            "displayName": "Trial Dungeon Exit"
          },
          "requiredCount": 1
        }
      ],
      "rewards": {
        "entries": [
          { "type": "XP", "amount": 100 },
          { "type": "Gold", "amount": 50 },
          { "type": "Reputation", "targetId": "adventurers-guild", "amount": 200, "displayName": "Adventurer's Guild" }
        ]
      }
    },
    {
      "id": "dangerous-errand",
      "name": "A Dangerous Errand",
      "description": "Retrieve supplies from the abandoned outpost. The journey is perilous, but the reward is worth the risk.",
      "giverNpcId": "quartermaster",
      "turnInNpcId": "quartermaster",
      "hint": "The outpost is beyond the eastern tunnels.",
      "autoActivate": true,
      "prerequisites": [],
      "objectives": [
        {
          "type": "Collect",
          "description": "Retrieve supply crates",
          "target": {
            "targetId": "item-supply-crate",
            "displayName": "Supply Crates"
          },
          "requiredCount": 3
        }
      ],
      "rewards": {
        "entries": [
          { "type": "XP", "amount": 100 },
          { "type": "Gold", "amount": 30 },
          { "type": "Item", "targetId": "iron-sword", "displayName": "Iron Sword", "isChoice": true, "choiceGroup": "weapon" },
          { "type": "Item", "targetId": "iron-axe", "displayName": "Iron Axe", "isChoice": true, "choiceGroup": "weapon" },
          { "type": "Item", "targetId": "iron-mace", "displayName": "Iron Mace", "isChoice": true, "choiceGroup": "weapon" }
        ]
      }
    }
  ]
}
```

### 6.2 Updated quests.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Quest Configuration",
  "description": "Defines quests, objectives, rewards, and prerequisites for the game",
  "type": "object",
  "required": ["quests"],
  "properties": {
    "quests": {
      "type": "array",
      "description": "List of quest definitions",
      "items": {
        "$ref": "#/definitions/questDefinition"
      }
    }
  },
  "definitions": {
    "questDefinition": {
      "type": "object",
      "required": ["id", "name", "description", "objectives"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier"
        },
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "description": "Display name"
        },
        "description": {
          "type": "string",
          "minLength": 10,
          "maxLength": 1000,
          "description": "Narrative description"
        },
        "giverNpcId": {
          "type": ["string", "null"],
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "turnInNpcId": {
          "type": ["string", "null"],
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "hint": {
          "type": ["string", "null"],
          "maxLength": 500
        },
        "autoActivate": {
          "type": "boolean",
          "default": true
        },
        "prerequisites": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/prerequisite"
          },
          "description": "Requirements to unlock this quest"
        },
        "objectives": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/definitions/objectiveDefinition"
          }
        },
        "rewards": {
          "$ref": "#/definitions/questReward"
        },
        "bonusRewards": {
          "$ref": "#/definitions/questReward"
        }
      }
    },
    "prerequisite": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["Level", "Reputation", "Quest", "Item", "Class", "Skill"],
          "description": "Type of prerequisite"
        },
        "targetId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Target ID (quest, faction, item, class, skill)"
        },
        "requiredValue": {
          "type": "integer",
          "description": "Required value (level, reputation, quantity, skill level)"
        },
        "displayName": {
          "type": ["string", "null"],
          "description": "Display name for the target"
        },
        "isNegated": {
          "type": "boolean",
          "default": false,
          "description": "If true, condition must NOT be met"
        }
      },
      "allOf": [
        {
          "if": {
            "properties": { "type": { "const": "Level" } }
          },
          "then": {
            "required": ["requiredValue"],
            "properties": {
              "requiredValue": { "minimum": 1 }
            }
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "Reputation" } }
          },
          "then": {
            "required": ["targetId", "requiredValue"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "Quest" } }
          },
          "then": {
            "required": ["targetId"]
          }
        },
        {
          "if": {
            "properties": { "type": { "const": "Item" } }
          },
          "then": {
            "required": ["targetId"]
          }
        }
      ]
    },
    "objectiveDefinition": {
      "type": "object",
      "required": ["type", "description", "target"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["Kill", "Collect", "Explore", "Talk", "Deliver", "Use", "Custom"]
        },
        "description": {
          "type": "string",
          "minLength": 1,
          "maxLength": 200
        },
        "target": {
          "$ref": "#/definitions/objectiveTarget"
        },
        "requiredCount": {
          "type": "integer",
          "minimum": 1,
          "default": 1
        },
        "isOptional": {
          "type": "boolean",
          "default": false
        },
        "isHidden": {
          "type": "boolean",
          "default": false
        },
        "order": {
          "type": "integer",
          "minimum": 0,
          "default": 0
        }
      }
    },
    "objectiveTarget": {
      "type": "object",
      "properties": {
        "targetId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "displayName": {
          "type": "string",
          "minLength": 1
        },
        "locationHint": {
          "type": ["string", "null"]
        },
        "anyOfType": {
          "type": "boolean",
          "default": false
        },
        "targetType": {
          "type": ["string", "null"],
          "pattern": "^[a-z][a-z0-9-]*$"
        }
      },
      "required": ["displayName"]
    },
    "questReward": {
      "type": "object",
      "required": ["entries"],
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/rewardEntry"
          }
        }
      }
    },
    "rewardEntry": {
      "type": "object",
      "required": ["type"],
      "properties": {
        "type": {
          "type": "string",
          "enum": ["XP", "Gold", "Item", "Reputation", "Unlock"]
        },
        "amount": {
          "type": "integer"
        },
        "targetId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$"
        },
        "displayName": {
          "type": ["string", "null"]
        },
        "isChoice": {
          "type": "boolean",
          "default": false
        },
        "choiceGroup": {
          "type": ["string", "null"],
          "pattern": "^[a-z][a-z0-9-]*$"
        }
      }
    }
  }
}
```

---

## 7. Service Specifications

### 7.1 IQuestRewardService Interface

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Handles quest reward distribution.
/// </summary>
/// <remarks>
/// IQuestRewardService is responsible for delivering rewards to players
/// when quests are turned in, including XP, gold, items, and reputation.
/// It also handles choice reward selection.
/// </remarks>
public interface IQuestRewardService
{
    /// <summary>
    /// Distributes rewards for completing a quest.
    /// </summary>
    /// <param name="player">The player receiving rewards.</param>
    /// <param name="quest">The completed quest.</param>
    /// <returns>Result of the distribution.</returns>
    /// <remarks>
    /// Fails if the quest has pending choice selections.
    /// Use the overload with choiceSelections for quests with choices.
    /// </remarks>
    RewardDistributionResult DistributeRewards(Player player, Quest quest);

    /// <summary>
    /// Distributes rewards with choice selection.
    /// </summary>
    /// <param name="player">The player receiving rewards.</param>
    /// <param name="quest">The completed quest.</param>
    /// <param name="choiceSelections">Map of choice group ID to selected item ID.</param>
    /// <returns>Result of the distribution.</returns>
    RewardDistributionResult DistributeRewards(
        Player player,
        Quest quest,
        Dictionary<string, string>? choiceSelections);

    /// <summary>
    /// Gets pending choice rewards for a quest.
    /// </summary>
    /// <param name="quest">The quest to check.</param>
    /// <returns>Choice groups that require player selection.</returns>
    IEnumerable<RewardChoiceGroup> GetPendingChoices(Quest quest);

    /// <summary>
    /// Validates that a player can receive rewards.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <param name="quest">The quest to receive rewards from.</param>
    /// <returns>True if rewards can be distributed.</returns>
    /// <remarks>
    /// Checks for inventory space, valid quest state, etc.
    /// </remarks>
    bool CanReceiveRewards(Player player, Quest quest);
}
```

### 7.2 QuestRewardService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Implementation of quest reward distribution.
/// </summary>
public class QuestRewardService : IQuestRewardService
{
    private readonly IExperienceService _experienceService;
    private readonly IReputationService _reputationService;
    private readonly IItemService _itemService;
    private readonly ILogger<QuestRewardService> _logger;

    public QuestRewardService(
        IExperienceService experienceService,
        IReputationService reputationService,
        IItemService itemService,
        ILogger<QuestRewardService> logger)
    {
        _experienceService = experienceService;
        _reputationService = reputationService;
        _itemService = itemService;
        _logger = logger;
    }

    public RewardDistributionResult DistributeRewards(Player player, Quest quest)
    {
        return DistributeRewards(player, quest, null);
    }

    public RewardDistributionResult DistributeRewards(
        Player player,
        Quest quest,
        Dictionary<string, string>? choiceSelections)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(quest);

        // Validate state
        if (!CanReceiveRewards(player, quest))
        {
            return RewardDistributionResult.Failed("Cannot receive rewards for this quest.");
        }

        // Check for pending choices
        var pendingChoices = GetPendingChoices(quest).ToList();
        if (pendingChoices.Count > 0)
        {
            if (choiceSelections == null || choiceSelections.Count == 0)
            {
                return RewardDistributionResult.Failed("Quest has pending reward choices.");
            }

            // Validate all choices are made
            foreach (var group in pendingChoices)
            {
                if (!choiceSelections.TryGetValue(group.GroupId, out var selection))
                {
                    return RewardDistributionResult.Failed(
                        $"Missing selection for choice group '{group.GroupId}'.");
                }

                if (!group.IsValidChoice(selection))
                {
                    return RewardDistributionResult.Failed(
                        $"Invalid selection '{selection}' for choice group '{group.GroupId}'.");
                }
            }
        }

        // Get effective rewards (base + bonus if earned)
        var rewards = quest.GetEffectiveRewards();

        try
        {
            var xpGranted = 0;
            var goldGranted = 0;
            var itemsGranted = new List<Item>();
            var reputationChanges = new Dictionary<string, int>();

            // Distribute XP
            if (rewards.TotalXP > 0)
            {
                _experienceService.GrantXP(player, rewards.TotalXP);
                xpGranted = rewards.TotalXP;
                _logger.LogDebug("Granted {XP} XP to player {PlayerId}", xpGranted, player.Id);
            }

            // Distribute gold
            if (rewards.TotalGold > 0)
            {
                player.AddGold(rewards.TotalGold);
                goldGranted = rewards.TotalGold;
                _logger.LogDebug("Granted {Gold} gold to player {PlayerId}", goldGranted, player.Id);
            }

            // Distribute guaranteed items
            foreach (var entry in rewards.GuaranteedRewards.Where(e => e.Type == RewardType.Item))
            {
                for (var i = 0; i < entry.Amount; i++)
                {
                    var item = _itemService.CreateItem(entry.TargetId);
                    if (item != null)
                    {
                        player.Inventory.AddItem(item);
                        itemsGranted.Add(item);
                        _logger.LogDebug("Granted item {ItemId} to player {PlayerId}", entry.TargetId, player.Id);
                    }
                }
            }

            // Distribute choice items
            if (choiceSelections != null)
            {
                foreach (var (groupId, selectedId) in choiceSelections)
                {
                    var group = pendingChoices.FirstOrDefault(g => g.GroupId == groupId);
                    var choice = group.GetChoice(selectedId);
                    if (choice.HasValue)
                    {
                        var item = _itemService.CreateItem(choice.Value.TargetId);
                        if (item != null)
                        {
                            player.Inventory.AddItem(item);
                            itemsGranted.Add(item);
                            _logger.LogDebug(
                                "Granted choice item {ItemId} from group {GroupId} to player {PlayerId}",
                                choice.Value.TargetId, groupId, player.Id);
                        }
                    }
                }
            }

            // Distribute reputation
            foreach (var entry in rewards.ReputationRewards)
            {
                _reputationService.ModifyReputation(player, entry.TargetId, entry.Amount);

                if (reputationChanges.ContainsKey(entry.TargetId))
                    reputationChanges[entry.TargetId] += entry.Amount;
                else
                    reputationChanges[entry.TargetId] = entry.Amount;

                _logger.LogDebug(
                    "Modified reputation with {FactionId} by {Amount} for player {PlayerId}",
                    entry.TargetId, entry.Amount, player.Id);
            }

            _logger.LogInformation(
                "Distributed rewards for quest '{QuestName}' to player {PlayerId}: " +
                "{XP} XP, {Gold} gold, {ItemCount} items, {RepCount} reputation changes",
                quest.Name, player.Id, xpGranted, goldGranted,
                itemsGranted.Count, reputationChanges.Count);

            return RewardDistributionResult.Succeeded(
                xpGranted, goldGranted, itemsGranted, reputationChanges);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to distribute rewards for quest '{QuestName}'", quest.Name);
            return RewardDistributionResult.Failed($"Reward distribution failed: {ex.Message}");
        }
    }

    public IEnumerable<RewardChoiceGroup> GetPendingChoices(Quest quest)
    {
        ArgumentNullException.ThrowIfNull(quest);

        var rewards = quest.GetEffectiveRewards();

        foreach (var groupId in rewards.ChoiceGroups)
        {
            var choices = rewards.GetChoicesForGroup(groupId).ToList();
            if (choices.Count > 0)
            {
                yield return RewardChoiceGroup.Create(groupId, choices);
            }
        }
    }

    public bool CanReceiveRewards(Player player, Quest quest)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(quest);

        // Quest must be completable
        if (!quest.CanTurnIn())
            return false;

        // Check for inventory space for items
        var rewards = quest.GetEffectiveRewards();
        var itemCount = rewards.ItemRewards.Count();

        if (itemCount > 0 && !player.Inventory.HasSpaceFor(itemCount))
        {
            _logger.LogDebug(
                "Player {PlayerId} cannot receive rewards - not enough inventory space",
                player.Id);
            return false;
        }

        return true;
    }
}
```

### 7.3 Turn-In Flow Integration

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Result of a quest turn-in attempt.
/// </summary>
public readonly record struct TurnInResult
{
    public bool Success { get; init; }
    public bool RequiresChoice { get; init; }
    public RewardDistributionResult? RewardResult { get; init; }
    public IReadOnlyList<RewardChoiceGroup>? PendingChoices { get; init; }
    public string? ErrorMessage { get; init; }

    public static TurnInResult Succeeded(RewardDistributionResult rewardResult) => new()
    {
        Success = true,
        RequiresChoice = false,
        RewardResult = rewardResult
    };

    public static TurnInResult RequiresChoiceSelection(IEnumerable<RewardChoiceGroup> choices) => new()
    {
        Success = false,
        RequiresChoice = true,
        PendingChoices = choices.ToList()
    };

    public static TurnInResult Failed(string message) => new()
    {
        Success = false,
        RequiresChoice = false,
        ErrorMessage = message
    };
}

// In QuestService or DialogueService:

/// <summary>
/// Processes a quest turn-in through NPC dialogue.
/// </summary>
/// <param name="player">The player turning in the quest.</param>
/// <param name="quest">The quest to turn in.</param>
/// <param name="choices">Optional choice selections.</param>
/// <returns>The result of the turn-in attempt.</returns>
public TurnInResult ProcessQuestTurnIn(
    Player player,
    Quest quest,
    Dictionary<string, string>? choices = null)
{
    ArgumentNullException.ThrowIfNull(player);
    ArgumentNullException.ThrowIfNull(quest);

    // Verify quest is completable
    if (!quest.CanTurnIn())
    {
        return TurnInResult.Failed("Quest objectives not complete.");
    }

    // Check for pending choices
    var pendingChoices = _rewardService.GetPendingChoices(quest).ToList();
    if (pendingChoices.Count > 0 && (choices == null || choices.Count == 0))
    {
        return TurnInResult.RequiresChoiceSelection(pendingChoices);
    }

    // Distribute rewards
    var rewardResult = _rewardService.DistributeRewards(player, quest, choices);
    if (!rewardResult.Success)
    {
        return TurnInResult.Failed(rewardResult.ErrorMessage!);
    }

    // Complete the quest
    quest.Complete();
    _questRepository.Update(quest);

    // Add to player's completed quests
    player.AddCompletedQuest(quest.DefinitionId);

    _logger.LogInformation(
        "Player {PlayerId} completed quest '{QuestName}'",
        player.Id, quest.Name);

    return TurnInResult.Succeeded(rewardResult);
}
```

### 7.4 Application DTOs

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for quest turn-in result display.
/// </summary>
/// <param name="QuestName">The completed quest name.</param>
/// <param name="XPGranted">XP received.</param>
/// <param name="GoldGranted">Gold received.</param>
/// <param name="ItemsGranted">Items received.</param>
/// <param name="ReputationChanges">Reputation changes.</param>
/// <param name="BonusRewardsEarned">Whether bonus rewards were included.</param>
public record TurnInResultDto(
    string QuestName,
    int XPGranted,
    int GoldGranted,
    IReadOnlyList<ItemGrantDto> ItemsGranted,
    IReadOnlyList<ReputationChangeDto> ReputationChanges,
    bool BonusRewardsEarned)
{
    public static TurnInResultDto FromResult(Quest quest, RewardDistributionResult result)
    {
        return new TurnInResultDto(
            quest.Name,
            result.XPGranted,
            result.GoldGranted,
            result.ItemsGranted.Select(i => new ItemGrantDto(i.Id, i.Name, 1)).ToList(),
            result.ReputationChanges.Select(kvp =>
                new ReputationChangeDto(kvp.Key, kvp.Key, kvp.Value)).ToList(),
            quest.ShouldGrantBonusRewards());
    }
}

/// <summary>
/// DTO for an item grant.
/// </summary>
/// <param name="ItemId">The item definition ID.</param>
/// <param name="ItemName">The display name.</param>
/// <param name="Quantity">The quantity granted.</param>
public record ItemGrantDto(string ItemId, string ItemName, int Quantity);

/// <summary>
/// DTO for a reputation change.
/// </summary>
/// <param name="FactionId">The faction ID.</param>
/// <param name="FactionName">The faction display name.</param>
/// <param name="Amount">The change amount.</param>
public record ReputationChangeDto(string FactionId, string FactionName, int Amount);

/// <summary>
/// DTO for a locked quest display.
/// </summary>
/// <param name="QuestId">The quest definition ID.</param>
/// <param name="QuestName">The quest display name.</param>
/// <param name="UnmetPrerequisites">Prerequisites not met.</param>
public record LockedQuestDto(
    string QuestId,
    string QuestName,
    IReadOnlyList<PrerequisiteDto> UnmetPrerequisites);

/// <summary>
/// DTO for a prerequisite display.
/// </summary>
/// <param name="Type">The prerequisite type.</param>
/// <param name="Description">The display description.</param>
/// <param name="IsMet">Whether currently met.</param>
public record PrerequisiteDto(string Type, string Description, bool IsMet);

/// <summary>
/// DTO for reward choice prompt.
/// </summary>
/// <param name="QuestName">The quest name.</param>
/// <param name="ChoiceGroups">The choice groups requiring selection.</param>
public record ChoicePromptDto(
    string QuestName,
    IReadOnlyList<ChoiceGroupDto> ChoiceGroups);

/// <summary>
/// DTO for a choice group.
/// </summary>
/// <param name="GroupId">The group identifier.</param>
/// <param name="DisplayName">Optional display name.</param>
/// <param name="Choices">Available choices.</param>
public record ChoiceGroupDto(
    string GroupId,
    string? DisplayName,
    IReadOnlyList<ChoiceOptionDto> Choices);

/// <summary>
/// DTO for a choice option.
/// </summary>
/// <param name="TargetId">The item ID.</param>
/// <param name="DisplayName">The display name.</param>
public record ChoiceOptionDto(string TargetId, string DisplayName);
```

---

## 8. User-Facing Changes

### 8.1 Quest with Prerequisites (Locked)

```
> talk captain
The Guard Captain looks up from his maps. "Adventurer! We could
use someone with your skills."

[QUESTS AVAILABLE]
  [!] The Goblin Menace (New)

[QUESTS LOCKED]
  [LOCKED] Eliminate the Goblin Chief
      Requires: Complete "The Goblin Menace"
      Requires: Level 5

[1] Tell me about the goblin problem.
[2] [Accept: The Goblin Menace]
[3] Just checking in.
```

### 8.2 Quest Turn-In with Rewards

```
> talk captain
The Guard Captain smiles. "Outstanding work! Those goblins won't
be troubling travelers anymore."

[QUEST READY TO TURN IN]
  [?] The Goblin Menace

[1] [Turn In: The Goblin Menace]
[2] I'll keep patrolling.

> 1

=== QUEST COMPLETE ===
The Goblin Menace

REWARDS RECEIVED:
  + 50 XP
  + 25 gold
  + 100 City Guard reputation

The Guard Captain hands you a pouch of coins.
"The city thanks you, adventurer. Come back if you're looking
for more work."
```

### 8.3 Quest Turn-In with Choice Selection

```
> talk quartermaster

The Quartermaster nods approvingly. "You've proven yourself.
As promised, pick your reward."

[QUEST COMPLETE: A Dangerous Errand]
Choose your reward:
  [1] Iron Sword
  [2] Iron Axe
  [3] Iron Mace

> 2

=== QUEST COMPLETE ===
A Dangerous Errand

REWARDS RECEIVED:
  + 100 XP
  + 30 gold
  + Iron Axe

"A fine choice. May it serve you well in the depths."
```

### 8.4 Quest Turn-In with Bonus Rewards

```
> talk cartographer

Archivist Meren's eyes widen. "You found the Hidden Treasury!
Remarkable! You've exceeded all expectations."

[QUEST COMPLETE: Mapping the Depths]

REWARDS RECEIVED:
  + 80 XP
  + 40 gold
  + 100 Adventurer's Guild reputation

BONUS REWARDS (optional objectives completed):
  + 50 XP
  + 100 gold
  + Treasure Map

"This map reveals secrets few have ever seen. Guard it well."
```

### 8.5 Prerequisite Met - Quest Unlocked

```
[LEVEL UP! You are now level 5]

> talk captain

The Guard Captain regards you with new respect. "You've grown
stronger, adventurer. Perhaps you're ready for a greater challenge."

[QUESTS AVAILABLE]
  [!] Eliminate the Goblin Chief (New)

[1] Tell me about the Goblin Chief.
[2] [Accept: Eliminate the Goblin Chief]
[3] Just checking in.
```

---

## 9. Logging Requirements

### 9.1 Log Events

| Event | Level | Message Template | Properties |
|-------|-------|------------------|------------|
| Prereq Config | Debug | "Quest '{QuestId}' has {PrereqCount} prerequisites" | QuestId, PrereqCount |
| Prereq Eval | Debug | "Prerequisite {Type} for '{QuestId}': {Result}" | Type, QuestId, Result |
| Quest Locked | Debug | "Quest '{QuestId}' locked for player {PlayerId}: {UnmetCount} unmet prerequisites" | QuestId, PlayerId, UnmetCount |
| Reward Dist Start | Debug | "Distributing rewards for quest '{QuestName}' to player {PlayerId}" | QuestName, PlayerId |
| XP Granted | Debug | "Granted {XP} XP to player {PlayerId}" | XP, PlayerId |
| Gold Granted | Debug | "Granted {Gold} gold to player {PlayerId}" | Gold, PlayerId |
| Item Granted | Debug | "Granted item {ItemId} to player {PlayerId}" | ItemId, PlayerId |
| Rep Modified | Debug | "Modified reputation with {FactionId} by {Amount} for player {PlayerId}" | FactionId, Amount, PlayerId |
| Choice Made | Debug | "Player {PlayerId} selected {ItemId} from choice group {GroupId}" | PlayerId, ItemId, GroupId |
| Quest Complete | Information | "Player {PlayerId} completed quest '{QuestName}'" | PlayerId, QuestName |
| Dist Failed | Warning | "Failed to distribute rewards for quest '{QuestName}': {Error}" | QuestName, Error |

### 9.2 Example Log Output

```
[2024-01-20 14:30:15 DBG] Quest 'eliminate-goblin-chief' has 2 prerequisites
[2024-01-20 14:30:15 DBG] Prerequisite Quest for 'eliminate-goblin-chief': False
[2024-01-20 14:30:15 DBG] Quest 'eliminate-goblin-chief' locked for player a1b2c3d4: 2 unmet prerequisites
[2024-01-20 14:35:22 DBG] Distributing rewards for quest 'The Goblin Menace' to player a1b2c3d4
[2024-01-20 14:35:22 DBG] Granted 50 XP to player a1b2c3d4
[2024-01-20 14:35:22 DBG] Granted 25 gold to player a1b2c3d4
[2024-01-20 14:35:22 DBG] Modified reputation with city-guard by 100 for player a1b2c3d4
[2024-01-20 14:35:22 INF] Player a1b2c3d4 completed quest 'The Goblin Menace'
[2024-01-20 14:40:10 DBG] Prerequisite Quest for 'eliminate-goblin-chief': True
[2024-01-20 14:40:10 DBG] Prerequisite Level for 'eliminate-goblin-chief': True
[2024-01-20 14:45:30 DBG] Player a1b2c3d4 selected iron-axe from choice group weapon
```

---

## 10. Unit Test Specifications

### 10.1 QuestPrerequisite Tests (~8 tests)

```csharp
namespace RuneAndRust.Domain.Tests.ValueObjects;

[TestFixture]
public class QuestPrerequisiteTests
{
    [Test]
    public void Level_CreatesLevelPrerequisite()
    {
        var prereq = QuestPrerequisite.Level(5);

        prereq.Type.Should().Be(PrerequisiteType.Level);
        prereq.RequiredValue.Should().Be(5);
        prereq.TargetId.Should().BeEmpty();
        prereq.Description.Should().Contain("level 5");
    }

    [Test]
    public void Level_WithInvalidValue_Throws()
    {
        var act = () => QuestPrerequisite.Level(0);

        act.Should().Throw<ArgumentOutOfRangeException>();
    }

    [Test]
    public void Reputation_CreatesReputationPrerequisite()
    {
        var prereq = QuestPrerequisite.Reputation("city-guard", 100, "City Guard");

        prereq.Type.Should().Be(PrerequisiteType.Reputation);
        prereq.TargetId.Should().Be("city-guard");
        prereq.RequiredValue.Should().Be(100);
        prereq.Description.Should().Contain("City Guard");
    }

    [Test]
    public void QuestComplete_CreatesQuestPrerequisite()
    {
        var prereq = QuestPrerequisite.QuestComplete("goblin-menace", "The Goblin Menace");

        prereq.Type.Should().Be(PrerequisiteType.Quest);
        prereq.TargetId.Should().Be("goblin-menace");
        prereq.Description.Should().Contain("The Goblin Menace");
    }

    [Test]
    public void HasItem_CreatesItemPrerequisite()
    {
        var prereq = QuestPrerequisite.HasItem("magic-key", 3);

        prereq.Type.Should().Be(PrerequisiteType.Item);
        prereq.TargetId.Should().Be("magic-key");
        prereq.RequiredValue.Should().Be(3);
    }

    [Test]
    public void Evaluate_Level_ChecksPlayerLevel()
    {
        var prereq = QuestPrerequisite.Level(5);
        var lowPlayer = CreatePlayerWithLevel(3);
        var highPlayer = CreatePlayerWithLevel(5);

        prereq.Evaluate(lowPlayer).Should().BeFalse();
        prereq.Evaluate(highPlayer).Should().BeTrue();
    }

    [Test]
    public void Evaluate_Quest_ChecksCompletedQuests()
    {
        var prereq = QuestPrerequisite.QuestComplete("goblin-menace");
        var incomplete = CreatePlayerWithCompletedQuests();
        var complete = CreatePlayerWithCompletedQuests("goblin-menace");

        prereq.Evaluate(incomplete).Should().BeFalse();
        prereq.Evaluate(complete).Should().BeTrue();
    }

    [Test]
    public void Negate_InvertsEvaluation()
    {
        var prereq = QuestPrerequisite.QuestComplete("goblin-menace").Negate();
        var incomplete = CreatePlayerWithCompletedQuests();
        var complete = CreatePlayerWithCompletedQuests("goblin-menace");

        prereq.Evaluate(incomplete).Should().BeTrue(); // NOT completed = true
        prereq.Evaluate(complete).Should().BeFalse();  // Completed = false
    }

    private Player CreatePlayerWithLevel(int level) { /* Create test player */ }
    private Player CreatePlayerWithCompletedQuests(params string[] questIds) { /* Create test player */ }
}
```

### 10.2 QuestDefinition Prerequisite Tests (~4 tests)

```csharp
[TestFixture]
public class QuestDefinitionPrerequisiteTests
{
    [Test]
    public void Create_WithPrerequisites_StoresPrerequisites()
    {
        var prereqs = new[]
        {
            QuestPrerequisite.Level(5),
            QuestPrerequisite.QuestComplete("first-quest")
        };

        var definition = QuestDefinition.Create(
            "test-quest",
            "Test Quest",
            "A test quest.",
            Array.Empty<ObjectiveDefinition>(),
            prerequisites: prereqs);

        definition.HasPrerequisites.Should().BeTrue();
        definition.Prerequisites.Should().HaveCount(2);
    }

    [Test]
    public void MeetsPrerequisites_AllMet_ReturnsTrue()
    {
        var prereqs = new[] { QuestPrerequisite.Level(3) };
        var definition = CreateDefinitionWithPrereqs(prereqs);
        var player = CreatePlayerWithLevel(5);

        definition.MeetsPrerequisites(player).Should().BeTrue();
    }

    [Test]
    public void MeetsPrerequisites_SomeUnmet_ReturnsFalse()
    {
        var prereqs = new[]
        {
            QuestPrerequisite.Level(3),
            QuestPrerequisite.Level(10) // Too high
        };
        var definition = CreateDefinitionWithPrereqs(prereqs);
        var player = CreatePlayerWithLevel(5);

        definition.MeetsPrerequisites(player).Should().BeFalse();
    }

    [Test]
    public void GetUnmetPrerequisites_ReturnsOnlyUnmet()
    {
        var prereqs = new[]
        {
            QuestPrerequisite.Level(3),  // Met
            QuestPrerequisite.Level(10)  // Unmet
        };
        var definition = CreateDefinitionWithPrereqs(prereqs);
        var player = CreatePlayerWithLevel(5);

        var unmet = definition.GetUnmetPrerequisites(player).ToList();

        unmet.Should().HaveCount(1);
        unmet[0].RequiredValue.Should().Be(10);
    }

    private QuestDefinition CreateDefinitionWithPrereqs(IEnumerable<QuestPrerequisite> prereqs) { /* ... */ }
    private Player CreatePlayerWithLevel(int level) { /* ... */ }
}
```

### 10.3 QuestRewardService Tests (~6 tests)

```csharp
[TestFixture]
public class QuestRewardServiceTests
{
    private QuestRewardService _service;
    private Mock<IExperienceService> _xpServiceMock;
    private Mock<IReputationService> _repServiceMock;
    private Mock<IItemService> _itemServiceMock;

    [SetUp]
    public void SetUp()
    {
        _xpServiceMock = new Mock<IExperienceService>();
        _repServiceMock = new Mock<IReputationService>();
        _itemServiceMock = new Mock<IItemService>();
        _service = new QuestRewardService(
            _xpServiceMock.Object,
            _repServiceMock.Object,
            _itemServiceMock.Object,
            Mock.Of<ILogger<QuestRewardService>>());
    }

    [Test]
    public void DistributeRewards_GrantsXP()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithRewards(xp: 100);

        var result = _service.DistributeRewards(player, quest);

        result.Success.Should().BeTrue();
        result.XPGranted.Should().Be(100);
        _xpServiceMock.Verify(s => s.GrantXP(player, 100), Times.Once);
    }

    [Test]
    public void DistributeRewards_GrantsGold()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithRewards(gold: 50);

        var result = _service.DistributeRewards(player, quest);

        result.Success.Should().BeTrue();
        result.GoldGranted.Should().Be(50);
    }

    [Test]
    public void DistributeRewards_GrantsItems()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithItemReward("iron-sword");
        var mockItem = new Item { Id = Guid.NewGuid(), Name = "Iron Sword" };
        _itemServiceMock.Setup(s => s.CreateItem("iron-sword")).Returns(mockItem);

        var result = _service.DistributeRewards(player, quest);

        result.Success.Should().BeTrue();
        result.ItemsGranted.Should().HaveCount(1);
        result.ItemsGranted[0].Name.Should().Be("Iron Sword");
    }

    [Test]
    public void DistributeRewards_ModifiesReputation()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithReputationReward("city-guard", 100);

        var result = _service.DistributeRewards(player, quest);

        result.Success.Should().BeTrue();
        result.ReputationChanges.Should().ContainKey("city-guard");
        result.ReputationChanges["city-guard"].Should().Be(100);
        _repServiceMock.Verify(s => s.ModifyReputation(player, "city-guard", 100), Times.Once);
    }

    [Test]
    public void DistributeRewards_WithChoices_RequiresSelection()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithChoiceReward();

        var result = _service.DistributeRewards(player, quest, null);

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().Contain("pending reward choices");
    }

    [Test]
    public void DistributeRewards_WithChoiceSelection_GrantsSelectedItem()
    {
        var player = CreateTestPlayer();
        var quest = CreateQuestWithChoiceReward();
        var choices = new Dictionary<string, string> { ["weapon"] = "iron-axe" };
        var mockItem = new Item { Id = Guid.NewGuid(), Name = "Iron Axe" };
        _itemServiceMock.Setup(s => s.CreateItem("iron-axe")).Returns(mockItem);

        var result = _service.DistributeRewards(player, quest, choices);

        result.Success.Should().BeTrue();
        result.ItemsGranted.Should().ContainSingle(i => i.Name == "Iron Axe");
    }

    private Player CreateTestPlayer() { /* ... */ }
    private Quest CreateQuestWithRewards(int xp = 0, int gold = 0) { /* ... */ }
    private Quest CreateQuestWithItemReward(string itemId) { /* ... */ }
    private Quest CreateQuestWithReputationReward(string factionId, int amount) { /* ... */ }
    private Quest CreateQuestWithChoiceReward() { /* ... */ }
}
```

### 10.4 RewardDistributionResult Tests (~2 tests)

```csharp
[TestFixture]
public class RewardDistributionResultTests
{
    [Test]
    public void Succeeded_CreatesSuccessfulResult()
    {
        var items = new[] { new Item { Name = "Sword" } };
        var rep = new Dictionary<string, int> { ["guard"] = 100 };

        var result = RewardDistributionResult.Succeeded(50, 25, items, rep);

        result.Success.Should().BeTrue();
        result.XPGranted.Should().Be(50);
        result.GoldGranted.Should().Be(25);
        result.ItemsGranted.Should().HaveCount(1);
        result.ReputationChanges.Should().ContainKey("guard");
        result.ErrorMessage.Should().BeNull();
    }

    [Test]
    public void Failed_CreatesFailedResult()
    {
        var result = RewardDistributionResult.Failed("Not enough space");

        result.Success.Should().BeFalse();
        result.ErrorMessage.Should().Be("Not enough space");
        result.XPGranted.Should().Be(0);
        result.GoldGranted.Should().Be(0);
        result.ItemsGranted.Should().BeEmpty();
    }
}
```

---

## 11. Use Cases

### UC-001: Check Quest Prerequisites
**Actor:** Player
**Flow:** Talk to NPC -> View locked quest -> See unmet prerequisites

### UC-002: Unlock Quest via Prerequisite
**Actor:** Player
**Flow:** Complete prerequisite quest -> Return to NPC -> Quest now available

### UC-003: Turn In Quest with Standard Rewards
**Actor:** Player
**Flow:** Complete objectives -> Talk to NPC -> Turn in -> Receive XP, gold, items, reputation

### UC-004: Turn In Quest with Choice Reward
**Actor:** Player
**Flow:** Complete objectives -> Talk to NPC -> Turn in -> Select from choices -> Receive selected item + other rewards

### UC-005: Turn In Quest with Bonus Rewards
**Actor:** Player
**Flow:** Complete all objectives including optional -> Talk to NPC -> Turn in -> Receive base + bonus rewards

---

## 12. Acceptance Criteria

### AC-3.1c-1: QuestPrerequisite Value Object
- [ ] QuestPrerequisite has Type, TargetId, RequiredValue, IsNegated, Description
- [ ] Level() factory creates level prerequisite
- [ ] Reputation() factory creates reputation prerequisite
- [ ] QuestComplete() factory creates quest prerequisite
- [ ] HasItem() factory creates item prerequisite
- [ ] Negate() creates inverted prerequisite
- [ ] Evaluate() correctly checks player state

### AC-3.1c-2: PrerequisiteType Enum
- [ ] PrerequisiteType has 6 values: Level, Reputation, Quest, Item, Class, Skill
- [ ] All values have XML documentation

### AC-3.1c-3: QuestDefinition Updates
- [ ] QuestDefinition has Prerequisites collection
- [ ] HasPrerequisites returns true when prerequisites exist
- [ ] MeetsPrerequisites evaluates all prerequisites
- [ ] GetUnmetPrerequisites returns only unmet ones

### AC-3.1c-4: IQuestRewardService
- [ ] DistributeRewards grants XP via ExperienceService
- [ ] DistributeRewards grants gold via Player.AddGold
- [ ] DistributeRewards grants items via ItemService + Inventory
- [ ] DistributeRewards modifies reputation via ReputationService
- [ ] GetPendingChoices returns choice groups
- [ ] DistributeRewards with choices grants selected items
- [ ] CanReceiveRewards checks inventory space

### AC-3.1c-5: RewardDistributionResult
- [ ] Succeeded() creates result with all reward details
- [ ] Failed() creates result with error message
- [ ] HasRewards correctly indicates if any rewards granted

### AC-3.1c-6: Turn-In Flow
- [ ] Turn-in prompts for choice selection when needed
- [ ] Turn-in completes quest and grants rewards
- [ ] Turn-in displays reward summary
- [ ] Bonus rewards included when optional objectives complete

### AC-3.1c-7: Configuration
- [ ] quests.json supports prerequisites array
- [ ] Level, Reputation, Quest, Item types supported
- [ ] Schema validates prerequisite entries

### AC-3.1c-8: Locked Quest Display
- [ ] Locked quests show [LOCKED] indicator
- [ ] Unmet prerequisites listed with descriptions
- [ ] Met prerequisites not shown

### AC-3.1c-9: Unit Tests
- [ ] ~20 unit tests implemented
- [ ] All tests pass
- [ ] Tests cover prerequisites, distribution, choices

---

## 13. Deliverable Checklist

### Domain Layer
- [ ] `ValueObjects/QuestPrerequisite.cs`
- [ ] `ValueObjects/RewardDistributionResult.cs`
- [ ] `ValueObjects/RewardChoiceGroup.cs`
- [ ] `Enums/PrerequisiteType.cs`
- [ ] `Definitions/QuestDefinition.cs` updates (Prerequisites)
- [ ] `Entities/NPC.cs` updates (GetLockedQuests)

### Application Layer
- [ ] `Interfaces/IQuestRewardService.cs`
- [ ] `Services/QuestRewardService.cs`
- [ ] `DTOs/TurnInResultDto.cs`
- [ ] `DTOs/ItemGrantDto.cs`
- [ ] `DTOs/ReputationChangeDto.cs`
- [ ] `DTOs/LockedQuestDto.cs`
- [ ] `DTOs/PrerequisiteDto.cs`
- [ ] `DTOs/ChoicePromptDto.cs`
- [ ] `DTOs/ChoiceGroupDto.cs`
- [ ] `DTOs/ChoiceOptionDto.cs`
- [ ] `Services/QuestService.cs` updates (ProcessQuestTurnIn)

### Infrastructure Layer
- [ ] `Configuration/JsonConfigurationProvider.cs` updates (prerequisite parsing)
- [ ] `Configuration/PrerequisiteConfigDto.cs`

### Configuration Files
- [ ] `config/quests.json` updates (prerequisites)
- [ ] `config/schemas/quests.schema.json` updates (prerequisite schema)

### Tests
- [ ] `Domain.Tests/ValueObjects/QuestPrerequisiteTests.cs`
- [ ] `Domain.Tests/Definitions/QuestDefinitionPrerequisiteTests.cs`
- [ ] `Application.Tests/Services/QuestRewardServiceTests.cs`
- [ ] `Domain.Tests/ValueObjects/RewardDistributionResultTests.cs`

### Documentation
- [ ] XML documentation on all public members

---

## 14. Dependencies

### Required from v0.3.0
- Quest entity (from v0.3.0a)
- Player entity with HasCompletedQuest, GetReputation, Inventory (from v0.3.0c)
- QuestDefinition (from v0.3.0a)

### Required from v0.3.1a
- QuestReward value object
- RewardEntry value object
- RewardType enum
- QuestReward.GetEffectiveRewards()
- QuestReward.ChoiceGroups

### Required from v0.3.1b
- NPC.GetAvailableQuests (to be updated with prerequisite checking)
- QuestService.TurnInQuest (to be updated with reward distribution)
- Quest giver dialogue infrastructure

### Required External Services
- IExperienceService for XP delivery
- IReputationService for reputation changes
- IItemService for item creation

### Provided to v0.3.2 (Quest Chains)
- Prerequisite system for chain sequencing
- Quest completion prerequisite type
- Reward distribution infrastructure

---

## 15. Future Considerations

### Deferred to v0.3.2
- **Quest Chains**: Sequential quest requirements using Quest prerequisite
- **Chain Rewards**: Special rewards for completing quest chains
- **Repeatable Quests**: Quests that can be done multiple times

### Deferred to v0.4.x
- **Class Prerequisites**: Requiring specific player class
- **Skill Prerequisites**: Requiring minimum skill levels
- **Dynamic Prerequisites**: Prerequisites that change based on game state

### Out of Scope
- **Time-Based Prerequisites**: Availability windows
- **Group Prerequisites**: Requiring party composition
- **Achievement Prerequisites**: Requiring specific achievements

---

*Document Version: 1.0*
*Last Updated: 2024-01-20*
*Author: Claude Code*
