# v0.0.5 Design Specification: Dice Pool System

**Version:** 0.0.5
**Prerequisite:** v0.0.4d (Integration & Polish) - Complete
**Current Test Count:** 198 tests (123 Domain + 67 Application + 8 Architecture)
**Target Test Count:** ~260 tests (+62 new tests)

> **See Also:** [v0.0.5 Scope Breakdown](v0.0.5-scope-breakdown.md) for phase overview, feature categorization, and design decisions.
>
> This document contains detailed implementation specifications including code samples, architecture diagrams, and test patterns.

---

## Table of Contents

1. [Overview](#overview)
2. [User Stories & Use Cases](#user-stories--use-cases)
3. [Architecture Diagrams](#architecture-diagrams)
4. [Sub-Phase Breakdown](#sub-phase-breakdown)
5. [Phase 5a: Core Dice Engine](#phase-5a-core-dice-engine)
6. [Phase 5b: Skill Check System](#phase-5b-skill-check-system)
7. [Phase 5c: Combat Integration](#phase-5c-combat-integration)
8. [Phase 5d: Configuration & Polish](#phase-5d-configuration--polish)
9. [Testing Strategy](#testing-strategy)
10. [Logging Strategy](#logging-strategy)
11. [Acceptance Criteria](#acceptance-criteria)
12. [Risk Assessment](#risk-assessment)

---

## Overview

### Goals
The Dice Pool System provides the core randomization engine for all game mechanics. This system transforms the current simple random number generation into a comprehensive, configurable dice system that supports:

- **Dice Types**: d4, d6, d8, d10
- **Dice Pools**: Multiple dice rolled together (e.g., 3d6, 2d10+5)
- **Modifiers**: Bonuses/penalties from stats, equipment, abilities
- **Advantage/Disadvantage**: Roll multiple, take best/worst
- **Exploding Dice**: Max roll triggers additional die
- **Skill Checks**: Dice-based success/failure for actions
- **Roll Display**: Show individual dice results to player

### Integration with v0.0.4 Systems

| v0.0.4 System | v0.0.5 Integration |
|---------------|-------------------|
| **Classes** | Class abilities provide skill check bonuses |
| **Resources** | Skill checks may cost resources |
| **Abilities** | Ability effects use dice for damage/healing |
| **Turn Processing** | Skill checks can be turn-ending actions |
| **Combat** | Attack/damage rolls replace static calculations |

### Why Sub-Phases?

The dice pool system touches many parts of the codebase. Breaking into 4 sub-phases allows:
1. Incremental, testable progress
2. Focused code reviews
3. Reduced merge conflicts
4. Clear milestone boundaries

---

## User Stories & Use Cases

### User Story 1: Dice Rolling
**As a** player
**I want to** see dice roll results with individual die values
**So that** I understand how randomness affects my actions

**Acceptance Criteria:**
- [ ] Roll results show individual dice (e.g., "Rolled 3d6: [4, 2, 6] = 12")
- [ ] Critical successes (natural max) are highlighted
- [ ] Critical failures (natural 1) are highlighted
- [ ] Modifiers displayed separately (e.g., "+3 from Might = 15")

### User Story 2: Skill Checks
**As a** player
**I want to** perform skill checks for non-combat actions
**So that** my character's abilities affect exploration and interaction

**Example Use Cases:**
- Lockpicking a chest (Finesse check)
- Intimidating an enemy (Might check)
- Searching for secrets (Wits check)
- Resisting poison (Fortitude check)
- Sensing magic (Will check)

### User Story 3: Combat Dice
**As a** player
**I want to** see attack and damage rolls
**So that** combat feels more dynamic and strategic

**Example Combat Flow:**
```
> attack goblin

You attack the Goblin!
Attack Roll: [14] + 3 (Finesse) = 17 vs Defense 12
Hit! Rolling damage...
Damage Roll: 2d6 [3, 5] + 2 (Might) = 10 damage!
The Goblin takes 10 damage. (HP: 15 -> 5)
```

### User Story 4: Advantage/Disadvantage
**As a** player
**I want to** roll with advantage or disadvantage
**So that** situational bonuses feel impactful

**Example:**
```
> attack goblin (with advantage from Shadowstep)

Attack Roll with Advantage:
  Roll 1: [8] + 3 = 11
  Roll 2: [17] + 3 = 20 (BEST)
Using 20 vs Defense 12 - Critical Hit!
```

### User Story 5: Exploding Dice
**As a** player
**I want to** see dice explode on maximum rolls
**So that** lucky streaks create exciting moments

**Example:**
```
Damage Roll: 1d8 (exploding)
[8] EXPLODES! -> [8] EXPLODES! -> [3]
Total: 19 damage! The gods smile upon you!
```

---

## Architecture Diagrams

### Component Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              PRESENTATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌────────────────────┐  │
│  │   GameView.cs       │  │ SpectreGameRenderer │  │ ConsoleInputHandler│  │
│  │ - HandleSkillCheck  │  │ - RenderDiceRoll    │  │ - Parse "roll"     │  │
│  │ - HandleRollCommand │  │ - RenderSkillCheck  │  │ - Parse "check"    │  │
│  └─────────────────────┘  └─────────────────────┘  └────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌────────────────────┐  │
│  │   DiceService       │  │  SkillCheckService  │  │ GameSessionService │  │
│  │ - Roll()            │  │ - PerformCheck()    │  │ - TrySkillCheck()  │  │
│  │ - RollWithAdvantage │  │ - GetDifficulty()   │  │ - TryAttack()      │  │
│  │ - RollExploding()   │  │ - ApplyModifiers()  │  │   (uses dice)      │  │
│  └─────────────────────┘  └─────────────────────┘  └────────────────────┘  │
│                                      │                                      │
│  ┌─────────────────────┐  ┌─────────────────────┐                          │
│  │   DTOs/             │  │  IGameConfig...     │                          │
│  │ - DiceRollDto       │  │ - GetDiceConfig()   │                          │
│  │ - SkillCheckDto     │  │ - GetSkillDefs()    │                          │
│  │ - DiceConfigDto     │  └─────────────────────┘                          │
│  └─────────────────────┘                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                               DOMAIN LAYER                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌────────────────────┐  │
│  │   ValueObjects/     │  │   Definitions/      │  │   Services/        │  │
│  │ - DicePool          │  │ - DicePoolDef       │  │ - CombatService    │  │
│  │ - DiceResult        │  │ - SkillDefinition   │  │   (updated)        │  │
│  │ - DiceRollResult    │  │ - DifficultyClass   │  └────────────────────┘  │
│  │ - SkillCheckResult  │  └─────────────────────┘                          │
│  └─────────────────────┘                                                    │
│                                      │                                      │
│  ┌─────────────────────┐  ┌─────────────────────┐                          │
│  │   Enums/            │  │   Entities/         │                          │
│  │ - DiceType          │  │ - Player (updated)  │                          │
│  │ - AdvantageType     │  │   + SkillBonuses    │                          │
│  │ - SuccessLevel      │  └─────────────────────┘                          │
│  └─────────────────────┘                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            INFRASTRUCTURE LAYER                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    JsonConfigurationProvider                         │   │
│  │  - GetDicePoolConfiguration()                                        │   │
│  │  - GetSkillDefinitions()                                             │   │
│  │  - GetDifficultyClasses()                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│  ┌─────────────────────┐  ┌─────────────────────┐                          │
│  │  config/            │  │  config/            │                          │
│  │  dice.json          │  │  skills.json        │                          │
│  └─────────────────────┘  └─────────────────────┘                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Dice Roll Workflow

```
┌──────────┐     ┌──────────────┐     ┌─────────────┐     ┌──────────────┐
│  Player  │────▶│ InputHandler │────▶│ GameView    │────▶│ DiceService  │
│  "roll   │     │ Parse        │     │ HandleRoll  │     │ Roll()       │
│   3d6+2" │     │ RollCommand  │     │ Command()   │     │              │
└──────────┘     └──────────────┘     └─────────────┘     └──────────────┘
                                                                  │
                                                                  ▼
┌──────────┐     ┌──────────────┐     ┌─────────────┐     ┌──────────────┐
│  Player  │◀────│ Renderer     │◀────│ DiceRollDto │◀────│ DiceResult   │
│  Sees    │     │ RenderDice   │     │ Transform   │     │ (domain)     │
│  Result  │     │ Roll()       │     │ to DTO      │     │              │
└──────────┘     └──────────────┘     └─────────────┘     └──────────────┘
```

### Skill Check Workflow

```
┌─────────┐   ┌─────────┐   ┌───────────────┐   ┌─────────────────┐
│ Player  │──▶│ "search"│──▶│ GameSession   │──▶│ SkillCheckSvc   │
│ Action  │   │ command │   │ TrySkillCheck │   │ PerformCheck()  │
└─────────┘   └─────────┘   └───────────────┘   └─────────────────┘
                                                        │
                 ┌──────────────────────────────────────┘
                 ▼
        ┌─────────────────┐
        │ 1. Get Skill    │
        │    Definition   │
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 2. Calculate    │──▶ Player Attributes
        │    Modifiers    │──▶ Equipment Bonuses
        └────────┬────────┘──▶ Ability Effects
                 │
                 ▼
        ┌─────────────────┐
        │ 3. DiceService  │──▶ Roll dice pool
        │    Roll()       │──▶ Apply modifiers
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 4. Compare to   │──▶ Get DC from config
        │    Difficulty   │──▶ Determine success
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 5. Get          │──▶ dice.json descriptors
        │    Descriptor   │──▶ skillchecks.json
        └────────┬────────┘
                 │
                 ▼
        ┌─────────────────┐
        │ 6. Return       │──▶ SkillCheckResultDto
        │    Result       │
        └─────────────────┘
```

### Combat Dice Integration

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           COMBAT ROUND FLOW                                  │
└─────────────────────────────────────────────────────────────────────────────┘

    ┌─────────────┐
    │ Player      │
    │ "attack"    │
    └──────┬──────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  ATTACK ROLL                                                     │
    │  ┌─────────────┐   ┌─────────────┐   ┌─────────────────────┐   │
    │  │ Roll 1d20   │ + │ Finesse     │ + │ Weapon Bonus        │   │
    │  │ [14]        │   │ +3          │   │ +1 (Rusty Sword)    │   │
    │  └─────────────┘   └─────────────┘   └─────────────────────┘   │
    │                           = 18 (Attack Total)                   │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  COMPARE TO DEFENSE                                              │
    │  Attack (18) vs Monster Defense (12)                             │
    │  Result: HIT!                                                    │
    │                                                                  │
    │  Critical Check:                                                 │
    │  - Natural 20? → Critical Hit (double damage dice)               │
    │  - Natural 1?  → Critical Miss (fumble)                          │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  DAMAGE ROLL (if hit)                                            │
    │  ┌─────────────┐   ┌─────────────┐   ┌─────────────────────┐   │
    │  │ Weapon Dice │ + │ Might       │ + │ Ability Bonus       │   │
    │  │ 1d6 [4]     │   │ +2          │   │ +0                  │   │
    │  └─────────────┘   └─────────────┘   └─────────────────────┘   │
    │                           = 6 (Raw Damage)                      │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  APPLY DAMAGE                                                    │
    │  Raw Damage (6) - Monster Armor (2) = 4 Final Damage             │
    │  Monster HP: 15 → 11                                             │
    └─────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌─────────────────────────────────────────────────────────────────┐
    │  MONSTER COUNTERATTACK (same flow)                               │
    │  Attack Roll → Defense Check → Damage Roll → Apply               │
    └─────────────────────────────────────────────────────────────────┘
```

---

## Sub-Phase Breakdown

| Phase | Focus | Deliverables | Est. Tests |
|-------|-------|--------------|------------|
| **5a** | Core Dice Engine | DicePool, DiceResult, DiceService, basic rolling | ~18 |
| **5b** | Skill Check System | SkillDefinition, SkillCheckService, difficulty classes | ~20 |
| **5c** | Combat Integration | Attack rolls, damage rolls, CombatService refactor | ~15 |
| **5d** | Configuration & Polish | JSON configs, rendering, commands, descriptors | ~9 |

---

## Phase 5a: Core Dice Engine
[Implementation Plan](v0.0.5a-implementation-plan.md)

### Overview
Create the fundamental dice rolling infrastructure: value objects, enums, and the core DiceService.

### Files to Create

#### 1. Domain Enums

**File:** `src/Core/RuneAndRust.Domain/Enums/DiceType.cs`
```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the type of die used in a dice pool.
/// All skill checks and resolutions use d10 increments.
/// </summary>
public enum DiceType
{
    D4 = 4,
    D6 = 6,
    D8 = 8,
    D10 = 10
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/AdvantageType.cs`
```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents advantage/disadvantage state for dice rolls.
/// </summary>
public enum AdvantageType
{
    /// <summary>Normal roll - single roll used.</summary>
    Normal,
    /// <summary>Advantage - roll twice, take higher.</summary>
    Advantage,
    /// <summary>Disadvantage - roll twice, take lower.</summary>
    Disadvantage
}
```

**File:** `src/Core/RuneAndRust.Domain/Enums/SuccessLevel.cs`
```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the degree of success or failure for a check.
/// </summary>
public enum SuccessLevel
{
    CriticalFailure,
    Failure,
    Success,
    CriticalSuccess
}
```

#### 2. Domain Value Objects

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DicePool.cs`
```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a pool of dice to be rolled together.
/// Immutable value object supporting dice notation (e.g., "3d6+5").
/// </summary>
public readonly record struct DicePool
{
    /// <summary>Number of dice in the pool (minimum 1).</summary>
    public int Count { get; init; }

    /// <summary>Type of dice (d4, d6, d8, d10).</summary>
    public DiceType DiceType { get; init; }

    /// <summary>Flat modifier added to the total roll.</summary>
    public int Modifier { get; init; }

    /// <summary>Whether dice explode on maximum value.</summary>
    public bool Exploding { get; init; }

    /// <summary>Maximum number of explosions allowed (prevents infinite loops).</summary>
    public int MaxExplosions { get; init; }

    /// <summary>Number of sides on each die.</summary>
    public int Faces => (int)DiceType;

    /// <summary>Minimum possible result (Count * 1 + Modifier).</summary>
    public int MinimumResult => Count + Modifier;

    /// <summary>Maximum possible result without explosions.</summary>
    public int MaximumResult => Count * Faces + Modifier;

    /// <summary>Average expected result.</summary>
    public float AverageResult => Count * ((Faces + 1) / 2f) + Modifier;

    /// <summary>
    /// Creates a new dice pool with validation.
    /// </summary>
    /// <exception cref="ArgumentOutOfRangeException">If count is less than 1.</exception>
    public DicePool(int count, DiceType diceType, int modifier = 0, bool exploding = false, int maxExplosions = 10)
    {
        if (count < 1)
            throw new ArgumentOutOfRangeException(nameof(count), "Dice count must be at least 1");
        if (maxExplosions < 0)
            throw new ArgumentOutOfRangeException(nameof(maxExplosions), "Max explosions cannot be negative");

        Count = count;
        DiceType = diceType;
        Modifier = modifier;
        Exploding = exploding;
        MaxExplosions = maxExplosions;
    }

    /// <summary>Dice notation string (e.g., "3d6+5").</summary>
    public override string ToString()
    {
        var notation = $"{Count}d{Faces}";
        if (Modifier > 0) notation += $"+{Modifier}";
        else if (Modifier < 0) notation += Modifier.ToString();
        if (Exploding) notation += "!";
        return notation;
    }

    // Static factory methods for common dice pools
    public static DicePool D4(int count = 1, int modifier = 0) => new(count, DiceType.D4, modifier);
    public static DicePool D6(int count = 1, int modifier = 0) => new(count, DiceType.D6, modifier);
    public static DicePool D8(int count = 1, int modifier = 0) => new(count, DiceType.D8, modifier);
    public static DicePool D10(int count = 1, int modifier = 0) => new(count, DiceType.D10, modifier);

    /// <summary>Creates an exploding dice pool.</summary>
    public DicePool WithExploding(int maxExplosions = 10) => this with { Exploding = true, MaxExplosions = maxExplosions };

    /// <summary>Creates a copy with a different modifier.</summary>
    public DicePool WithModifier(int modifier) => this with { Modifier = modifier };

    /// <summary>
    /// Parses dice notation string (e.g., "3d6+5", "1d20", "2d8-1").
    /// </summary>
    /// <exception cref="FormatException">If notation is invalid.</exception>
    public static DicePool Parse(string notation)
    {
        if (string.IsNullOrWhiteSpace(notation))
            throw new FormatException("Dice notation cannot be empty");

        // Handle exploding notation
        var exploding = notation.EndsWith('!');
        if (exploding)
            notation = notation[..^1];

        // Parse: [count]d[faces][+/-modifier]
        var dIndex = notation.IndexOf('d', StringComparison.OrdinalIgnoreCase);
        if (dIndex < 0)
            throw new FormatException($"Invalid dice notation: {notation}");

        // Parse count (default to 1 if not specified)
        var countStr = dIndex > 0 ? notation[..dIndex] : "1";
        if (!int.TryParse(countStr, out var count))
            throw new FormatException($"Invalid dice count: {countStr}");

        // Parse faces and modifier
        var rest = notation[(dIndex + 1)..];
        var modifier = 0;
        var facesStr = rest;

        var plusIndex = rest.IndexOf('+');
        var minusIndex = rest.IndexOf('-');
        var modIndex = plusIndex >= 0 ? plusIndex : minusIndex;

        if (modIndex >= 0)
        {
            facesStr = rest[..modIndex];
            var modStr = rest[modIndex..];
            if (!int.TryParse(modStr, out modifier))
                throw new FormatException($"Invalid modifier: {modStr}");
        }

        if (!int.TryParse(facesStr, out var faces))
            throw new FormatException($"Invalid dice faces: {facesStr}");

        var diceType = faces switch
        {
            4 => DiceType.D4,
            6 => DiceType.D6,
            8 => DiceType.D8,
            10 => DiceType.D10,
            _ => throw new FormatException($"Unsupported dice type: d{faces}")
        };

        return new DicePool(count, diceType, modifier, exploding);
    }

    /// <summary>Tries to parse dice notation, returning false if invalid.</summary>
    public static bool TryParse(string notation, out DicePool result)
    {
        try
        {
            result = Parse(notation);
            return true;
        }
        catch
        {
            result = default;
            return false;
        }
    }
}
```

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/DiceRollResult.cs`
```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of rolling a dice pool.
/// Immutable value object containing all roll details.
/// </summary>
public readonly record struct DiceRollResult
{
    /// <summary>The dice pool that was rolled.</summary>
    public DicePool Pool { get; init; }

    /// <summary>Individual dice results before modifier.</summary>
    public IReadOnlyList<int> Rolls { get; init; }

    /// <summary>Additional rolls from exploding dice.</summary>
    public IReadOnlyList<int> ExplosionRolls { get; init; }

    /// <summary>Total of all dice (including explosions).</summary>
    public int DiceTotal { get; init; }

    /// <summary>Final total including modifier.</summary>
    public int Total { get; init; }

    /// <summary>Advantage type used for this roll.</summary>
    public AdvantageType AdvantageType { get; init; }

    /// <summary>All rolls made (for advantage/disadvantage).</summary>
    public IReadOnlyList<int> AllRollTotals { get; init; }

    /// <summary>Index of the selected roll (0 for normal).</summary>
    public int SelectedRollIndex { get; init; }

    /// <summary>True if the first die rolled its maximum value.</summary>
    public bool IsNaturalMax => Rolls.Count > 0 && Rolls[0] == Pool.Faces;

    /// <summary>True if the first die rolled a 1.</summary>
    public bool IsNaturalOne => Rolls.Count > 0 && Rolls[0] == 1;

    /// <summary>True if any dice exploded.</summary>
    public bool HadExplosions => ExplosionRolls.Count > 0;

    /// <summary>Number of explosions that occurred.</summary>
    public int ExplosionCount => ExplosionRolls.Count;

    /// <summary>
    /// Creates a roll result with required fields.
    /// </summary>
    public DiceRollResult(
        DicePool pool,
        IReadOnlyList<int> rolls,
        int total,
        AdvantageType advantageType = AdvantageType.Normal,
        IReadOnlyList<int>? explosionRolls = null,
        IReadOnlyList<int>? allRollTotals = null,
        int selectedRollIndex = 0)
    {
        Pool = pool;
        Rolls = rolls;
        ExplosionRolls = explosionRolls ?? Array.Empty<int>();
        DiceTotal = rolls.Sum() + (explosionRolls?.Sum() ?? 0);
        Total = total;
        AdvantageType = advantageType;
        AllRollTotals = allRollTotals ?? new[] { total };
        SelectedRollIndex = selectedRollIndex;
    }

    /// <summary>
    /// Returns a formatted string showing the roll breakdown.
    /// Example: "3d6+2: [4, 2, 5] + 2 = 13"
    /// </summary>
    public override string ToString()
    {
        var rollsStr = $"[{string.Join(", ", Rolls)}]";

        if (HadExplosions)
            rollsStr += $" + explosions [{string.Join(", ", ExplosionRolls)}]";

        var result = $"{Pool}: {rollsStr}";

        if (Pool.Modifier != 0)
        {
            var modSign = Pool.Modifier > 0 ? "+" : "";
            result += $" {modSign}{Pool.Modifier}";
        }

        result += $" = {Total}";

        if (AdvantageType != AdvantageType.Normal)
        {
            var allRolls = string.Join(", ", AllRollTotals);
            var typeStr = AdvantageType == AdvantageType.Advantage ? "ADV" : "DIS";
            result += $" ({typeStr}: [{allRolls}])";
        }

        return result;
    }
}
```

#### 3. Application Service

**File:** `src/Core/RuneAndRust.Application/Services/DiceService.cs`
```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Core dice rolling service. Handles all randomization in the game.
/// </summary>
public class DiceService
{
    private readonly Random _random;
    private readonly ILogger<DiceService> _logger;

    public DiceService(ILogger<DiceService> logger, Random? random = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = random ?? new Random();
        _logger.LogInformation("DiceService initialized");
    }

    /// <summary>
    /// Rolls a dice pool and returns the result.
    /// </summary>
    /// <param name="pool">The dice pool to roll.</param>
    /// <param name="advantageType">Whether to roll with advantage or disadvantage.</param>
    /// <returns>The complete roll result with breakdown.</returns>
    public DiceRollResult Roll(DicePool pool, AdvantageType advantageType = AdvantageType.Normal)
    {
        _logger.LogDebug("Rolling {Pool} with {AdvantageType}", pool, advantageType);

        if (advantageType == AdvantageType.Normal)
        {
            return RollOnce(pool, advantageType);
        }

        // Roll twice for advantage/disadvantage
        var roll1 = RollOnce(pool, advantageType);
        var roll2 = RollOnce(pool, advantageType);

        var allTotals = new[] { roll1.Total, roll2.Total };
        var selectedIndex = advantageType == AdvantageType.Advantage
            ? (roll1.Total >= roll2.Total ? 0 : 1)
            : (roll1.Total <= roll2.Total ? 0 : 1);

        var selectedRoll = selectedIndex == 0 ? roll1 : roll2;

        var result = new DiceRollResult(
            pool,
            selectedRoll.Rolls,
            selectedRoll.Total,
            advantageType,
            selectedRoll.ExplosionRolls,
            allTotals,
            selectedIndex);

        _logger.LogInformation(
            "Roll {Pool} ({AdvantageType}): [{Roll1}, {Roll2}] -> {Selected}",
            pool, advantageType, roll1.Total, roll2.Total, result.Total);

        return result;
    }

    /// <summary>
    /// Performs a single roll of the dice pool.
    /// </summary>
    private DiceRollResult RollOnce(DicePool pool, AdvantageType advantageType)
    {
        var rolls = new List<int>();
        var explosions = new List<int>();

        // Roll each die
        for (var i = 0; i < pool.Count; i++)
        {
            var roll = RollSingleDie(pool.Faces);
            rolls.Add(roll);

            // Handle exploding dice
            if (pool.Exploding && roll == pool.Faces)
            {
                var explosionCount = 0;
                var explosionRoll = roll;

                while (explosionRoll == pool.Faces && explosionCount < pool.MaxExplosions)
                {
                    explosionRoll = RollSingleDie(pool.Faces);
                    explosions.Add(explosionRoll);
                    explosionCount++;

                    _logger.LogDebug(
                        "Die exploded! Roll {Explosion} on d{Faces} (explosion {Count})",
                        explosionRoll, pool.Faces, explosionCount);
                }
            }
        }

        var diceTotal = rolls.Sum() + explosions.Sum();
        var total = diceTotal + pool.Modifier;

        _logger.LogDebug(
            "Rolled {Pool}: dice=[{Rolls}] explosions=[{Explosions}] total={Total}",
            pool, string.Join(",", rolls), string.Join(",", explosions), total);

        return new DiceRollResult(
            pool,
            rolls.AsReadOnly(),
            total,
            advantageType,
            explosions.AsReadOnly());
    }

    /// <summary>
    /// Rolls a single die with the specified number of faces.
    /// </summary>
    private int RollSingleDie(int faces) => _random.Next(1, faces + 1);

    /// <summary>
    /// Parses dice notation and rolls.
    /// </summary>
    /// <param name="notation">Dice notation (e.g., "3d6+5").</param>
    /// <param name="advantageType">Advantage/disadvantage.</param>
    /// <returns>Roll result.</returns>
    /// <exception cref="FormatException">If notation is invalid.</exception>
    public DiceRollResult Roll(string notation, AdvantageType advantageType = AdvantageType.Normal)
    {
        var pool = DicePool.Parse(notation);
        return Roll(pool, advantageType);
    }

    /// <summary>
    /// Convenience method for rolling a single die type.
    /// </summary>
    public DiceRollResult Roll(DiceType diceType, int count = 1, int modifier = 0)
    {
        var pool = new DicePool(count, diceType, modifier);
        return Roll(pool);
    }

    /// <summary>
    /// Quick roll returning just the total (for internal use).
    /// </summary>
    public int RollTotal(DicePool pool) => Roll(pool).Total;

    /// <summary>
    /// Quick roll returning just the total from notation.
    /// </summary>
    public int RollTotal(string notation) => Roll(notation).Total;
}
```

#### 4. Application DTOs

**File:** `src/Core/RuneAndRust.Application/DTOs/DiceDtos.cs`
```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for dice roll results displayed to the player.
/// </summary>
public record DiceRollDto(
    string Notation,
    IReadOnlyList<int> Rolls,
    IReadOnlyList<int> ExplosionRolls,
    int Modifier,
    int DiceTotal,
    int Total,
    bool IsNaturalMax,
    bool IsNaturalOne,
    bool HadExplosions,
    string AdvantageType,
    IReadOnlyList<int>? AllRollTotals = null,
    string? Descriptor = null)
{
    /// <summary>
    /// Creates a DTO from a domain DiceRollResult.
    /// </summary>
    public static DiceRollDto FromDomainResult(
        Domain.ValueObjects.DiceRollResult result,
        string? descriptor = null)
    {
        return new DiceRollDto(
            result.Pool.ToString(),
            result.Rolls,
            result.ExplosionRolls,
            result.Pool.Modifier,
            result.DiceTotal,
            result.Total,
            result.IsNaturalMax,
            result.IsNaturalOne,
            result.HadExplosions,
            result.AdvantageType.ToString(),
            result.AllRollTotals,
            descriptor);
    }
}

/// <summary>
/// DTO for dice pool configuration.
/// </summary>
public record DicePoolDto(
    string Id,
    string Name,
    string Notation,
    bool Exploding,
    int MaxExplosions,
    string? Description = null);
```

### Phase 5a Tests (~18 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/DicePoolTests.cs`
```csharp
[TestFixture]
public class DicePoolTests
{
    [Test]
    public void Constructor_WithValidCount_CreatesDicePool()
    {
        var pool = new DicePool(3, DiceType.D6, 5);

        pool.Count.Should().Be(3);
        pool.DiceType.Should().Be(DiceType.D6);
        pool.Modifier.Should().Be(5);
        pool.Faces.Should().Be(6);
    }

    [Test]
    public void Constructor_WithZeroCount_ThrowsException()
    {
        var act = () => new DicePool(0, DiceType.D6);
        act.Should().Throw<ArgumentOutOfRangeException>();
    }

    [Test]
    public void MinimumResult_CalculatesCorrectly()
    {
        var pool = new DicePool(3, DiceType.D6, 2);
        pool.MinimumResult.Should().Be(5); // 3 * 1 + 2
    }

    [Test]
    public void MaximumResult_CalculatesCorrectly()
    {
        var pool = new DicePool(3, DiceType.D6, 2);
        pool.MaximumResult.Should().Be(20); // 3 * 6 + 2
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        new DicePool(3, DiceType.D6, 5).ToString().Should().Be("3d6+5");
        new DicePool(2, DiceType.D8, -2).ToString().Should().Be("2d8-2");
        new DicePool(1, DiceType.D10).ToString().Should().Be("1d10");
        new DicePool(2, DiceType.D6, 0, true).ToString().Should().Be("2d6!");
    }

    [Test]
    public void Parse_ValidNotation_CreatesDicePool()
    {
        var pool = DicePool.Parse("3d6+5");

        pool.Count.Should().Be(3);
        pool.DiceType.Should().Be(DiceType.D6);
        pool.Modifier.Should().Be(5);
    }

    [Test]
    public void Parse_NegativeModifier_ParsesCorrectly()
    {
        var pool = DicePool.Parse("2d8-3");

        pool.Count.Should().Be(2);
        pool.Modifier.Should().Be(-3);
    }

    [Test]
    public void Parse_ExplodingNotation_SetsExplodingFlag()
    {
        var pool = DicePool.Parse("1d6!");
        pool.Exploding.Should().BeTrue();
    }

    [Test]
    public void Parse_NoCount_DefaultsToOne()
    {
        var pool = DicePool.Parse("d10");
        pool.Count.Should().Be(1);
    }

    [Test]
    public void Parse_InvalidNotation_ThrowsFormatException()
    {
        var act = () => DicePool.Parse("invalid");
        act.Should().Throw<FormatException>();
    }

    [Test]
    public void TryParse_InvalidNotation_ReturnsFalse()
    {
        var result = DicePool.TryParse("invalid", out _);
        result.Should().BeFalse();
    }

    [Test]
    public void StaticFactories_CreateCorrectPools()
    {
        DicePool.D10().Faces.Should().Be(10);
        DicePool.D6(3, 2).Count.Should().Be(3);
        DicePool.D6(3, 2).Modifier.Should().Be(2);
    }
}
```

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/DiceRollResultTests.cs`
```csharp
[TestFixture]
public class DiceRollResultTests
{
    [Test]
    public void IsNaturalMax_WhenFirstDieIsMax_ReturnsTrue()
    {
        var pool = DicePool.D10();
        var result = new DiceRollResult(pool, new[] { 10 }, 10);

        result.IsNaturalMax.Should().BeTrue();
    }

    [Test]
    public void IsNaturalOne_WhenFirstDieIsOne_ReturnsTrue()
    {
        var pool = DicePool.D10();
        var result = new DiceRollResult(pool, new[] { 1 }, 1);

        result.IsNaturalOne.Should().BeTrue();
    }

    [Test]
    public void HadExplosions_WhenExplosionsExist_ReturnsTrue()
    {
        var pool = DicePool.D6().WithExploding();
        var result = new DiceRollResult(pool, new[] { 6 }, 10,
            explosionRolls: new[] { 4 });

        result.HadExplosions.Should().BeTrue();
        result.ExplosionCount.Should().Be(1);
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        var pool = new DicePool(2, DiceType.D6, 3);
        var result = new DiceRollResult(pool, new[] { 4, 5 }, 12);

        result.ToString().Should().Contain("[4, 5]");
        result.ToString().Should().Contain("= 12");
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/DiceServiceTests.cs`
```csharp
[TestFixture]
public class DiceServiceTests
{
    private DiceService _service = null!;
    private Mock<ILogger<DiceService>> _mockLogger = null!;
    private Mock<Random> _mockRandom = null!;

    [SetUp]
    public void SetUp()
    {
        _mockLogger = new Mock<ILogger<DiceService>>();
        // Use real Random for most tests
        _service = new DiceService(_mockLogger.Object);
    }

    [Test]
    public void Roll_SingleD10_ReturnsValidRange()
    {
        var results = Enumerable.Range(0, 100)
            .Select(_ => _service.Roll(DicePool.D10()))
            .ToList();

        results.Should().AllSatisfy(r =>
        {
            r.Total.Should().BeInRange(1, 10);
            r.Rolls.Should().HaveCount(1);
        });
    }

    [Test]
    public void Roll_3d6Plus5_ReturnsCorrectRange()
    {
        var pool = new DicePool(3, DiceType.D6, 5);
        var results = Enumerable.Range(0, 100)
            .Select(_ => _service.Roll(pool))
            .ToList();

        results.Should().AllSatisfy(r =>
        {
            r.Total.Should().BeInRange(8, 23); // 3+5 to 18+5
            r.Rolls.Should().HaveCount(3);
        });
    }

    [Test]
    public void Roll_WithAdvantage_RollsTwiceAndTakesHigher()
    {
        var pool = DicePool.D10();
        var result = _service.Roll(pool, AdvantageType.Advantage);

        result.AllRollTotals.Should().HaveCount(2);
        result.Total.Should().Be(result.AllRollTotals!.Max());
        result.AdvantageType.Should().Be(AdvantageType.Advantage);
    }

    [Test]
    public void Roll_WithDisadvantage_RollsTwiceAndTakesLower()
    {
        var pool = DicePool.D10();
        var result = _service.Roll(pool, AdvantageType.Disadvantage);

        result.AllRollTotals.Should().HaveCount(2);
        result.Total.Should().Be(result.AllRollTotals!.Min());
        result.AdvantageType.Should().Be(AdvantageType.Disadvantage);
    }

    [Test]
    public void Roll_FromNotation_ParsesAndRolls()
    {
        var result = _service.Roll("2d6+3");

        result.Pool.Count.Should().Be(2);
        result.Pool.DiceType.Should().Be(DiceType.D6);
        result.Pool.Modifier.Should().Be(3);
    }

    [Test]
    public void RollTotal_ReturnsJustTotal()
    {
        var total = _service.RollTotal("1d6");
        total.Should().BeInRange(1, 6);
    }
}
```

### Phase 5a Deliverables Checklist

- [ ] `DiceType.cs` - Enum for dice types (d4, d6, d8, d10)
- [ ] `AdvantageType.cs` - Enum for advantage/disadvantage
- [ ] `SuccessLevel.cs` - Enum for success levels
- [ ] `DicePool.cs` - Value object with parsing
- [ ] `DiceRollResult.cs` - Value object for roll results
- [ ] `DiceService.cs` - Core rolling service
- [ ] `DiceDtos.cs` - DTOs for presentation layer
- [ ] `DicePoolTests.cs` - ~12 tests
- [ ] `DiceRollResultTests.cs` - ~4 tests
- [ ] `DiceServiceTests.cs` - ~6 tests
- [ ] All existing 198 tests still pass

---

## Phase 5b: Skill Check System
[Design Specification](v0.0.5b-design-specification.md)

[Implementation Plan](v0.0.5b-implementation-plan.md)

### Overview
Build the skill check framework that uses dice rolls to determine success/failure for player actions.

### Files to Create

#### 1. Domain Definitions

**File:** `src/Core/RuneAndRust.Domain/Definitions/SkillDefinition.cs`
```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a skill that can be checked against difficulty.
/// Loaded from configuration.
/// </summary>
public class SkillDefinition
{
    /// <summary>Unique identifier (e.g., "lockpicking", "perception").</summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>Display name (e.g., "Lockpicking", "Perception").</summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>Description of what the skill does.</summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>Primary attribute that modifies this skill (e.g., "finesse", "wits").</summary>
    public string PrimaryAttribute { get; init; } = string.Empty;

    /// <summary>Optional secondary attribute that provides half bonus.</summary>
    public string? SecondaryAttribute { get; init; }

    /// <summary>Base dice pool notation (e.g., "1d10", "2d6").</summary>
    public string BaseDicePool { get; init; } = "1d10";

    /// <summary>Whether this skill can be attempted untrained.</summary>
    public bool AllowUntrained { get; init; } = true;

    /// <summary>Penalty when attempting untrained.</summary>
    public int UntrainedPenalty { get; init; } = 0;

    /// <summary>Category for organization (e.g., "Combat", "Exploration", "Social").</summary>
    public string Category { get; init; } = "General";

    /// <summary>Tags for filtering and searching.</summary>
    public IReadOnlyList<string> Tags { get; init; } = Array.Empty<string>();

    public static SkillDefinition Create(
        string id,
        string name,
        string description,
        string primaryAttribute,
        string? secondaryAttribute = null,
        string baseDicePool = "1d10",
        bool allowUntrained = true,
        int untrainedPenalty = 0,
        string category = "General",
        IReadOnlyList<string>? tags = null)
    {
        if (string.IsNullOrWhiteSpace(id))
            throw new ArgumentException("Skill ID is required", nameof(id));
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Skill name is required", nameof(name));
        if (string.IsNullOrWhiteSpace(primaryAttribute))
            throw new ArgumentException("Primary attribute is required", nameof(primaryAttribute));

        return new SkillDefinition
        {
            Id = id,
            Name = name,
            Description = description,
            PrimaryAttribute = primaryAttribute,
            SecondaryAttribute = secondaryAttribute,
            BaseDicePool = baseDicePool,
            AllowUntrained = allowUntrained,
            UntrainedPenalty = untrainedPenalty,
            Category = category,
            Tags = tags ?? Array.Empty<string>()
        };
    }
}
```

**File:** `src/Core/RuneAndRust.Domain/Definitions/DifficultyClassDefinition.cs`
```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a difficulty class (DC) threshold.
/// Loaded from configuration.
/// </summary>
public class DifficultyClassDefinition
{
    /// <summary>Unique identifier (e.g., "trivial", "easy", "hard").</summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>Display name (e.g., "Trivial", "Easy", "Hard").</summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>Description shown to player.</summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>Target number to meet or exceed.</summary>
    public int TargetNumber { get; init; }

    /// <summary>Display color (for UI).</summary>
    public string Color { get; init; } = "#FFFFFF";

    /// <summary>Sort order for display.</summary>
    public int SortOrder { get; init; }

    public static DifficultyClassDefinition Create(
        string id,
        string name,
        string description,
        int targetNumber,
        string color = "#FFFFFF",
        int sortOrder = 0)
    {
        if (string.IsNullOrWhiteSpace(id))
            throw new ArgumentException("Difficulty class ID is required", nameof(id));
        if (targetNumber < 1)
            throw new ArgumentOutOfRangeException(nameof(targetNumber), "Target number must be at least 1");

        return new DifficultyClassDefinition
        {
            Id = id,
            Name = name,
            Description = description,
            TargetNumber = targetNumber,
            Color = color,
            SortOrder = sortOrder
        };
    }
}
```

#### 2. Domain Value Objects

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillCheckResult.cs`
```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of a skill check.
/// </summary>
public readonly record struct SkillCheckResult
{
    /// <summary>The skill that was checked.</summary>
    public string SkillId { get; init; }

    /// <summary>The skill display name.</summary>
    public string SkillName { get; init; }

    /// <summary>The dice roll result.</summary>
    public DiceRollResult DiceResult { get; init; }

    /// <summary>Bonus from primary attribute.</summary>
    public int AttributeBonus { get; init; }

    /// <summary>Bonus from other sources (equipment, abilities, etc.).</summary>
    public int OtherBonus { get; init; }

    /// <summary>Total result (dice + all bonuses).</summary>
    public int TotalResult { get; init; }

    /// <summary>Difficulty class that was checked against.</summary>
    public int DifficultyClass { get; init; }

    /// <summary>Name of the difficulty level.</summary>
    public string DifficultyName { get; init; }

    /// <summary>The degree of success or failure.</summary>
    public SuccessLevel SuccessLevel { get; init; }

    /// <summary>Margin of success (positive) or failure (negative).</summary>
    public int Margin => TotalResult - DifficultyClass;

    /// <summary>True if the check succeeded.</summary>
    public bool IsSuccess => SuccessLevel is SuccessLevel.Success or SuccessLevel.CriticalSuccess;

    /// <summary>True if the check was a critical (natural 1 or max).</summary>
    public bool IsCritical => SuccessLevel is SuccessLevel.CriticalSuccess or SuccessLevel.CriticalFailure;

    /// <summary>
    /// Creates a skill check result.
    /// </summary>
    public SkillCheckResult(
        string skillId,
        string skillName,
        DiceRollResult diceResult,
        int attributeBonus,
        int otherBonus,
        int difficultyClass,
        string difficultyName)
    {
        SkillId = skillId;
        SkillName = skillName;
        DiceResult = diceResult;
        AttributeBonus = attributeBonus;
        OtherBonus = otherBonus;
        TotalResult = diceResult.Total + attributeBonus + otherBonus;
        DifficultyClass = difficultyClass;
        DifficultyName = difficultyName;

        // Determine success level
        if (diceResult.IsNaturalOne)
        {
            SuccessLevel = SuccessLevel.CriticalFailure;
        }
        else if (diceResult.IsNaturalMax)
        {
            SuccessLevel = SuccessLevel.CriticalSuccess;
        }
        else if (TotalResult >= difficultyClass)
        {
            SuccessLevel = SuccessLevel.Success;
        }
        else
        {
            SuccessLevel = SuccessLevel.Failure;
        }
    }

    public override string ToString()
    {
        var bonusStr = "";
        if (AttributeBonus != 0)
            bonusStr += $" + {AttributeBonus} (attr)";
        if (OtherBonus != 0)
            bonusStr += $" + {OtherBonus} (bonus)";

        return $"{SkillName}: {DiceResult.Total}{bonusStr} = {TotalResult} vs DC {DifficultyClass} ({DifficultyName}) -> {SuccessLevel}";
    }
}
```

#### 3. Application Service

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs`
```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for performing skill checks.
/// Integrates dice rolling with player attributes and configuration.
/// </summary>
public class SkillCheckService
{
    private readonly DiceService _diceService;
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<SkillCheckService> _logger;

    public SkillCheckService(
        DiceService diceService,
        IGameConfigurationProvider configProvider,
        ILogger<SkillCheckService> logger)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("SkillCheckService initialized");
    }

    /// <summary>
    /// Performs a skill check for a player.
    /// </summary>
    /// <param name="player">The player making the check.</param>
    /// <param name="skillId">The skill to check.</param>
    /// <param name="difficultyClassId">The difficulty level (e.g., "easy", "hard").</param>
    /// <param name="advantageType">Optional advantage/disadvantage.</param>
    /// <param name="additionalBonus">Extra bonus from situational effects.</param>
    /// <returns>The skill check result.</returns>
    public SkillCheckResult PerformCheck(
        Player player,
        string skillId,
        string difficultyClassId,
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonus = 0)
    {
        ArgumentNullException.ThrowIfNull(player);

        _logger.LogDebug(
            "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
            player.Name, skillId, difficultyClassId, advantageType);

        // Get skill definition
        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        // Get difficulty class
        var dc = _configProvider.GetDifficultyClassById(difficultyClassId)
            ?? throw new ArgumentException($"Unknown difficulty class: {difficultyClassId}", nameof(difficultyClassId));

        // Calculate attribute bonus
        var attributeBonus = GetAttributeBonus(player, skill);

        // Calculate other bonuses (equipment, class features, etc.)
        var otherBonus = additionalBonus;
        if (!skill.AllowUntrained && !PlayerHasSkillTraining(player, skillId))
        {
            otherBonus -= skill.UntrainedPenalty;
        }

        // Roll the dice
        var dicePool = DicePool.Parse(skill.BaseDicePool);
        var rollResult = _diceService.Roll(dicePool, advantageType);

        // Create and return result
        var result = new SkillCheckResult(
            skillId,
            skill.Name,
            rollResult,
            attributeBonus,
            otherBonus,
            dc.TargetNumber,
            dc.Name);

        _logger.LogInformation(
            "Skill check complete: {Result}",
            result);

        return result;
    }

    /// <summary>
    /// Performs a skill check with a specific DC value.
    /// </summary>
    public SkillCheckResult PerformCheckWithDC(
        Player player,
        string skillId,
        int difficultyClass,
        string difficultyName = "Custom",
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonus = 0)
    {
        ArgumentNullException.ThrowIfNull(player);

        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        var attributeBonus = GetAttributeBonus(player, skill);
        var dicePool = DicePool.Parse(skill.BaseDicePool);
        var rollResult = _diceService.Roll(dicePool, advantageType);

        return new SkillCheckResult(
            skillId,
            skill.Name,
            rollResult,
            attributeBonus,
            additionalBonus,
            difficultyClass,
            difficultyName);
    }

    /// <summary>
    /// Gets the attribute bonus for a skill check.
    /// </summary>
    private int GetAttributeBonus(Player player, SkillDefinition skill)
    {
        var primaryBonus = GetAttributeValue(player, skill.PrimaryAttribute);

        if (skill.SecondaryAttribute != null)
        {
            var secondaryBonus = GetAttributeValue(player, skill.SecondaryAttribute) / 2;
            return primaryBonus + secondaryBonus;
        }

        return primaryBonus;
    }

    /// <summary>
    /// Gets a player's attribute modifier value.
    /// </summary>
    private int GetAttributeValue(Player player, string attributeId)
    {
        // Map attribute IDs to player attributes
        return attributeId.ToLowerInvariant() switch
        {
            "might" => player.Attributes.Might,
            "fortitude" => player.Attributes.Fortitude,
            "will" => player.Attributes.Will,
            "wits" => player.Attributes.Wits,
            "finesse" => player.Attributes.Finesse,
            _ => 0
        };
    }

    /// <summary>
    /// Checks if a player has training in a skill.
    /// For now, always returns true (training system TBD).
    /// </summary>
    private static bool PlayerHasSkillTraining(Player player, string skillId)
    {
        // TODO: Implement skill training system in future version
        return true;
    }

    /// <summary>
    /// Gets all available skill definitions.
    /// </summary>
    public IReadOnlyList<SkillDefinition> GetAllSkills() => _configProvider.GetSkills();

    /// <summary>
    /// Gets all difficulty class definitions.
    /// </summary>
    public IReadOnlyList<DifficultyClassDefinition> GetDifficultyClasses()
        => _configProvider.GetDifficultyClasses();
}
```

#### 4. Application DTOs

**File:** `src/Core/RuneAndRust.Application/DTOs/SkillCheckDtos.cs`
```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for skill check results displayed to the player.
/// </summary>
public record SkillCheckResultDto(
    string SkillId,
    string SkillName,
    DiceRollDto DiceRoll,
    int AttributeBonus,
    int OtherBonus,
    int TotalResult,
    int DifficultyClass,
    string DifficultyName,
    string SuccessLevel,
    int Margin,
    bool IsSuccess,
    bool IsCritical,
    string? Descriptor = null)
{
    public static SkillCheckResultDto FromDomainResult(
        SkillCheckResult result,
        string? descriptor = null)
    {
        return new SkillCheckResultDto(
            result.SkillId,
            result.SkillName,
            DiceRollDto.FromDomainResult(result.DiceResult),
            result.AttributeBonus,
            result.OtherBonus,
            result.TotalResult,
            result.DifficultyClass,
            result.DifficultyName,
            result.SuccessLevel.ToString(),
            result.Margin,
            result.IsSuccess,
            result.IsCritical,
            descriptor);
    }
}

/// <summary>
/// DTO for skill definitions.
/// </summary>
public record SkillDefinitionDto(
    string Id,
    string Name,
    string Description,
    string PrimaryAttribute,
    string? SecondaryAttribute,
    string BaseDicePool,
    bool AllowUntrained,
    int UntrainedPenalty,
    string Category,
    IReadOnlyList<string> Tags);

/// <summary>
/// DTO for difficulty class definitions.
/// </summary>
public record DifficultyClassDto(
    string Id,
    string Name,
    string Description,
    int TargetNumber,
    string Color);
```

### Configuration Files

**File:** `config/skills.json`
```json
{
  "$schema": "skills.schema.json",
  "skills": [
    {
      "id": "athletics",
      "name": "Athletics",
      "description": "Physical feats of strength, climbing, jumping, and swimming.",
      "primaryAttribute": "might",
      "secondaryAttribute": "fortitude",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "strength"]
    },
    {
      "id": "acrobatics",
      "name": "Acrobatics",
      "description": "Balance, tumbling, and agile maneuvers.",
      "primaryAttribute": "finesse",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "agility"]
    },
    {
      "id": "stealth",
      "name": "Stealth",
      "description": "Moving silently and remaining hidden.",
      "primaryAttribute": "finesse",
      "secondaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "sneaking"]
    },
    {
      "id": "perception",
      "name": "Perception",
      "description": "Noticing hidden things, spotting danger, and awareness.",
      "primaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Mental",
      "tags": ["mental", "awareness"]
    },
    {
      "id": "investigation",
      "name": "Investigation",
      "description": "Searching for clues, deducing information, and solving puzzles.",
      "primaryAttribute": "wits",
      "secondaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Mental",
      "tags": ["mental", "intellect"]
    },
    {
      "id": "lockpicking",
      "name": "Lockpicking",
      "description": "Opening locks without the key.",
      "primaryAttribute": "finesse",
      "baseDicePool": "1d10",
      "allowUntrained": false,
      "untrainedPenalty": 5,
      "category": "Specialty",
      "tags": ["specialty", "tools"]
    },
    {
      "id": "intimidation",
      "name": "Intimidation",
      "description": "Frightening or coercing others through threats.",
      "primaryAttribute": "might",
      "secondaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Social",
      "tags": ["social", "influence"]
    },
    {
      "id": "persuasion",
      "name": "Persuasion",
      "description": "Convincing others through charm and logic.",
      "primaryAttribute": "will",
      "secondaryAttribute": "wits",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Social",
      "tags": ["social", "influence"]
    },
    {
      "id": "arcana",
      "name": "Arcana",
      "description": "Knowledge of magic, runes, and supernatural phenomena.",
      "primaryAttribute": "will",
      "baseDicePool": "1d10",
      "allowUntrained": false,
      "untrainedPenalty": 5,
      "category": "Knowledge",
      "tags": ["knowledge", "magic"]
    },
    {
      "id": "endurance",
      "name": "Endurance",
      "description": "Resisting poison, disease, and physical exhaustion.",
      "primaryAttribute": "fortitude",
      "baseDicePool": "1d10",
      "allowUntrained": true,
      "untrainedPenalty": 0,
      "category": "Physical",
      "tags": ["physical", "resilience"]
    }
  ]
}
```

**File:** `config/difficulty.json`
```json
{
  "$schema": "difficulty.schema.json",
  "difficultyClasses": [
    {
      "id": "trivial",
      "name": "Trivial",
      "description": "Almost anyone can do this.",
      "targetNumber": 5,
      "color": "#88FF88",
      "sortOrder": 1
    },
    {
      "id": "easy",
      "name": "Easy",
      "description": "A simple task for someone with basic ability.",
      "targetNumber": 8,
      "color": "#44DD44",
      "sortOrder": 2
    },
    {
      "id": "moderate",
      "name": "Moderate",
      "description": "Requires some skill or effort.",
      "targetNumber": 12,
      "color": "#FFFF44",
      "sortOrder": 3
    },
    {
      "id": "challenging",
      "name": "Challenging",
      "description": "Difficult for most people.",
      "targetNumber": 15,
      "color": "#FFAA44",
      "sortOrder": 4
    },
    {
      "id": "hard",
      "name": "Hard",
      "description": "Only skilled individuals succeed reliably.",
      "targetNumber": 18,
      "color": "#FF6644",
      "sortOrder": 5
    },
    {
      "id": "very_hard",
      "name": "Very Hard",
      "description": "Even experts struggle.",
      "targetNumber": 22,
      "color": "#FF4444",
      "sortOrder": 6
    },
    {
      "id": "heroic",
      "name": "Heroic",
      "description": "A legendary feat.",
      "targetNumber": 25,
      "color": "#FF00FF",
      "sortOrder": 7
    },
    {
      "id": "impossible",
      "name": "Nearly Impossible",
      "description": "Only the most exceptional can hope to succeed.",
      "targetNumber": 30,
      "color": "#8800FF",
      "sortOrder": 8
    }
  ]
}
```

### Phase 5b Tests (~20 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/SkillDefinitionTests.cs` (~5 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Definitions/DifficultyClassDefinitionTests.cs` (~3 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/SkillCheckResultTests.cs` (~5 tests)

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SkillCheckServiceTests.cs` (~7 tests)

### Phase 5b Deliverables Checklist

- [ ] `SkillDefinition.cs` - Skill definitions loaded from config
- [ ] `DifficultyClassDefinition.cs` - DC definitions loaded from config
- [ ] `SkillCheckResult.cs` - Value object for check results
- [ ] `SkillCheckService.cs` - Service for performing checks
- [ ] `SkillCheckDtos.cs` - DTOs for presentation layer
- [ ] `config/skills.json` - 10 skill definitions
- [ ] `config/difficulty.json` - 8 difficulty classes
- [ ] Update `IGameConfigurationProvider` with skill/DC methods
- [ ] Update `JsonConfigurationProvider` to load skills/DCs
- [ ] 20 new tests
- [ ] All existing tests still pass

---

## Phase 5c: Combat Integration
[Design Specification](v0.0.5c-design-specification.md)

[Implementation Plan](v0.0.5c-implementation-plan.md)

### Overview
Refactor combat to use dice-based attack and damage rolls instead of static calculations.

### Files to Modify

#### 1. Update CombatService

**File:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs` (MODIFY)

Key changes:
- Add `DiceService` dependency
- Replace `CalculateDamage()` with dice-based calculation
- Add `AttackRoll()` method for hit determination
- Add `DamageRoll()` method for damage calculation
- Add support for critical hits/misses

```csharp
// New attack flow
public CombatRoundResult ResolveCombatRound(Player player, Monster monster, DiceService diceService)
{
    // 1. Player attack roll (1d10 + Finesse vs Monster Defense)
    var attackRoll = diceService.Roll(DicePool.D10());
    var attackTotal = attackRoll.Total + player.Attributes.Finesse;

    var isHit = attackTotal >= monster.Stats.Defense || attackRoll.IsNaturalMax;
    var isCriticalHit = attackRoll.IsNaturalMax;  // Natural 10
    var isCriticalMiss = attackRoll.IsNaturalOne;

    int playerDamage = 0;
    DiceRollResult? damageRoll = null;

    if (isHit && !isCriticalMiss)
    {
        // 2. Damage roll (weapon dice + Might)
        var damagePool = GetPlayerDamagePool(player); // Default: 1d6
        if (isCriticalHit)
        {
            // Critical hit on natural 10: double dice
            damagePool = damagePool with { Count = damagePool.Count * 2 };
        }

        damageRoll = diceService.Roll(damagePool);
        playerDamage = damageRoll.Value.Total + player.Attributes.Might;
        playerDamage = Math.Max(1, playerDamage - monster.Stats.Defense / 2); // Armor reduces damage

        monster.TakeDamage(playerDamage);
    }

    // 3. Monster counterattack (if alive)
    // Similar flow...

    return new CombatRoundResult(
        AttackRoll: attackRoll,
        AttackTotal: attackTotal,
        IsHit: isHit,
        IsCriticalHit: isCriticalHit,
        IsCriticalMiss: isCriticalMiss,
        DamageRoll: damageRoll,
        DamageDealt: playerDamage,
        MonsterCounterAttack: monsterAttackResult,
        MonsterDefeated: monster.IsDefeated,
        PlayerDefeated: player.IsDead);
}
```

#### 2. New Combat Result Types

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/CombatResults.cs` (NEW)

```csharp
/// <summary>
/// Detailed result of a combat round with dice breakdown.
/// </summary>
public record CombatRoundResult(
    DiceRollResult AttackRoll,
    int AttackTotal,
    bool IsHit,
    bool IsCriticalHit,
    bool IsCriticalMiss,
    DiceRollResult? DamageRoll,
    int DamageDealt,
    MonsterCounterAttackResult? MonsterCounterAttack,
    bool MonsterDefeated,
    bool PlayerDefeated);

/// <summary>
/// Result of a monster's counterattack.
/// </summary>
public record MonsterCounterAttackResult(
    DiceRollResult AttackRoll,
    int AttackTotal,
    bool IsHit,
    DiceRollResult? DamageRoll,
    int DamageDealt);
```

### Phase 5c Tests (~15 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceDiceTests.cs`
- Attack roll succeeds when total >= defense
- Attack roll fails when total < defense
- Critical hit on natural 10 doubles damage dice
- Critical miss on natural 1 always misses
- Damage roll uses weapon dice pool
- Monster counterattack uses dice
- Combat round returns full dice breakdown

### Phase 5c Deliverables Checklist

- [ ] `CombatResults.cs` - New result types with dice breakdown
- [ ] Update `CombatService` to use `DiceService`
- [ ] Add attack roll logic with criticals
- [ ] Add damage roll logic with modifiers
- [ ] Update `GameSessionService.TryAttack()` to pass DiceService
- [ ] Update combat DTOs for dice display
- [ ] 15 new tests
- [ ] All existing tests still pass (may need updates)

---

## Phase 5d: Configuration & Polish
[Design Specification](v0.0.5d-design-specification.md)

[Implementation Plan](v0.0.5d-implementation-plan.md)

### Overview
Complete the presentation layer integration, add commands, and polish the dice display.

### Files to Create/Modify

#### 1. Input Handling

**Commands to Add:**
- `roll <notation>` - Roll dice directly (e.g., "roll 3d6+5")
- `check <skill> [difficulty]` - Perform skill check

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInputHandler.cs` (MODIFY)
```csharp
public record RollCommand(string Notation) : ICommand;
public record SkillCheckCommand(string SkillId, string? DifficultyId = null) : ICommand;
```

#### 2. Rendering

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs` (MODIFY)
```csharp
Task RenderDiceRollAsync(DiceRollDto roll, CancellationToken ct = default);
Task RenderSkillCheckAsync(SkillCheckResultDto result, CancellationToken ct = default);
Task RenderCombatRoundAsync(CombatRoundResultDto result, CancellationToken ct = default);
```

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs` (MODIFY)

```csharp
public Task RenderDiceRollAsync(DiceRollDto roll, CancellationToken ct = default)
{
    var table = new Table()
        .Border(TableBorder.Rounded)
        .AddColumn("Dice")
        .AddColumn("Rolls")
        .AddColumn("Total");

    var rollsDisplay = string.Join(", ", roll.Rolls);
    if (roll.HadExplosions)
    {
        rollsDisplay += $" [yellow]+ explosions: {string.Join(", ", roll.ExplosionRolls)}[/]";
    }

    var totalColor = roll.IsNaturalMax ? "green" : roll.IsNaturalOne ? "red" : "white";
    var totalDisplay = $"[{totalColor}]{roll.Total}[/]";

    if (roll.IsNaturalMax)
        totalDisplay += " [green bold]CRITICAL![/]";
    else if (roll.IsNaturalOne)
        totalDisplay += " [red bold]FUMBLE![/]";

    table.AddRow(
        roll.Notation,
        $"[{rollsDisplay}] {(roll.Modifier != 0 ? $"+ {roll.Modifier}" : "")}",
        totalDisplay);

    if (roll.Descriptor != null)
    {
        AnsiConsole.MarkupLine($"[italic]{roll.Descriptor}[/]");
    }

    AnsiConsole.Write(table);
    return Task.CompletedTask;
}
```

#### 3. View Handling

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs` (MODIFY)

```csharp
private async Task HandleRollCommandAsync(string notation, CancellationToken ct)
{
    try
    {
        var result = _diceService.Roll(notation);
        var descriptor = GetDiceDescriptor(result);
        var dto = DiceRollDto.FromDomainResult(result, descriptor);
        await _renderer.RenderDiceRollAsync(dto, ct);
    }
    catch (FormatException ex)
    {
        await _renderer.RenderMessageAsync($"Invalid dice notation: {ex.Message}", MessageType.Error, ct);
    }
}

private string? GetDiceDescriptor(DiceRollResult result)
{
    if (result.IsNaturalMax)
        return _descriptorService.GetDescriptor("dice.natural_max");
    if (result.IsNaturalOne)
        return _descriptorService.GetDescriptor("dice.natural_one");
    // Use percentage of max for high/low rolls
    var percentage = (float)result.DiceTotal / result.Pool.MaximumResult;
    if (percentage >= 0.75f)
        return _descriptorService.GetDescriptor("dice.high_rolls");
    if (percentage <= 0.25f)
        return _descriptorService.GetDescriptor("dice.low_rolls");
    return null;
}
```

### Phase 5d Tests (~9 tests)

**File:** `tests/RuneAndRust.Application.UnitTests/Services/DiceDescriptorTests.cs` (~3 tests)

**File:** Integration tests for roll and check commands (~6 tests)

### Phase 5d Deliverables Checklist

- [ ] Add `roll` command to input handler
- [ ] Add `check` command to input handler
- [ ] Implement `RenderDiceRollAsync` in SpectreGameRenderer
- [ ] Implement `RenderSkillCheckAsync` in SpectreGameRenderer
- [ ] Implement `RenderCombatRoundAsync` in SpectreGameRenderer
- [ ] Add `HandleRollCommandAsync` to GameView
- [ ] Add `HandleSkillCheckCommandAsync` to GameView
- [ ] Integrate descriptors with dice rolls
- [ ] 9 new tests
- [ ] All tests pass
- [ ] Build with 0 errors/warnings

---

## Testing Strategy

### Test Categories

| Category | Location | Count | Coverage |
|----------|----------|-------|----------|
| Domain Value Objects | Domain.UnitTests/ValueObjects/ | ~20 | DicePool, DiceRollResult, SkillCheckResult |
| Domain Definitions | Domain.UnitTests/Definitions/ | ~8 | SkillDefinition, DifficultyClassDefinition |
| Application Services | Application.UnitTests/Services/ | ~25 | DiceService, SkillCheckService |
| Integration | Application.UnitTests/Integration/ | ~9 | Command handling, rendering |

### Test Patterns

```csharp
// Pattern 1: Deterministic Testing with Seeded Random
[Test]
public void Roll_WithSeededRandom_ProducesExpectedResult()
{
    var seededRandom = new Random(42); // Fixed seed
    var service = new DiceService(_mockLogger.Object, seededRandom);

    var result = service.Roll(DicePool.D10());

    result.Rolls[0].Should().Be(/* expected value for seed 42 */);
}

// Pattern 2: Statistical Testing
[Test]
public void Roll_ManyTimes_ProducesUniformDistribution()
{
    var results = Enumerable.Range(0, 10000)
        .Select(_ => _service.Roll(DicePool.D6()))
        .GroupBy(r => r.Total)
        .ToDictionary(g => g.Key, g => g.Count());

    // Each face should appear roughly 1666 times (10000/6)
    foreach (var count in results.Values)
    {
        count.Should().BeInRange(1400, 1900);
    }
}

// Pattern 3: Boundary Testing
[Test]
public void Roll_NeverExceedsMaximum()
{
    var pool = new DicePool(3, DiceType.D6, 5);
    var results = Enumerable.Range(0, 1000).Select(_ => _service.Roll(pool));

    results.Should().AllSatisfy(r => r.Total.Should().BeLessThanOrEqualTo(23));
}
```

### Mock Configurations

```csharp
// IGameConfigurationProvider mock for skills
_mockConfig.Setup(c => c.GetSkillById("perception"))
    .Returns(SkillDefinition.Create(
        "perception", "Perception", "Notice things",
        "wits", null, "1d10"));

_mockConfig.Setup(c => c.GetDifficultyClassById("moderate"))
    .Returns(DifficultyClassDefinition.Create(
        "moderate", "Moderate", "Requires effort", 12));
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Service initialization | Information | "DiceService initialized" |
| Roll request | Debug | "Rolling 3d6+5 with Advantage" |
| Individual die | Debug | "Die 1: rolled 4 on d6" |
| Explosion | Debug | "Die exploded! Roll 6 on d6" |
| Roll complete | Information | "Roll 3d6+5: [4,2,6]+5=17" |
| Skill check request | Debug | "Skill check: perception vs DC 15" |
| Skill check complete | Information | "Skill check: 18 vs DC 15 = Success" |
| Critical result | Information | "Critical success on perception!" |
| Parse error | Warning | "Invalid dice notation: xyz" |

### Structured Logging Format

```csharp
_logger.LogInformation(
    "Dice roll complete: Pool={Pool} Rolls={@Rolls} Explosions={@Explosions} Total={Total}",
    pool.ToString(),
    rolls,
    explosions,
    total);

_logger.LogInformation(
    "Skill check: Skill={Skill} Roll={Roll} Bonus={Bonus} Total={Total} DC={DC} Result={Result}",
    skillId,
    rollResult.Total,
    attributeBonus,
    totalResult,
    difficultyClass,
    successLevel);
```

---

## Acceptance Criteria

### Phase 5a: Core Dice Engine
- [ ] Can roll any standard dice type (d4, d6, d8, d10)
- [ ] Dice notation parsing works (e.g., "3d6+5", "1d10-2", "2d8!")
- [ ] Exploding dice trigger on maximum value
- [ ] Advantage rolls twice and takes higher
- [ ] Disadvantage rolls twice and takes lower
- [ ] Roll results include individual die values
- [ ] 18 new tests pass

### Phase 5b: Skill Check System
- [ ] 10 skills defined in configuration
- [ ] 8 difficulty classes defined
- [ ] Skill checks use player attributes
- [ ] Critical success on natural max
- [ ] Critical failure on natural 1
- [ ] Skill check results include full breakdown
- [ ] 20 new tests pass

### Phase 5c: Combat Integration
- [ ] Attack rolls determine hit/miss
- [ ] Critical hits (natural 10) double damage dice
- [ ] Critical misses (natural 1) always miss
- [ ] Damage rolls include weapon dice
- [ ] Monster counterattacks use dice
- [ ] Combat results show full dice breakdown
- [ ] 15 new tests pass

### Phase 5d: Configuration & Polish
- [ ] `roll <notation>` command works
- [ ] `check <skill>` command works
- [ ] Dice rolls display with formatting
- [ ] Descriptors appear for critical rolls
- [ ] Combat round displays dice breakdown
- [ ] 9 new tests pass
- [ ] All 260 tests pass
- [ ] Build: 0 errors, 0 warnings

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Combat balance disruption | High | Medium | Keep variance similar to current system initially |
| Infinite explosion loops | Medium | Low | MaxExplosions cap (default 10) |
| Random test flakiness | Medium | Medium | Use seeded Random for deterministic tests |
| Performance with many dice | Low | Low | Dice pools limited by game design |
| Breaking existing tests | High | Medium | Phase-by-phase integration with regression testing |

---

## Summary

### Files to Create (New)

| Phase | File | Purpose |
|-------|------|---------|
| 5a | `DiceType.cs` | Enum for dice types |
| 5a | `AdvantageType.cs` | Enum for advantage |
| 5a | `SuccessLevel.cs` | Enum for success levels |
| 5a | `DicePool.cs` | Value object for dice pools |
| 5a | `DiceRollResult.cs` | Value object for results |
| 5a | `DiceService.cs` | Core rolling service |
| 5a | `DiceDtos.cs` | DTOs for dice rolls |
| 5b | `SkillDefinition.cs` | Skill definition entity |
| 5b | `DifficultyClassDefinition.cs` | DC definition entity |
| 5b | `SkillCheckResult.cs` | Value object for checks |
| 5b | `SkillCheckService.cs` | Skill check service |
| 5b | `SkillCheckDtos.cs` | DTOs for skill checks |
| 5b | `config/skills.json` | Skill configuration |
| 5b | `config/difficulty.json` | DC configuration |
| 5c | `CombatResults.cs` | Combat result records |

### Files to Modify

| Phase | File | Changes |
|-------|------|---------|
| 5b | `IGameConfigurationProvider.cs` | Add skill/DC methods |
| 5b | `JsonConfigurationProvider.cs` | Load skills/DCs |
| 5c | `CombatService.cs` | Use dice for combat |
| 5c | `GameSessionService.cs` | Pass DiceService to combat |
| 5d | `IInputHandler.cs` | Add roll/check commands |
| 5d | `ConsoleInputHandler.cs` | Parse roll/check |
| 5d | `IGameRenderer.cs` | Add dice rendering |
| 5d | `SpectreGameRenderer.cs` | Implement rendering |
| 5d | `GameView.cs` | Handle roll/check commands |

### Test Files to Create

| Phase | File | Count |
|-------|------|-------|
| 5a | `DicePoolTests.cs` | 12 |
| 5a | `DiceRollResultTests.cs` | 4 |
| 5a | `DiceServiceTests.cs` | 6 |
| 5b | `SkillDefinitionTests.cs` | 5 |
| 5b | `DifficultyClassDefinitionTests.cs` | 3 |
| 5b | `SkillCheckResultTests.cs` | 5 |
| 5b | `SkillCheckServiceTests.cs` | 7 |
| 5c | `CombatServiceDiceTests.cs` | 15 |
| 5d | `DiceDescriptorTests.cs` | 3 |
| 5d | `CommandIntegrationTests.cs` | 6 |

### Final Metrics

| Metric | Before v0.0.5 | After v0.0.5 |
|--------|---------------|--------------|
| Domain Tests | 123 | ~155 |
| Application Tests | 67 | ~97 |
| Architecture Tests | 8 | 8 |
| **Total Tests** | **198** | **~260** |
| Config Files | 7 | 9 |
| Domain Files | ~25 | ~33 |
| Application Files | ~18 | ~23 |

---

## Next Steps

After completing v0.0.5:
1. **v0.0.6 (Enhanced Combat)** - Multi-monster rooms, target selection, status effects
2. **v0.0.7 (Equipment System)** - Equipment slots, weapon dice pools, armor defense
3. **v0.0.8 (Experience & Leveling)** - XP from combat, level-up with dice-based bonuses

The dice pool system provides the foundation for all future randomization mechanics.
