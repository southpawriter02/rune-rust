> **Archived** - This plan has been consolidated. See the complete version at [v0.3.23](../v0.3.x/v0.3.23.md).

Here is the comprehensive implementation plan for v0.3.23c: The Mouse (TUI Pointing).
This sub-version adds experimental mouse support to the Terminal UI. While the game remains keyboard-first, mouse support enhances accessibility and ease of use, particularly for grid-based targeting in combat and inventory management. This requires enabling VT mouse reporting in the terminal and mapping screen coordinates to game logic.

v0.3.23c: The Mouse
Goal: Implement a VT sequence parser to capture mouse events, a Hitbox system to map screen coordinates to UI elements, and integrate "Click" events into the input stream.
1. Architecture & Data Flow
	•	VT Sequence Parsing: Standard Console.ReadKey does not capture mouse input. We must read the raw Standard Input stream to detect ANSI escape sequences (e.g., \x1b[M... or SGR mode \x1b[<...).
	•	Hitbox Registry: Since the TUI is redrawn frequently, we need a frame-based HitboxRegistry. When CombatScreenRenderer draws a grid tile at (10, 5), it registers a hitbox for that coordinate mapping to a game entity.
	•	Input Unification: The InputService prioritizes keyboard input but interweaves mouse events when detected.
Data Flow: The Click Pipeline
	1	Hardware: User clicks Left Button at row 10, column 15.
	2	Terminal: Sends VT sequence \x1b[<0;15;10M to Standard Input.
	3	Driver: MouseInputProvider detects the ESC sequence, parses coordinates, and creates a MouseEvent(15, 10).
	4	Mapping: InputService queries HitboxRegistry.GetActionAt(15, 10).
	◦	Result: Returns GameAction.Target with payload TargetId: "Goblin A".
	5	Event: InputService broadcasts the ActionEvent.
	6	Consumer: CommandParser executes the action as if typed.

2. Logic Decision Trees
A. VT Parsing Logic (Simplified SGR Mode) Input: Character Stream
	1	Detect Leader: Is char \x1b (Escape)?
	◦	No: Treat as Key Press.
	◦	Yes: Read next. Is it [? -> Is it <? -> Mouse Sequence.
	2	Parse Payload: Read until M or m.
	◦	Format: ID;X;Y.
	◦	ID: 0 (Left), 1 (Middle), 2 (Right).
	◦	X, Y: Screen coordinates (1-based).
	3	Action: Return MouseEvent.
B. Hitbox Resolution Logic Input: MouseEvent(X, Y)
	1	Bounds Check: Iterate through active Hitbox list (Z-order top to bottom).
	2	Intersection: Does Hitbox.Contains(X, Y)?
	◦	Yes:
	▪	Is Hitbox.Action generic (e.g., Confirm)? -> Return ActionEvent(Confirm).
	▪	Is Hitbox.Action spatial (e.g., GridClick)? -> Return TargetEvent(Hitbox.EntityId).
	◦	No: Input ignored (click on empty space).

3. Code Implementation
A. Hitbox Registry File: RuneAndRust.Terminal/Services/HitboxRegistry.cs
public record Hitbox(int X, int Y, int Width, int Height, GameAction Action, string? Data);

public class HitboxRegistry
{
    private readonly List<Hitbox> _activeHitboxes = new();

    public void Clear() => _activeHitboxes.Clear();

    public void Register(int x, int y, int w, int h, GameAction action, string? data = null)
    {
        _activeHitboxes.Add(new Hitbox(x, y, w, h, action, data));
    }

    public (GameAction, string?)? Resolve(int x, int y)
    {
        // LIFO search (top-most element first)
        var hit = _activeHitboxes.LastOrDefault(h =>
            x >= h.X && x < h.X + h.Width &&
            y >= h.Y && y < h.Y + h.Height);

        return hit != null ? (hit.Action, hit.Data) : null;
    }
}
B. Mouse Provider (VT Parsing) File: RuneAndRust.Terminal/Services/MouseInputProvider.cs
public class MouseInputProvider
{
    public void EnableMouseMode()
    {
        // Enable SGR Mouse Mode (1006) and Mouse Tracking (1003)
        Console.Write("\x1b[?1003h\x1b[?1006h");
    }

    public void DisableMouseMode()
    {
        Console.Write("\x1b[?1003l\x1b[?1006l");
    }

    public MouseEvent? ParseSequence(string sequence)
    {
        // Regex for SGR format: \x1b[<0;20;10M
        var match = Regex.Match(sequence, @"\x1b\[<(\d+);(\d+);(\d+)([Mm])");
        if (match.Success)
        {
            var btn = int.Parse(match.Groups.Value);
            var x = int.Parse(match.Groups.Value);
            var y = int.Parse(match.Groups.Value);
            var isRelease = match.Groups.Value == "m";

            if (!isRelease && btn == 0) // Left Click Press
            {
                return new MouseEvent(x, y, true);
            }
        }
        return null;
    }
}
C. Renderer Integration (Example) File: RuneAndRust.Terminal/Services/CombatScreenRenderer.cs
// Inside Render loop
foreach (var combatant in vm.TurnOrder)
{
    // ... draw logic ...
    // Register visual area as clickable
    _hitboxRegistry.Register(
        rowX, rowY, width, height,
        GameAction.Target,
        combatant.Id.ToString()
    );
}

4. Deliverable Checklist (v0.3.23c)
	•	Core:
	◦	[ ] Define MouseEvent in InputEvent hierarchy.
	◦	[ ] Add GameAction.Click fallback.
	•	Terminal:
	◦	[ ] Implement HitboxRegistry service.
	◦	[ ] Implement MouseInputProvider with SGR sequence parsing.
	◦	[ ] Register HitboxRegistry as Singleton (cleared per frame).
	◦	[ ] Update TerminalGameLoop to enable mouse mode on start / disable on exit.
	◦	[ ] Update CombatScreenRenderer to register hitboxes for enemies.
	◦	[ ] Update InventoryScreenRenderer to register hitboxes for items.
	•	Engine:
	◦	[ ] Update CommandParser to accept GameAction.Target with ID payload.

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Input
Mouse Raw
Verbose
"[Input] Raw VT Sequence: {Seq}"
Seq
Input
Click
Debug
"[Input] Click at ({X}, {Y}) -> {Action} ({Data})"
X, Y, Action, Data
Render
Hitbox
Trace
"[UI] Registered {Count} hitboxes."
Count

6. Testing Strategy
Unit Tests (MouseProviderTests.cs):
	•	Parse_SGR_Sequence:
	◦	Input: "\x1b[<0;15;10M" (Left Click at 15,10).
	◦	Act: Parse.
	◦	Assert: Returns MouseEvent(15, 10, Left).
	•	Ignore_Release:
	◦	Input: "\x1b[<0;15;10m" (Release).
	◦	Assert: Returns null (prevent double-firing).
Integration Tests:
	•	Hitbox_Resolution:
	◦	Register Hitbox at (5,5, 10,1).
	◦	Simulate Click at (6,5).
	◦	Assert: Returns correct Action.
	◦	Simulate Click at (4,5).
	◦	Assert: Returns null.

7. Draft Changelog (v0.3.23c)
# Changelog: v0.3.23c - The Mouse

**Release Date:** 2026-03-XX

## Summary
The final phase of "The Gatekeeper" adds experimental mouse support to the Terminal UI. Players using modern terminal emulators (Windows Terminal, iTerm2, Kitty) can now click to select targets in combat or items in inventory, bridging the gap between CLI and GUI interactions.

## Changes
- **Input:** Implemented VT Mouse Reporting (SGR Mode).
- **UI:** Added Hitbox system to Renderers. Elements like Enemies and Items are now "aware" of their screen coordinates.
- **Controls:** Clicking an entity in combat now triggers the "Target" or "Attack" command for that entity.