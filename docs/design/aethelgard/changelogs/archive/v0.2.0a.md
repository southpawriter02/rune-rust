> **Archived** - This changelog has been consolidated. See the complete version at [v0.2.0](../v0.2.x/v0.2.0.md).

# Changelog: v0.2.0a - The Arena (State & Initiative)

**Release Date:** 2025-12-19

## Summary

This release establishes the foundational infrastructure for turn-based combat in Rune & Rust. The implementation introduces combat state management, initiative calculation, and turn order resolution using the Combatant Adapter Pattern to isolate combat-volatile state from persistent character/enemy data. The Core Layer gained combat domain models and service contracts, the Engine Layer received two new combat lifecycle services, and the Test Layer added 36 comprehensive tests validating the combat initialization sequence. Key architectural patterns employed include the Adapter Pattern for combatant wrapping, Singleton DI for stateless combat services, and d10-based initiative using the FINESSE + WITS (Vigilance) formula.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/Enemy.cs` | Stub enemy entity with attribute dictionary, HP tracking, and GetAttribute method for combat integration |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Adapter wrapping Character or Enemy for combat with combat-volatile state (Initiative, CurrentHp, CurrentStamina) and static factory methods |
| `RuneAndRust.Core/Models/CombatState.cs` | Tracks active combat encounter state including turn order list, round number, turn index, and computed properties for active combatant |
| `RuneAndRust.Core/Interfaces/IInitiativeService.cs` | Contract defining RollInitiative and SortTurnOrder operations for combat turn sequencing |
| `RuneAndRust.Core/Interfaces/ICombatService.cs` | Contract defining combat lifecycle operations (StartCombat, NextTurn, EndCombat) |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/InitiativeService.cs` | Implements initiative calculation using d10 + FINESSE + WITS and turn order sorting with Finesse tiebreaker |
| `RuneAndRust.Engine/Services/CombatService.cs` | Manages combat lifecycle including combatant registration, initiative rolling, turn advancement, and phase transitions |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/InitiativeServiceTests.cs` | Contains 12 tests validating initiative calculation formula, attribute integration, and turn order sorting with tiebreakers |
| `RuneAndRust.Tests/Engine/CombatServiceTests.cs` | Contains 18 tests validating combat state creation, turn advancement, round cycling, and phase management |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Core/Interfaces/IDiceService.cs` | Added RollSingle method signature with `int sides` and `string context` parameters for single die rolls |
| `RuneAndRust.Engine/Services/DiceService.cs` | Implemented RollSingle with side count validation (clamping to minimum 1), logging at Trace and Debug levels, and Random.Shared usage |
| `RuneAndRust.Core/Models/GameState.cs` | Added `CombatState?` property with `[JsonIgnore]` attribute to track active combat; added CombatState reset to Reset method |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added `ICombatService?` constructor parameter; implemented `debug-combat` command creating Training Dummy enemy and initiating combat via ICombatService.StartCombat |
| `RuneAndRust.Terminal/Program.cs` | Registered IInitiativeService as Singleton and ICombatService as Singleton in DI container; updated boot message to display v0.2.0a |
| `RuneAndRust.Tests/Engine/DiceServiceTests.cs` | Added 6 tests for RollSingle covering range validation, side clamping, context logging, and distribution randomness |

---

## Code Implementation Details

### Enemy Entity (Stub Implementation)

**File:** `RuneAndRust.Core/Entities/Enemy.cs`

**Properties:**
- `Guid Id` - Unique identifier, defaults to `Guid.NewGuid()`
- `string Name` - Display name, defaults to "Training Dummy"
- `Dictionary<CharacterAttribute, int> Attributes` - Attribute dictionary with default values (Sturdiness: 5, Might: 5, Wits: 3, Will: 3, Finesse: 3)
- `int MaxHp` - Maximum health points, defaults to 50
- `int CurrentHp` - Current health points, defaults to 50

**Methods:**
- `int GetAttribute(CharacterAttribute attr)` - Returns attribute value from dictionary or 0 if not found

**Notes:**
- Marked as stub entity for v0.2.0a; will be expanded with behaviors and AI in v0.2.1
- Uses `using CharacterAttribute = RuneAndRust.Core.Enums.Attribute;` to disambiguate from System.Attribute

### Combatant Adapter Pattern

**File:** `RuneAndRust.Core/Models/Combat/Combatant.cs`

**Adapter Properties:**
- `Guid Id` - Unique identifier for combatant instance
- `string Name` - Display name copied from source entity
- `bool IsPlayer` - Flag distinguishing player from enemy combatants

**Combat-Volatile State:**
- `int Initiative` - Initiative roll result for turn order
- `int CurrentHp` - Combat HP copied from source at combat start
- `int MaxHp` - Maximum HP from source entity
- `int CurrentStamina` - Combat stamina copied from source at combat start
- `int MaxStamina` - Maximum stamina from source entity

**Source References:**
- `CharacterEntity? CharacterSource` - Reference to source Character if player combatant
- `Enemy? EnemySource` - Reference to source Enemy if enemy combatant

**Methods:**
- `int GetAttribute(CharacterAttribute attr)` - Delegates to CharacterSource.GetEffectiveAttribute or EnemySource.GetAttribute; returns 0 if no source set
- `static Combatant FromCharacter(CharacterEntity c)` - Factory method creating player combatant with IsPlayer = true, copying HP and Stamina
- `static Combatant FromEnemy(Enemy e)` - Factory method creating enemy combatant with IsPlayer = false, CurrentStamina and MaxStamina set to 0

**Design Rationale:**
- Isolates combat-volatile state from persistent entity data
- Prevents direct modification of Character/Enemy HP during combat simulation
- Allows combat to be rolled back or canceled without affecting source entities

### CombatState Model

**File:** `RuneAndRust.Core/Models/CombatState.cs`

**Properties:**
- `Guid Id` - Unique identifier for combat encounter
- `List<Combatant> TurnOrder` - Ordered list of combatants sorted by initiative (highest first)
- `int RoundNumber` - Current round number, starts at 1
- `int TurnIndex` - Zero-based index of active combatant in TurnOrder

**Computed Properties:**
- `Combatant? ActiveCombatant` - Returns `TurnOrder[TurnIndex]` if valid, otherwise null
- `bool IsPlayerTurn` - Returns `ActiveCombatant?.IsPlayer ?? false`

**Behaviors:**
- TurnOrder starts empty and is populated by CombatService.StartCombat
- RoundNumber increments when TurnIndex wraps past end of TurnOrder
- TurnIndex wraps to 0 when incremented past TurnOrder.Count - 1

### InitiativeService Implementation

**File:** `RuneAndRust.Engine/Services/InitiativeService.cs`

**Dependencies:**
- `IDiceService` - For rolling d10 initiative die
- `ILogger<InitiativeService>` - For structured logging

**Method: RollInitiative**
```csharp
void RollInitiative(Combatant combatant)
```
- Rolls 1d10 using `_dice.RollSingle(10, $"Initiative:{combatant.Name}")`
- Retrieves Finesse and Wits attributes from combatant via GetAttribute
- Calculates Vigilance as `finesse + wits`
- Sets `combatant.Initiative = roll + vigilance`
- Logs at Trace level for method entry with combatant name
- Logs at Debug level with final total, breakdown showing d10 roll and Vigilance modifier

**Method: SortTurnOrder**
```csharp
List<Combatant> SortTurnOrder(IEnumerable<Combatant> combatants)
```
- Sorts combatants using LINQ OrderByDescending with three-tier comparison:
  1. Primary: Initiative value (descending)
  2. Tiebreaker 1: Finesse attribute (descending)
  3. Tiebreaker 2: Random GUID (`Guid.NewGuid()`)
- Returns new list instance (does not mutate input)
- Logs at Trace level with combatant count
- Logs at Debug level with formatted turn order string showing Name(Initiative)

**Initiative Formula:** `d10 + FINESSE + WITS (Vigilance)`

**Tiebreaker Rules:**
1. Descending by Initiative
2. Descending by Finesse
3. Random (Guid.NewGuid())

### CombatService Implementation

**File:** `RuneAndRust.Engine/Services/CombatService.cs`

**Dependencies:**
- `GameState` - Singleton game state for CombatState and Phase management
- `IInitiativeService` - For rolling initiative and sorting turn order
- `ILogger<CombatService>` - For structured logging

**Method: StartCombat**
```csharp
void StartCombat(List<Enemy> enemies)
```
- Validates CurrentCharacter is not null; logs warning and returns early if null
- Creates new CombatState instance
- Creates Combatant from CurrentCharacter using `Combatant.FromCharacter`
- Rolls initiative for player combatant via `_initiative.RollInitiative`
- Adds player to TurnOrder
- Iterates enemies, creating Combatants via `Combatant.FromEnemy`, rolling initiative, adding to TurnOrder
- Sorts TurnOrder using `_initiative.SortTurnOrder`
- Sets `_gameState.CombatState` to new state
- Sets `_gameState.Phase` to `GamePhase.Combat`
- Logs at Information level with enemy count, round number, and active combatant name

**Method: NextTurn**
```csharp
void NextTurn()
```
- Validates CombatState is not null; logs warning and returns early if null
- Increments TurnIndex
- If TurnIndex >= TurnOrder.Count, wraps to 0 and increments RoundNumber
- Logs at Information level when new round begins
- Logs at Information level with active combatant name and type (Player/Enemy)

**Method: EndCombat**
```csharp
void EndCombat()
```
- Logs at Information level
- Sets `_gameState.Phase` to `GamePhase.Exploration`
- Sets `_gameState.CombatState` to null

**Behaviors:**
- StartCombat always initializes RoundNumber to 1 and TurnIndex to 0
- NextTurn handles cycling from last combatant back to first
- Round number increments occur at cycle point, not at start of first combatant's turn

### DiceService.RollSingle Method

**File:** `RuneAndRust.Engine/Services/DiceService.cs`

**Method Signature:**
```csharp
int RollSingle(int sides, string context = "Unspecified")
```

**Behaviors:**
- Validates `sides >= 1`; clamps to 1 if invalid with Warning log
- Uses `Random.Shared.Next(1, sides + 1)` for random value generation
- Logs at Trace level with sides and context before rolling
- Logs at Debug level with result, sides, and context after rolling
- Returns raw die value (1 to sides, inclusive)

**Validation:**
- Negative sides: Logs Warning and clamps to 1
- Zero sides: Logs Warning and clamps to 1
- Valid sides: No clamping or warning

### debug-combat Command

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

**Command:** `debug-combat`

**Behavior:**
- Available in Exploration phase
- Validates `_combatService != null` and `_gameState.CurrentCharacter != null`
- Creates stub Training Dummy enemy with 30 MaxHp and 30 CurrentHp
- Calls `_combatService.StartCombat(new List<Enemy> { dummyEnemy })`
- Displays yellow debug message: "[yellow]DEBUG: Combat initiated with Training Dummy.[/]"
- If validation fails, displays red error message

**Purpose:**
- Provides quick combat testing without dungeon population
- Demonstrates combat initialization flow for development iteration

---

## Logging Matrix

### DiceService

| Event | Level | Template |
|-------|-------|----------|
| RollSingle entry | Trace | `"Rolling 1d{Sides} for {Context}"` |
| RollSingle result | Debug | `"Rolled {Result} on 1d{Sides} ({Context})"` |
| Invalid die sides | Warning | `"Invalid die sides {Sides} for {Context}. Clamping to minimum of 1."` |

### InitiativeService

| Event | Level | Template |
|-------|-------|----------|
| RollInitiative entry | Trace | `"Rolling initiative for {Name}"` |
| Initiative result | Debug | `"{Name} rolled initiative: {Total} (d10:{Roll} + Vigilance:{Vig})"` |
| SortTurnOrder entry | Trace | `"Sorting turn order for {Count} combatants"` |
| Turn order result | Debug | `"Turn order: {Order}"` (formatted as "Name(Initiative) → Name(Initiative)") |

### CombatService

| Event | Level | Template |
|-------|-------|----------|
| StartCombat entry | Information | `"Initializing Combat. Enemies: {Count}"` |
| No active character | Warning | `"Cannot start combat without active character"` |
| Player added | Debug | `"Added player {Name} to combat"` |
| Enemy added | Debug | `"Added enemy {Name} to combat"` |
| Combat started | Information | `"Combat Started. Round {Round}. Active: {Name}"` |
| NextTurn called with no combat | Warning | `"NextTurn called but no combat is active"` |
| Round begins | Information | `"Round {Round} begins"` |
| Turn change | Information | `"Turn: {Name} ({Type})"` (Type = "Player" or "Enemy") |
| EndCombat | Information | `"Combat Ended"` |

---

## Test Coverage

```
Total: 1209 | Passed: 1207 | Failed: 2 | Duration: 477ms
```

**Note:** 2 pre-existing failures in `TextRedactorTests` unrelated to combat implementation.

**New Tests Added:** 36 tests (12 InitiativeServiceTests + 18 CombatServiceTests + 6 DiceService.RollSingle tests)

### InitiativeServiceTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| `RollInitiative_SetsInitiativeProperty` | Verifies RollInitiative sets the Initiative property to a value greater than 0 |
| `RollInitiative_AddsAttributesToRoll` | Validates formula: d10(5) + Finesse(4) + Wits(3) = 12 using Character combatant |
| `RollInitiative_UsesEnemyAttributes` | Validates formula: d10(7) + Finesse(6) + Wits(2) = 15 using Enemy combatant |
| `RollInitiative_CallsDiceServiceWithCorrectContext` | Verifies DiceService.RollSingle called with context "Initiative:TestFighter" |
| `RollInitiative_WithZeroAttributes_ReturnsRollValueOnly` | Validates combatant with no source returns only d10 roll value (attributes = 0) |
| `SortTurnOrder_HigherInitiativeFirst` | Validates descending sort by initiative (fast combatant before slow combatant) |
| `SortTurnOrder_FinesseBreaksTies` | Validates Finesse tiebreaker when Initiative values are equal (nimble before clumsy) |
| `SortTurnOrder_EmptyList_ReturnsEmpty` | Validates empty input produces empty output |
| `SortTurnOrder_SingleCombatant_ReturnsSame` | Validates single combatant returns list containing that combatant |
| `SortTurnOrder_MultipleCombatants_SortsCorrectly` | Validates multi-combatant sort produces descending order by initiative |
| `SortTurnOrder_ReturnsNewList` | Validates method returns new list instance, not input list reference |
| Helper: `CreateCombatantWithFinesse` | Test helper creating Character-based combatant with specified initiative and finesse |

### CombatServiceTests (18 tests)

| Test Name | Description |
|-----------|-------------|
| `StartCombat_SetsPhaseToСombat` | Validates GameState.Phase transitions from Exploration to Combat |
| `StartCombat_CreatesCombatState` | Validates GameState.CombatState is not null after StartCombat |
| `StartCombat_AddsPlayerAndEnemies` | Validates TurnOrder contains 3 combatants (1 player + 2 enemies) |
| `StartCombat_SortsTurnOrder` | Verifies IInitiativeService.SortTurnOrder called exactly once |
| `StartCombat_RollsInitiativeForAllCombatants` | Verifies IInitiativeService.RollInitiative called exactly twice (player + 1 enemy) |
| `StartCombat_WithNoCharacter_DoesNothing` | Validates early return when CurrentCharacter is null, Phase remains Exploration |
| `StartCombat_SetsRoundToOne` | Validates CombatState.RoundNumber initialized to 1 |
| `StartCombat_SetsTurnIndexToZero` | Validates CombatState.TurnIndex initialized to 0 |
| `StartCombat_PlayerCombatantIsMarkedAsPlayer` | Validates player combatant has IsPlayer = true and CharacterSource set |
| `StartCombat_EnemyCombatantIsNotMarkedAsPlayer` | Validates enemy combatant has IsPlayer = false and EnemySource set |
| `NextTurn_IncrementsTurnIndex` | Validates TurnIndex increases by 1 when NextTurn called mid-round |
| `NextTurn_WrapsToZeroAtEndOfTurnOrder` | Validates TurnIndex wraps from 1 to 0 when at last combatant |
| `NextTurn_IncrementsRoundWhenWrapping` | Validates RoundNumber increments from 1 to 2 when TurnIndex wraps |
| `NextTurn_WithNoCombat_DoesNothing` | Validates NextTurn does not throw when CombatState is null |
| `NextTurn_MiddleOfRound_DoesNotIncrementRound` | Validates RoundNumber remains 1 when advancing from TurnIndex 0 to 1 |
| `EndCombat_SetsPhaseToExploration` | Validates GameState.Phase transitions from Combat to Exploration |
| `EndCombat_ClearsCombatState` | Validates GameState.CombatState set to null |
| `EndCombat_WhenNoCombatActive_DoesNotThrow` | Validates EndCombat safe to call when CombatState already null |
| Helper: `CreateTestCharacter` | Test helper creating Character entity with specified name and default attributes |
| Helper: `CreateTestEnemy` | Test helper creating Enemy entity with specified name, 50 MaxHp, 50 CurrentHp |
| Helper: `SetupActiveCombat` | Test helper creating CombatState with specified combatant count for turn advancement tests |

### DiceServiceTests - RollSingle Tests (6 new tests)

| Test Name | Description |
|-----------|-------------|
| `RollSingle_ReturnsValueInRange` | Validates 100 RollSingle(10) calls return values between 1 and 10 inclusive |
| `RollSingle_WithDifferentSides_ReturnsValueInRange` | Validates d6 returns 1-6 and d20 returns 1-20 across 50 samples each |
| `RollSingle_WithZeroSides_ClampsToOne` | Validates sides=0 returns 1 and logs Warning |
| `RollSingle_WithNegativeSides_ClampsToOne` | Validates sides=-5 returns 1 and logs Warning |
| `RollSingle_LogsContext` | Verifies context "InitiativeRoll" appears in log messages |
| `RollSingle_Distribution_ShouldBeReasonablyRandom` | Validates 1000 d10 rolls produce each value 1-10 at least 50 times (statistical randomness) |

---

## DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

```csharp
// Register Combat Services
services.AddSingleton<IInitiativeService, InitiativeService>();
services.AddSingleton<ICombatService, CombatService>();
```

**Justification for Singleton Lifetime:**
- Both services are stateless and thread-safe
- InitiativeService depends only on IDiceService (also Singleton) and ILogger
- CombatService depends on GameState (Singleton), IInitiativeService (Singleton), and ILogger
- Singleton registration avoids unnecessary instantiation overhead in game loop

---

## Verification Results

### Build Output

```
Build succeeded.

    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:00.62
```

**Note:** Warning MSB3277 regarding EntityFrameworkCore.Relational version conflict is pre-existing and does not affect combat implementation.

### Test Output

```
Failed!  - Failed:     2, Passed:  1207, Skipped:     0, Total:  1209, Duration: 477 ms
```

**New Tests:**
- InitiativeServiceTests: 12/12 passed
- CombatServiceTests: 18/18 passed
- DiceServiceTests (RollSingle): 6/6 passed

**Pre-existing Failures:**
- `TextRedactorTests.RedactText_AtFiftyPercent_ReturnsMixedText` - Unrelated to combat
- `TextRedactorTests.RedactText_ContainsRedactedBlocks_UsesGreyMarkup` - Unrelated to combat

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Entities/
│   ├── Character.cs
│   ├── CodexEntry.cs
│   ├── DataCapture.cs
│   ├── Enemy.cs [NEW]
│   ├── InteractableObject.cs
│   ├── Room.cs
│   └── SaveGame.cs
├── Enums/
│   ├── Attribute.cs
│   ├── Direction.cs
│   ├── EquipmentSlot.cs
│   ├── GamePhase.cs
│   ├── ItemRarity.cs
│   ├── ObjectState.cs
│   ├── ObjectType.cs
│   └── PendingGameAction.cs
├── Interfaces/
│   ├── ICharacterRepository.cs
│   ├── ICodexEntryRepository.cs
│   ├── ICombatService.cs [NEW]
│   ├── IDataCaptureRepository.cs
│   ├── IDataCaptureService.cs
│   ├── IDescriptorEngine.cs
│   ├── IDiceService.cs [MODIFIED]
│   ├── IGameService.cs
│   ├── IInitiativeService.cs [NEW]
│   ├── IInputHandler.cs
│   ├── IInteractableObjectRepository.cs
│   ├── IInteractionService.cs
│   ├── IJournalService.cs
│   ├── INavigationService.cs
│   ├── IRepository.cs
│   ├── IRoomRepository.cs
│   ├── ISaveGameRepository.cs
│   └── IStatCalculationService.cs
├── Models/
│   ├── Combat/
│   │   └── Combatant.cs [NEW]
│   ├── CombatState.cs [NEW]
│   ├── GameState.cs [MODIFIED]
│   └── (other model files)

RuneAndRust.Engine/
├── Services/
│   ├── CombatService.cs [NEW]
│   ├── CommandParser.cs [MODIFIED]
│   ├── DataCaptureService.cs
│   ├── DescriptorEngine.cs
│   ├── DiceService.cs [MODIFIED]
│   ├── GameService.cs
│   ├── InitiativeService.cs [NEW]
│   ├── InteractionService.cs
│   ├── JournalService.cs
│   ├── NavigationService.cs
│   ├── SaveManager.cs
│   ├── StatCalculationService.cs
│   └── TextRedactor.cs
├── Factories/
│   ├── CharacterFactory.cs
│   └── ObjectSpawner.cs
└── (other directories)

RuneAndRust.Tests/
├── Engine/
│   ├── CombatServiceTests.cs [NEW]
│   ├── DataCaptureServiceTests.cs
│   ├── DescriptorEngineTests.cs
│   ├── DiceServiceTests.cs [MODIFIED]
│   ├── InitiativeServiceTests.cs [NEW]
│   ├── InteractionServiceTests.cs
│   ├── JournalServiceTests.cs
│   ├── NavigationServiceTests.cs
│   ├── StatCalculationServiceTests.cs
│   └── TextRedactorTests.cs
└── (other directories)

RuneAndRust.Terminal/
├── Program.cs [MODIFIED]
└── Services/
    ├── CharacterCreationController.cs
    └── TerminalInputHandler.cs
```

---

## Running Tests

### Run All Tests
```bash
dotnet test
```

### Run Combat Tests Only
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests"
dotnet test --filter "FullyQualifiedName~InitiativeServiceTests"
```

### Run DiceService Tests (Including RollSingle)
```bash
dotnet test --filter "FullyQualifiedName~DiceServiceTests"
```

### Run New Combat Tests (Combined)
```bash
dotnet test --filter "FullyQualifiedName~CombatServiceTests|FullyQualifiedName~InitiativeServiceTests"
```

---

## Next Steps

**Planned for v0.2.1:**
- Implement combat action system (Attack, Defend, UseItem, Flee)
- Add damage calculation service using dice pools
- Implement enemy AI decision-making patterns
- Create combat UI display with turn indicator and combatant health bars
- Add combat logging to Scavenger's Journal
- Implement stamina cost for combat actions
- Add status effects (Bleeding, Stunned, Fortified)
- Create combat victory/defeat resolution with XP awards
- Add loot drops from defeated enemies
- Implement flee mechanics with FINESSE check

**Planned for v0.2.2:**
- Expand Enemy entity with behaviors, loot tables, and AI personality types
- Add enemy type definitions (Automaton, Revenant, Beast, Construct)
- Implement enemy spawning in DungeonGenerator
- Create bestiary entries for Codex system
- Add combat encounter triggers in Exploration phase
- Implement surprise round mechanics
- Add multi-target combat encounters
