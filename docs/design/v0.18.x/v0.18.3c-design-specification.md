# v0.18.3c Design Specification: Trauma Check System

**Version:** 0.18.3c
**Parent:** v0.18.3 (Trauma System)
**Prerequisites:** v0.18.3a (Trauma Enums & Definitions), v0.18.3b (CharacterTrauma Entity), v0.6.x (Dice System)
**Status:** Design Complete
**Estimated Unit Tests:** ~4

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [TraumaCheckTrigger Enum](#5-traumachecktrigger-enum)
6. [TraumaCheckResult Record](#6-traumacheckresult-record)
7. [ITraumaCheckService Interface](#7-itraumacheckservice-interface)
8. [Trauma Check Mechanics](#8-trauma-check-mechanics)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Dependencies](#13-dependencies)
14. [Future Considerations](#14-future-considerations)

---

## 1. Executive Summary

This design specification defines the Trauma Check system — mechanics that determine when characters must roll to avoid acquiring new traumas.

v0.18.3c establishes the **Check Mechanics Layer** for Trauma by defining:

- `TraumaCheckTrigger` enum — 8 trauma-inducing events
- `TraumaCheckResult` record — check outcome data
- `ITraumaCheckService` interface — service contract

### Key Deliverables

| Category          | Items                     |
| ----------------- | ------------------------- |
| **Domain Enums**  | `TraumaCheckTrigger`      |
| **Domain Records** | `TraumaCheckResult`       |
| **Service Interfaces** | `ITraumaCheckService`    |
| **Tests**         | ~4 unit tests             |

### Trauma Check Triggers Overview

| Trigger                | Difficulty | Category on Fail      | Event |
| ---------------------- | ---------- | --------------------- | ----- |
| StressThreshold100     | 3          | Cognitive/Emotional   | Hit max stress |
| CorruptionThreshold100 | 4          | Corruption            | Hit max corruption |
| AllyDeath              | 2          | Emotional             | Party member dies |
| NearDeathExperience    | 2          | Physical/Emotional    | Reduced to 1 HP |
| CriticalFailure        | 1          | Context-dependent     | Failed opposed check |
| ProlongedExposure      | 2          | Existential           | Extended danger |
| WitnessingHorror       | 3          | Cognitive             | Saw traumatic event |
| RuinMadnessEscape      | 4          | Cognitive/Existential | Survived Ruin-Madness |

---

## 2. Feature Overview

```
v0.18.3c Features
└── Trauma Check Mechanics (Application Layer)
    │
    ├── TraumaCheckTrigger Enum
    │   ├── StressThreshold100
    │   ├── CorruptionThreshold100
    │   ├── AllyDeath
    │   ├── NearDeathExperience
    │   ├── CriticalFailure
    │   ├── ProlongedExposure
    │   ├── WitnessingHorror
    │   └── RuinMadnessEscape
    │
    ├── TraumaCheckResult Record
    │   ├── CharacterId: Guid
    │   ├── Trigger: TraumaCheckTrigger
    │   ├── DiceRolled: int
    │   ├── SuccessesNeeded: int
    │   ├── SuccessesAchieved: int
    │   ├── Passed: bool
    │   ├── TraumaAcquired: string?
    │   ├── Modifiers: IReadOnlyList<string>
    │   └── ResolvePenaltyApplied: int
    │
    └── ITraumaCheckService Interface
        ├── PerformTraumaCheck(...)
        ├── GetTraumaCheckDifficulty(...)
        ├── GetCurrentModifiers(...)
        ├── ShouldTriggerCheck(...)
        └── GetRandomTrauma(...)
```

---

## 3. Architecture Diagrams

### 3.1 Trauma Check Flow

```
┌─────────────────────────────────────────────┐
│   Trauma Event Occurs (e.g., AllyDeath)    │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
        ┌──────────────────────────┐
        │ ShouldTriggerCheck?      │
        │ (check for prior check)  │
        └────────┬─────────┬───────┘
                 │         │
              [YES]      [NO]
                 │         └─→ Return (no check)
                 │
                 ▼
        ┌──────────────────────────┐
        │ Get Check Difficulty     │
        │ for Trigger              │
        └────────┬─────────────────┘
                 │
                 ▼
        ┌──────────────────────────┐
        │ Calculate Dice Pool:     │
        │ RESOLVE dice pool        │
        │ - Corruption penalty     │
        │ - Apply modifiers        │
        └────────┬─────────────────┘
                 │
                 ▼
        ┌──────────────────────────┐
        │ Roll dice                │
        │ Count successes          │
        └────────┬─────────────────┘
                 │
                 ▼
        ┌──────────────────────────┐
        │ Passed = Successes       │
        │   >= SuccessesNeeded?    │
        └────┬───────────────┬─────┘
             │               │
          [YES]            [NO]
             │               │
             │               ▼
             │        ┌────────────────────────┐
             │        │ Select Random Trauma   │
             │        │ from category          │
             │        └────────┬───────────────┘
             │                 │
             │                 ▼
             │        ┌────────────────────────┐
             │        │ Acquire Trauma         │
             │        └────────┬───────────────┘
             │                 │
             └─────────┬───────┘
                       │
                       ▼
        ┌──────────────────────────┐
        │ Return TraumaCheckResult │
        └──────────────────────────┘
```

### 3.2 Corruption Penalty Calculation

```
                    Corruption Value
                          │
                          ▼
                ┌───────────────────────┐
                │ Divide by 20          │
                │ (floor division)      │
                │ Result = Penalty      │
                └───────────┬───────────┘
                            │
    ┌───────────────────────┴───────────────────────┐
    │                                               │
    ▼                                               ▼
Corruption 0-19:    Corruption 20-39:  Corruption 40-59:
  Penalty = 0        Penalty = 1        Penalty = 2
    │                 │                 │
    └─────────────────┼─────────────────┘
                      │
    ┌─────────────────┴─────────────────┐
    │                                   │
    ▼                                   ▼
Corruption 60-79:               Corruption 80-100:
  Penalty = 3                     Penalty = 4-5
    │                              │
    └──────────────────────────────┘
                 │
                 ▼
        Reduced Dice Pool
        (removed from RESOLVE pool)
```

### 3.3 Trauma Category Mapping

```
┌─────────────────────────────────────────┐
│   Trigger → Trauma Category              │
└─────────────────────────────────────────┘
     │
     ├─ StressThreshold100 ──→ Cognitive/Emotional
     ├─ CorruptionThreshold100 ──→ Corruption
     ├─ AllyDeath ──→ Emotional
     ├─ NearDeathExperience ──→ Physical/Emotional
     ├─ CriticalFailure ──→ (context-dependent)
     ├─ ProlongedExposure ──→ Existential
     ├─ WitnessingHorror ──→ Cognitive
     └─ RuinMadnessEscape ──→ Cognitive/Existential
```

---

## 4. User Stories

### US-18.3c-1: Define Trauma Check Triggers

**As a** game designer
**I want to** categorize trauma-inducing events
**So that** trauma checks activate at appropriate moments

**Acceptance Criteria:**

- TraumaCheckTrigger enum has 8 values
- Each trigger maps to specific event (ally death, stress threshold)
- Difficulty varies by trigger severity

### US-18.3c-2: Calculate Trauma Check Difficulty

**As a** check system
**I want to** determine difficulty based on trigger type
**So that** harder events require more successes

**Acceptance Criteria:**

- GetTraumaCheckDifficulty returns correct value per trigger
- Difficulties range from 1-4
- Difficulty is deterministic

### US-18.3c-3: Apply Corruption Penalty to Dice Pool

**As a** corruption mechanics system
**I want to** reduce trauma check dice pool by corruption level
**So that** corrupted characters are more likely to acquire traumas

**Acceptance Criteria:**

- Corruption 0-19 applies 0 penalty
- Corruption 20+ applies floor(corruption/20) penalty
- Penalty cannot reduce pool below 1 die

### US-18.3c-4: Select Random Trauma from Category

**As a** trauma acquisition system
**I want to** select a random trauma matching the failure category
**So that** failed checks result in thematic traumas

**Acceptance Criteria:**

- Selection respects trauma category
- Random selection is unweighted (all equal probability)
- Only valid traumas are selected

---

## 5. TraumaCheckTrigger Enum

### 5.1 Purpose

Defines the eight events that can trigger trauma checks.

### 5.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/TraumaCheckTrigger.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the events that trigger trauma checks.
/// </summary>
/// <remarks>
/// <para>
/// Trauma checks occur when characters experience stressful or horrific events.
/// Different triggers have different difficulties and result in different trauma types.
/// </para>
/// <para>
/// Trigger Mechanics:
/// <list type="bullet">
/// <item>StressThreshold100: When stress reaches 100 points</item>
/// <item>CorruptionThreshold100: When corruption reaches 100 points</item>
/// <item>AllyDeath: When a party member dies</item>
/// <item>NearDeathExperience: When character is reduced to 1 HP</item>
/// <item>CriticalFailure: When character fails opposed check by large margin</item>
/// <item>ProlongedExposure: When character spends extended time in dangerous location</item>
/// <item>WitnessingHorror: When character witnesses traumatic event</item>
/// <item>RuinMadnessEscape: When character survives Ruin-Madness stage (CPS >= 60)</item>
/// </list>
/// </para>
/// </remarks>
public enum TraumaCheckTrigger
{
    /// <summary>
    /// Character's psychic stress reaches maximum (100).
    /// </summary>
    /// <remarks>
    /// Difficulty: 3 successes
    /// Trauma Category: Cognitive/Emotional
    /// Result: Trauma from stress-related categories
    /// </remarks>
    StressThreshold100 = 0,

    /// <summary>
    /// Character's corruption reaches maximum (100).
    /// </summary>
    /// <remarks>
    /// Difficulty: 4 successes
    /// Trauma Category: Corruption
    /// Result: Corruption-type trauma
    /// </remarks>
    CorruptionThreshold100 = 1,

    /// <summary>
    /// A party member dies.
    /// </summary>
    /// <remarks>
    /// Difficulty: 2 successes
    /// Trauma Category: Emotional
    /// Result: Emotional trauma (grief, guilt)
    /// </remarks>
    AllyDeath = 2,

    /// <summary>
    /// Character is reduced to 1 HP (near-death experience).
    /// </summary>
    /// <remarks>
    /// Difficulty: 2 successes
    /// Trauma Category: Physical/Emotional
    /// Result: Physical or emotional trauma
    /// </remarks>
    NearDeathExperience = 3,

    /// <summary>
    /// Character critically fails an opposed check.
    /// </summary>
    /// <remarks>
    /// Difficulty: 1 success
    /// Trauma Category: Context-dependent
    /// Result: Trauma related to check type
    /// Note: May not always trigger (GM discretion)
    /// </remarks>
    CriticalFailure = 4,

    /// <summary>
    /// Character spends extended time in a dangerous area.
    /// </summary>
    /// <remarks>
    /// Difficulty: 2 successes
    /// Trauma Category: Existential
    /// Result: Reality/identity crisis trauma
    /// Duration: Exposure time varies by environment
    /// </remarks>
    ProlongedExposure = 5,

    /// <summary>
    /// Character witnesses a horrific or traumatic event.
    /// </summary>
    /// <remarks>
    /// Difficulty: 3 successes
    /// Trauma Category: Cognitive
    /// Result: Cognitive trauma (flashbacks, paranoia)
    /// Examples: Seeing someone disintegrated, ritual sacrifice
    /// </remarks>
    WitnessingHorror = 6,

    /// <summary>
    /// Character survives Ruin-Madness stage (CPS 60-79).
    /// </summary>
    /// <remarks>
    /// Difficulty: 4 successes
    /// Trauma Category: Cognitive/Existential
    /// Result: Severe cognitive or existential trauma
    /// Note: Only triggers if character reaches RuinMadness and escapes
    /// </remarks>
    RuinMadnessEscape = 7
}
```

---

## 6. TraumaCheckResult Record

### 6.1 Purpose

Immutable record representing the complete outcome of a trauma check.

### 6.2 Definition

**File:** `src/Core/RuneAndRust.Domain/Records/TraumaCheckResult.cs`

```csharp
namespace RuneAndRust.Domain.Records;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the result of a trauma check roll.
/// </summary>
/// <remarks>
/// <para>
/// This record contains all information about a trauma check, including
/// the dice rolled, successes achieved, and whether a trauma was acquired.
/// </para>
/// <para>
/// Check Resolution:
/// - Roll RESOLVE attribute dice pool (base or reduced by corruption)
/// - Count successes (each die showing 4+ is one success)
/// - Compare to SuccessesNeeded for this trigger
/// - If successes < required: character acquires random trauma
/// - If successes >= required: character avoids trauma this time
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var result = TraumaCheckResult.CreatePassed(
///     characterId: characterId,
///     trigger: TraumaCheckTrigger.AllyDeath,
///     diceRolled: 3,
///     successesNeeded: 2,
///     successesAchieved: 2,
///     modifiers: new[] { "Grieving Bond" }
/// );
/// </code>
/// </example>
public record TraumaCheckResult
{
    /// <summary>
    /// Gets the character making the check.
    /// </summary>
    public Guid CharacterId { get; init; }

    /// <summary>
    /// Gets the trigger event for this check.
    /// </summary>
    public TraumaCheckTrigger Trigger { get; init; }

    /// <summary>
    /// Gets the number of dice rolled.
    /// </summary>
    /// <remarks>
    /// Base = RESOLVE attribute value
    /// Reduced by floor(corruption/20)
    /// </remarks>
    public int DiceRolled { get; init; }

    /// <summary>
    /// Gets the successes needed to pass this check.
    /// </summary>
    /// <remarks>
    /// Determined by trigger type (1-4)
    /// </remarks>
    public int SuccessesNeeded { get; init; }

    /// <summary>
    /// Gets the successes achieved on the roll.
    /// </summary>
    public int SuccessesAchieved { get; init; }

    /// <summary>
    /// Gets whether the check was passed.
    /// </summary>
    /// <remarks>
    /// True if SuccessesAchieved >= SuccessesNeeded
    /// False = character acquires trauma
    /// </remarks>
    public bool Passed { get; init; }

    /// <summary>
    /// Gets the trauma ID acquired (if check failed).
    /// </summary>
    /// <remarks>
    /// Null if check passed or no suitable trauma exists.
    /// </remarks>
    public string? TraumaAcquired { get; init; }

    /// <summary>
    /// Gets the modifiers applied to this check.
    /// </summary>
    /// <remarks>
    /// Examples: "Grieving Bond", "Corrupted Mind", "Strong Will"
    /// Modifiers affect dice pool or difficulty.
    /// </remarks>
    public IReadOnlyList<string> Modifiers { get; init; }

    /// <summary>
    /// Gets the number of dice removed due to corruption.
    /// </summary>
    /// <remarks>
    /// floor(corruption/20)
    /// </remarks>
    public int ResolvePenaltyApplied { get; init; }

    /// <summary>
    /// Creates a passed trauma check result.
    /// </summary>
    /// <param name="characterId">Character making check</param>
    /// <param name="trigger">Trigger event type</param>
    /// <param name="diceRolled">Dice rolled</param>
    /// <param name="successesNeeded">Successes needed</param>
    /// <param name="successesAchieved">Successes rolled</param>
    /// <param name="modifiers">Applied modifiers</param>
    /// <param name="resolvePenalty">Corruption penalty applied</param>
    /// <returns>A passed TraumaCheckResult</returns>
    public static TraumaCheckResult CreatePassed(
        Guid characterId,
        TraumaCheckTrigger trigger,
        int diceRolled,
        int successesNeeded,
        int successesAchieved,
        IReadOnlyList<string>? modifiers = null,
        int resolvePenalty = 0)
    {
        return new TraumaCheckResult
        {
            CharacterId = characterId,
            Trigger = trigger,
            DiceRolled = diceRolled,
            SuccessesNeeded = successesNeeded,
            SuccessesAchieved = successesAchieved,
            Passed = true,
            TraumaAcquired = null,
            Modifiers = modifiers ?? new List<string>(),
            ResolvePenaltyApplied = resolvePenalty
        };
    }

    /// <summary>
    /// Creates a failed trauma check result with trauma acquired.
    /// </summary>
    /// <param name="characterId">Character making check</param>
    /// <param name="trigger">Trigger event type</param>
    /// <param name="diceRolled">Dice rolled</param>
    /// <param name="successesNeeded">Successes needed</param>
    /// <param name="successesAchieved">Successes rolled</param>
    /// <param name="traumaAcquired">Trauma ID acquired</param>
    /// <param name="modifiers">Applied modifiers</param>
    /// <param name="resolvePenalty">Corruption penalty applied</param>
    /// <returns>A failed TraumaCheckResult</returns>
    public static TraumaCheckResult CreateFailed(
        Guid characterId,
        TraumaCheckTrigger trigger,
        int diceRolled,
        int successesNeeded,
        int successesAchieved,
        string traumaAcquired,
        IReadOnlyList<string>? modifiers = null,
        int resolvePenalty = 0)
    {
        return new TraumaCheckResult
        {
            CharacterId = characterId,
            Trigger = trigger,
            DiceRolled = diceRolled,
            SuccessesNeeded = successesNeeded,
            SuccessesAchieved = successesAchieved,
            Passed = false,
            TraumaAcquired = traumaAcquired,
            Modifiers = modifiers ?? new List<string>(),
            ResolvePenaltyApplied = resolvePenalty
        };
    }

    /// <summary>
    /// Gets the display string for this result.
    /// </summary>
    public override string ToString() =>
        $"{Trigger}: {DiceRolled}d[RESOLVE] → {SuccessesAchieved}/{SuccessesNeeded} " +
        (Passed ? "PASSED" : $"FAILED → {TraumaAcquired}") +
        (ResolvePenaltyApplied > 0 ? $" [-{ResolvePenaltyApplied} corruption]" : "");
}
```

---

## 7. ITraumaCheckService Interface

### 7.1 Purpose

Defines the service contract for all trauma check operations.

### 7.2 Definition

**File:** `src/Core/RuneAndRust.Application/Services/Interfaces/ITraumaCheckService.cs`

```csharp
namespace RuneAndRust.Application.Services.Interfaces;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Records;

/// <summary>
/// Service for performing trauma checks and managing check mechanics.
/// </summary>
/// <remarks>
/// <para>
/// The ITraumaCheckService handles the mechanics of trauma checks,
/// including difficulty determination, dice pool calculation, and
/// random trauma selection.
/// </para>
/// <para>
/// Responsibilities:
/// - Determine check difficulty for each trigger type
/// - Calculate effective dice pool (RESOLVE - corruption penalty)
/// - Prevent duplicate checks (one check per event per character)
/// - Select random trauma from appropriate category on failure
/// - Track check history and modifiers
/// </para>
/// </remarks>
public interface ITraumaCheckService
{
    /// <summary>
    /// Performs a trauma check for the given character and trigger.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Full trauma check flow:
    /// 1. Check if this character has already had this check type (ShouldTriggerCheck)
    /// 2. Get base RESOLVE pool
    /// 3. Apply corruption penalty (floor(corruption/20))
    /// 4. Get modifiers applicable to this character
    /// 5. Roll dice using IDiceService
    /// 6. Count successes
    /// 7. If failed, select random trauma
    /// 8. Return TraumaCheckResult
    /// </para>
    /// </remarks>
    /// <param name="characterId">Character making the check</param>
    /// <param name="trigger">Type of trauma-inducing event</param>
    /// <returns>Complete check result with outcome</returns>
    /// <exception cref="ArgumentException">If character not found</exception>
    Task<TraumaCheckResult> PerformTraumaCheckAsync(
        Guid characterId,
        TraumaCheckTrigger trigger);

    /// <summary>
    /// Gets the difficulty (successes needed) for the given trigger.
    /// </summary>
    /// <remarks>
    /// Difficulties are fixed per trigger type:
    /// - CriticalFailure: 1
    /// - AllyDeath, NearDeathExperience, ProlongedExposure: 2
    /// - StressThreshold100, WitnessingHorror: 3
    /// - CorruptionThreshold100, RuinMadnessEscape: 4
    /// </remarks>
    /// <param name="trigger">Trigger type</param>
    /// <returns>Number of successes needed (1-4)</returns>
    int GetTraumaCheckDifficulty(TraumaCheckTrigger trigger);

    /// <summary>
    /// Gets modifiers applicable to the character's trauma checks.
    /// </summary>
    /// <remarks>
    /// Modifiers can come from:
    /// - Existing traumas (some make checks harder/easier)
    /// - Character traits or abilities
    /// - Current status effects
    /// - Campaign-specific rules
    /// </remarks>
    /// <param name="characterId">Character to check</param>
    /// <returns>List of applicable modifiers</returns>
    Task<IReadOnlyList<string>> GetCurrentModifiersAsync(Guid characterId);

    /// <summary>
    /// Determines whether a trauma check should trigger.
    /// </summary>
    /// <remarks>
    /// Returns false if:
    /// - Character already had this check type recently (e.g., only one AllyDeath check per session)
    /// - Character is not in valid state for this check
    /// - Check has been explicitly disabled
    /// </remarks>
    /// <param name="characterId">Character to check</param>
    /// <param name="trigger">Trigger type</param>
    /// <returns>True if check should proceed, false to skip</returns>
    Task<bool> ShouldTriggerCheckAsync(Guid characterId, TraumaCheckTrigger trigger);

    /// <summary>
    /// Gets a random trauma from the given category.
    /// </summary>
    /// <remarks>
    /// Used when trauma check fails. Selects from the category determined
    /// by the trigger type. Selection is unweighted (random).
    /// </remarks>
    /// <param name="category">Trauma category to select from</param>
    /// <returns>Trauma ID, or null if no suitable trauma exists</returns>
    Task<string?> GetRandomTraumaAsync(TraumaType category);
}
```

---

## 8. Trauma Check Mechanics

### 8.1 Check Calculation Formula

```
TRAUMA CHECK FORMULA:
═══════════════════════════════════════════════════════════

Effective Dice Pool = base_resolve - corruption_penalty

where:
  base_resolve = Character's RESOLVE attribute value
  corruption_penalty = floor(corruption_value / 20)

Successes = Count all dice ≥ 4 in roll

Result = Successes >= SuccessesNeeded for Trigger

IF Result == FALSE:
  Acquire random trauma from trigger's category
ENDIF
```

### 8.2 Difficulty Table

| Trigger                | DC | Category on Fail      | When |
| ---------------------- | -- | --------------------- | ---- |
| CriticalFailure        | 1  | Context-dependent     | When opposed check fails by 2+ |
| AllyDeath              | 2  | Emotional             | Party member dies |
| NearDeathExperience    | 2  | Physical/Emotional    | Reduced to 1 HP |
| ProlongedExposure      | 2  | Existential           | Extended time in danger |
| StressThreshold100     | 3  | Cognitive/Emotional   | Stress reaches 100 |
| WitnessingHorror       | 3  | Cognitive             | Witness traumatic event |
| CorruptionThreshold100 | 4  | Corruption            | Corruption reaches 100 |
| RuinMadnessEscape      | 4  | Cognitive/Existential | Escape RuinMadness alive |

### 8.3 Corruption Penalty Reference Table

| Corruption Value | Penalty |
| --- | --- |
| 0-19            | 0 |
| 20-39           | 1 |
| 40-59           | 2 |
| 60-79           | 3 |
| 80-99           | 4 |
| 100             | 5 |

---

## 9. Logging Specifications

### 9.1 Service Logging

Service implementation (v0.18.3e) should log:

| Event                    | Level       | Template                                                       |
| ------------------------ | ----------- | -------------------------------------------------------------- |
| Trauma Check Triggered   | Information | `"Trauma check: {CharacterId} {Trigger}"`                      |
| Check Passed             | Information | `"Trauma check passed: {CharacterId} {Trigger} {Successes}"`   |
| Check Failed             | Warning     | `"Trauma acquired: {CharacterId} {Trauma} from {Trigger}"`     |
| Corruption Penalty       | Debug       | `"Corruption penalty applied: -{Penalty} dice"`                |
| Invalid Check State      | Warning     | `"Trauma check skipped: {CharacterId} {Trigger} (duplicate)"`  |

---

## 10. Unit Testing Requirements

### 10.1 Test File Locations

**Files:**
- `tests/RuneAndRust.Domain.UnitTests/Enums/TraumaCheckTriggerTests.cs`
- `tests/RuneAndRust.Domain.UnitTests/Records/TraumaCheckResultTests.cs`
- `tests/RuneAndRust.Application.UnitTests/Services/TraumaCheckServiceTests.cs`

### 10.2 Required Tests

| Test Name | Description |
| --- | --- |
| `GetTraumaCheckDifficulty_ReturnCorrectDifficulty` | Verify difficulty per trigger |
| `PerformTraumaCheck_PassedCheck_ReturnsPassedResult` | Verify passing check |
| `PerformTraumaCheck_FailedCheck_AcquiresTrauma` | Verify trauma acquisition on failure |
| `PerformTraumaCheck_WithCorruption_ReducesDicePool` | Verify corruption penalty |

### 10.3 Example Test

```csharp
[TestFixture]
public class TraumaCheckServiceTests
{
    private ITraumaCheckService _service;
    private Mock<IDiceService> _diceService;
    private Mock<ICharacterRepository> _characterRepository;
    private Mock<ITraumaRepository> _traumaRepository;
    private Guid _characterId;

    [SetUp]
    public void Setup()
    {
        _diceService = new Mock<IDiceService>();
        _characterRepository = new Mock<ICharacterRepository>();
        _traumaRepository = new Mock<ITraumaRepository>();
        _characterId = Guid.NewGuid();

        _service = new TraumaCheckService(
            _diceService.Object,
            _characterRepository.Object,
            _traumaRepository.Object,
            NullLogger<TraumaCheckService>.Instance
        );
    }

    [Test]
    public void GetTraumaCheckDifficulty_ReturnsCorrectDifficulty()
    {
        // Arrange & Act & Assert
        Assert.That(_service.GetTraumaCheckDifficulty(TraumaCheckTrigger.CriticalFailure), Is.EqualTo(1));
        Assert.That(_service.GetTraumaCheckDifficulty(TraumaCheckTrigger.AllyDeath), Is.EqualTo(2));
        Assert.That(_service.GetTraumaCheckDifficulty(TraumaCheckTrigger.StressThreshold100), Is.EqualTo(3));
        Assert.That(_service.GetTraumaCheckDifficulty(TraumaCheckTrigger.CorruptionThreshold100), Is.EqualTo(4));
    }

    [Test]
    public async Task PerformTraumaCheck_PassedCheck_ReturnsPassedResult()
    {
        // Arrange
        var character = CreateMockCharacter(_characterId, resolveAttribute: 3, corruption: 0);
        _characterRepository.Setup(r => r.GetByIdAsync(_characterId))
            .ReturnsAsync(character);
        _diceService.Setup(d => d.RollDiceAsync(3, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new[] { 4, 5, 3 }); // 2 successes
        _traumaRepository.Setup(r => r.GetByTypeAsync(TraumaType.Emotional, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new List<TraumaDefinition>());

        // Act
        var result = await _service.PerformTraumaCheckAsync(
            _characterId,
            TraumaCheckTrigger.AllyDeath
        );

        // Assert
        result.Passed.Should().BeTrue();
        result.SuccessesAchieved.Should().Be(2);
        result.SuccessesNeeded.Should().Be(2);
    }

    [Test]
    public async Task PerformTraumaCheck_FailedCheck_AcquiresTrauma()
    {
        // Arrange
        var character = CreateMockCharacter(_characterId, resolveAttribute: 2, corruption: 0);
        _characterRepository.Setup(r => r.GetByIdAsync(_characterId))
            .ReturnsAsync(character);
        _diceService.Setup(d => d.RollDiceAsync(2, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new[] { 2, 3 }); // 0 successes

        var emotionalTrauma = CreateMockTraumaDefinition("survivors-guilt", TraumaType.Emotional);
        _traumaRepository.Setup(r => r.GetByTypeAsync(TraumaType.Emotional, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new[] { emotionalTrauma });

        // Act
        var result = await _service.PerformTraumaCheckAsync(
            _characterId,
            TraumaCheckTrigger.AllyDeath
        );

        // Assert
        result.Passed.Should().BeFalse();
        result.TraumaAcquired.Should().Be("survivors-guilt");
    }

    [Test]
    public async Task PerformTraumaCheck_WithCorruption_ReducesDicePool()
    {
        // Arrange
        var character = CreateMockCharacter(_characterId, resolveAttribute: 3, corruption: 25);
        _characterRepository.Setup(r => r.GetByIdAsync(_characterId))
            .ReturnsAsync(character);
        // Corruption 25 = penalty of 1, so 3-1 = 2 dice
        _diceService.Setup(d => d.RollDiceAsync(2, It.IsAny<CancellationToken>()))
            .ReturnsAsync(new[] { 4, 3 });

        // Act
        var result = await _service.PerformTraumaCheckAsync(
            _characterId,
            TraumaCheckTrigger.AllyDeath
        );

        // Assert
        result.DiceRolled.Should().Be(2);
        result.ResolvePenaltyApplied.Should().Be(1);
    }

    // Helper methods
    private Character CreateMockCharacter(Guid id, int resolveAttribute, int corruption)
    {
        var character = new Character
        {
            Id = id,
            Attributes = new Dictionary<string, int> { { "RESOLVE", resolveAttribute } },
            Corruption = corruption
        };
        return character;
    }

    private TraumaDefinition CreateMockTraumaDefinition(string id, TraumaType type)
    {
        return TraumaDefinition.Create(
            traumaId: id,
            name: id,
            type: type,
            description: "Test",
            flavorText: "Test",
            isRetirementTrauma: false,
            retirementCondition: null,
            isStackable: true,
            acquisitionSources: new[] { "Test" },
            triggers: new List<TraumaTrigger>(),
            effects: new List<TraumaEffect>()
        );
    }
}
```

---

## 11. Deliverable Checklist

### 11.1 Domain Layer

- [ ] `src/Core/RuneAndRust.Domain/Enums/TraumaCheckTrigger.cs`
- [ ] `src/Core/RuneAndRust.Domain/Records/TraumaCheckResult.cs`

### 11.2 Application Layer

- [ ] `src/Core/RuneAndRust.Application/Services/Interfaces/ITraumaCheckService.cs`

### 11.3 Tests

- [ ] `tests/RuneAndRust.Domain.UnitTests/Enums/TraumaCheckTriggerTests.cs`
- [ ] `tests/RuneAndRust.Domain.UnitTests/Records/TraumaCheckResultTests.cs`
- [ ] `tests/RuneAndRust.Application.UnitTests/Services/TraumaCheckServiceTests.cs`

### 11.4 Documentation

- [ ] Update `docs/design/v0.18.x/v0.18.3-scope-breakdown.md` (mark v0.18.3c complete)
- [ ] Create `docs/changelogs/v0.18.3c-changelog.md`

---

## 12. Acceptance Criteria

### 12.1 Build Verification

- [ ] Solution builds without errors
- [ ] Solution builds without warnings in new code

### 12.2 Test Verification

- [ ] All new unit tests pass (~4 tests)
- [ ] All existing unit tests continue to pass

### 12.3 Functional Verification

- [ ] `TraumaCheckTrigger` enum has all 8 values
- [ ] `GetTraumaCheckDifficulty()` returns correct difficulty per trigger
- [ ] `TraumaCheckResult.CreatePassed()` sets Passed=true
- [ ] `TraumaCheckResult.CreateFailed()` sets TraumaAcquired correctly
- [ ] Corruption penalty correctly reduces dice pool
- [ ] Interface compiles with no implementation
- [ ] All methods have XML documentation

---

## 13. Dependencies

### 13.1 Required Prerequisites

| Dependency                | Version | Status   | Notes                                |
| ------------------------- | ------- | -------- | ------------------------------------ |
| Trauma Enums & Definitions | v0.18.3a | Required | TraumaType enum for category mapping |
| CharacterTrauma Entity    | v0.18.3b | Required | For acquiring traumas on failure     |
| Dice System               | v0.6.x  | Required | IDiceService for rolling checks     |
| Character Entity          | v0.x.x  | Required | RESOLVE attribute for dice pool     |

### 13.2 Provides to v0.18.3d-e

| Type | Usage |
| --- | --- |
| `TraumaCheckTrigger` | Enum used in check mechanics |
| `TraumaCheckResult` | Returned by service |
| `ITraumaCheckService` | Implemented by TraumaCheckService |

### 13.3 Deferred to Later Phases

| Item | Deferred To | Reason |
| --- | --- | --- |
| Service implementation | v0.18.3e | Application layer |
| Integration with events | v0.18.5 | Event system integration |
| Combat/Rest integration | v0.18.5 | Requires complete trauma system |

---

## 14. Future Considerations

### 14.1 v0.18.3d (ITraumaService Interface)

- Integration of trauma checks into main service
- Methods for performing checks as part of character operations

### 14.2 v0.18.3e (TraumaService & Config)

- Full implementation of ITraumaCheckService
- Database persistence of check history
- Integration with IDiceService

### 14.3 v0.18.5 (Trauma Integration)

- Integration with combat event system
- Integration with rest mechanics
- NPC trauma check mechanics
- Trauma interaction matrix (checks that trigger other checks)

### 14.4 Future Enhancements

- Modifiers system (traits that modify check difficulty)
- Check history tracking (one check per character per trigger type per session)
- Custom trauma selection logic (weighted by narrative context)
- Trauma check streaming (multiple checks on single event)

---

*This design specification provides the detailed blueprint for implementing v0.18.3c. The Trauma Check System layer provides the mechanics for all trauma acquisition.*

---

## Changelog

| Version | Date       | Changes                        |
| ------- | ---------- | ------------------------------ |
| 1.0     | 2026-01-28 | Initial design specification   |
