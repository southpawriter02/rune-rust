# v0.13.2a Design Specification: Tree Visualization

**Version:** 0.13.2a
**Parent:** v0.13.2 (Ability Tree UI)
**Prerequisites:** v0.13.1 Complete (Boss & Monster UI), v0.10.2a Complete (Ability Trees)
**Status:** Design Complete
**Estimated Unit Tests:** ~6

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Ability Tree View Component](#4-ability-tree-view-component)
   - 4.1 [AbilityTreeView Class](#41-abilitytreeview-class)
   - 4.2 [Tree Header Rendering](#42-tree-header-rendering)
   - 4.3 [Tier Column Layout](#43-tier-column-layout)
5. [Tree Layout Renderer](#5-tree-layout-renderer)
   - 5.1 [TreeLayoutRenderer Class](#51-treelayoutrenderer-class)
   - 5.2 [Node Position Calculation](#52-node-position-calculation)
   - 5.3 [Tier Column Rendering](#53-tier-column-rendering)
6. [Branch Display](#6-branch-display)
   - 6.1 [Branch Organization](#61-branch-organization)
   - 6.2 [Branch Header Rendering](#62-branch-header-rendering)
7. [Data Model Changes](#7-data-model-changes)
8. [Configuration File Schemas](#8-configuration-file-schemas)
9. [CharacterView Integration](#9-characterview-integration)
10. [Logging Specifications](#10-logging-specifications)
11. [Unit Testing Requirements](#11-unit-testing-requirements)
12. [Use Cases](#12-use-cases)
13. [Deliverable Checklist](#13-deliverable-checklist)
14. [Acceptance Criteria](#14-acceptance-criteria)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

This version implements the ability tree visualization component that displays the hierarchical structure of ability nodes organized by tiers. The tree visualization shows all nodes in a column-based layout with clear tier separation, branch organization, and a tree header displaying the tree name. This component provides the foundational layout for the ability tree UI without handling node states, prerequisite lines, or interactions.

### Key Deliverables

| Category | Items |
|----------|-------|
| **UI Components** | `AbilityTreeView` |
| **Renderers** | `TreeLayoutRenderer` |
| **DTOs** | `TreeDisplayDto`, `TierDisplayDto`, `NodeLayoutDto`, `BranchDisplayDto` |
| **View Updates** | `CharacterView` integration |
| **Configuration** | `ability-tree-display.json` |
| **Tests** | ~6 unit tests |

### Architectural Significance

This version establishes the **Ability Tree UI Pattern** that will be used throughout the ability tree display:
- Tree structures are rendered using column-based tier layouts
- Node positions are calculated from tree definition coordinates
- Branches are visually grouped within their respective tiers
- Configuration drives layout dimensions and spacing
- The pattern supports future extension for states, lines, and tooltips (v0.13.2b-d)

---

## 2. Feature Overview

```
v0.13.2a Features
├── AbilityTreeView (UI Component)
│   ├── RenderTree(TreeDisplayDto)
│   ├── RenderTiers(IEnumerable<TierDisplayDto>)
│   ├── SetTreeHeader(string)
│   └── HandleSelection(int, int)
│
├── TreeLayoutRenderer (Renderer)
│   ├── CalculateNodePositions(AbilityTreeDefinition)
│   ├── RenderTierColumn(TierDisplayDto)
│   ├── GetTierLabel(int)
│   ├── GetTreeWidth()
│   └── FormatNodeBox(NodeLayoutDto)
│
├── Tree Header Display
│   ├── Tree Name Centering
│   ├── Header Border
│   └── Branch Tabs
│
├── Tier Column Layout
│   ├── Column Spacing
│   ├── Tier Labels
│   └── Vertical Node Arrangement
│
└── CharacterView Integration
    ├── Tree Tab Detection
    ├── View Panel Placement
    └── Navigation Support
```

### Scope Verification

| Feature | Source | Included |
|---------|--------|----------|
| Hierarchical tree layout with tier columns | v0.13.2-scope-breakdown.md | Yes |
| Visual tree structure rendering | v0.13.2-scope-breakdown.md | Yes |
| Tier labels and separators | v0.13.2-scope-breakdown.md | Yes |
| Tree header with tree name | v0.13.2-scope-breakdown.md | Yes |
| Node state rendering | v0.13.2-scope-breakdown.md | No (v0.13.2b) |
| Prerequisite lines | v0.13.2-scope-breakdown.md | No (v0.13.2c) |
| Tooltips and interaction | v0.13.2-scope-breakdown.md | No (v0.13.2d) |

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PRESENTATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │    CharacterView        │      │    AbilityTreeView      │               │
│  │    (existing)           │◄────▶│    (NEW)                │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ - RenderCharacterInfo() │      │ - RenderTree()          │               │
│  │ - HandleAbilityTreeTab()│      │ - RenderTiers()         │               │
│  │ - IntegrateComponents() │      │ - SetTreeHeader()       │               │
│  └─────────────────────────┘      │ - HandleSelection()     │               │
│                                    └───────────┬─────────────┘               │
│                                                │                             │
│  ┌─────────────────────────────────────────────┴───────────────────────────┐ │
│  │                     TreeLayoutRenderer (NEW)                             │ │
│  ├─────────────────────────────────────────────────────────────────────────┤ │
│  │ - CalculateNodePositions()  - GetTierLabel()                            │ │
│  │ - RenderTierColumn()        - GetTreeWidth()                            │ │
│  │ - FormatNodeBox()           - FormatBranchHeader()                      │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          APPLICATION LAYER                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    IAbilityTreeProvider (existing v0.10.2a)         │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + GetTreeForClass(classId) : AbilityTreeDefinition?                 │    │
│  │ + GetTree(treeId) : AbilityTreeDefinition?                          │    │
│  │ + GetAllTrees() : IReadOnlyList<AbilityTreeDefinition>              │    │
│  │ + FindNode(nodeId) : AbilityTreeNode?                               │    │
│  │ + GetTreeContainingNode(nodeId) : AbilityTreeDefinition?            │    │
│  │ + GetBranchContainingNode(nodeId) : AbilityTreeBranch?              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    ITalentPointService (existing v0.10.2b)          │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │ + GetUnspentPoints(player) : int                                    │    │
│  │ + GetTotalPointsSpent(player) : int                                 │    │
│  │ + GetNodeRank(player, nodeId) : int                                 │    │
│  │ + GetAllocationsForTree(player, treeId) : IReadOnlyList<...>        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                        │
                                        ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            DOMAIN LAYER                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────┐      ┌─────────────────────────┐               │
│  │  AbilityTreeDefinition  │      │   AbilityTreeBranch     │               │
│  │   (existing v0.10.2a)   │◄─────│   (existing v0.10.2a)   │               │
│  ├─────────────────────────┤      ├─────────────────────────┤               │
│  │ + TreeId: string        │      │ + BranchId: string      │               │
│  │ + ClassId: string       │      │ + Name: string          │               │
│  │ + Name: string          │      │ + Description: string   │               │
│  │ + Description: string   │      │ + Nodes: IReadOnly...   │               │
│  │ + PointsPerLevel: int   │      │ + IconPath: string?     │               │
│  │ + Branches: IReadOnly...│      └─────────────────────────┘               │
│  │ + GetAllNodes()         │                                                 │
│  │ + GetNodesAtTier(tier)  │      ┌─────────────────────────┐               │
│  │ + GetMaxTier()          │      │    AbilityTreeNode      │               │
│  │ + FindNode(nodeId)      │      │   (existing v0.10.2a)   │               │
│  └─────────────────────────┘      ├─────────────────────────┤               │
│                                    │ + NodeId: string        │               │
│                                    │ + Name: string          │               │
│                                    │ + Description: string   │               │
│                                    │ + Tier: int             │               │
│                                    │ + PointCost: int        │               │
│                                    │ + MaxRank: int          │               │
│                                    │ + Position: NodePosition│               │
│                                    │ + PrerequisiteNodeIds   │               │
│                                    └─────────────────────────┘               │
│                                                                              │
│  ┌─────────────────────────┐                                                 │
│  │     NodePosition        │                                                 │
│  │   (existing v0.10.2a)   │                                                 │
│  ├─────────────────────────┤                                                 │
│  │ + X: int                │                                                 │
│  │ + Y: int                │                                                 │
│  └─────────────────────────┘                                                 │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    ABILITY TREE VIEW DATA FLOW                               │
└─────────────────────────────────────────────────────────────────────────────┘

    Character View Opens Ability Tree Tab
           │
           ▼
┌─────────────────────────┐
│     CharacterView       │
│  HandleAbilityTreeTab() │
└───────────┬─────────────┘
            │
            │ 1. Get player's class and tree
            ▼
┌─────────────────────────┐
│  IAbilityTreeProvider   │
│  GetTreeForClass(classId)│
└───────────┬─────────────┘
            │
            │ 2. Returns AbilityTreeDefinition
            ▼
┌─────────────────────────────────────────────────────────────┐
│    AbilityTreeView                                           │
│                                                              │
│  ┌───────────────────┐  ┌───────────────────┐               │
│  │ CreateTreeDto()   │  │ CreateTierDtos()  │               │
│  └─────────┬─────────┘  └─────────┬─────────┘               │
│            │                      │                          │
│            │ 3. Build display DTOs from definition          │
│            ▼                      ▼                          │
│  ┌───────────────────┐  ┌───────────────────┐               │
│  │ SetTreeHeader()   │  │ RenderTiers()     │               │
│  └─────────┬─────────┘  └─────────┬─────────┘               │
│            │                      │                          │
│            │ 4. Render tree header and tier columns         │
└────────────┼──────────────────────┼─────────────────────────┘
             │                      │
             │ 5. Call renderer for layout calculations
             ▼                      ▼
┌─────────────────────────────────────────────────────────────┐
│ TreeLayoutRenderer                                           │
│                                                              │
│ - CalculateNodePositions()  │ 6. Calculate grid positions   │
│ - GetTierLabel()            │ 7. Generate "TIER 1", etc.    │
│ - RenderTierColumn()        │ 8. Build column strings       │
│ - FormatNodeBox()           │ 9. Create node box ASCII      │
│ - GetTreeWidth()            │ 10. Calculate total width     │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ 11. Return formatted strings
            ▼
┌─────────────────────────┐
│   ITerminalService      │
│   WriteAt(x, y, text)   │
│   WriteColoredAt(...)   │
└─────────────────────────┘
```

### 3.3 Tree Layout Calculation Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    TREE LAYOUT CALCULATION FLOW                              │
└─────────────────────────────────────────────────────────────────────────────┘

    AbilityTreeDefinition Input
           │
           ▼
┌─────────────────────────┐
│  Get Max Tier Number    │
│  GetMaxTier()           │
└───────────┬─────────────┘
            │
            │ maxTier = 3
            ▼
┌─────────────────────────┐
│  Create Tier Columns    │
│  for tier = 1 to maxTier│
└───────────┬─────────────┘
            │
            │ For each tier...
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Get Nodes at Tier                                           │
│                                                              │
│  Tier 1: [Power Strike, Iron Skin, Battle Cry]               │
│  Tier 2: [Cleave, Shield Bash, War Cry]                      │
│  Tier 3: [Whirlwind, Last Stand]                             │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ Calculate positions based on node.Position.Y
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Sort Nodes by Y Position                                    │
│                                                              │
│  Tier 1 Column:                                              │
│    Y=0: Power Strike                                         │
│    Y=1: Iron Skin                                            │
│    Y=2: Battle Cry                                           │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ Calculate column X positions
            ▼
┌─────────────────────────────────────────────────────────────┐
│  Column X Calculation                                        │
│                                                              │
│  Tier 1 Column X = StartX + Padding                          │
│  Tier 2 Column X = Tier1X + NodeWidth + ColumnSpacing        │
│  Tier 3 Column X = Tier2X + NodeWidth + ColumnSpacing        │
└───────────┬─────────────────────────────────────────────────┘
            │
            │ Return node position dictionary
            ▼
┌─────────────────────────┐
│  Dictionary<NodeId,     │
│   (ScreenX, ScreenY)>   │
└─────────────────────────┘
```

---

## 4. Ability Tree View Component

### 4.1 AbilityTreeView Class

**Purpose:** Renders the complete ability tree display with header, tier columns, and node placeholders.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/UI/AbilityTreeView.cs`

```csharp
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Presentation.Tui.Renderers;
using RuneAndRust.Presentation.Tui.Services;
using RuneAndRust.Presentation.Tui.DTOs;

namespace RuneAndRust.Presentation.Tui.UI;

/// <summary>
/// Renders the ability tree visualization showing hierarchical nodes
/// organized by tiers in a column-based layout.
/// </summary>
/// <remarks>
/// The ability tree view displays the tree structure with clear tier
/// separation. Node states, prerequisite lines, and tooltips are handled
/// by separate components (v0.13.2b-d).
/// </remarks>
public class AbilityTreeView
{
    private readonly TreeLayoutRenderer _renderer;
    private readonly ITerminalService _terminalService;
    private readonly AbilityTreeDisplayConfig _config;
    private readonly ILogger<AbilityTreeView> _logger;

    private TreeDisplayDto? _currentTree;
    private Dictionary<string, NodeScreenPosition> _nodePositions = new();
    private (int TierIndex, int NodeIndex) _selectedPosition;

    /// <summary>
    /// Creates a new instance of the AbilityTreeView.
    /// </summary>
    /// <param name="renderer">The renderer for layout calculations.</param>
    /// <param name="terminalService">The terminal output service.</param>
    /// <param name="config">Configuration for display settings.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    public AbilityTreeView(
        TreeLayoutRenderer renderer,
        ITerminalService terminalService,
        AbilityTreeDisplayConfig config,
        ILogger<AbilityTreeView> logger)
    {
        _renderer = renderer ?? throw new ArgumentNullException(nameof(renderer));
        _terminalService = terminalService ?? throw new ArgumentNullException(nameof(terminalService));
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Renders the complete ability tree display.
    /// </summary>
    /// <param name="treeDto">The tree display data.</param>
    public void RenderTree(TreeDisplayDto treeDto)
    {
        _currentTree = treeDto ?? throw new ArgumentNullException(nameof(treeDto));

        _logger.LogDebug(
            "Rendering ability tree '{TreeName}' with {TierCount} tiers",
            treeDto.TreeName,
            treeDto.Tiers.Count);

        // Clear previous display
        ClearTreeArea();

        // Render tree border and header
        RenderTreeBorder();
        SetTreeHeader(treeDto.TreeName);

        // Calculate node positions
        _nodePositions = _renderer.CalculateNodePositions(treeDto);

        // Render tier columns
        RenderTiers(treeDto.Tiers);

        // Render branch headers if multiple branches
        if (treeDto.Branches.Count > 1)
        {
            RenderBranchHeaders(treeDto.Branches);
        }
    }

    /// <summary>
    /// Renders the tier columns with their labels and nodes.
    /// </summary>
    /// <param name="tiers">The tier display data collection.</param>
    public void RenderTiers(IReadOnlyList<TierDisplayDto> tiers)
    {
        foreach (var tier in tiers)
        {
            RenderTierColumn(tier);
        }

        _logger.LogDebug("Rendered {TierCount} tier columns", tiers.Count);
    }

    /// <summary>
    /// Sets the tree header with the tree name.
    /// </summary>
    /// <param name="treeName">The display name of the ability tree.</param>
    public void SetTreeHeader(string treeName)
    {
        var header = _renderer.FormatTreeHeader(treeName, _config.TotalWidth);

        _terminalService.WriteColoredAt(
            _config.StartX,
            _config.StartY + 1,
            header,
            _config.Colors.HeaderColor);

        _logger.LogDebug("Set tree header: {TreeName}", treeName);
    }

    /// <summary>
    /// Handles keyboard navigation selection within the tree.
    /// </summary>
    /// <param name="tierIndex">The tier column index (0-based).</param>
    /// <param name="nodeIndex">The node index within the tier (0-based).</param>
    public void HandleSelection(int tierIndex, int nodeIndex)
    {
        if (_currentTree == null)
        {
            _logger.LogWarning("Cannot handle selection - no tree rendered");
            return;
        }

        // Validate selection bounds
        if (tierIndex < 0 || tierIndex >= _currentTree.Tiers.Count)
        {
            _logger.LogDebug("Selection tier index {TierIndex} out of bounds", tierIndex);
            return;
        }

        var tier = _currentTree.Tiers[tierIndex];
        if (nodeIndex < 0 || nodeIndex >= tier.Nodes.Count)
        {
            _logger.LogDebug("Selection node index {NodeIndex} out of bounds for tier {TierIndex}", nodeIndex, tierIndex);
            return;
        }

        // Update selection
        var previousSelection = _selectedPosition;
        _selectedPosition = (tierIndex, nodeIndex);

        // Redraw previous selection (unhighlighted)
        if (previousSelection != _selectedPosition)
        {
            RedrawNodeAtPosition(previousSelection.TierIndex, previousSelection.NodeIndex, false);
        }

        // Draw new selection (highlighted)
        RedrawNodeAtPosition(tierIndex, nodeIndex, true);

        _logger.LogDebug("Selection moved to tier {TierIndex}, node {NodeIndex}", tierIndex, nodeIndex);
    }

    /// <summary>
    /// Gets the currently selected node ID.
    /// </summary>
    /// <returns>The node ID of the selected node, or null if none selected.</returns>
    public string? GetSelectedNodeId()
    {
        if (_currentTree == null) return null;
        if (_selectedPosition.TierIndex >= _currentTree.Tiers.Count) return null;

        var tier = _currentTree.Tiers[_selectedPosition.TierIndex];
        if (_selectedPosition.NodeIndex >= tier.Nodes.Count) return null;

        return tier.Nodes[_selectedPosition.NodeIndex].NodeId;
    }

    /// <summary>
    /// Clears the ability tree display from the terminal.
    /// </summary>
    public void Clear()
    {
        _currentTree = null;
        _nodePositions.Clear();
        _selectedPosition = (0, 0);

        ClearTreeArea();

        _logger.LogDebug("Cleared ability tree display");
    }

    #region Private Rendering Methods

    private void ClearTreeArea()
    {
        var clearLine = new string(' ', _config.TotalWidth);
        for (var row = 0; row < _config.TotalHeight; row++)
        {
            _terminalService.WriteAt(_config.StartX, _config.StartY + row, clearLine);
        }
    }

    private void RenderTreeBorder()
    {
        var topBorder = "┌" + new string('─', _config.TotalWidth - 2) + "┐";
        var bottomBorder = "└" + new string('─', _config.TotalWidth - 2) + "┘";
        var divider = "├" + new string('─', _config.TotalWidth - 2) + "┤";

        _terminalService.WriteColoredAt(
            _config.StartX,
            _config.StartY,
            topBorder,
            _config.Colors.BorderColor);

        _terminalService.WriteColoredAt(
            _config.StartX,
            _config.StartY + 2,
            divider,
            _config.Colors.BorderColor);

        _terminalService.WriteColoredAt(
            _config.StartX,
            _config.StartY + _config.TotalHeight - 1,
            bottomBorder,
            _config.Colors.BorderColor);

        // Side borders
        for (var row = 1; row < _config.TotalHeight - 1; row++)
        {
            _terminalService.WriteColoredAt(_config.StartX, _config.StartY + row, "│", _config.Colors.BorderColor);
            _terminalService.WriteColoredAt(_config.StartX + _config.TotalWidth - 1, _config.StartY + row, "│", _config.Colors.BorderColor);
        }
    }

    private void RenderTierColumn(TierDisplayDto tier)
    {
        var tierX = CalculateTierColumnX(tier.TierNumber);
        var tierLabelY = _config.StartY + _config.TierLabelRow;

        // Render tier label
        var tierLabel = _renderer.GetTierLabel(tier.TierNumber);
        _terminalService.WriteColoredAt(tierX, tierLabelY, tierLabel, _config.Colors.TierLabelColor);

        // Render underline
        var underline = new string('─', tierLabel.Length);
        _terminalService.WriteAt(tierX, tierLabelY + 1, underline);

        // Render nodes in this tier
        foreach (var node in tier.Nodes)
        {
            RenderNodePlaceholder(node, tier.TierNumber);
        }
    }

    private void RenderNodePlaceholder(NodeLayoutDto node, int tierNumber)
    {
        if (!_nodePositions.TryGetValue(node.NodeId, out var screenPos))
        {
            _logger.LogWarning("No screen position calculated for node {NodeId}", node.NodeId);
            return;
        }

        var nodeBox = _renderer.FormatNodeBox(node, _config.NodeWidth, _config.NodeHeight);
        var lines = nodeBox.Split('\n');

        for (var i = 0; i < lines.Length; i++)
        {
            _terminalService.WriteColoredAt(
                screenPos.X,
                screenPos.Y + i,
                lines[i],
                _config.Colors.NodeBorderColor);
        }
    }

    private void RenderBranchHeaders(IReadOnlyList<BranchDisplayDto> branches)
    {
        // Branch headers are rendered as tabs at the top of each branch's node column
        // This is optional visual enhancement for multi-branch trees
        var branchY = _config.StartY + _config.BranchHeaderRow;

        foreach (var branch in branches)
        {
            var branchX = CalculateBranchHeaderX(branch);
            var branchHeader = _renderer.FormatBranchHeader(branch.BranchName);

            _terminalService.WriteColoredAt(
                branchX,
                branchY,
                branchHeader,
                _config.Colors.BranchHeaderColor);
        }
    }

    private void RedrawNodeAtPosition(int tierIndex, int nodeIndex, bool highlighted)
    {
        if (_currentTree == null) return;
        if (tierIndex >= _currentTree.Tiers.Count) return;

        var tier = _currentTree.Tiers[tierIndex];
        if (nodeIndex >= tier.Nodes.Count) return;

        var node = tier.Nodes[nodeIndex];
        if (!_nodePositions.TryGetValue(node.NodeId, out var screenPos)) return;

        var color = highlighted
            ? _config.Colors.SelectedNodeColor
            : _config.Colors.NodeBorderColor;

        var nodeBox = _renderer.FormatNodeBox(node, _config.NodeWidth, _config.NodeHeight);
        var lines = nodeBox.Split('\n');

        for (var i = 0; i < lines.Length; i++)
        {
            _terminalService.WriteColoredAt(screenPos.X, screenPos.Y + i, lines[i], color);
        }
    }

    private int CalculateTierColumnX(int tierNumber)
    {
        // Tier 1 starts at StartX + Padding
        // Each subsequent tier adds NodeWidth + ColumnSpacing
        return _config.StartX +
               _config.Padding +
               ((tierNumber - 1) * (_config.NodeWidth + _config.ColumnSpacing));
    }

    private int CalculateBranchHeaderX(BranchDisplayDto branch)
    {
        // Branch header X is based on the first node of the branch
        // Default to start position if no nodes
        return _config.StartX + _config.Padding;
    }

    #endregion
}
```

### 4.2 Tree Header Rendering

**Purpose:** Display the ability tree name prominently at the top of the display.

The tree header is centered within the display area and uses decorative formatting:

**Header Format:**

```
┌─────────────────────────────────────────────────────────────────────┐
│                      WARRIOR ABILITY TREE                           │
├─────────────────────────────────────────────────────────────────────┤
```

**Header Formatting Algorithm:**

```csharp
/// <summary>
/// Formats the tree name as a centered header.
/// </summary>
/// <param name="treeName">The tree display name.</param>
/// <param name="totalWidth">The total display width.</param>
/// <returns>A centered tree name header.</returns>
/// <remarks>
/// The header converts the tree name to uppercase for emphasis.
/// Example: "Warrior Ability Tree" becomes "WARRIOR ABILITY TREE"
/// </remarks>
public string FormatTreeHeader(string treeName, int totalWidth)
{
    var upperName = treeName.ToUpperInvariant();
    var availableWidth = totalWidth - 4; // Account for border characters

    if (upperName.Length > availableWidth)
    {
        upperName = upperName.Substring(0, availableWidth);
    }

    var padding = (availableWidth - upperName.Length) / 2;
    return upperName.PadLeft(padding + upperName.Length).PadRight(availableWidth);
}
```

### 4.3 Tier Column Layout

**Purpose:** Organize nodes into vertical columns by tier with clear labels.

Each tier is displayed as a column with:
1. Tier label at top (e.g., "TIER 1")
2. Underline separator
3. Nodes arranged vertically by their Y position

**Tier Layout Example:**

```
  TIER 1                    TIER 2                    TIER 3
  ──────                    ──────                    ──────

  ┌─────────┐              ┌─────────┐              ┌─────────┐
  │  Power  │              │  Cleave │              │  Whirl  │
  │  Strike │              │         │              │   wind  │
  └─────────┘              └─────────┘              └─────────┘

  ┌─────────┐              ┌─────────┐              ┌─────────┐
  │  Iron   │              │  Shield │              │  Last   │
  │   Skin  │              │   Bash  │              │  Stand  │
  └─────────┘              └─────────┘              └─────────┘
```

**Column Spacing Calculation:**

```csharp
/// <summary>
/// Calculates the X coordinate for a tier column.
/// </summary>
/// <param name="tierNumber">The tier number (1-based).</param>
/// <param name="config">The display configuration.</param>
/// <returns>The X coordinate for the tier column.</returns>
/// <remarks>
/// Tiers are evenly spaced across the display width.
/// Tier 1 starts at StartX + Padding.
/// Each tier adds NodeWidth + ColumnSpacing.
/// </remarks>
public static int CalculateTierColumnX(int tierNumber, AbilityTreeDisplayConfig config)
{
    return config.StartX +
           config.Padding +
           ((tierNumber - 1) * (config.NodeWidth + config.ColumnSpacing));
}
```

---

## 5. Tree Layout Renderer

### 5.1 TreeLayoutRenderer Class

**Purpose:** Handles all layout calculations and text formatting for the ability tree.

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Renderers/TreeLayoutRenderer.cs`

```csharp
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Presentation.Tui.DTOs;

namespace RuneAndRust.Presentation.Tui.Renderers;

/// <summary>
/// Handles layout calculations and text formatting for ability tree display.
/// </summary>
/// <remarks>
/// This renderer calculates node positions based on the tree definition
/// and formats visual elements like tier labels and node boxes.
/// </remarks>
public class TreeLayoutRenderer
{
    private readonly AbilityTreeDisplayConfig _config;

    /// <summary>
    /// Creates a new instance of the TreeLayoutRenderer.
    /// </summary>
    /// <param name="config">Configuration for display settings.</param>
    public TreeLayoutRenderer(AbilityTreeDisplayConfig config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Calculates screen positions for all nodes in the tree.
    /// </summary>
    /// <param name="treeDto">The tree display data.</param>
    /// <returns>A dictionary mapping node IDs to screen positions.</returns>
    public Dictionary<string, NodeScreenPosition> CalculateNodePositions(TreeDisplayDto treeDto)
    {
        var positions = new Dictionary<string, NodeScreenPosition>();

        foreach (var tier in treeDto.Tiers)
        {
            var tierX = CalculateTierColumnX(tier.TierNumber);

            // Sort nodes by their Y position from the definition
            var sortedNodes = tier.Nodes.OrderBy(n => n.DefinitionY).ToList();

            for (var i = 0; i < sortedNodes.Count; i++)
            {
                var node = sortedNodes[i];
                var nodeY = CalculateNodeY(i);

                positions[node.NodeId] = new NodeScreenPosition(tierX, nodeY);
            }
        }

        return positions;
    }

    /// <summary>
    /// Renders a tier column and returns the formatted string.
    /// </summary>
    /// <param name="tier">The tier display data.</param>
    /// <returns>The formatted tier column string.</returns>
    public string RenderTierColumn(TierDisplayDto tier)
    {
        var lines = new List<string>();

        // Tier label
        lines.Add(GetTierLabel(tier.TierNumber));
        lines.Add(new string('─', GetTierLabel(tier.TierNumber).Length));
        lines.Add(string.Empty);

        // Nodes
        foreach (var node in tier.Nodes.OrderBy(n => n.DefinitionY))
        {
            var nodeBox = FormatNodeBox(node, _config.NodeWidth, _config.NodeHeight);
            lines.AddRange(nodeBox.Split('\n'));
            lines.Add(string.Empty); // Spacing between nodes
        }

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Gets the formatted tier label.
    /// </summary>
    /// <param name="tierNumber">The tier number (1-based).</param>
    /// <returns>The formatted tier label string.</returns>
    public string GetTierLabel(int tierNumber)
    {
        return $"TIER {tierNumber}";
    }

    /// <summary>
    /// Calculates the total width of the tree display.
    /// </summary>
    /// <param name="maxTier">The maximum tier number in the tree.</param>
    /// <returns>The total width in characters.</returns>
    public int GetTreeWidth(int maxTier)
    {
        // Width = Padding + (Tiers * NodeWidth) + ((Tiers - 1) * ColumnSpacing) + Padding
        return (_config.Padding * 2) +
               (maxTier * _config.NodeWidth) +
               ((maxTier - 1) * _config.ColumnSpacing);
    }

    /// <summary>
    /// Formats a node box with the node name.
    /// </summary>
    /// <param name="node">The node layout data.</param>
    /// <param name="width">The box width.</param>
    /// <param name="height">The box height (typically 3 lines).</param>
    /// <returns>The formatted node box string.</returns>
    public string FormatNodeBox(NodeLayoutDto node, int width, int height)
    {
        var innerWidth = width - 2; // Account for borders

        var topBorder = $"┌{new string('─', innerWidth)}┐";
        var bottomBorder = $"└{new string('─', innerWidth)}┘";

        // Split name across multiple lines if needed
        var nameLines = SplitNodeName(node.NodeName, innerWidth - 2);
        var contentLines = new List<string>();

        // Pad to fill height (height - 2 for borders)
        var contentHeight = height - 2;
        var paddingLines = contentHeight - nameLines.Count;
        var topPadding = paddingLines / 2;
        var bottomPadding = paddingLines - topPadding;

        for (var i = 0; i < topPadding; i++)
        {
            contentLines.Add(FormatContentLine(string.Empty, innerWidth));
        }

        foreach (var nameLine in nameLines)
        {
            contentLines.Add(FormatContentLine(nameLine, innerWidth));
        }

        for (var i = 0; i < bottomPadding; i++)
        {
            contentLines.Add(FormatContentLine(string.Empty, innerWidth));
        }

        var lines = new List<string> { topBorder };
        lines.AddRange(contentLines);
        lines.Add(bottomBorder);

        return string.Join("\n", lines);
    }

    /// <summary>
    /// Formats the tree header with the tree name.
    /// </summary>
    /// <param name="treeName">The tree display name.</param>
    /// <param name="totalWidth">The total display width.</param>
    /// <returns>The formatted header string.</returns>
    public string FormatTreeHeader(string treeName, int totalWidth)
    {
        var upperName = treeName.ToUpperInvariant();
        var availableWidth = totalWidth - 4;

        if (upperName.Length > availableWidth)
        {
            upperName = upperName.Substring(0, availableWidth);
        }

        var padding = (availableWidth - upperName.Length) / 2;
        return upperName.PadLeft(padding + upperName.Length).PadRight(availableWidth);
    }

    /// <summary>
    /// Formats a branch header.
    /// </summary>
    /// <param name="branchName">The branch display name.</param>
    /// <returns>The formatted branch header string.</returns>
    public string FormatBranchHeader(string branchName)
    {
        return $"[ {branchName.ToUpperInvariant()} ]";
    }

    #region Private Helper Methods

    private int CalculateTierColumnX(int tierNumber)
    {
        return _config.StartX +
               _config.Padding +
               ((tierNumber - 1) * (_config.NodeWidth + _config.ColumnSpacing));
    }

    private int CalculateNodeY(int nodeIndex)
    {
        // Start after header, tier label, and spacing
        var baseY = _config.StartY + _config.NodeAreaStartRow;
        return baseY + (nodeIndex * (_config.NodeHeight + _config.NodeVerticalSpacing));
    }

    private static List<string> SplitNodeName(string name, int maxWidth)
    {
        var lines = new List<string>();

        if (name.Length <= maxWidth)
        {
            lines.Add(name);
            return lines;
        }

        // Try to split at spaces
        var words = name.Split(' ');
        var currentLine = string.Empty;

        foreach (var word in words)
        {
            if (string.IsNullOrEmpty(currentLine))
            {
                currentLine = word;
            }
            else if (currentLine.Length + 1 + word.Length <= maxWidth)
            {
                currentLine += " " + word;
            }
            else
            {
                lines.Add(currentLine);
                currentLine = word;
            }
        }

        if (!string.IsNullOrEmpty(currentLine))
        {
            lines.Add(currentLine);
        }

        return lines;
    }

    private static string FormatContentLine(string content, int width)
    {
        var centeredContent = content.Length >= width
            ? content.Substring(0, width)
            : content.PadLeft((width + content.Length) / 2).PadRight(width);

        return $"│{centeredContent}│";
    }

    #endregion
}
```

### 5.2 Node Position Calculation

**Purpose:** Calculate screen coordinates for each node based on tier and definition position.

The position calculation uses:
1. **Tier** to determine X column position
2. **Definition Y** to determine vertical ordering within the tier
3. **Node index** after sorting to calculate actual screen Y

**Position Algorithm:**

```csharp
/// <summary>
/// Calculates screen coordinates for a node.
/// </summary>
/// <param name="tierNumber">The tier number (1-based).</param>
/// <param name="sortedIndex">The node's index after sorting by definition Y.</param>
/// <param name="config">The display configuration.</param>
/// <returns>The screen position (X, Y) for the node.</returns>
public static NodeScreenPosition CalculateNodePosition(
    int tierNumber,
    int sortedIndex,
    AbilityTreeDisplayConfig config)
{
    // X = StartX + Padding + ((Tier - 1) * (NodeWidth + ColumnSpacing))
    var x = config.StartX +
            config.Padding +
            ((tierNumber - 1) * (config.NodeWidth + config.ColumnSpacing));

    // Y = StartY + HeaderHeight + TierLabelHeight + (Index * (NodeHeight + Spacing))
    var y = config.StartY +
            config.NodeAreaStartRow +
            (sortedIndex * (config.NodeHeight + config.NodeVerticalSpacing));

    return new NodeScreenPosition(x, y);
}
```

### 5.3 Tier Column Rendering

**Purpose:** Render a single tier column with its label and nodes.

Each tier column contains:
1. Tier label (e.g., "TIER 1")
2. Underline separator
3. Vertically stacked node boxes

**Tier Column Example:**

```
TIER 2
──────

┌─────────┐
│  Cleave │
│         │
└─────────┘

┌─────────┐
│  Shield │
│   Bash  │
└─────────┘

┌─────────┐
│   War   │
│   Cry   │
└─────────┘
```

---

## 6. Branch Display

### 6.1 Branch Organization

**Purpose:** Visually group nodes by their specialization branch within tiers.

Ability trees can have multiple branches (e.g., "Berserker", "Guardian", "Champion" for Warrior). Nodes within each branch share a common theme and progression path.

**Branch Structure:**

```
AbilityTreeDefinition
├── Branch: Berserker (Offense)
│   ├── Tier 1: Frenzy, Bloodlust
│   ├── Tier 2: Rage, Berserker Stance
│   └── Tier 3: Rampage
├── Branch: Guardian (Defense)
│   ├── Tier 1: Iron Skin, Shield Wall
│   ├── Tier 2: Fortify, Taunt
│   └── Tier 3: Last Stand
└── Branch: Champion (Support)
    ├── Tier 1: Battle Cry
    ├── Tier 2: War Cry, Inspiring Presence
    └── Tier 3: Rally
```

**Branch Display Rules:**
- Branches are organized vertically within each tier column
- Branch nodes appear in sequence by their definition Y position
- Branch headers appear when multiple branches exist
- Single-branch trees do not display branch headers

### 6.2 Branch Header Rendering

**Purpose:** Display branch names to help identify node groupings.

Branch headers appear above nodes belonging to that branch:

**Branch Header Format:**

```
[ BERSERKER ]

┌─────────┐
│ Frenzy  │
│         │
└─────────┘

┌─────────┐
│Bloodlust│
│         │
└─────────┘

[ GUARDIAN ]

┌─────────┐
│  Iron   │
│   Skin  │
└─────────┘
```

**Branch Header Configuration:**
- Only displayed for trees with 2+ branches
- Uses bracket notation: `[ BRANCH NAME ]`
- Displayed in uppercase
- Positioned above first node of each branch in the tier

---

## 7. Data Model Changes

### 7.1 New DTOs

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/DTOs/AbilityTreeDtos.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.DTOs;

/// <summary>
/// Data transfer object for complete ability tree display.
/// </summary>
/// <param name="TreeId">The unique tree identifier.</param>
/// <param name="TreeName">The display name of the tree.</param>
/// <param name="ClassId">The associated character class.</param>
/// <param name="Tiers">The tier display data collection.</param>
/// <param name="Branches">The branch display data collection.</param>
/// <param name="MaxTier">The maximum tier number in the tree.</param>
public record TreeDisplayDto(
    string TreeId,
    string TreeName,
    string ClassId,
    IReadOnlyList<TierDisplayDto> Tiers,
    IReadOnlyList<BranchDisplayDto> Branches,
    int MaxTier);

/// <summary>
/// Data transfer object for a single tier column display.
/// </summary>
/// <param name="TierNumber">The tier number (1-based).</param>
/// <param name="TierLabel">The display label (e.g., "TIER 1").</param>
/// <param name="Nodes">The nodes in this tier.</param>
public record TierDisplayDto(
    int TierNumber,
    string TierLabel,
    IReadOnlyList<NodeLayoutDto> Nodes);

/// <summary>
/// Data transfer object for node layout information.
/// </summary>
/// <param name="NodeId">The unique node identifier.</param>
/// <param name="NodeName">The display name of the node.</param>
/// <param name="Tier">The tier number (1-based).</param>
/// <param name="DefinitionX">The X position from the definition.</param>
/// <param name="DefinitionY">The Y position from the definition.</param>
/// <param name="BranchId">The branch this node belongs to.</param>
public record NodeLayoutDto(
    string NodeId,
    string NodeName,
    int Tier,
    int DefinitionX,
    int DefinitionY,
    string BranchId);

/// <summary>
/// Data transfer object for branch display information.
/// </summary>
/// <param name="BranchId">The unique branch identifier.</param>
/// <param name="BranchName">The display name of the branch.</param>
/// <param name="Description">The branch description.</param>
/// <param name="NodeCount">The number of nodes in this branch.</param>
public record BranchDisplayDto(
    string BranchId,
    string BranchName,
    string Description,
    int NodeCount);

/// <summary>
/// Represents a calculated screen position for a node.
/// </summary>
/// <param name="X">The X coordinate on screen.</param>
/// <param name="Y">The Y coordinate on screen.</param>
public record NodeScreenPosition(int X, int Y);
```

### 7.2 Configuration Classes

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/AbilityTreeDisplayConfig.cs`

```csharp
namespace RuneAndRust.Presentation.Tui.Configuration;

/// <summary>
/// Configuration for ability tree display settings.
/// </summary>
public class AbilityTreeDisplayConfig
{
    /// <summary>
    /// The total width of the display area.
    /// </summary>
    public int TotalWidth { get; set; } = 72;

    /// <summary>
    /// The total height of the display area in rows.
    /// </summary>
    public int TotalHeight { get; set; } = 24;

    /// <summary>
    /// Starting X coordinate for the display.
    /// </summary>
    public int StartX { get; set; } = 0;

    /// <summary>
    /// Starting Y coordinate for the display.
    /// </summary>
    public int StartY { get; set; } = 0;

    /// <summary>
    /// Padding from the border to content.
    /// </summary>
    public int Padding { get; set; } = 2;

    /// <summary>
    /// Row offset for the tier labels (from StartY).
    /// </summary>
    public int TierLabelRow { get; set; } = 4;

    /// <summary>
    /// Row offset for branch headers (from StartY).
    /// </summary>
    public int BranchHeaderRow { get; set; } = 3;

    /// <summary>
    /// Row offset where node area begins (from StartY).
    /// </summary>
    public int NodeAreaStartRow { get; set; } = 7;

    /// <summary>
    /// Width of each node box.
    /// </summary>
    public int NodeWidth { get; set; } = 11;

    /// <summary>
    /// Height of each node box.
    /// </summary>
    public int NodeHeight { get; set; } = 3;

    /// <summary>
    /// Horizontal spacing between tier columns.
    /// </summary>
    public int ColumnSpacing { get; set; } = 8;

    /// <summary>
    /// Vertical spacing between nodes in the same tier.
    /// </summary>
    public int NodeVerticalSpacing { get; set; } = 1;

    /// <summary>
    /// Maximum number of tiers to display before scrolling.
    /// </summary>
    public int MaxVisibleTiers { get; set; } = 4;

    /// <summary>
    /// Maximum number of nodes per tier before scrolling.
    /// </summary>
    public int MaxNodesPerTier { get; set; } = 4;

    /// <summary>
    /// Color configuration for the tree display.
    /// </summary>
    public AbilityTreeColors Colors { get; set; } = new();
}

/// <summary>
/// Color configuration for ability tree elements.
/// </summary>
public class AbilityTreeColors
{
    /// <summary>Color for the tree border.</summary>
    public ConsoleColor BorderColor { get; set; } = ConsoleColor.DarkGray;

    /// <summary>Color for the tree header text.</summary>
    public ConsoleColor HeaderColor { get; set; } = ConsoleColor.Cyan;

    /// <summary>Color for tier labels.</summary>
    public ConsoleColor TierLabelColor { get; set; } = ConsoleColor.Yellow;

    /// <summary>Color for branch headers.</summary>
    public ConsoleColor BranchHeaderColor { get; set; } = ConsoleColor.Magenta;

    /// <summary>Color for node borders.</summary>
    public ConsoleColor NodeBorderColor { get; set; } = ConsoleColor.Gray;

    /// <summary>Color for selected node borders.</summary>
    public ConsoleColor SelectedNodeColor { get; set; } = ConsoleColor.White;

    /// <summary>Default text color.</summary>
    public ConsoleColor DefaultColor { get; set; } = ConsoleColor.Gray;
}
```

---

## 8. Configuration File Schemas

### 8.1 ability-tree-display.json

**File:** `config/ability-tree-display.json`

```json
{
  "$schema": "./schemas/ability-tree-display.schema.json",
  "totalWidth": 72,
  "totalHeight": 24,
  "startX": 0,
  "startY": 0,
  "padding": 2,
  "tierLabelRow": 4,
  "branchHeaderRow": 3,
  "nodeAreaStartRow": 7,
  "nodeWidth": 11,
  "nodeHeight": 3,
  "columnSpacing": 8,
  "nodeVerticalSpacing": 1,
  "maxVisibleTiers": 4,
  "maxNodesPerTier": 4,
  "colors": {
    "borderColor": "DarkGray",
    "headerColor": "Cyan",
    "tierLabelColor": "Yellow",
    "branchHeaderColor": "Magenta",
    "nodeBorderColor": "Gray",
    "selectedNodeColor": "White",
    "defaultColor": "Gray"
  }
}
```

### 8.2 ability-tree-display.schema.json

**File:** `config/schemas/ability-tree-display.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "ability-tree-display.schema.json",
  "title": "Ability Tree Display Configuration",
  "description": "Configuration for ability tree visualization in character UI",
  "type": "object",
  "properties": {
    "totalWidth": {
      "type": "integer",
      "description": "Total width of the display area",
      "minimum": 40,
      "maximum": 150,
      "default": 72
    },
    "totalHeight": {
      "type": "integer",
      "description": "Total height of the display area in rows",
      "minimum": 15,
      "maximum": 50,
      "default": 24
    },
    "startX": {
      "type": "integer",
      "description": "Starting X coordinate",
      "minimum": 0,
      "default": 0
    },
    "startY": {
      "type": "integer",
      "description": "Starting Y coordinate",
      "minimum": 0,
      "default": 0
    },
    "padding": {
      "type": "integer",
      "description": "Padding from border to content",
      "minimum": 0,
      "maximum": 10,
      "default": 2
    },
    "tierLabelRow": {
      "type": "integer",
      "description": "Row offset for tier labels",
      "minimum": 2,
      "maximum": 10,
      "default": 4
    },
    "branchHeaderRow": {
      "type": "integer",
      "description": "Row offset for branch headers",
      "minimum": 2,
      "maximum": 10,
      "default": 3
    },
    "nodeAreaStartRow": {
      "type": "integer",
      "description": "Row offset where node area begins",
      "minimum": 5,
      "maximum": 15,
      "default": 7
    },
    "nodeWidth": {
      "type": "integer",
      "description": "Width of each node box",
      "minimum": 7,
      "maximum": 20,
      "default": 11
    },
    "nodeHeight": {
      "type": "integer",
      "description": "Height of each node box",
      "minimum": 3,
      "maximum": 7,
      "default": 3
    },
    "columnSpacing": {
      "type": "integer",
      "description": "Horizontal spacing between tier columns",
      "minimum": 2,
      "maximum": 20,
      "default": 8
    },
    "nodeVerticalSpacing": {
      "type": "integer",
      "description": "Vertical spacing between nodes",
      "minimum": 0,
      "maximum": 5,
      "default": 1
    },
    "maxVisibleTiers": {
      "type": "integer",
      "description": "Maximum tiers visible before scrolling",
      "minimum": 2,
      "maximum": 8,
      "default": 4
    },
    "maxNodesPerTier": {
      "type": "integer",
      "description": "Maximum nodes per tier before scrolling",
      "minimum": 2,
      "maximum": 10,
      "default": 4
    },
    "colors": {
      "type": "object",
      "description": "Color configuration",
      "properties": {
        "borderColor": { "$ref": "#/$defs/consoleColor", "default": "DarkGray" },
        "headerColor": { "$ref": "#/$defs/consoleColor", "default": "Cyan" },
        "tierLabelColor": { "$ref": "#/$defs/consoleColor", "default": "Yellow" },
        "branchHeaderColor": { "$ref": "#/$defs/consoleColor", "default": "Magenta" },
        "nodeBorderColor": { "$ref": "#/$defs/consoleColor", "default": "Gray" },
        "selectedNodeColor": { "$ref": "#/$defs/consoleColor", "default": "White" },
        "defaultColor": { "$ref": "#/$defs/consoleColor", "default": "Gray" }
      },
      "additionalProperties": false
    }
  },
  "$defs": {
    "consoleColor": {
      "type": "string",
      "enum": [
        "Black", "DarkBlue", "DarkGreen", "DarkCyan",
        "DarkRed", "DarkMagenta", "DarkYellow", "Gray",
        "DarkGray", "Blue", "Green", "Cyan",
        "Red", "Magenta", "Yellow", "White"
      ]
    }
  },
  "additionalProperties": false
}
```

---

## 9. CharacterView Integration

### 9.1 Integration Points

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/CharacterView.cs` (modifications)

```csharp
// Add to CharacterView class

private readonly AbilityTreeView _abilityTreeView;
private readonly IAbilityTreeProvider _abilityTreeProvider;

/// <summary>
/// Initializes ability tree UI when the ability tree tab is selected.
/// </summary>
private void HandleAbilityTreeTab()
{
    var player = _gameState.CurrentPlayer;
    if (player == null)
    {
        _logger.LogWarning("Cannot show ability tree - no current player");
        return;
    }

    var tree = _abilityTreeProvider.GetTreeForClass(player.ClassId);
    if (tree == null)
    {
        _logger.LogWarning("No ability tree found for class {ClassId}", player.ClassId);
        return;
    }

    // Create tree display DTO
    var treeDto = CreateTreeDisplayDto(tree);

    // Render the ability tree
    _abilityTreeView.RenderTree(treeDto);

    _logger.LogDebug("Rendered ability tree for class {ClassId}", player.ClassId);
}

/// <summary>
/// Creates a tree display DTO from the domain definition.
/// </summary>
private TreeDisplayDto CreateTreeDisplayDto(AbilityTreeDefinition definition)
{
    var maxTier = definition.GetMaxTier();

    // Create tier DTOs
    var tierDtos = new List<TierDisplayDto>();
    for (var tier = 1; tier <= maxTier; tier++)
    {
        var tierNodes = definition.GetNodesAtTier(tier)
            .Select(n => CreateNodeLayoutDto(n, GetBranchForNode(definition, n)))
            .ToList();

        tierDtos.Add(new TierDisplayDto(
            TierNumber: tier,
            TierLabel: $"TIER {tier}",
            Nodes: tierNodes));
    }

    // Create branch DTOs
    var branchDtos = definition.Branches
        .Select(b => new BranchDisplayDto(
            BranchId: b.BranchId,
            BranchName: b.Name,
            Description: b.Description,
            NodeCount: b.Nodes.Count))
        .ToList();

    return new TreeDisplayDto(
        TreeId: definition.TreeId,
        TreeName: $"{definition.Name} ABILITY TREE",
        ClassId: definition.ClassId,
        Tiers: tierDtos,
        Branches: branchDtos,
        MaxTier: maxTier);
}

/// <summary>
/// Creates a node layout DTO from the domain node.
/// </summary>
private NodeLayoutDto CreateNodeLayoutDto(AbilityTreeNode node, string branchId)
{
    return new NodeLayoutDto(
        NodeId: node.NodeId,
        NodeName: node.Name,
        Tier: node.Tier,
        DefinitionX: node.Position.X,
        DefinitionY: node.Position.Y,
        BranchId: branchId);
}

/// <summary>
/// Finds the branch ID for a given node.
/// </summary>
private string GetBranchForNode(AbilityTreeDefinition definition, AbilityTreeNode node)
{
    var branch = _abilityTreeProvider.GetBranchContainingNode(node.NodeId);
    return branch?.BranchId ?? "default";
}
```

### 9.2 Layout Position

The ability tree view is displayed as a tab within the CharacterView:

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Stats]  [Equipment]  [Abilities]  [Inventory]                      │
├─────────────────────────────────────────────────────────────────────┤
│┌───────────────────────────────────────────────────────────────────┐│
││                      WARRIOR ABILITY TREE                          ││
│├───────────────────────────────────────────────────────────────────┤│
││                                                                    ││
││  TIER 1                    TIER 2                    TIER 3        ││
││  ──────                    ──────                    ──────        ││
││                                                                    ││
││  ┌─────────┐              ┌─────────┐              ┌─────────┐     ││
││  │  Power  │              │  Cleave │              │  Whirl  │     ││
││  │  Strike │              │         │              │   wind  │     ││
││  └─────────┘              └─────────┘              └─────────┘     ││
││                                                                    ││
││  ┌─────────┐              ┌─────────┐              ┌─────────┐     ││
││  │  Iron   │              │  Shield │              │  Last   │     ││
││  │   Skin  │              │   Bash  │              │  Stand  │     ││
││  └─────────┘              └─────────┘              └─────────┘     ││
││                                                                    ││
│└───────────────────────────────────────────────────────────────────┘│
│ Navigation: [←][→] Move between tiers  [↑][↓] Select node           │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 10. Logging Specifications

### 10.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `AbilityTreeView` | Information | Tree display initialized |
| `AbilityTreeView` | Debug | Rendering tree, tiers, selection changes |
| `AbilityTreeView` | Warning | Cannot handle selection - no tree, node position not found |
| `TreeLayoutRenderer` | Debug | Position calculations, layout operations |
| `CharacterView` | Information | Ability tree tab opened |
| `CharacterView` | Debug | Creating DTOs, rendering tree |
| `CharacterView` | Warning | No current player, no tree found |

### 10.2 Log Message Examples

```
[INF] AbilityTreeView: Initialized ability tree display for "Warrior Ability Tree"
[DBG] AbilityTreeView: Rendering ability tree 'Warrior Ability Tree' with 3 tiers
[DBG] AbilityTreeView: Set tree header: WARRIOR ABILITY TREE
[DBG] AbilityTreeView: Rendered 3 tier columns
[DBG] AbilityTreeView: Selection moved to tier 1, node 0
[WRN] AbilityTreeView: No screen position calculated for node frenzy-3
[INF] CharacterView: Ability tree tab opened for class warrior
[DBG] CharacterView: Created tree display DTO with 9 nodes across 3 tiers
[WRN] CharacterView: No ability tree found for class rogue
```

---

## 11. Unit Testing Requirements

### 11.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| TreeLayoutRenderer | ~3 |
| AbilityTreeView | ~2 |
| Position Calculations | ~1 |
| **Total** | **~6** |

### 11.2 Test Specifications

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/Renderers/TreeLayoutRendererTests.cs`

```csharp
[TestFixture]
public class TreeLayoutRendererTests
{
    private TreeLayoutRenderer _renderer;
    private AbilityTreeDisplayConfig _config;

    [SetUp]
    public void Setup()
    {
        _config = new AbilityTreeDisplayConfig();
        _renderer = new TreeLayoutRenderer(_config);
    }

    [Test]
    public void GetTierLabel_WithTierNumber_ReturnsFormattedLabel()
    {
        // Arrange
        var tierNumber = 2;

        // Act
        var result = _renderer.GetTierLabel(tierNumber);

        // Assert
        Assert.That(result, Is.EqualTo("TIER 2"));
    }

    [Test]
    public void FormatTreeHeader_WithTreeName_ReturnsCenteredHeader()
    {
        // Arrange
        var treeName = "Warrior Ability Tree";
        var totalWidth = 60;

        // Act
        var result = _renderer.FormatTreeHeader(treeName, totalWidth);

        // Assert
        Assert.That(result, Does.Contain("WARRIOR ABILITY TREE"));
        Assert.That(result.Length, Is.EqualTo(totalWidth - 4)); // Account for borders
    }

    [Test]
    public void FormatNodeBox_WithNodeName_ReturnsValidBoxStructure()
    {
        // Arrange
        var node = new NodeLayoutDto(
            NodeId: "power-strike",
            NodeName: "Power Strike",
            Tier: 1,
            DefinitionX: 0,
            DefinitionY: 0,
            BranchId: "berserker");

        // Act
        var result = _renderer.FormatNodeBox(node, 11, 3);

        // Assert
        var lines = result.Split('\n');
        Assert.That(lines.Length, Is.EqualTo(3));
        Assert.That(lines[0], Does.StartWith("┌"));
        Assert.That(lines[0], Does.EndWith("┐"));
        Assert.That(lines[2], Does.StartWith("└"));
        Assert.That(lines[2], Does.EndWith("┘"));
    }
}
```

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/UI/AbilityTreeViewTests.cs`

```csharp
[TestFixture]
public class AbilityTreeViewTests
{
    private Mock<TreeLayoutRenderer> _mockRenderer;
    private Mock<ITerminalService> _mockTerminal;
    private Mock<ILogger<AbilityTreeView>> _mockLogger;
    private AbilityTreeDisplayConfig _config;
    private AbilityTreeView _treeView;

    [SetUp]
    public void Setup()
    {
        _config = new AbilityTreeDisplayConfig();
        _mockRenderer = new Mock<TreeLayoutRenderer>(_config);
        _mockTerminal = new Mock<ITerminalService>();
        _mockLogger = new Mock<ILogger<AbilityTreeView>>();

        _treeView = new AbilityTreeView(
            _mockRenderer.Object,
            _mockTerminal.Object,
            _config,
            _mockLogger.Object);
    }

    [Test]
    public void RenderTree_WithValidDto_RendersHeaderAndTiers()
    {
        // Arrange
        var nodes = new List<NodeLayoutDto>
        {
            new("power-strike", "Power Strike", 1, 0, 0, "berserker")
        };

        var tiers = new List<TierDisplayDto>
        {
            new(1, "TIER 1", nodes)
        };

        var dto = new TreeDisplayDto(
            TreeId: "warrior-tree",
            TreeName: "Warrior Ability Tree",
            ClassId: "warrior",
            Tiers: tiers,
            Branches: new List<BranchDisplayDto>(),
            MaxTier: 1);

        _mockRenderer.Setup(r => r.FormatTreeHeader(It.IsAny<string>(), It.IsAny<int>()))
            .Returns("WARRIOR ABILITY TREE");
        _mockRenderer.Setup(r => r.CalculateNodePositions(It.IsAny<TreeDisplayDto>()))
            .Returns(new Dictionary<string, NodeScreenPosition> { { "power-strike", new(10, 10) } });
        _mockRenderer.Setup(r => r.GetTierLabel(It.IsAny<int>())).Returns("TIER 1");
        _mockRenderer.Setup(r => r.FormatNodeBox(It.IsAny<NodeLayoutDto>(), It.IsAny<int>(), It.IsAny<int>()))
            .Returns("┌─────────┐\n│  Node   │\n└─────────┘");

        // Act
        _treeView.RenderTree(dto);

        // Assert
        _mockTerminal.Verify(t => t.WriteColoredAt(
            It.IsAny<int>(), It.IsAny<int>(),
            It.Is<string>(s => s.Contains("WARRIOR ABILITY TREE")),
            _config.Colors.HeaderColor), Times.Once);
    }

    [Test]
    public void HandleSelection_WithValidPosition_UpdatesSelection()
    {
        // Arrange
        var nodes = new List<NodeLayoutDto>
        {
            new("node-1", "Node 1", 1, 0, 0, "branch"),
            new("node-2", "Node 2", 1, 0, 1, "branch")
        };

        var tiers = new List<TierDisplayDto>
        {
            new(1, "TIER 1", nodes)
        };

        var dto = new TreeDisplayDto(
            TreeId: "test-tree",
            TreeName: "Test Tree",
            ClassId: "test",
            Tiers: tiers,
            Branches: new List<BranchDisplayDto>(),
            MaxTier: 1);

        _mockRenderer.Setup(r => r.CalculateNodePositions(It.IsAny<TreeDisplayDto>()))
            .Returns(new Dictionary<string, NodeScreenPosition>
            {
                { "node-1", new(10, 10) },
                { "node-2", new(10, 14) }
            });
        _mockRenderer.Setup(r => r.FormatTreeHeader(It.IsAny<string>(), It.IsAny<int>())).Returns("TEST TREE");
        _mockRenderer.Setup(r => r.GetTierLabel(It.IsAny<int>())).Returns("TIER 1");
        _mockRenderer.Setup(r => r.FormatNodeBox(It.IsAny<NodeLayoutDto>(), It.IsAny<int>(), It.IsAny<int>()))
            .Returns("┌─────────┐\n│  Node   │\n└─────────┘");

        _treeView.RenderTree(dto);

        // Act
        _treeView.HandleSelection(0, 1);

        // Assert
        var selectedNodeId = _treeView.GetSelectedNodeId();
        Assert.That(selectedNodeId, Is.EqualTo("node-2"));
    }
}
```

**File:** `tests/RuneAndRust.Presentation.Tui.Tests/Renderers/NodePositionCalculationTests.cs`

```csharp
[TestFixture]
public class NodePositionCalculationTests
{
    private AbilityTreeDisplayConfig _config;
    private TreeLayoutRenderer _renderer;

    [SetUp]
    public void Setup()
    {
        _config = new AbilityTreeDisplayConfig
        {
            StartX = 0,
            StartY = 0,
            Padding = 2,
            NodeWidth = 11,
            ColumnSpacing = 8,
            NodeAreaStartRow = 7,
            NodeHeight = 3,
            NodeVerticalSpacing = 1
        };
        _renderer = new TreeLayoutRenderer(_config);
    }

    [Test]
    [TestCase(1, 0, 2, 7)]   // Tier 1, Node 0: X = 0+2 = 2, Y = 0+7 = 7
    [TestCase(1, 1, 2, 11)]  // Tier 1, Node 1: X = 2, Y = 7+(1*(3+1)) = 11
    [TestCase(2, 0, 21, 7)]  // Tier 2, Node 0: X = 2+11+8 = 21, Y = 7
    [TestCase(3, 0, 40, 7)]  // Tier 3, Node 0: X = 2+2*(11+8) = 40, Y = 7
    public void CalculateNodePositions_WithTierAndIndex_ReturnsCorrectPosition(
        int tierNumber, int nodeIndex, int expectedX, int expectedY)
    {
        // Arrange
        var nodes = new List<NodeLayoutDto>();
        for (var i = 0; i <= nodeIndex; i++)
        {
            nodes.Add(new NodeLayoutDto($"node-{i}", $"Node {i}", tierNumber, 0, i, "branch"));
        }

        var tiers = new List<TierDisplayDto>
        {
            new(tierNumber, $"TIER {tierNumber}", nodes)
        };

        var dto = new TreeDisplayDto(
            TreeId: "test",
            TreeName: "Test",
            ClassId: "test",
            Tiers: tiers,
            Branches: new List<BranchDisplayDto>(),
            MaxTier: tierNumber);

        // Act
        var positions = _renderer.CalculateNodePositions(dto);
        var nodeId = $"node-{nodeIndex}";

        // Assert
        Assert.That(positions.ContainsKey(nodeId), Is.True);
        Assert.That(positions[nodeId].X, Is.EqualTo(expectedX));
        Assert.That(positions[nodeId].Y, Is.EqualTo(expectedY));
    }
}
```

---

## 12. Use Cases

### UC-001: View Ability Tree Structure

**Actor:** Player
**Flow:** Open character view → Select abilities tab → Tree visualization displays → View tier columns with nodes → See tree name in header → Observe branch organization

### UC-002: Navigate Between Tiers

**Actor:** Player
**Flow:** View ability tree → Press right arrow → Selection moves to next tier → Press left arrow → Selection returns to previous tier → Continue navigation

### UC-003: Select Node Within Tier

**Actor:** Player
**Flow:** View tier column → Press down arrow → Selection moves to next node in tier → Press up arrow → Selection returns to previous node → Node highlights on selection

### UC-004: View Multi-Branch Tree

**Actor:** Player
**Flow:** Open tree with multiple branches → See branch headers above node groups → Identify which nodes belong to each branch → Navigate between branches using arrow keys

### UC-005: View Large Tree with Scrolling

**Actor:** Player
**Flow:** Open tree with 4+ tiers → See first 4 tiers displayed → Navigate to tier 5 → Display scrolls to show tiers 2-5 → Continue navigation → Display adjusts visible range

---

## 13. Deliverable Checklist

### UI Components
- [ ] `AbilityTreeView` class implemented
- [ ] `RenderTree()` method renders complete tree display
- [ ] `RenderTiers()` method renders tier columns
- [ ] `SetTreeHeader()` method displays tree name
- [ ] `HandleSelection()` method supports navigation
- [ ] `Clear()` method removes display

### Renderers
- [ ] `TreeLayoutRenderer` class implemented
- [ ] `CalculateNodePositions()` calculates screen coordinates
- [ ] `RenderTierColumn()` formats tier columns
- [ ] `GetTierLabel()` returns tier label string
- [ ] `GetTreeWidth()` calculates total width
- [ ] `FormatNodeBox()` creates node box ASCII
- [ ] `FormatTreeHeader()` creates centered header
- [ ] `FormatBranchHeader()` creates branch header

### DTOs
- [ ] `TreeDisplayDto` record created
- [ ] `TierDisplayDto` record created
- [ ] `NodeLayoutDto` record created
- [ ] `BranchDisplayDto` record created
- [ ] `NodeScreenPosition` record created

### Configuration
- [ ] `AbilityTreeDisplayConfig` class created
- [ ] `AbilityTreeColors` class created
- [ ] `config/ability-tree-display.json` created
- [ ] `config/schemas/ability-tree-display.schema.json` created

### View Integration
- [ ] `CharacterView` ability tree tab implemented
- [ ] `CharacterView` tree DTO creation implemented
- [ ] Ability tree view positioned correctly in layout

### Testing
- [ ] ~6 unit tests implemented
- [ ] All tests passing

---

## 14. Acceptance Criteria

### Functional
- [ ] Tree visualization displays hierarchical structure
- [ ] Tier columns show with clear labels
- [ ] Tree header displays tree name centered
- [ ] Nodes arranged in correct tier positions
- [ ] Layout handles varying node counts per tier
- [ ] Selection navigates between nodes
- [ ] Branch headers display for multi-branch trees
- [ ] Tree border renders correctly

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~6 unit tests pass
- [ ] Configuration file validates against schema
- [ ] XML documentation complete on all public members
- [ ] No hardcoded values (all configurable)

---

## 15. Dependencies

### Required from v0.10.2a

| Type | Location | Usage in v0.13.2a |
|------|----------|-------------------|
| `IAbilityTreeProvider` | `Application/Interfaces/` | Get tree definitions |
| `AbilityTreeDefinition` | `Domain/Definitions/` | Tree structure with branches |
| `AbilityTreeBranch` | `Domain/Definitions/` | Branch with nodes |
| `AbilityTreeNode` | `Domain/Definitions/` | Node with position data |
| `NodePosition` | `Domain/ValueObjects/` | X, Y coordinates |

### Required from v0.13.0

| Type | Location | Usage in v0.13.2a |
|------|----------|-------------------|
| `CharacterView` | `Presentation.Tui/Views/` | Integration point |
| `ITerminalService` | `Presentation.Tui/Services/` | Terminal output |

### Provides to v0.13.2b

| Type | Usage |
|------|-------|
| `AbilityTreeView` | Node state rendering integration |
| `TreeLayoutRenderer` | Position calculations for state display |
| `NodeLayoutDto` | Node information for state determination |
| `AbilityTreeDisplayConfig` | Shared configuration |

---

## 16. Future Considerations

### Deferred to v0.13.2b
- **Node State Rendering**: Locked/available/unlocked visual indicators
- **State Colors**: Color coding based on unlock status
- **Progress Indicators**: Visual representation of rank progress

### Deferred to v0.13.2c
- **Prerequisite Lines**: Connection lines between dependent nodes
- **Line States**: Satisfied/unsatisfied line rendering

### Deferred to v0.13.2d
- **Node Tooltips**: Detailed ability information on selection
- **Unlock Action**: Spending talent points to unlock nodes
- **Talent Point Display**: Available/spent point counter

### Out of Scope
- **Ability Effects**: Actual ability functionality (domain layer scope)
- **Talent Point Allocation Logic**: Handled by ITalentPointService
- **Prerequisite Validation**: Handled by IPrerequisiteValidator
- **Respec Functionality**: Handled by IRespecService

---

*Document Version: 1.0*
*Last Updated: 2026-01-16*
*Author: Claude (AI Assistant)*
