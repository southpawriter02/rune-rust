# v0.8.2c Design Specification: Puzzle Window

**Version:** 0.8.2c
**Parent:** v0.8.2 (Interaction Windows)
**Prerequisites:** v0.8.2b Complete (Dialogue Window)
**Status:** Design Complete
**Estimated Unit Tests:** ~10

---

## 1. Overview

### Purpose

Implement a puzzle window that renders interactive puzzles with clickable/toggleable elements, provides hints, tracks attempts, and gives visual feedback on success or failure. Supports multiple puzzle types: lever, sequence, and matching.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Windows** | `PuzzleWindow` |
| **ViewModels** | `PuzzleWindowViewModel`, `PuzzleElementViewModel` |
| **Controls** | `LeverControl`, `SequenceSlotControl`, `MatchTileControl` |
| **Animations** | Success celebration, failure shake |
| **Styles** | `PuzzleWindowStyles.axaml` |
| **Tests** | ~10 unit tests |

---

## 2. Feature Overview

```
v0.8.2c Features
â”œâ”€â”€ PuzzleWindow (Modal)
â”‚   â”œâ”€â”€ Puzzle title and instructions
â”‚   â”œâ”€â”€ Interactive puzzle area
â”‚   â”œâ”€â”€ Current input display
â”‚   â”œâ”€â”€ Attempts remaining counter
â”‚   â”œâ”€â”€ Hint display area
â”‚   â””â”€â”€ Action buttons (Reset, Hint, Solve, Give Up)
â”‚
â”œâ”€â”€ Puzzle Types
â”‚   â”œâ”€â”€ Lever: Toggle up/down (â†‘/â†“)
â”‚   â”œâ”€â”€ Sequence: Order selection (1st, 2nd, 3rd...)
â”‚   â””â”€â”€ Matching: Reveal and pair tiles
â”‚
â”œâ”€â”€ PuzzleElementControl Variants
â”‚   â”œâ”€â”€ LeverControl: Click to toggle
â”‚   â”œâ”€â”€ SequenceSlotControl: Click to add to sequence
â”‚   â””â”€â”€ MatchTileControl: Click to reveal, match pairs
â”‚
â”œâ”€â”€ Hint System
â”‚   â”œâ”€â”€ Limited hints per puzzle
â”‚   â”œâ”€â”€ Progressive reveal
â”‚   â””â”€â”€ Hint counter display
â”‚
â”œâ”€â”€ Attempt Tracking
â”‚   â”œâ”€â”€ Max attempts per puzzle
â”‚   â”œâ”€â”€ Decrement on wrong solution
â”‚   â””â”€â”€ Failure on zero attempts
â”‚
â””â”€â”€ Feedback
    â”œâ”€â”€ Success: Celebration animation + message
    â”œâ”€â”€ Failure: Shake animation + attempts remaining
    â””â”€â”€ Give Up: Immediate failure
```

---

## 3. Architecture

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       PRESENTATION LAYER                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Windows                                                                â”‚
â”‚  â””â”€â”€ PuzzleWindow : Window                                             â”‚
â”‚       â”œâ”€â”€ Title & Instructions                                         â”‚
â”‚       â”œâ”€â”€ Puzzle Element Grid                                          â”‚
â”‚       â”œâ”€â”€ Current Input Display                                        â”‚
â”‚       â”œâ”€â”€ Hint Display                                                 â”‚
â”‚       â”œâ”€â”€ Attempt Counter                                              â”‚
â”‚       â””â”€â”€ Action Buttons                                               â”‚
â”‚                                                                         â”‚
â”‚  Controls                                                               â”‚
â”‚  â”œâ”€â”€ LeverControl (toggle â†‘/â†“)                                         â”‚
â”‚  â”œâ”€â”€ SequenceSlotControl (numbered selection)                          â”‚
â”‚  â””â”€â”€ MatchTileControl (reveal/match)                                   â”‚
â”‚                                                                         â”‚
â”‚  ViewModels                                                             â”‚
â”‚  â”œâ”€â”€ PuzzleWindowViewModel                                             â”‚
â”‚  â”‚    â”œâ”€â”€ Puzzle, Title, Instructions                                  â”‚
â”‚  â”‚    â”œâ”€â”€ PuzzleType, Elements                                         â”‚
â”‚  â”‚    â”œâ”€â”€ CurrentInput, AttemptsRemaining, HintsRemaining              â”‚
â”‚  â”‚    â”œâ”€â”€ IsSolved, HasFailed, ResultMessage                           â”‚
â”‚  â”‚    â””â”€â”€ Commands: Toggle, Select, Solve, Hint, Reset, GiveUp         â”‚
â”‚  â”‚                                                                     â”‚
â”‚  â””â”€â”€ PuzzleElementViewModel                                            â”‚
â”‚       â”œâ”€â”€ Id, Symbol, IsToggled, SelectionOrder                        â”‚
â”‚       â”œâ”€â”€ IsRevealed, IsMatched                                        â”‚
â”‚       â””â”€â”€ Reset()                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       APPLICATION / DOMAIN LAYER                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  IPuzzleService                                                         â”‚
â”‚  â”œâ”€â”€ ValidateSolution(puzzle, input): PuzzleSolutionResult             â”‚
â”‚  â””â”€â”€ MarkPuzzleSolved(puzzle)                                          â”‚
â”‚                                                                         â”‚
â”‚  Puzzle Entity                                                          â”‚
â”‚  â”œâ”€â”€ Id, Name, Instructions, Type                                      â”‚
â”‚  â”œâ”€â”€ Elements[], Solution                                              â”‚
â”‚  â”œâ”€â”€ MaxAttempts, Hints[]                                              â”‚
â”‚  â””â”€â”€ SuccessMessage, FailureMessage                                    â”‚
â”‚                                                                         â”‚
â”‚  PuzzleType Enum: Lever, Sequence, Matching                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. Puzzle Window

### PuzzleWindow.axaml

**File:** `src/Presentation/RuneAndRust.Avalonia/Views/PuzzleWindow.axaml`

```xml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:RuneAndRust.Avalonia.ViewModels"
        xmlns:controls="using:RuneAndRust.Avalonia.Controls"
        x:Class="RuneAndRust.Avalonia.Views.PuzzleWindow"
        x:DataType="vm:PuzzleWindowViewModel"
        Title="Puzzle" Width="650" Height="500"
        WindowStartupLocation="CenterOwner" CanResize="False">
    
    <Grid RowDefinitions="Auto,*,Auto,Auto">
        
        <!-- Header: Title -->
        <Border Grid.Row="0" Classes="puzzle-header" Padding="16">
            <TextBlock Text="{Binding Title}" Classes="puzzle-title" />
        </Border>
        
        <!-- Main Puzzle Area -->
        <Border Grid.Row="1" Classes="puzzle-main" Padding="20">
            <StackPanel>
                <!-- Instructions -->
                <TextBlock Text="{Binding Instructions}" 
                           Classes="puzzle-instructions" 
                           TextWrapping="Wrap" Margin="0,0,0,20" />
                
                <!-- Puzzle Elements (dynamic based on type) -->
                <ItemsControl ItemsSource="{Binding Elements}" HorizontalAlignment="Center">
                    <ItemsControl.ItemsPanel>
                        <ItemsPanelTemplate>
                            <WrapPanel Orientation="Horizontal" />
                        </ItemsPanelTemplate>
                    </ItemsControl.ItemsPanel>
                    <ItemsControl.ItemTemplate>
                        <DataTemplate DataType="vm:PuzzleElementViewModel">
                            <controls:PuzzleElementControl
                                ElementType="{Binding $parent[Window].DataContext.PuzzleType}"
                                Symbol="{Binding Symbol}"
                                IsToggled="{Binding IsToggled}"
                                SelectionOrder="{Binding SelectionOrder}"
                                IsRevealed="{Binding IsRevealed}"
                                IsMatched="{Binding IsMatched}"
                                PointerPressed="OnElementPressed" />
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
                
                <!-- Current Input -->
                <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,20,0,0">
                    <TextBlock Text="Current: " Classes="label" />
                    <TextBlock Text="{Binding CurrentInput}" Classes="current-input" />
                </StackPanel>
                
                <!-- Hint Display -->
                <TextBlock Text="{Binding CurrentHint}" 
                           Classes="hint-text"
                           IsVisible="{Binding CurrentHint, Converter={x:Static StringConverters.IsNotNullOrEmpty}}"
                           Margin="0,12,0,0" HorizontalAlignment="Center" />
            </StackPanel>
        </Border>
        
        <!-- Status Bar -->
        <Border Grid.Row="2" Classes="puzzle-status" Padding="16,8">
            <Grid ColumnDefinitions="*,Auto">
                <TextBlock Text="{Binding AttemptsText}" Classes="attempts-label" />
                <TextBlock Grid.Column="1" Text="{Binding ResultMessage}" Classes="result-message" />
            </Grid>
        </Border>
        
        <!-- Action Buttons -->
        <Border Grid.Row="3" Classes="puzzle-footer" Padding="16">
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Spacing="12">
                <Button Content="Reset" Command="{Binding ResetCommand}" />
                <Button Content="{Binding HintButtonText}" Command="{Binding UseHintCommand}" 
                        IsEnabled="{Binding CanUseHint}" />
                <Button Content="Solve" Command="{Binding SolveCommand}" Classes="primary" />
                <Button Content="Give Up" Command="{Binding GiveUpCommand}" Classes="danger" />
            </StackPanel>
        </Border>
        
        <!-- Success/Failure Overlay -->
        <Border Grid.RowSpan="4" Classes="result-overlay"
                IsVisible="{Binding ShowResult}" Background="#CC000000">
            <Border Classes="result-panel" Padding="32" HorizontalAlignment="Center" VerticalAlignment="Center">
                <StackPanel>
                    <TextBlock Text="{Binding ResultMessage}" Classes="result-title" TextWrapping="Wrap" />
                    <Button Content="Continue" Command="{Binding CloseCommand}" 
                            HorizontalAlignment="Center" Margin="0,20,0,0" />
                </StackPanel>
            </Border>
        </Border>
    </Grid>
</Window>
```

---

## 5. Puzzle Element Control

**File:** `src/Presentation/RuneAndRust.Avalonia/Controls/PuzzleElementControl.cs`

```csharp
namespace RuneAndRust.Avalonia.Controls;

public class PuzzleElementControl : TemplatedControl
{
    public static readonly StyledProperty<PuzzleType> ElementTypeProperty =
        AvaloniaProperty.Register<PuzzleElementControl, PuzzleType>(nameof(ElementType));
    public static readonly StyledProperty<string> SymbolProperty =
        AvaloniaProperty.Register<PuzzleElementControl, string>(nameof(Symbol), "");
    public static readonly StyledProperty<bool> IsToggledProperty =
        AvaloniaProperty.Register<PuzzleElementControl, bool>(nameof(IsToggled));
    public static readonly StyledProperty<int> SelectionOrderProperty =
        AvaloniaProperty.Register<PuzzleElementControl, int>(nameof(SelectionOrder), -1);
    public static readonly StyledProperty<bool> IsRevealedProperty =
        AvaloniaProperty.Register<PuzzleElementControl, bool>(nameof(IsRevealed));
    public static readonly StyledProperty<bool> IsMatchedProperty =
        AvaloniaProperty.Register<PuzzleElementControl, bool>(nameof(IsMatched));

    public PuzzleType ElementType { get => GetValue(ElementTypeProperty); set => SetValue(ElementTypeProperty, value); }
    public string Symbol { get => GetValue(SymbolProperty); set => SetValue(SymbolProperty, value); }
    public bool IsToggled { get => GetValue(IsToggledProperty); set => SetValue(IsToggledProperty, value); }
    public int SelectionOrder { get => GetValue(SelectionOrderProperty); set => SetValue(SelectionOrderProperty, value); }
    public bool IsRevealed { get => GetValue(IsRevealedProperty); set => SetValue(IsRevealedProperty, value); }
    public bool IsMatched { get => GetValue(IsMatchedProperty); set => SetValue(IsMatchedProperty, value); }

    public string DisplaySymbol => ElementType switch
    {
        PuzzleType.Lever => IsToggled ? "â†“" : "â†‘",
        PuzzleType.Sequence => IsRevealed ? Symbol : "?",
        PuzzleType.Matching => IsRevealed || IsMatched ? Symbol : "?",
        _ => Symbol
    };

    public bool IsSelected => SelectionOrder >= 0;
}
```

---

## 6. View Models

### PuzzleWindowViewModel

**File:** `src/Presentation/RuneAndRust.Avalonia/ViewModels/PuzzleWindowViewModel.cs`

```csharp
namespace RuneAndRust.Avalonia.ViewModels;

public partial class PuzzleWindowViewModel : ViewModelBase
{
    private readonly IPuzzleService _puzzleService;
    private readonly ILogger<PuzzleWindowViewModel> _logger;
    private readonly Action? _onClose;

    [ObservableProperty] private Puzzle _puzzle = null!;
    [ObservableProperty] private string _title = "";
    [ObservableProperty] private string _instructions = "";
    [ObservableProperty] private PuzzleType _puzzleType;
    [ObservableProperty] private ObservableCollection<PuzzleElementViewModel> _elements = new();
    [ObservableProperty] private string _currentInput = "";
    [ObservableProperty] private int _attemptsRemaining;
    [ObservableProperty] private int _hintsRemaining;
    [ObservableProperty] private string? _currentHint;
    [ObservableProperty] private bool _isSolved;
    [ObservableProperty] private bool _hasFailed;
    [ObservableProperty] private string? _resultMessage;

    public bool CanUseHint => HintsRemaining > 0 && !IsSolved && !HasFailed;
    public bool ShowResult => IsSolved || HasFailed;
    public string AttemptsText => $"Attempts remaining: {AttemptsRemaining}";
    public string HintButtonText => $"Hint ({HintsRemaining} left)";

    public PuzzleWindowViewModel(IPuzzleService puzzleService, ILogger<PuzzleWindowViewModel> logger, Action? onClose = null)
    {
        _puzzleService = puzzleService;
        _logger = logger;
        _onClose = onClose;
    }

    public void LoadPuzzle(Puzzle puzzle)
    {
        Puzzle = puzzle;
        Title = puzzle.Name;
        Instructions = puzzle.Instructions;
        PuzzleType = puzzle.Type;
        AttemptsRemaining = puzzle.MaxAttempts;
        HintsRemaining = puzzle.Hints.Count;
        LoadElements(puzzle);
        _logger.LogDebug("Loaded puzzle: {Title}", Title);
    }

    [RelayCommand]
    private void ToggleElement(PuzzleElementViewModel element)
    {
        if (PuzzleType == PuzzleType.Lever)
        {
            element.IsToggled = !element.IsToggled;
            UpdateCurrentInput();
        }
    }

    [RelayCommand]
    private void SelectElement(PuzzleElementViewModel element)
    {
        if (PuzzleType == PuzzleType.Sequence && !element.IsSelected)
        {
            element.SelectionOrder = GetNextSelectionOrder();
            UpdateCurrentInput();
        }
        else if (PuzzleType == PuzzleType.Matching && !element.IsMatched)
        {
            HandleMatchingSelection(element);
        }
    }

    [RelayCommand]
    private void Solve()
    {
        var result = _puzzleService.ValidateSolution(Puzzle, GetCurrentSolution());
        if (result.IsCorrect)
        {
            IsSolved = true;
            ResultMessage = "ğŸ‰ PUZZLE SOLVED! ğŸ‰\n\n" + Puzzle.SuccessMessage;
            _puzzleService.MarkPuzzleSolved(Puzzle);
            _logger.LogInformation("Puzzle solved: {Title}", Title);
        }
        else
        {
            AttemptsRemaining--;
            if (AttemptsRemaining <= 0)
            {
                HasFailed = true;
                ResultMessage = "Puzzle failed!\n\n" + Puzzle.FailureMessage;
                _logger.LogInformation("Puzzle failed: {Title}", Title);
            }
            else
            {
                ResultMessage = $"Incorrect. {AttemptsRemaining} attempts remaining.";
                TriggerShakeAnimation();
            }
        }
    }

    [RelayCommand]
    private void UseHint()
    {
        if (HintsRemaining <= 0) return;
        var hintIndex = Puzzle.Hints.Count - HintsRemaining;
        CurrentHint = Puzzle.Hints[hintIndex];
        HintsRemaining--;
        _logger.LogDebug("Used hint: {Hint}", CurrentHint);
    }

    [RelayCommand]
    private void Reset()
    {
        foreach (var el in Elements) el.Reset();
        CurrentInput = "";
        CurrentHint = null;
        ResultMessage = null;
        _logger.LogDebug("Puzzle reset");
    }

    [RelayCommand]
    private void GiveUp()
    {
        HasFailed = true;
        ResultMessage = "You gave up.\n\n" + Puzzle.FailureMessage;
        _logger.LogDebug("Gave up on puzzle");
    }

    [RelayCommand]
    private void Close() => _onClose?.Invoke();

    private void LoadElements(Puzzle puzzle)
    {
        Elements.Clear();
        foreach (var el in puzzle.Elements)
            Elements.Add(new PuzzleElementViewModel(el.Id, el.Symbol));
    }

    private int GetNextSelectionOrder() => Elements.Count(e => e.IsSelected) + 1;

    private void UpdateCurrentInput()
    {
        CurrentInput = PuzzleType switch
        {
            PuzzleType.Lever => string.Join(" ", Elements.Select(e => e.IsToggled ? "â†“" : "â†‘")),
            PuzzleType.Sequence => string.Join(" â†’ ", Elements.Where(e => e.IsSelected)
                .OrderBy(e => e.SelectionOrder).Select(e => e.Symbol)),
            _ => ""
        };
    }

    private string GetCurrentSolution() => PuzzleType switch
    {
        PuzzleType.Lever => string.Join("", Elements.Select(e => e.IsToggled ? "1" : "0")),
        PuzzleType.Sequence => string.Join(",", Elements.Where(e => e.IsSelected)
            .OrderBy(e => e.SelectionOrder).Select(e => e.Id)),
        PuzzleType.Matching => Elements.All(e => e.IsMatched) ? "complete" : "incomplete",
        _ => ""
    };

    private PuzzleElementViewModel? _firstMatchSelection;
    private void HandleMatchingSelection(PuzzleElementViewModel element)
    {
        element.IsRevealed = true;
        if (_firstMatchSelection is null)
        {
            _firstMatchSelection = element;
        }
        else
        {
            if (_firstMatchSelection.Symbol == element.Symbol)
            {
                _firstMatchSelection.IsMatched = true;
                element.IsMatched = true;
            }
            else
            {
                var first = _firstMatchSelection;
                Dispatcher.UIThread.InvokeAsync(async () =>
                {
                    await Task.Delay(500);
                    first.IsRevealed = false;
                    element.IsRevealed = false;
                });
            }
            _firstMatchSelection = null;
        }
    }

    private void TriggerShakeAnimation() { /* Trigger shake via behavior or animation */ }
}
```

### PuzzleElementViewModel

```csharp
public partial class PuzzleElementViewModel : ViewModelBase
{
    public string Id { get; }
    public string Symbol { get; }
    [ObservableProperty] private bool _isToggled;
    [ObservableProperty] private int _selectionOrder = -1;
    [ObservableProperty] private bool _isRevealed;
    [ObservableProperty] private bool _isMatched;
    public bool IsSelected => SelectionOrder >= 0;

    public PuzzleElementViewModel(string id, string symbol) { Id = id; Symbol = symbol; }
    public void Reset() { IsToggled = false; SelectionOrder = -1; IsRevealed = false; }
}
```

---

## 7. Puzzle Types

| Type | Interaction | Win Condition |
|------|-------------|---------------|
| **Lever** | Click toggles â†‘/â†“ | All levers match solution pattern |
| **Sequence** | Click adds to ordered sequence | Sequence matches correct order |
| **Matching** | Click reveals, find pairs | All pairs matched |

---

## 8. Styles

**File:** `src/Presentation/RuneAndRust.Avalonia/Styles/PuzzleWindowStyles.axaml`

```xml
<Styles xmlns="https://github.com/avaloniaui" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    <Style Selector="Border.puzzle-header">
        <Setter Property="Background" Value="{StaticResource SurfaceDarkBrush}" />
    </Style>
    <Style Selector="TextBlock.puzzle-title">
        <Setter Property="FontSize" Value="18" /><Setter Property="FontWeight" Value="Bold" />
        <Setter Property="HorizontalAlignment" Value="Center" />
    </Style>
    <Style Selector="TextBlock.puzzle-instructions">
        <Setter Property="FontSize" Value="14" /><Setter Property="FontStyle" Value="Italic" />
        <Setter Property="HorizontalAlignment" Value="Center" />
    </Style>
    <Style Selector="TextBlock.current-input">
        <Setter Property="FontSize" Value="16" /><Setter Property="FontWeight" Value="SemiBold" />
    </Style>
    <Style Selector="TextBlock.hint-text">
        <Setter Property="FontStyle" Value="Italic" /><Setter Property="Foreground" Value="Gold" />
    </Style>
    <Style Selector="Border.result-panel">
        <Setter Property="Background" Value="{StaticResource SurfaceBrush}" />
        <Setter Property="CornerRadius" Value="8" />
    </Style>
    <Style Selector="TextBlock.result-title">
        <Setter Property="FontSize" Value="20" /><Setter Property="FontWeight" Value="Bold" />
        <Setter Property="HorizontalAlignment" Value="Center" />
    </Style>
    <Style Selector="Button.primary">
        <Setter Property="Background" Value="{StaticResource SuccessBrush}" />
    </Style>
    <Style Selector="Button.danger">
        <Setter Property="Background" Value="{StaticResource DangerBrush}" />
    </Style>
</Styles>
```

---

## 9. Unit Testing Requirements (~10 tests)

| Feature | Tests |
|---------|-------|
| Load puzzle | 1 |
| Toggle lever | 1 |
| Sequence selection | 1 |
| Matching pairs | 2 |
| Solve correct | 1 |
| Solve incorrect (decrement) | 1 |
| Use hint | 1 |
| Reset | 1 |
| Give up | 1 |

---

## 10. Use Cases

| ID | Use Case |
|----|----------|
| UC-082c-001 | Open puzzle window |
| UC-082c-002 | Toggle lever element |
| UC-082c-003 | Select sequence element |
| UC-082c-004 | Match tile pairs |
| UC-082c-005 | Solve puzzle successfully |
| UC-082c-006 | Fail puzzle (out of attempts) |
| UC-082c-007 | Use hint |
| UC-082c-008 | Reset puzzle |
| UC-082c-009 | Give up |

---

## 11. Acceptance Criteria

- [ ] Puzzle window shows title and instructions
- [ ] Lever puzzle toggles on click (â†‘/â†“)
- [ ] Sequence puzzle records selection order
- [ ] Matching puzzle reveals tiles and matches pairs
- [ ] Current input updates correctly
- [ ] Solve validates solution
- [ ] Success shows celebration overlay
- [ ] Failure decrements attempts
- [ ] Zero attempts triggers failure overlay
- [ ] Hint button reveals hints progressively
- [ ] Hint count decrements
- [ ] Reset clears puzzle state
- [ ] Give Up closes with failure
- [ ] ~10 unit tests pass

---

## 12. Dependencies

| From | Required |
|------|----------|
| Domain | `Puzzle`, `PuzzleElement`, `PuzzleType` |
| Application | `IPuzzleService` |
| v0.8.2b | Modal window patterns |

---

## 13. Future Considerations

**Deferred:** Timed puzzles, physics puzzles, puzzle editor, difficulty scaling, undo/redo.

---

*Document Version: 1.0 | Last Updated: 2026-01-10*
