Here is the comprehensive implementation plan for v0.0.5: The Spatial Core.
v0.0.5: The Spatial Core
Goal: Implement the fundamental 3D coordinate system, procedural graph generation, and room navigation logic. This phase transitions the application from a static menu loop into a navigable world where the player can move between discrete locations (Rooms) mapped to a coordinate grid.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v005)
- [4. Logging Matrix](#4-logging-matrix-v005)
- [5. Deliverable Checklist](#5-v005-deliverable-checklist)

1. Implementation Workflow
	1	Domain Definition: Create Room, Coordinate, and Direction types in Core.
	2	State Expansion: Update GameState to track the player's current location (RoomId or Coordinate).
	3	Generation Logic: Implement DungeonGenerator in Engine to create a connected graph of rooms (initially a simple test grid).
	4	Navigation Logic: Build NavigationService to validate movement and update state.
	5	Persistence Update: Add DbSet<Room> to the DbContext and create a migration to save the world state.
	6	Command Wiring: Implement GoCommand and integrate it into the CommandParser.

2. Code Implementation
A. Core Layer (Domain)
We define the spatial primitives. The inclusion of the Z-axis is critical for the "Verticality" design pillar (e.g., The Deep, Canopy Sea).
File: RuneAndRust.Core/ValueObjects/Coordinate.cs
namespace RuneAndRust.Core.ValueObjects;

public record Coordinate(int X, int Y, int Z)
{
    public override string ToString() => $"({X}, {Y}, {Z})";

    public static Coordinate Origin => new(0, 0, 0);
}
File: RuneAndRust.Core/Enums/Direction.cs
namespace RuneAndRust.Core.Enums;

public enum Direction
{
    North,
    South,
    East,
    West,
    Up,
    Down
}
File: RuneAndRust.Core/Entities/Room.cs
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.ValueObjects;

namespace RuneAndRust.Core.Entities;

public class Room
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public Coordinate Position { get; set; } = Coordinate.Origin;

    // Navigation properties
    // Note: For EF Core, we may need a separate join table or JSON mapping
    // This is a simplified in-memory representation for v0.0.5 logic
    public Dictionary<Direction, Guid> Exits { get; set; } = new();
}
B. Persistence Layer (Database Update)
We must persist the world data so the player returns to the same room after loading.
File: RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs
// Update DbContext to include Rooms
public DbSet<Room> Rooms { get; set; }

protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // ... previous configs

    modelBuilder.Entity<Room>()
        .OwnsOne(r => r.Position); // Maps Coordinate X/Y/Z to columns

    // Store Exits as JSON for simplicity in early dev (requires Npgsql.Json.NET)
    // Alternatively, use a navigation property for strict SQL relationships
}
Migration Workflow:
dotnet ef migrations add AddRooms --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal
dotnet ef database update --project RuneAndRust.Persistence --startup-project RuneAndRust.Terminal
C. Engine Layer (Generation & Logic)
Implement a basic generator to verify connectivity.
File: RuneAndRust.Engine/Services/DungeonGenerator.cs
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.ValueObjects;

namespace RuneAndRust.Engine.Services;

public class DungeonGenerator
{
    public Dictionary<Guid, Room> GenerateTestMap()
    {
        var rooms = new Dictionary<Guid, Room>();

        // 1. Origin: Entry Hall
        var entry = new Room
        {
            Name = "Entry Hall",
            Description = "A cold, metallic chamber. The air smells of ozone.",
            Position = new Coordinate(0, 0, 0)
        };
        rooms.Add(entry.Id, entry);

        // 2. North: Rusted Corridor
        var corridor = new Room
        {
            Name = "Rusted Corridor",
            Description = "Pipes line the walls of this narrow passage.",
            Position = new Coordinate(0, 1, 0)
        };
        rooms.Add(corridor.Id, corridor);

        // 3. Link them (Bi-directional)
        entry.Exits[Direction.North] = corridor.Id;
        corridor.Exits[Direction.South] = entry.Id;

        return rooms;
    }
}
File: RuneAndRust.Engine/Services/NavigationService.cs
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Engine.Services;

public class NavigationService
{
    private readonly GameState _gameState;
    private readonly IRepository<Room> _roomRepo;
    private readonly ILogger<NavigationService> _logger;

    public NavigationService(GameState gameState, IRepository<Room> roomRepo, ILogger<NavigationService> logger)
    {
        _gameState = gameState;
        _roomRepo = roomRepo;
        _logger = logger;
    }

    public async Task<string> MoveAsync(Direction direction)
    {
        // 1. Get current room
        var currentRoom = await _roomRepo.GetByIdAsync(_gameState.CurrentRoomId);
        if (currentRoom == null) return "Error: You are in the void.";

        // 2. Check exit validity
        if (currentRoom.Exits.TryGetValue(direction, out var nextRoomId))
        {
            // 3. Update State
            _gameState.CurrentRoomId = nextRoomId;
            var nextRoom = await _roomRepo.GetByIdAsync(nextRoomId);

            _logger.LogInformation("Player moved {Direction} to {RoomName}", direction, nextRoom.Name);
            return $"You move {direction}...\n\n[{nextRoom.Name}]\n{nextRoom.Description}";
        }

        return "You cannot go that way.";
    }
}
D. Terminal Layer (Command Wiring)
Update the command parser to handle movement.
File: RuneAndRust.Terminal/Services/CommandParser.cs (Snippet)
// Inside ParseAndExecute logic
if (command.StartsWith("go "))
{
    var dirString = command.Substring(3).Trim();
    if (Enum.TryParse<Direction>(dirString, true, out var dir))
    {
        var result = await _navigationService.MoveAsync(dir);
        _inputHandler.DisplayMessage(result);
        return;
    }
}
// Handle aliases: "n", "s", "e", "w", "u", "d"

3. Architecture Decision Tree (v0.0.5)
	•	Q: Should we implement the Wave Function Collapse algorithm now?
	◦	A: No. For v0.0.5, hardcode the GenerateTestMap method. The complex procedural generation defined in the "Room Engine" specs is a Milestone 2 task. We only need to prove the structure (Graph/Coordinate) works.
	•	Q: How do we handle "Looking"?
	◦	A: The NavigationService should return the room description upon entry. We should also implement a lookcommand that re-prints the current room's details without moving.
	•	Q: Where does the map state live?
	◦	A: In the Database (Rooms table). On New Game, the DungeonGenerator creates entities and saves them to the DB via IRepository<Room>. The GameState only holds the CurrentRoomId.

4. Logging Matrix (v0.0.5)
System
Event
Level
Message Template
Properties
Navigation
Move Success
Info
"Player moved {Direction} to {Room} ({Id})."
Direction, Room, Id
Navigation
Move Fail
Debug
"Invalid move attempt: {Direction} from {Room}."
Direction, Room
Generator
Map Created
Info
"Generated dungeon with {Count} rooms."
Count
Db
Room Save
Verbose
"Persisted room {Id} to database."
Id

5. v0.0.5 Deliverable Checklist
	•	[ ] Core: Coordinate struct defined (X, Y, Z).
	•	[ ] Core: Room entity defined with Exits dictionary.
	•	[ ] Persistence: Rooms table created in PostgreSQL via EF Migrations.
	•	[ ] Engine: DungeonGenerator successfully seeds at least 2 connected rooms into the DB on new game.
	•	[ ] Engine: NavigationService logic validates exits and updates GameState.
	•	[ ] Terminal: go [dir] command works and prints new room description.
	•	[ ] Terminal: look command prints current room description.
	•	[ ] Verification: Walk North, then South. Verify you are back in the start room. Restart app, Load Game, verify you are still in the correct room.
This completes the Infrastructure milestone. The next step, v0.1.0, will introduce Character Creation.
