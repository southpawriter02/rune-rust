# v0.2.1b Design Specification: Lore Fragments

## Overview

**Version:** 0.2.1b
**Status:** Planning
**Focus:** Implement the Lore Fragment system for collectible, scattered knowledge pieces
**Prerequisites:** v0.2.1a (Codex Foundation)
**Estimated Unit Tests:** ~25

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Data Models](#5-data-models)
6. [Configuration Schemas](#6-configuration-schemas)
7. [Service Specifications](#7-service-specifications)
8. [Fragment Discovery Flow](#8-fragment-discovery-flow)
9. [User-Facing Changes](#9-user-facing-changes)
10. [Logging Requirements](#10-logging-requirements)
11. [Unit Test Specifications](#11-unit-test-specifications)
12. [Use Cases](#12-use-cases)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Dependencies](#15-dependencies)
16. [Future Considerations](#16-future-considerations)

---

## 1. Executive Summary

This version introduces the Lore Fragment system, enabling scattered pieces of knowledge that players collect throughout the dungeon. Fragments represent incomplete information about legends, myths, prophecies, and historical events. When a player collects all fragments of a particular lore entry, the complete entry is revealed in the codex.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Entities** | LoreFragment |
| **Definitions** | LoreFragmentDefinition, FragmentedCodexEntryDefinition |
| **Value Objects** | FragmentCollectionProgress, FragmentDiscoveryResult |
| **Enums** | FragmentSourceType |
| **Commands** | `codex fragments`, `codex fragments <topic>` |
| **Services** | LoreFragmentService (ILoreFragmentService) |
| **Configuration** | lore-fragments.json, lore-fragments.schema.json |
| **Tests** | ~25 new unit tests |

### Architectural Significance

This version extends the discovery-based knowledge pattern established in v0.2.1a:
- Fragments as collectible pieces that combine into complete entries
- Progressive revelation through scattered discovery
- Integration with existing codex categories (especially Legends and History)
- Foundation for fragment hints (v0.2.1c) and UI display (v0.2.1d)

---

## 2. Feature Overview

```
v0.2.1b Features
├── Lore Fragment System
│   ├── LoreFragmentDefinition (config-loaded templates)
│   ├── LoreFragment (player-discovered fragment instance)
│   ├── FragmentedCodexEntryDefinition (entry requiring fragments)
│   └── Fragment ordering and positioning
├── Fragment Discovery
│   ├── FragmentSourceType enum (Document, Inscription, NPC, Item, Environment)
│   ├── Discovery triggers (reading, examining, dialogue)
│   ├── Automatic fragment tracking per player
│   └── Entry completion on all fragments collected
├── Fragment Commands
│   ├── codex fragments - List incomplete fragment collections
│   └── codex fragments <topic> - View collected fragments for topic
├── Progress Tracking
│   ├── FragmentCollectionProgress per entry
│   ├── Fragments found vs total per topic
│   └── Partial content display for incomplete entries
└── Service Layer
    ├── LoreFragmentService (fragment management)
    ├── ILoreFragmentService interface
    └── CodexService integration
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────┐  ┌─────────────────────┐  ┌────────────────┐  │
│  │   CodexHandler      │  │   InputHandler      │  │ IGameRenderer  │  │
│  │   (updated)         │  │   (updated)         │  │ (updated)      │  │
│  │                     │  │                     │  │                │  │
│  │ + HandleFragments() │  │ + ParseFragmentCmd()│  │ + RenderFrag() │  │
│  │ + HandleFragDetail()│  │                     │  │ + RenderProg() │  │
│  └─────────┬───────────┘  └─────────┬───────────┘  └───────┬────────┘  │
│            │                        │                      │           │
└────────────┼────────────────────────┼──────────────────────┼───────────┘
             │                        │                      │
             ▼                        ▼                      ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION LAYER                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                     LoreFragmentService                         │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + GetFragmentDefinition(id) : LoreFragmentDefinition?          │   │
│  │ + GetAllFragmentedEntries() : IReadOnlyList<...>               │   │
│  │ + GetDiscoveredFragments(playerId) : IReadOnlyList<LoreFragment>│   │
│  │ + GetFragmentsForEntry(playerId, entryId) : IReadOnlyList<...> │   │
│  │ + TryDiscoverFragment(playerId, fragmentId) : FragmentResult   │   │
│  │ + TryDiscoverBySource(playerId, sourceType, sourceId) : ...    │   │
│  │ + GetCollectionProgress(playerId, entryId) : FragmentProgress  │   │
│  │ + GetIncompleteCollections(playerId) : IReadOnlyList<...>      │   │
│  │ + IsEntryComplete(playerId, entryId) : bool                    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    CodexService (updated)                       │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + GetFragmentedEntries(playerId) : IReadOnlyList<...>          │   │
│  │ + TryCompleteFragmentedEntry(playerId, entryId) : bool         │   │
│  │ // Internal: Check fragment completion on TryUnlockByTrigger   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                    GameSessionService (updated)                 │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + ViewFragments() : FragmentOverviewDto                        │   │
│  │ + ViewFragmentsForTopic(topic) : FragmentDetailDto?            │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           DOMAIN LAYER                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ENTITIES                                                               │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                       LoreFragment                              │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Id: Guid                                                      │    │
│  │ + DefinitionId: string                                          │    │
│  │ + PlayerId: Guid                                                │    │
│  │ + ParentEntryId: string                                         │    │
│  │ + FragmentIndex: int                                            │    │
│  │ + Title: string                                                 │    │
│  │ + Content: string                                               │    │
│  │ + DiscoveredAt: DateTime                                        │    │
│  │ + SourceType: FragmentSourceType                                │    │
│  │ + SourceId: string                                              │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  DEFINITIONS                                                            │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │                   LoreFragmentDefinition                        │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Id: string                                                    │    │
│  │ + ParentEntryId: string                                         │    │
│  │ + FragmentIndex: int                                            │    │
│  │ + Title: string                                                 │    │
│  │ + Content: string                                               │    │
│  │ + SourceType: FragmentSourceType                                │    │
│  │ + SourceId: string                                              │    │
│  │ + LocationHint: string                                          │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │               FragmentedCodexEntryDefinition                    │    │
│  ├────────────────────────────────────────────────────────────────┤    │
│  │ + Id: string                                                    │    │
│  │ + Title: string                                                 │    │
│  │ + Category: CodexCategory                                       │    │
│  │ + TotalFragments: int                                           │    │
│  │ + CompletionSummary: string                                     │    │
│  │ + FragmentIds: IReadOnlyList<string>                            │    │
│  │ + Tags: IReadOnlyList<string>                                   │    │
│  └────────────────────────────────────────────────────────────────┘    │
│                                                                         │
│  VALUE OBJECTS                                                          │
│  ┌────────────────────────────────────┐  ┌─────────────────────────┐   │
│  │   FragmentCollectionProgress       │  │ FragmentDiscoveryResult │   │
│  ├────────────────────────────────────┤  ├─────────────────────────┤   │
│  │ + EntryId: string                  │  │ + Success: bool         │   │
│  │ + EntryTitle: string               │  │ + Fragment: LoreFragment│   │
│  │ + TotalFragments: int              │  │ + IsNewDiscovery: bool  │   │
│  │ + FoundFragments: int              │  │ + EntryCompleted: bool  │   │
│  │ + IsComplete: bool                 │  │ + Message: string       │   │
│  │ + FoundIndices: IReadOnlyList<int> │  └─────────────────────────┘   │
│  │ + PercentComplete: int             │                                │
│  └────────────────────────────────────┘                                │
│                                                                         │
│  ENUMS                                                                  │
│  ┌────────────────────────────────────┐                                │
│  │       FragmentSourceType           │                                │
│  ├────────────────────────────────────┤                                │
│  │ Document                           │                                │
│  │ Inscription                        │                                │
│  │ NPCDialogue                        │                                │
│  │ ItemExamination                    │                                │
│  │ EnvironmentExamination             │                                │
│  │ CombatDrop                         │                                │
│  └────────────────────────────────────┘                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        INFRASTRUCTURE LAYER                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                IConfigurationProvider (updated)                  │   │
│  ├─────────────────────────────────────────────────────────────────┤   │
│  │ + LoadLoreFragmentDefinitions() : IReadOnlyList<...>            │   │
│  │ + LoadFragmentedEntryDefinitions() : IReadOnlyList<...>         │   │
│  │ + GetLoreFragmentDefinition(string id) : LoreFragmentDefinition?│   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  Configuration Files:                                                   │
│  ├── config/lore-fragments.json                                        │
│  └── config/schemas/lore-fragments.schema.json                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Fragment Discovery Flow

```
┌───────────────────┐
│   Player Action   │
│ (read document,   │
│  examine object,  │
│  dialogue choice, │
│  examine item)    │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ Originating       │
│ Service notifies  │
│ LoreFragmentSvc   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ LoreFragmentSvc.  │
│ TryDiscoverBySource│
│ (sourceType,      │
│  sourceId)        │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ Find matching     │
│ fragment def by   │
│ sourceType +      │
│ sourceId          │
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────────────────────────────────┐
│                    FRAGMENT DISCOVERY                          │
├───────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────────┐                                         │
│  │ Already discovered│      ┌───────────────────┐              │
│  │ by this player?   │──YES▶│ Return: already   │              │
│  └─────────┬─────────┘      │ discovered        │              │
│            │                └───────────────────┘              │
│           NO                                                    │
│            │                                                    │
│            ▼                                                    │
│  ┌───────────────────┐                                         │
│  │ Create LoreFragment│                                         │
│  │ from definition   │                                         │
│  └─────────┬─────────┘                                         │
│            │                                                    │
│            ▼                                                    │
│  ┌───────────────────┐                                         │
│  │ Track fragment    │                                         │
│  │ for player        │                                         │
│  └─────────┬─────────┘                                         │
│            │                                                    │
│            ▼                                                    │
│  ┌───────────────────┐      ┌───────────────────┐              │
│  │ All fragments     │──YES▶│ Notify CodexSvc   │              │
│  │ collected for     │      │ to complete entry │              │
│  │ parent entry?     │      └─────────┬─────────┘              │
│  └─────────┬─────────┘                │                        │
│            │                          ▼                        │
│           NO               ┌───────────────────┐              │
│            │               │ Create full codex │              │
│            │               │ entry with all    │              │
│            │               │ fragment content  │              │
│            │               └───────────────────┘              │
│            │                          │                        │
└────────────┼──────────────────────────┼────────────────────────┘
             │                          │
             ▼                          ▼
┌───────────────────┐      ┌───────────────────┐
│ Return: fragment  │      │ Return: fragment  │
│ discovered        │      │ discovered +      │
│ (X/Y collected)   │      │ entry completed!  │
└───────────────────┘      └───────────────────┘
             │                          │
             └──────────┬───────────────┘
                        │
                        ▼
             ┌───────────────────┐
             │ Display discovery │
             │ notification to   │
             │ player            │
             └───────────────────┘
```

### 3.3 Fragment Collection View Flow

```
┌───────────────────┐
│   Player Input    │
│ "codex fragments" │
│ or                │
│ "codex fragments  │
│  <topic>"         │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐      ┌───────────────────┐
│   InputHandler    │─────▶│ GameSessionService│
│  ParseFragmentCmd │      │   Fragment methods│
└───────────────────┘      └─────────┬─────────┘
                                     │
                    ┌────────────────┴────────────────┐
                    │                                 │
                    ▼                                 ▼
           ┌─────────────┐                   ┌─────────────┐
           │  "codex     │                   │  "codex     │
           │  fragments" │                   │  fragments  │
           │  (no args)  │                   │   <topic>"  │
           └──────┬──────┘                   └──────┬──────┘
                  │                                 │
                  ▼                                 ▼
           ┌─────────────┐                   ┌─────────────┐
           │ GetIncomplete│                   │ GetFragments│
           │ Collections()│                   │ ForEntry()  │
           │              │                   │             │
           │ Show list of │                   │ Show found  │
           │ in-progress  │                   │ fragments   │
           │ collections  │                   │ with content│
           └──────┬──────┘                   └──────┬──────┘
                  │                                 │
                  └────────────────┬────────────────┘
                                   │
                                   ▼
                           ┌───────────────────┐
                           │   IGameRenderer   │
                           │  Render Fragment  │
                           │  Overview/Detail  │
                           └───────────────────┘
```

---

## 4. User Stories

### US-2.1b-1: View Fragment Collections
**As a** player exploring the dungeon
**I want to** see my incomplete fragment collections
**So that** I know what lore I'm piecing together

**Acceptance Criteria:**
- `codex fragments` shows all in-progress collections
- Each collection shows title and X/Y fragments found
- Collections are organized by category
- Completed collections are not shown (they're in codex)

### US-2.1b-2: View Collected Fragments
**As a** player who has found fragments
**I want to** view the content of fragments I've collected
**So that** I can read partial lore and speculate about the whole

**Acceptance Criteria:**
- `codex fragments <topic>` shows fragments for that topic
- Found fragments display their content in order
- Missing fragment slots show "[Fragment not yet discovered]"
- Progress bar shows completion percentage

### US-2.1b-3: Discover Fragment from Document
**As a** player reading a document
**I want to** discover a lore fragment
**So that** exploration yields knowledge rewards

**Acceptance Criteria:**
- Reading certain documents discovers fragments
- Notification shows fragment title and collection progress
- Fragment content is immediately viewable
- Duplicate reads don't re-notify

### US-2.1b-4: Complete Fragment Collection
**As a** player who has collected all fragments
**I want to** see the complete codex entry
**So that** my effort in collecting fragments is rewarded

**Acceptance Criteria:**
- Collecting final fragment shows completion message
- Complete entry appears in main codex
- Entry contains all fragment content in order
- Entry shows "[Assembled from fragments]" indicator

### US-2.1b-5: Discover Fragment from NPC
**As a** player talking to an NPC
**I want to** learn fragments of lore through dialogue
**So that** NPCs feel like sources of world knowledge

**Acceptance Criteria:**
- Certain dialogue options reveal fragments
- Fragment ties to specific dialogue node
- NPC's knowledge feels contextually appropriate
- Same NPC won't repeat same fragment

### US-2.1b-6: Configure Fragments via JSON
**As a** game designer
**I want to** define lore fragments in configuration files
**So that** I can create scattered lore without code changes

**Acceptance Criteria:**
- Fragments defined in lore-fragments.json
- Fragment sources reference valid game objects
- Validation ensures all fragments for an entry exist
- Schema validates fragment structure

---

## 5. Data Models

### 5.1 LoreFragment Entity

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a player's discovered lore fragment.
/// </summary>
/// <remarks>
/// Lore fragments are pieces of larger entries that players collect
/// throughout the dungeon. When all fragments of an entry are found,
/// the complete entry is unlocked in the codex.
/// </remarks>
public class LoreFragment : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this fragment instance.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the fragment definition ID.
    /// </summary>
    /// <example>"prophecy-of-darkness-frag-1"</example>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the player who discovered this fragment.
    /// </summary>
    public Guid PlayerId { get; private set; }

    /// <summary>
    /// Gets the parent codex entry ID this fragment belongs to.
    /// </summary>
    /// <example>"prophecy-of-darkness"</example>
    public string ParentEntryId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the position of this fragment in the complete entry.
    /// </summary>
    /// <remarks>
    /// 1-based index. Fragment 1 is the beginning of the lore,
    /// fragment N is the end.
    /// </remarks>
    public int FragmentIndex { get; private set; }

    /// <summary>
    /// Gets the fragment's display title.
    /// </summary>
    /// <example>"Fragment I: The Beginning"</example>
    public string Title { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the fragment's content text.
    /// </summary>
    public string Content { get; private set; } = string.Empty;

    /// <summary>
    /// Gets when this fragment was discovered.
    /// </summary>
    public DateTime DiscoveredAt { get; private set; }

    /// <summary>
    /// Gets how this fragment was discovered.
    /// </summary>
    public FragmentSourceType SourceType { get; private set; }

    /// <summary>
    /// Gets the ID of the source that revealed this fragment.
    /// </summary>
    /// <example>"ancient-tome", "elder-npc-dialogue-3"</example>
    public string SourceId { get; private set; } = string.Empty;

    /// <summary>
    /// Private constructor for EF Core.
    /// </summary>
    private LoreFragment() { }

    /// <summary>
    /// Creates a new lore fragment from a definition.
    /// </summary>
    /// <param name="definition">The fragment definition.</param>
    /// <param name="playerId">The discovering player's ID.</param>
    /// <returns>A new LoreFragment instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown if definition is null.</exception>
    public static LoreFragment Create(
        LoreFragmentDefinition definition,
        Guid playerId)
    {
        ArgumentNullException.ThrowIfNull(definition);

        return new LoreFragment
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            PlayerId = playerId,
            ParentEntryId = definition.ParentEntryId,
            FragmentIndex = definition.FragmentIndex,
            Title = definition.Title,
            Content = definition.Content,
            DiscoveredAt = DateTime.UtcNow,
            SourceType = definition.SourceType,
            SourceId = definition.SourceId
        };
    }
}
```

### 5.2 FragmentSourceType Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of sources that can reveal lore fragments.
/// </summary>
/// <remarks>
/// Used to categorize how players discover fragments,
/// enabling source-specific discovery logic.
/// </remarks>
public enum FragmentSourceType
{
    /// <summary>
    /// Fragment found by reading a book, scroll, or letter.
    /// </summary>
    /// <remarks>
    /// SourceId = document item definition ID.
    /// </remarks>
    Document,

    /// <summary>
    /// Fragment found by examining wall carvings or engravings.
    /// </summary>
    /// <remarks>
    /// SourceId = room feature or inscription ID.
    /// </remarks>
    Inscription,

    /// <summary>
    /// Fragment learned through NPC dialogue.
    /// </summary>
    /// <remarks>
    /// SourceId = dialogue node ID.
    /// </remarks>
    NPCDialogue,

    /// <summary>
    /// Fragment found by examining a specific item.
    /// </summary>
    /// <remarks>
    /// SourceId = item definition ID.
    /// </remarks>
    ItemExamination,

    /// <summary>
    /// Fragment found by examining environmental details.
    /// </summary>
    /// <remarks>
    /// SourceId = room or feature ID.
    /// </remarks>
    EnvironmentExamination,

    /// <summary>
    /// Fragment dropped by defeating a specific enemy.
    /// </summary>
    /// <remarks>
    /// SourceId = monster definition ID.
    /// </remarks>
    CombatDrop
}
```

### 5.3 LoreFragmentDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Configuration template for lore fragments.
/// </summary>
/// <remarks>
/// Loaded from JSON configuration. Defines individual fragments
/// that combine to form complete codex entries.
/// </remarks>
public class LoreFragmentDefinition
{
    /// <summary>
    /// Gets the unique identifier for this fragment.
    /// </summary>
    /// <example>"prophecy-of-darkness-frag-1"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the parent codex entry this fragment belongs to.
    /// </summary>
    /// <example>"prophecy-of-darkness"</example>
    public string ParentEntryId { get; init; } = string.Empty;

    /// <summary>
    /// Gets the position of this fragment in the sequence.
    /// </summary>
    /// <remarks>
    /// 1-based index. Determines display order when viewing
    /// collected fragments and in the completed entry.
    /// </remarks>
    public int FragmentIndex { get; init; }

    /// <summary>
    /// Gets the fragment's display title.
    /// </summary>
    /// <example>"Fragment I: Whispers in the Dark"</example>
    public string Title { get; init; } = string.Empty;

    /// <summary>
    /// Gets the fragment's content text.
    /// </summary>
    public string Content { get; init; } = string.Empty;

    /// <summary>
    /// Gets how this fragment is discovered.
    /// </summary>
    public FragmentSourceType SourceType { get; init; }

    /// <summary>
    /// Gets the ID of the source that reveals this fragment.
    /// </summary>
    /// <remarks>
    /// Interpretation depends on SourceType:
    /// - Document: Item definition ID
    /// - Inscription: Room feature ID
    /// - NPCDialogue: Dialogue node ID
    /// - ItemExamination: Item definition ID
    /// - EnvironmentExamination: Room/feature ID
    /// - CombatDrop: Monster definition ID
    /// </remarks>
    public string SourceId { get; init; } = string.Empty;

    /// <summary>
    /// Gets a hint about where to find this fragment.
    /// </summary>
    /// <remarks>
    /// Displayed in the codex when viewing incomplete collections.
    /// Should be vague enough to encourage exploration.
    /// </remarks>
    /// <example>"Spoken by one who remembers the old ways."</example>
    public string LocationHint { get; init; } = string.Empty;

    /// <summary>
    /// Private constructor for deserialization.
    /// </summary>
    private LoreFragmentDefinition() { }

    /// <summary>
    /// Creates a lore fragment definition.
    /// </summary>
    public static LoreFragmentDefinition Create(
        string id,
        string parentEntryId,
        int fragmentIndex,
        string title,
        string content,
        FragmentSourceType sourceType,
        string sourceId,
        string locationHint = "")
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(parentEntryId);
        ArgumentException.ThrowIfNullOrWhiteSpace(title);
        ArgumentException.ThrowIfNullOrWhiteSpace(content);
        ArgumentException.ThrowIfNullOrWhiteSpace(sourceId);

        if (fragmentIndex < 1)
        {
            throw new ArgumentOutOfRangeException(
                nameof(fragmentIndex),
                "Fragment index must be at least 1.");
        }

        return new LoreFragmentDefinition
        {
            Id = id.ToLowerInvariant(),
            ParentEntryId = parentEntryId.ToLowerInvariant(),
            FragmentIndex = fragmentIndex,
            Title = title,
            Content = content,
            SourceType = sourceType,
            SourceId = sourceId.ToLowerInvariant(),
            LocationHint = locationHint
        };
    }
}
```

### 5.4 FragmentedCodexEntryDefinition

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a codex entry that is assembled from fragments.
/// </summary>
/// <remarks>
/// Unlike regular CodexEntryDefinitions, these entries are not
/// unlocked directly but are completed when all their fragments
/// have been discovered.
/// </remarks>
public class FragmentedCodexEntryDefinition
{
    /// <summary>
    /// Gets the unique identifier for this entry.
    /// </summary>
    /// <example>"prophecy-of-darkness"</example>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets the entry's display title.
    /// </summary>
    /// <example>"The Prophecy of Darkness"</example>
    public string Title { get; init; } = string.Empty;

    /// <summary>
    /// Gets the entry's category.
    /// </summary>
    /// <remarks>
    /// Typically Legends or History for fragmented entries.
    /// </remarks>
    public CodexCategory Category { get; init; }

    /// <summary>
    /// Gets the total number of fragments for this entry.
    /// </summary>
    public int TotalFragments { get; init; }

    /// <summary>
    /// Gets text displayed when the entry is completed.
    /// </summary>
    /// <remarks>
    /// A summary or commentary that appears before the
    /// assembled fragment content.
    /// </remarks>
    /// <example>"You have pieced together the ancient prophecy."</example>
    public string CompletionSummary { get; init; } = string.Empty;

    /// <summary>
    /// Gets the ordered list of fragment definition IDs.
    /// </summary>
    public IReadOnlyList<string> FragmentIds { get; init; } = [];

    /// <summary>
    /// Gets tags for categorization and searching.
    /// </summary>
    public IReadOnlyList<string> Tags { get; init; } = [];

    /// <summary>
    /// Gets IDs of related codex entries.
    /// </summary>
    public IReadOnlyList<string> RelatedEntryIds { get; init; } = [];

    /// <summary>
    /// Private constructor for deserialization.
    /// </summary>
    private FragmentedCodexEntryDefinition() { }

    /// <summary>
    /// Creates a fragmented codex entry definition.
    /// </summary>
    public static FragmentedCodexEntryDefinition Create(
        string id,
        string title,
        CodexCategory category,
        int totalFragments,
        string completionSummary,
        IEnumerable<string>? fragmentIds = null,
        IEnumerable<string>? tags = null,
        IEnumerable<string>? relatedEntryIds = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(id);
        ArgumentException.ThrowIfNullOrWhiteSpace(title);

        if (totalFragments < 2)
        {
            throw new ArgumentOutOfRangeException(
                nameof(totalFragments),
                "Fragmented entries must have at least 2 fragments.");
        }

        return new FragmentedCodexEntryDefinition
        {
            Id = id.ToLowerInvariant(),
            Title = title,
            Category = category,
            TotalFragments = totalFragments,
            CompletionSummary = completionSummary,
            FragmentIds = fragmentIds?.Select(f => f.ToLowerInvariant()).ToList() ?? [],
            Tags = tags?.Select(t => t.ToLowerInvariant()).ToList() ?? [],
            RelatedEntryIds = relatedEntryIds?.Select(r => r.ToLowerInvariant()).ToList() ?? []
        };
    }
}
```

### 5.5 FragmentCollectionProgress Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks a player's progress on a fragment collection.
/// </summary>
public readonly record struct FragmentCollectionProgress
{
    /// <summary>
    /// Gets the fragmented entry ID.
    /// </summary>
    public string EntryId { get; init; }

    /// <summary>
    /// Gets the entry's display title.
    /// </summary>
    public string EntryTitle { get; init; }

    /// <summary>
    /// Gets the entry's category.
    /// </summary>
    public CodexCategory Category { get; init; }

    /// <summary>
    /// Gets the total number of fragments in this collection.
    /// </summary>
    public int TotalFragments { get; init; }

    /// <summary>
    /// Gets the number of fragments found by the player.
    /// </summary>
    public int FoundFragments { get; init; }

    /// <summary>
    /// Gets whether all fragments have been collected.
    /// </summary>
    public bool IsComplete => FoundFragments >= TotalFragments;

    /// <summary>
    /// Gets the indices of found fragments (1-based).
    /// </summary>
    public IReadOnlyList<int> FoundIndices { get; init; }

    /// <summary>
    /// Gets the completion percentage.
    /// </summary>
    public int PercentComplete => TotalFragments > 0
        ? (FoundFragments * 100) / TotalFragments
        : 0;

    /// <summary>
    /// Creates a collection progress summary.
    /// </summary>
    public static FragmentCollectionProgress Create(
        string entryId,
        string entryTitle,
        CodexCategory category,
        int totalFragments,
        int foundFragments,
        IEnumerable<int>? foundIndices = null)
    {
        return new FragmentCollectionProgress
        {
            EntryId = entryId,
            EntryTitle = entryTitle,
            Category = category,
            TotalFragments = totalFragments,
            FoundFragments = foundFragments,
            FoundIndices = foundIndices?.OrderBy(i => i).ToList() ?? []
        };
    }

    /// <summary>
    /// Gets indices of missing fragments.
    /// </summary>
    /// <returns>List of missing fragment indices (1-based).</returns>
    public IReadOnlyList<int> GetMissingIndices()
    {
        var allIndices = Enumerable.Range(1, TotalFragments);
        return allIndices.Except(FoundIndices).ToList();
    }
}
```

### 5.6 FragmentDiscoveryResult Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of attempting to discover a lore fragment.
/// </summary>
public readonly record struct FragmentDiscoveryResult
{
    /// <summary>
    /// Gets whether the discovery was successful.
    /// </summary>
    public bool Success { get; init; }

    /// <summary>
    /// Gets the discovered fragment, if any.
    /// </summary>
    public LoreFragment? Fragment { get; init; }

    /// <summary>
    /// Gets whether this is a new discovery (not previously found).
    /// </summary>
    public bool IsNewDiscovery { get; init; }

    /// <summary>
    /// Gets whether this discovery completed the fragment collection.
    /// </summary>
    public bool EntryCompleted { get; init; }

    /// <summary>
    /// Gets the current collection progress after this discovery.
    /// </summary>
    public FragmentCollectionProgress? Progress { get; init; }

    /// <summary>
    /// Gets a message describing the discovery.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Creates a successful new discovery result.
    /// </summary>
    public static FragmentDiscoveryResult Discovered(
        LoreFragment fragment,
        FragmentCollectionProgress progress,
        bool entryCompleted = false)
    {
        var message = entryCompleted
            ? $"Fragment discovered: {fragment.Title} - Collection complete!"
            : $"Fragment discovered: {fragment.Title} ({progress.FoundFragments}/{progress.TotalFragments})";

        return new FragmentDiscoveryResult
        {
            Success = true,
            Fragment = fragment,
            IsNewDiscovery = true,
            EntryCompleted = entryCompleted,
            Progress = progress,
            Message = message
        };
    }

    /// <summary>
    /// Creates a result for an already-discovered fragment.
    /// </summary>
    public static FragmentDiscoveryResult AlreadyDiscovered(
        LoreFragment fragment,
        FragmentCollectionProgress progress)
    {
        return new FragmentDiscoveryResult
        {
            Success = true,
            Fragment = fragment,
            IsNewDiscovery = false,
            EntryCompleted = false,
            Progress = progress,
            Message = "You have already discovered this fragment."
        };
    }

    /// <summary>
    /// Creates a result for no fragment found.
    /// </summary>
    public static FragmentDiscoveryResult NotFound()
    {
        return new FragmentDiscoveryResult
        {
            Success = false,
            Fragment = null,
            IsNewDiscovery = false,
            EntryCompleted = false,
            Progress = null,
            Message = string.Empty
        };
    }
}
```

---

## 6. Configuration Schemas

### 6.1 lore-fragments.json

```json
{
  "$schema": "../schemas/lore-fragments.schema.json",
  "fragmentedEntries": [
    {
      "id": "prophecy-of-darkness",
      "title": "The Prophecy of Darkness",
      "category": "Legends",
      "totalFragments": 4,
      "completionSummary": "You have assembled the complete prophecy, whispered through the ages by those who foresaw the coming darkness.",
      "fragmentIds": [
        "prophecy-of-darkness-frag-1",
        "prophecy-of-darkness-frag-2",
        "prophecy-of-darkness-frag-3",
        "prophecy-of-darkness-frag-4"
      ],
      "relatedEntryIds": ["ancient-order-faction", "shadow-king-character"],
      "tags": ["prophecy", "darkness", "legend", "ancient"]
    },
    {
      "id": "fall-of-karthum",
      "title": "The Fall of Karthum",
      "category": "History",
      "totalFragments": 3,
      "completionSummary": "The complete history of Karthum's downfall, pieced together from scattered records.",
      "fragmentIds": [
        "fall-of-karthum-frag-1",
        "fall-of-karthum-frag-2",
        "fall-of-karthum-frag-3"
      ],
      "relatedEntryIds": ["karthum-location", "karthum-king-character"],
      "tags": ["history", "karthum", "kingdom", "downfall"]
    }
  ],
  "fragments": [
    {
      "id": "prophecy-of-darkness-frag-1",
      "parentEntryId": "prophecy-of-darkness",
      "fragmentIndex": 1,
      "title": "Fragment I: The First Verse",
      "content": "When shadows grow long and the sun turns cold,\nWhen heroes fall silent and tales go untold,\nThen shall arise from the depths below,\nA darkness eternal, the world's final woe.",
      "sourceType": "Document",
      "sourceId": "ancient-tome",
      "locationHint": "Found in dusty tomes of forgotten libraries."
    },
    {
      "id": "prophecy-of-darkness-frag-2",
      "parentEntryId": "prophecy-of-darkness",
      "fragmentIndex": 2,
      "title": "Fragment II: The Warning",
      "content": "The stars shall weep tears of crimson flame,\nAnd those who seek power shall shoulder the blame,\nFor in their ambition, they opened the gate,\nAnd sealed forever the world's bitter fate.",
      "sourceType": "Inscription",
      "sourceId": "temple-wall-carving",
      "locationHint": "Carved into ancient temple walls."
    },
    {
      "id": "prophecy-of-darkness-frag-3",
      "parentEntryId": "prophecy-of-darkness",
      "fragmentIndex": 3,
      "title": "Fragment III: The Hope",
      "content": "Yet hope remains in the hearts of the brave,\nThose who would fight, those who would save,\nWith blade and with courage, with light and with will,\nThe prophecy's ending is not written still.",
      "sourceType": "NPCDialogue",
      "sourceId": "elder-sage-dialogue-prophecy",
      "locationHint": "Spoken by one who remembers the old ways."
    },
    {
      "id": "prophecy-of-darkness-frag-4",
      "parentEntryId": "prophecy-of-darkness",
      "fragmentIndex": 4,
      "title": "Fragment IV: The Final Verse",
      "content": "When five shall stand where once stood the king,\nWhen the bell of the ancients once more shall ring,\nThen light shall pierce the eternal night,\nAnd dawn shall return in glorious might.",
      "sourceType": "ItemExamination",
      "sourceId": "prophecy-amulet",
      "locationHint": "Hidden within an artifact of the old kingdom."
    },
    {
      "id": "fall-of-karthum-frag-1",
      "parentEntryId": "fall-of-karthum",
      "fragmentIndex": 1,
      "title": "Chronicle I: The Golden Age",
      "content": "In the age before darkness, Karthum stood as a beacon of civilization. Its towers reached toward the heavens, and its people knew neither want nor fear. King Aldric the Wise ruled with justice, and the kingdom prospered for three hundred years.",
      "sourceType": "Document",
      "sourceId": "karthum-history-scroll",
      "locationHint": "Recorded in the scrolls of the old kingdom."
    },
    {
      "id": "fall-of-karthum-frag-2",
      "parentEntryId": "fall-of-karthum",
      "fragmentIndex": 2,
      "title": "Chronicle II: The Corruption",
      "content": "It began with whispers in the court. Advisors spoke of ancient powers buried beneath the castle foundations. King Aldric's son, Prince Malachar, became obsessed with these tales. In secret, he delved into forbidden arts, seeking power that mortal hands should never hold.",
      "sourceType": "EnvironmentExamination",
      "sourceId": "karthum-ruins-mural",
      "locationHint": "Depicted in murals within the kingdom's ruins."
    },
    {
      "id": "fall-of-karthum-frag-3",
      "parentEntryId": "fall-of-karthum",
      "fragmentIndex": 3,
      "title": "Chronicle III: The End",
      "content": "On the night of the crimson moon, Malachar completed his ritual. What emerged from the darkness consumed him first, then spread through the castle like a plague. By dawn, Karthum was silent. The towers that once reached toward heaven now clawed at the sky like broken fingers, monuments to hubris and doom.",
      "sourceType": "CombatDrop",
      "sourceId": "karthum-ghost",
      "locationHint": "Carried by the restless spirits of the fallen kingdom."
    }
  ]
}
```

### 6.2 lore-fragments.schema.json

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Lore Fragments Configuration",
  "description": "Defines fragmented lore entries and their component fragments",
  "type": "object",
  "required": ["fragmentedEntries", "fragments"],
  "properties": {
    "fragmentedEntries": {
      "type": "array",
      "description": "List of codex entries assembled from fragments",
      "items": {
        "$ref": "#/definitions/fragmentedEntry"
      }
    },
    "fragments": {
      "type": "array",
      "description": "List of individual lore fragments",
      "items": {
        "$ref": "#/definitions/fragment"
      }
    }
  },
  "definitions": {
    "fragmentedEntry": {
      "type": "object",
      "required": ["id", "title", "category", "totalFragments", "fragmentIds"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier (lowercase, alphanumeric with hyphens)"
        },
        "title": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "description": "Display title of the completed entry"
        },
        "category": {
          "type": "string",
          "enum": [
            "Bestiary",
            "Locations",
            "ItemsAndArtifacts",
            "Characters",
            "Factions",
            "History",
            "Legends",
            "CraftingKnowledge"
          ],
          "description": "Entry category (typically Legends or History)"
        },
        "totalFragments": {
          "type": "integer",
          "minimum": 2,
          "maximum": 10,
          "description": "Number of fragments in this collection"
        },
        "completionSummary": {
          "type": "string",
          "maxLength": 500,
          "description": "Text displayed when collection is completed"
        },
        "fragmentIds": {
          "type": "array",
          "minItems": 2,
          "items": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9-]*$"
          },
          "description": "Ordered list of fragment IDs"
        },
        "relatedEntryIds": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9-]*$"
          },
          "description": "IDs of related codex entries"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string",
            "pattern": "^[a-z][a-z0-9-]*$"
          },
          "description": "Tags for categorization and search"
        }
      }
    },
    "fragment": {
      "type": "object",
      "required": ["id", "parentEntryId", "fragmentIndex", "title", "content", "sourceType", "sourceId"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "Unique identifier for this fragment"
        },
        "parentEntryId": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9-]*$",
          "description": "ID of the fragmented entry this belongs to"
        },
        "fragmentIndex": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "description": "Position in the collection (1-based)"
        },
        "title": {
          "type": "string",
          "minLength": 1,
          "maxLength": 100,
          "description": "Display title of the fragment"
        },
        "content": {
          "type": "string",
          "minLength": 1,
          "maxLength": 2000,
          "description": "Fragment content text"
        },
        "sourceType": {
          "type": "string",
          "enum": [
            "Document",
            "Inscription",
            "NPCDialogue",
            "ItemExamination",
            "EnvironmentExamination",
            "CombatDrop"
          ],
          "description": "How this fragment is discovered"
        },
        "sourceId": {
          "type": "string",
          "minLength": 1,
          "description": "ID of the source that reveals this fragment"
        },
        "locationHint": {
          "type": "string",
          "maxLength": 200,
          "description": "Vague hint about where to find this fragment"
        }
      }
    }
  }
}
```

---

## 7. Service Specifications

### 7.1 ILoreFragmentService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Provides operations for lore fragment management and discovery.
/// </summary>
public interface ILoreFragmentService
{
    /// <summary>
    /// Gets all fragmented entry definitions.
    /// </summary>
    /// <returns>List of all fragmented entry definitions.</returns>
    IReadOnlyList<FragmentedCodexEntryDefinition> GetAllFragmentedEntries();

    /// <summary>
    /// Gets a fragment definition by ID.
    /// </summary>
    /// <param name="id">The fragment definition ID.</param>
    /// <returns>The definition, or null if not found.</returns>
    LoreFragmentDefinition? GetFragmentDefinition(string id);

    /// <summary>
    /// Gets a fragmented entry definition by ID.
    /// </summary>
    /// <param name="id">The entry ID.</param>
    /// <returns>The definition, or null if not found.</returns>
    FragmentedCodexEntryDefinition? GetFragmentedEntryDefinition(string id);

    /// <summary>
    /// Gets all fragments discovered by a player.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <returns>List of discovered fragments.</returns>
    IReadOnlyList<LoreFragment> GetDiscoveredFragments(Guid playerId);

    /// <summary>
    /// Gets fragments for a specific entry discovered by a player.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <param name="entryId">The fragmented entry ID.</param>
    /// <returns>List of discovered fragments for the entry.</returns>
    IReadOnlyList<LoreFragment> GetFragmentsForEntry(Guid playerId, string entryId);

    /// <summary>
    /// Attempts to discover a fragment by its definition ID.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <param name="fragmentId">The fragment definition ID.</param>
    /// <returns>Result of the discovery attempt.</returns>
    FragmentDiscoveryResult TryDiscoverFragment(Guid playerId, string fragmentId);

    /// <summary>
    /// Attempts to discover a fragment by its source.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <param name="sourceType">The type of source.</param>
    /// <param name="sourceId">The source's ID.</param>
    /// <returns>Result of the discovery attempt.</returns>
    FragmentDiscoveryResult TryDiscoverBySource(
        Guid playerId,
        FragmentSourceType sourceType,
        string sourceId);

    /// <summary>
    /// Gets collection progress for a specific entry.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <param name="entryId">The fragmented entry ID.</param>
    /// <returns>Collection progress, or null if entry doesn't exist.</returns>
    FragmentCollectionProgress? GetCollectionProgress(Guid playerId, string entryId);

    /// <summary>
    /// Gets all incomplete fragment collections for a player.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <returns>List of in-progress collections.</returns>
    IReadOnlyList<FragmentCollectionProgress> GetIncompleteCollections(Guid playerId);

    /// <summary>
    /// Checks if a fragmented entry is complete.
    /// </summary>
    /// <param name="playerId">The player's ID.</param>
    /// <param name="entryId">The fragmented entry ID.</param>
    /// <returns>True if all fragments have been collected.</returns>
    bool IsEntryComplete(Guid playerId, string entryId);
}
```

### 7.2 LoreFragmentService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages lore fragments, discovery, and collection tracking.
/// </summary>
public class LoreFragmentService : ILoreFragmentService
{
    private readonly IReadOnlyList<FragmentedCodexEntryDefinition> _fragmentedEntries;
    private readonly IReadOnlyList<LoreFragmentDefinition> _fragmentDefinitions;
    private readonly Dictionary<string, FragmentedCodexEntryDefinition> _entryLookup;
    private readonly Dictionary<string, LoreFragmentDefinition> _fragmentLookup;
    private readonly Dictionary<(FragmentSourceType, string), LoreFragmentDefinition> _sourceLookup;
    private readonly Dictionary<Guid, List<LoreFragment>> _playerFragments = new();
    private readonly ICodexService _codexService;
    private readonly ILogger<LoreFragmentService> _logger;

    /// <summary>
    /// Initializes a new instance of LoreFragmentService.
    /// </summary>
    /// <param name="configProvider">Configuration provider.</param>
    /// <param name="codexService">Codex service for entry completion.</param>
    /// <param name="logger">Logger instance.</param>
    public LoreFragmentService(
        IConfigurationProvider configProvider,
        ICodexService codexService,
        ILogger<LoreFragmentService> logger)
    {
        _codexService = codexService;
        _logger = logger;

        _fragmentedEntries = configProvider.LoadFragmentedEntryDefinitions();
        _fragmentDefinitions = configProvider.LoadLoreFragmentDefinitions();

        _entryLookup = _fragmentedEntries.ToDictionary(
            e => e.Id,
            StringComparer.OrdinalIgnoreCase);

        _fragmentLookup = _fragmentDefinitions.ToDictionary(
            f => f.Id,
            StringComparer.OrdinalIgnoreCase);

        _sourceLookup = _fragmentDefinitions.ToDictionary(
            f => (f.SourceType, f.SourceId.ToLowerInvariant()),
            f => f);

        _logger.LogInformation(
            "LoreFragmentService initialized with {EntryCount} fragmented entries, {FragmentCount} fragments",
            _fragmentedEntries.Count,
            _fragmentDefinitions.Count);
    }

    /// <inheritdoc />
    public IReadOnlyList<FragmentedCodexEntryDefinition> GetAllFragmentedEntries()
    {
        _logger.LogDebug("GetAllFragmentedEntries called");
        return _fragmentedEntries;
    }

    /// <inheritdoc />
    public LoreFragmentDefinition? GetFragmentDefinition(string id)
    {
        _logger.LogDebug("GetFragmentDefinition called for ID: {FragmentId}", id);
        return _fragmentLookup.TryGetValue(id, out var def) ? def : null;
    }

    /// <inheritdoc />
    public FragmentedCodexEntryDefinition? GetFragmentedEntryDefinition(string id)
    {
        _logger.LogDebug("GetFragmentedEntryDefinition called for ID: {EntryId}", id);
        return _entryLookup.TryGetValue(id, out var def) ? def : null;
    }

    /// <inheritdoc />
    public IReadOnlyList<LoreFragment> GetDiscoveredFragments(Guid playerId)
    {
        _logger.LogDebug("GetDiscoveredFragments called for player: {PlayerId}", playerId);

        if (!_playerFragments.TryGetValue(playerId, out var fragments))
        {
            return [];
        }

        return fragments.AsReadOnly();
    }

    /// <inheritdoc />
    public IReadOnlyList<LoreFragment> GetFragmentsForEntry(Guid playerId, string entryId)
    {
        _logger.LogDebug(
            "GetFragmentsForEntry called for player: {PlayerId}, entry: {EntryId}",
            playerId, entryId);

        return GetDiscoveredFragments(playerId)
            .Where(f => f.ParentEntryId.Equals(entryId, StringComparison.OrdinalIgnoreCase))
            .OrderBy(f => f.FragmentIndex)
            .ToList();
    }

    /// <inheritdoc />
    public FragmentDiscoveryResult TryDiscoverFragment(Guid playerId, string fragmentId)
    {
        _logger.LogDebug(
            "TryDiscoverFragment called for player: {PlayerId}, fragment: {FragmentId}",
            playerId, fragmentId);

        var definition = GetFragmentDefinition(fragmentId);
        if (definition is null)
        {
            _logger.LogWarning("Fragment definition not found: {FragmentId}", fragmentId);
            return FragmentDiscoveryResult.NotFound();
        }

        return DiscoverFragment(playerId, definition);
    }

    /// <inheritdoc />
    public FragmentDiscoveryResult TryDiscoverBySource(
        Guid playerId,
        FragmentSourceType sourceType,
        string sourceId)
    {
        _logger.LogDebug(
            "TryDiscoverBySource: player={PlayerId}, type={SourceType}, id={SourceId}",
            playerId, sourceType, sourceId);

        var key = (sourceType, sourceId.ToLowerInvariant());
        if (!_sourceLookup.TryGetValue(key, out var definition))
        {
            _logger.LogDebug("No fragment found for source: {SourceType}:{SourceId}", sourceType, sourceId);
            return FragmentDiscoveryResult.NotFound();
        }

        return DiscoverFragment(playerId, definition);
    }

    /// <inheritdoc />
    public FragmentCollectionProgress? GetCollectionProgress(Guid playerId, string entryId)
    {
        _logger.LogDebug(
            "GetCollectionProgress called for player: {PlayerId}, entry: {EntryId}",
            playerId, entryId);

        var entryDef = GetFragmentedEntryDefinition(entryId);
        if (entryDef is null)
        {
            return null;
        }

        var found = GetFragmentsForEntry(playerId, entryId);
        var foundIndices = found.Select(f => f.FragmentIndex).ToList();

        return FragmentCollectionProgress.Create(
            entryDef.Id,
            entryDef.Title,
            entryDef.Category,
            entryDef.TotalFragments,
            found.Count,
            foundIndices);
    }

    /// <inheritdoc />
    public IReadOnlyList<FragmentCollectionProgress> GetIncompleteCollections(Guid playerId)
    {
        _logger.LogDebug("GetIncompleteCollections called for player: {PlayerId}", playerId);

        var result = new List<FragmentCollectionProgress>();

        foreach (var entry in _fragmentedEntries)
        {
            var progress = GetCollectionProgress(playerId, entry.Id);
            if (progress.HasValue && progress.Value.FoundFragments > 0 && !progress.Value.IsComplete)
            {
                result.Add(progress.Value);
            }
        }

        return result.OrderBy(p => p.EntryTitle).ToList();
    }

    /// <inheritdoc />
    public bool IsEntryComplete(Guid playerId, string entryId)
    {
        var progress = GetCollectionProgress(playerId, entryId);
        return progress?.IsComplete ?? false;
    }

    /// <summary>
    /// Internal method to discover a fragment from its definition.
    /// </summary>
    private FragmentDiscoveryResult DiscoverFragment(
        Guid playerId,
        LoreFragmentDefinition definition)
    {
        // Check if already discovered
        var existing = GetDiscoveredFragments(playerId)
            .FirstOrDefault(f => f.DefinitionId.Equals(definition.Id, StringComparison.OrdinalIgnoreCase));

        if (existing is not null)
        {
            _logger.LogDebug("Fragment already discovered: {FragmentId}", definition.Id);
            var existingProgress = GetCollectionProgress(playerId, definition.ParentEntryId);
            return FragmentDiscoveryResult.AlreadyDiscovered(existing, existingProgress!.Value);
        }

        // Create new fragment
        var fragment = LoreFragment.Create(definition, playerId);

        // Track fragment
        if (!_playerFragments.ContainsKey(playerId))
        {
            _playerFragments[playerId] = new List<LoreFragment>();
        }
        _playerFragments[playerId].Add(fragment);

        _logger.LogInformation(
            "Player {PlayerId} discovered fragment: {FragmentTitle} ({FragmentId})",
            playerId, definition.Title, definition.Id);

        // Get updated progress
        var progress = GetCollectionProgress(playerId, definition.ParentEntryId)!.Value;

        // Check if collection is now complete
        if (progress.IsComplete)
        {
            _logger.LogInformation(
                "Player {PlayerId} completed fragment collection: {EntryId}",
                playerId, definition.ParentEntryId);

            // Trigger codex entry completion
            CompleteFragmentedEntry(playerId, definition.ParentEntryId);
        }

        return FragmentDiscoveryResult.Discovered(fragment, progress, progress.IsComplete);
    }

    /// <summary>
    /// Completes a fragmented entry in the codex.
    /// </summary>
    private void CompleteFragmentedEntry(Guid playerId, string entryId)
    {
        var entryDef = GetFragmentedEntryDefinition(entryId);
        if (entryDef is null) return;

        var fragments = GetFragmentsForEntry(playerId, entryId);

        // Build combined content from fragments
        var combinedContent = new StringBuilder();
        combinedContent.AppendLine(entryDef.CompletionSummary);
        combinedContent.AppendLine();
        combinedContent.AppendLine("---");
        combinedContent.AppendLine();

        foreach (var fragment in fragments.OrderBy(f => f.FragmentIndex))
        {
            combinedContent.AppendLine($"### {fragment.Title}");
            combinedContent.AppendLine();
            combinedContent.AppendLine(fragment.Content);
            combinedContent.AppendLine();
        }

        // Notify codex service to create the complete entry
        // This integration point allows the CodexService to handle entry creation
        _codexService.TryCompleteFragmentedEntry(
            playerId,
            entryId,
            entryDef.Title,
            entryDef.Category,
            combinedContent.ToString(),
            entryDef.Tags,
            entryDef.RelatedEntryIds);
    }
}
```

### 7.3 CodexService Updates

```csharp
// Add to ICodexService interface:

/// <summary>
/// Completes a fragmented codex entry.
/// </summary>
/// <param name="playerId">The player's ID.</param>
/// <param name="entryId">The entry ID.</param>
/// <param name="title">The entry title.</param>
/// <param name="category">The entry category.</param>
/// <param name="content">The combined fragment content.</param>
/// <param name="tags">Entry tags.</param>
/// <param name="relatedEntryIds">Related entry IDs.</param>
/// <returns>True if entry was created successfully.</returns>
bool TryCompleteFragmentedEntry(
    Guid playerId,
    string entryId,
    string title,
    CodexCategory category,
    string content,
    IEnumerable<string> tags,
    IEnumerable<string> relatedEntryIds);

/// <summary>
/// Gets fragmented entries in progress or completed for a player.
/// </summary>
/// <param name="playerId">The player's ID.</param>
/// <returns>List of fragmented entry statuses.</returns>
IReadOnlyList<CodexEntry> GetFragmentedEntries(Guid playerId);
```

```csharp
// Add to CodexService implementation:

/// <inheritdoc />
public bool TryCompleteFragmentedEntry(
    Guid playerId,
    string entryId,
    string title,
    CodexCategory category,
    string content,
    IEnumerable<string> tags,
    IEnumerable<string> relatedEntryIds)
{
    _logger.LogDebug(
        "TryCompleteFragmentedEntry: player={PlayerId}, entry={EntryId}",
        playerId, entryId);

    // Check if already exists
    var existing = GetDiscoveredEntries(playerId)
        .FirstOrDefault(e => e.DefinitionId.Equals(entryId, StringComparison.OrdinalIgnoreCase));

    if (existing is not null)
    {
        _logger.LogDebug("Fragmented entry already exists: {EntryId}", entryId);
        return false;
    }

    // Create a special "assembled from fragments" entry
    var entry = CodexEntry.CreateFromFragments(
        entryId,
        playerId,
        category,
        title,
        content);

    // Track entry
    if (!_playerEntries.ContainsKey(playerId))
    {
        _playerEntries[playerId] = new List<CodexEntry>();
    }
    _playerEntries[playerId].Add(entry);

    _logger.LogInformation(
        "Player {PlayerId} completed fragmented codex entry: {EntryTitle} ({EntryId})",
        playerId, title, entryId);

    return true;
}
```

### 7.4 CodexEntry Update

```csharp
// Add to CodexEntry entity:

/// <summary>
/// Gets whether this entry was assembled from fragments.
/// </summary>
public bool IsFromFragments { get; private set; }

/// <summary>
/// Gets the combined content for fragment-assembled entries.
/// </summary>
/// <remarks>
/// Only populated for entries created via CreateFromFragments.
/// </remarks>
public string? AssembledContent { get; private set; }

/// <summary>
/// Creates a codex entry from collected fragments.
/// </summary>
/// <param name="definitionId">The entry definition ID.</param>
/// <param name="playerId">The player's ID.</param>
/// <param name="category">The entry category.</param>
/// <param name="title">The entry title.</param>
/// <param name="assembledContent">The combined fragment content.</param>
/// <returns>A new CodexEntry instance.</returns>
public static CodexEntry CreateFromFragments(
    string definitionId,
    Guid playerId,
    CodexCategory category,
    string title,
    string assembledContent)
{
    return new CodexEntry
    {
        Id = Guid.NewGuid(),
        DefinitionId = definitionId,
        PlayerId = playerId,
        Category = category,
        Title = title,
        State = CodexEntryState.Complete,
        DiscoveredAt = DateTime.UtcNow,
        RevealedSections = 1,
        TotalSections = 1,
        IsFromFragments = true,
        AssembledContent = assembledContent
    };
}
```

---

## 8. Fragment Discovery Flow

### 8.1 Document Reading Discovery

```
Player uses "read <item>" on a document
          │
          ▼
┌───────────────────┐
│   ItemService     │
│ ProcessReadAction │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ LoreFragmentSvc   │
│ .TryDiscoverBy    │
│ Source(Document,  │
│ itemDefId)        │
└─────────┬─────────┘
          │
          ▼
[Fragment Discovery Flow from 3.2]
```

### 8.2 NPC Dialogue Discovery

```
Player selects dialogue option that reveals lore
          │
          ▼
┌───────────────────┐
│  DialogueService  │
│ ProcessChoice()   │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ Check if dialogue │
│ node has fragment │
│ trigger           │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ LoreFragmentSvc   │
│ .TryDiscoverBy    │
│ Source(NPCDialogue│
│ dialogueNodeId)   │
└─────────┬─────────┘
          │
          ▼
[Fragment Discovery Flow from 3.2]
```

### 8.3 Combat Drop Discovery

```
Player defeats monster
          │
          ▼
┌───────────────────┐
│   CombatService   │
│ OnMonsterDefeated │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ Check if monster  │
│ drops fragment    │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ LoreFragmentSvc   │
│ .TryDiscoverBy    │
│ Source(CombatDrop,│
│ monsterDefId)     │
└─────────┬─────────┘
          │
          ▼
[Fragment Discovery Flow from 3.2]
```

---

## 9. User-Facing Changes

### 9.1 New Commands

```
> codex fragments              # List incomplete fragment collections
> codex fragments <topic>      # View collected fragments for topic
```

### 9.2 Output Examples

**Fragment Collection Overview:**
```
═══════════════════════════════════════════════
                LORE FRAGMENTS
═══════════════════════════════════════════════

In-Progress Collections:

[Legends]
  The Prophecy of Darkness .............. 2/4 (50%)

[History]
  The Fall of Karthum ................... 1/3 (33%)

───────────────────────────────────────────────
Tip: Use 'codex fragments <topic>' to view
collected fragments for a specific topic.
═══════════════════════════════════════════════
```

**Fragment Detail View:**
```
═══════════════════════════════════════════════
        THE PROPHECY OF DARKNESS
              [Legends] - 2/4
═══════════════════════════════════════════════

▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░ 50% Complete

───────────────────────────────────────────────
Fragment I: The First Verse [FOUND]
───────────────────────────────────────────────
When shadows grow long and the sun turns cold,
When heroes fall silent and tales go untold,
Then shall arise from the depths below,
A darkness eternal, the world's final woe.

───────────────────────────────────────────────
Fragment II: The Warning [FOUND]
───────────────────────────────────────────────
The stars shall weep tears of crimson flame,
And those who seek power shall shoulder the blame,
For in their ambition, they opened the gate,
And sealed forever the world's bitter fate.

───────────────────────────────────────────────
Fragment III: ??? [NOT YET DISCOVERED]
───────────────────────────────────────────────
Hint: Spoken by one who remembers the old ways.

───────────────────────────────────────────────
Fragment IV: ??? [NOT YET DISCOVERED]
───────────────────────────────────────────────
Hint: Hidden within an artifact of the old kingdom.

═══════════════════════════════════════════════
```

**Fragment Discovery Notification:**
```
┌─────────────────────────────────────────────┐
│           LORE FRAGMENT DISCOVERED          │
├─────────────────────────────────────────────┤
│                                             │
│  Fragment II: The Warning                   │
│                                             │
│  The Prophecy of Darkness                   │
│  Progress: 2/4 fragments collected          │
│                                             │
│  Use 'codex fragments prophecy' to view.    │
│                                             │
└─────────────────────────────────────────────┘
```

**Collection Complete Notification:**
```
┌─────────────────────────────────────────────┐
│         LORE COLLECTION COMPLETE!           │
├─────────────────────────────────────────────┤
│                                             │
│  The Prophecy of Darkness                   │
│                                             │
│  You have assembled all 4 fragments!        │
│  This entry is now available in your codex. │
│                                             │
│  Use 'codex prophecy' to read the           │
│  complete entry.                            │
│                                             │
└─────────────────────────────────────────────┘
```

---

## 10. Logging Requirements

### 10.1 Debug Logs

```
[DEBUG] GetFragmentDefinition called for ID: {FragmentId}
[DEBUG] GetFragmentsForEntry called for player: {PlayerId}, entry: {EntryId}
[DEBUG] TryDiscoverBySource: player={PlayerId}, type={SourceType}, id={SourceId}
[DEBUG] Fragment already discovered: {FragmentId}
[DEBUG] No fragment found for source: {SourceType}:{SourceId}
```

### 10.2 Info Logs

```
[INFO] LoreFragmentService initialized with {EntryCount} fragmented entries, {FragmentCount} fragments
[INFO] Player {PlayerId} discovered fragment: {FragmentTitle} ({FragmentId})
[INFO] Player {PlayerId} completed fragment collection: {EntryId}
[INFO] Player {PlayerId} completed fragmented codex entry: {EntryTitle} ({EntryId})
```

### 10.3 Warning Logs

```
[WARN] Fragment definition not found: {FragmentId}
[WARN] Fragmented entry definition not found: {EntryId}
```

---

## 11. Unit Test Specifications

### 11.1 Test Files

| File | Tests | Coverage |
|------|-------|----------|
| `LoreFragmentTests.cs` | ~5 | Entity creation, factory method |
| `LoreFragmentDefinitionTests.cs` | ~4 | Definition creation, validation |
| `FragmentedCodexEntryDefinitionTests.cs` | ~4 | Entry definition, validation |
| `FragmentCollectionProgressTests.cs` | ~4 | Progress tracking, calculations |
| `LoreFragmentServiceTests.cs` | ~8 | Discovery, collection, completion |

### 11.2 LoreFragmentTests.cs

```csharp
[TestFixture]
public class LoreFragmentTests
{
    [Test]
    public void Create_WithValidDefinition_ReturnsFragment()

    [Test]
    public void Create_WithNullDefinition_ThrowsArgumentNullException()

    [Test]
    public void Create_SetsAllPropertiesFromDefinition()

    [Test]
    public void Create_SetsDiscoveredAtToCurrentTime()

    [Test]
    public void Create_GeneratesUniqueId()
}
```

### 11.3 LoreFragmentDefinitionTests.cs

```csharp
[TestFixture]
public class LoreFragmentDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsDefinition()

    [Test]
    public void Create_WithEmptyId_ThrowsArgumentException()

    [Test]
    public void Create_WithZeroIndex_ThrowsArgumentOutOfRangeException()

    [Test]
    public void Create_NormalizesIdToLowercase()
}
```

### 11.4 FragmentedCodexEntryDefinitionTests.cs

```csharp
[TestFixture]
public class FragmentedCodexEntryDefinitionTests
{
    [Test]
    public void Create_WithValidParameters_ReturnsDefinition()

    [Test]
    public void Create_WithOneFragment_ThrowsArgumentOutOfRangeException()

    [Test]
    public void Create_WithEmptyTitle_ThrowsArgumentException()

    [Test]
    public void Create_NormalizesFragmentIdsToLowercase()
}
```

### 11.5 FragmentCollectionProgressTests.cs

```csharp
[TestFixture]
public class FragmentCollectionProgressTests
{
    [Test]
    public void IsComplete_WhenAllFound_ReturnsTrue()

    [Test]
    public void IsComplete_WhenPartiallyFound_ReturnsFalse()

    [Test]
    public void PercentComplete_CalculatesCorrectly()

    [Test]
    public void GetMissingIndices_ReturnsCorrectIndices()
}
```

### 11.6 LoreFragmentServiceTests.cs

```csharp
[TestFixture]
public class LoreFragmentServiceTests
{
    [Test]
    public void TryDiscoverFragment_NewFragment_ReturnsSuccess()

    [Test]
    public void TryDiscoverFragment_AlreadyDiscovered_ReturnsAlreadyDiscovered()

    [Test]
    public void TryDiscoverFragment_InvalidId_ReturnsNotFound()

    [Test]
    public void TryDiscoverBySource_MatchingSource_DiscoversFragment()

    [Test]
    public void TryDiscoverBySource_NoMatch_ReturnsNotFound()

    [Test]
    public void GetFragmentsForEntry_ReturnsOrderedFragments()

    [Test]
    public void GetIncompleteCollections_ReturnsOnlyInProgress()

    [Test]
    public void TryDiscoverFragment_CompletesCollection_NotifiesCodexService()
}
```

---

## 12. Use Cases

### UC-2.1b-1: Discover Fragment from Ancient Tome

**Preconditions:**
- Player has "ancient-tome" item in inventory
- Tome contains fragment "prophecy-of-darkness-frag-1"
- Player has not discovered this fragment

**Flow:**
1. Player enters `read ancient-tome`
2. ItemService processes read action
3. ItemService calls LoreFragmentService.TryDiscoverBySource(Document, "ancient-tome")
4. LoreFragmentService finds matching fragment definition
5. New LoreFragment created and stored
6. FragmentDiscoveryResult returned with success
7. Player sees fragment content and collection progress

**Postconditions:**
- LoreFragment "prophecy-of-darkness-frag-1" exists for player
- Player can view fragment via `codex fragments prophecy`

### UC-2.1b-2: Complete Fragment Collection

**Preconditions:**
- Player has discovered 3 of 4 fragments for "prophecy-of-darkness"
- Player finds source containing final fragment

**Flow:**
1. Player action triggers TryDiscoverBySource for final fragment
2. LoreFragmentService creates fragment
3. IsEntryComplete returns true
4. CompleteFragmentedEntry called
5. CodexService creates complete entry
6. Player sees collection complete notification

**Postconditions:**
- All 4 fragments stored for player
- CodexEntry "prophecy-of-darkness" created with assembled content
- Entry appears in main codex under Legends

---

## 13. Acceptance Criteria

### AC-2.1b-1: Fragment Discovery
- [ ] Fragments can be discovered via Document source type
- [ ] Fragments can be discovered via Inscription source type
- [ ] Fragments can be discovered via NPCDialogue source type
- [ ] Fragments can be discovered via ItemExamination source type
- [ ] Fragments can be discovered via EnvironmentExamination source type
- [ ] Fragments can be discovered via CombatDrop source type
- [ ] Discovering same fragment twice does not create duplicate
- [ ] Discovery notification shows fragment title and progress

### AC-2.1b-2: Fragment Collection Tracking
- [ ] GetCollectionProgress returns accurate counts
- [ ] GetIncompleteCollections returns only in-progress collections
- [ ] Completed collections not shown in incomplete list
- [ ] Progress percentage calculated correctly

### AC-2.1b-3: Fragment Commands
- [ ] `codex fragments` lists all in-progress collections
- [ ] `codex fragments <topic>` shows fragments for specific topic
- [ ] Missing fragments show hints (from LocationHint)
- [ ] Found fragments display full content

### AC-2.1b-4: Collection Completion
- [ ] Collecting final fragment triggers entry completion
- [ ] Complete entry added to main codex
- [ ] Entry contains all fragment content in order
- [ ] Entry marked as assembled from fragments

### AC-2.1b-5: Configuration
- [ ] Fragments load from lore-fragments.json
- [ ] Fragmented entries load from same file
- [ ] Schema validation catches missing required fields
- [ ] Fragment-to-entry references validated

### AC-2.1b-6: Logging
- [ ] Fragment discoveries logged at INFO level
- [ ] Collection completions logged at INFO level
- [ ] Missing definitions logged at WARN level

### AC-2.1b-7: Unit Tests
- [ ] ~25 unit tests implemented
- [ ] All tests pass
- [ ] Entity, definition, value object, and service tests included

---

## 14. Deliverable Checklist

### Domain Layer
- [ ] Entities/LoreFragment.cs
- [ ] Definitions/LoreFragmentDefinition.cs
- [ ] Definitions/FragmentedCodexEntryDefinition.cs
- [ ] ValueObjects/FragmentCollectionProgress.cs
- [ ] ValueObjects/FragmentDiscoveryResult.cs
- [ ] Enums/FragmentSourceType.cs
- [ ] Update Entities/CodexEntry.cs (add CreateFromFragments, IsFromFragments, AssembledContent)

### Application Layer
- [ ] Interfaces/ILoreFragmentService.cs
- [ ] Services/LoreFragmentService.cs
- [ ] Update Interfaces/ICodexService.cs (add TryCompleteFragmentedEntry)
- [ ] Update Services/CodexService.cs (implement TryCompleteFragmentedEntry)
- [ ] Update Services/GameSessionService.cs (add ViewFragments, ViewFragmentsForTopic)

### Infrastructure Layer
- [ ] Update IConfigurationProvider (add LoadLoreFragmentDefinitions, LoadFragmentedEntryDefinitions)
- [ ] Update ConfigurationProvider implementation
- [ ] config/lore-fragments.json
- [ ] config/schemas/lore-fragments.schema.json

### Presentation Layer
- [ ] Update CodexHandler (add HandleFragments, HandleFragmentDetail)
- [ ] Update InputHandler (parse fragment commands)
- [ ] Update IGameRenderer (add RenderFragmentOverview, RenderFragmentDetail)

### Tests
- [ ] Tests/Domain/Entities/LoreFragmentTests.cs
- [ ] Tests/Domain/Definitions/LoreFragmentDefinitionTests.cs
- [ ] Tests/Domain/Definitions/FragmentedCodexEntryDefinitionTests.cs
- [ ] Tests/Domain/ValueObjects/FragmentCollectionProgressTests.cs
- [ ] Tests/Application/Services/LoreFragmentServiceTests.cs

### Documentation
- [ ] XML documentation on all public members
- [ ] JSON schema complete and valid

---

## 15. Dependencies

### From v0.2.1a (Codex Foundation)
| Component | Purpose for v0.2.1b |
|-----------|---------------------|
| `CodexEntry` | Extended with CreateFromFragments factory |
| `CodexEntryState` | Used for completed fragment entries |
| `CodexCategory` | Used for fragment entry categorization |
| `ICodexService` | Extended with TryCompleteFragmentedEntry |
| `CodexService` | Handles fragment entry completion |

### From v0.2.0b (Dialogue System)
| Component | Purpose for v0.2.1b |
|-----------|---------------------|
| `DialogueService` | Triggers NPCDialogue fragment discovery |
| `DialogueNodeDefinition` | Referenced in fragment sourceId |

### From Item System
| Component | Purpose for v0.2.1b |
|-----------|---------------------|
| `ItemService` | Triggers Document/ItemExamination discovery |
| `ItemDefinition` | Referenced in fragment sourceId |

### From Combat System
| Component | Purpose for v0.2.1b |
|-----------|---------------------|
| `CombatService` | Triggers CombatDrop discovery |
| `MonsterDefinition` | Referenced in fragment sourceId |

### From Room System
| Component | Purpose for v0.2.1b |
|-----------|---------------------|
| `RoomService` | Triggers Inscription/Environment discovery |
| `RoomDefinition` | Referenced in fragment sourceId |

---

## 16. Future Considerations

### v0.2.1c: Codex Hints
- Fragment location hints will be enhanced with dynamic hints
- Incomplete codex entries may suggest related fragments
- Integration with v0.2.1b's LocationHint field

### v0.2.1d: Codex UI Enhancements
- Visual representation of fragment progress bars
- Interactive fragment collection view
- Fragment source tracking display

### Cross-References
- Fragments may reference regular codex entries
- Completed fragment entries link to related content
- Search includes fragment content for completed entries

---

*This design specification establishes the Lore Fragment system as an extension of the Codex Foundation, providing scattered knowledge collection mechanics that reward thorough exploration.*
