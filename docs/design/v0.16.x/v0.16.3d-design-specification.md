# v0.16.3d Design Specification: Loot Service Integration

**Version:** 0.16.3d  
**Phase Name:** Loot Service Integration  
**Parent Version:** v0.16.3 (Smart Loot Generation)  
**Prerequisites:** v0.16.3a-c Complete (Equipment Class Mapping, Smart Loot Algorithm, Weighted Selection)  
**Estimated Tests:** ~4 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [LootDrop Value Object Updates](#4-lootdrop-value-object-updates)
5. [LootService Enhancements](#5-lootservice-enhancements)
6. [Monster Death Integration](#6-monster-death-integration)
7. [Data Model Changes](#7-data-model-changes)
8. [Logging Specifications](#8-logging-specifications)
9. [Unit Testing Requirements](#9-unit-testing-requirements)
10. [Use Cases](#10-use-cases)
11. [Deliverable Checklist](#11-deliverable-checklist)
12. [Acceptance Criteria](#12-acceptance-criteria)
13. [Dependencies](#13-dependencies)
14. [Future Considerations](#14-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification integrates the smart loot system (v0.16.3a-c) into the existing `LootService`. After this phase, monster deaths will generate loot that respects the 60% class-appropriate bias, uses weighted selection based on rarity, and tracks whether each drop was class-appropriate for display and statistics.

Key integration points:

1. **LootDrop Enhancement**: Add `WasClassAppropriate` flag and `PlayerArchetypeId` field
2. **LootService Updates**: Use `ISmartLootService` and `WeightedItemPool` for generation
3. **Monster Death Hook**: Connect to combat resolution for automatic loot generation
4. **Fallback Behavior**: Random selection when no player context is available

### 1.2 Key Deliverables

| Category           | Items                                    |
| ------------------ | ---------------------------------------- |
| **Modified Types** | `LootDrop` (value object), `LootService` |
| **Integration**    | Monster death → LootService → SmartLoot  |
| **Tests**          | ~4 unit tests                            |

### 1.3 Architectural Significance

This version establishes the **Integrated Loot Pattern**:

- **Unified Generation**: Single `GenerateLoot()` method handles all loot scenarios
- **Player-Aware Drops**: Archetype influences drop selection when provided
- **Fallback Safety**: System works without player context (containers, world loot)
- **Tracking Metadata**: Each drop records whether it was class-appropriate

---

## 2. Feature Overview

```
v0.16.3d Loot Service Integration
├── LootDrop Value Object Updates
│   ├── WasClassAppropriate: bool (from SmartLootResult)
│   ├── PlayerArchetypeId: string? (archetype used for generation)
│   ├── SelectionReason: string (debug/display info)
│   └── BiasRoll: int (the roll for debugging)
├── LootService Enhancements
│   ├── GenerateLoot(monster, player?): IReadOnlyList<LootDrop>
│   ├── GenerateLoot(context): IReadOnlyList<LootDrop>
│   ├── CreateWeightedPool(lootTable): WeightedItemPool
│   └── ApplyBiomeModifiers(pool, biome): void
├── Monster Death Integration
│   └── OnMonsterDeath → LootService.GenerateLoot → Display drops
└── Dependencies
    ├── ISmartLootService (v0.16.3b)
    ├── IEquipmentClassMappingProvider (v0.16.3a)
    └── WeightedItemPool (v0.16.3c)
```

### 2.1 Scope Alignment

**In Scope:**

- Enhanced `LootDrop` with `WasClassAppropriate` flag
- Enhanced `LootDrop` with `PlayerArchetypeId` field
- Enhanced `LootService.GenerateLoot()` with smart loot integration
- Monster death integration point
- Biome modifier application (when present)
- Fallback to random without player context

**Out of Scope:**

- Container loot (v0.16.4)
- Unique items (v0.16.5)
- UI display of class-appropriate indicator (future)

---

## 3. Architecture Diagrams

### 3.1 Loot Generation Flow Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                  LOOT GENERATION FLOW OVERVIEW                       │
└─────────────────────────────────────────────────────────────────────┘

    Monster Death Event
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │                    CombatService                                  │
    ├──────────────────────────────────────────────────────────────────┤
    │  OnMonsterDefeated(monster, player)                              │
    │    │                                                             │
    │    └──→ _lootService.GenerateLoot(monster, player)              │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │                      LootService                                  │
    ├──────────────────────────────────────────────────────────────────┤
    │  GenerateLoot(monster, player)                                   │
    │    │                                                             │
    │    ├──→ Get loot table from monster.LootTableId                 │
    │    ├──→ Determine quality tier from monster.Level               │
    │    ├──→ Build WeightedItemPool from loot table                  │
    │    ├──→ Apply biome modifiers (if applicable)                   │
    │    ├──→ Create SmartLootContext with player.ArchetypeId         │
    │    └──→ For each drop: _smartLootService.SelectItem(context)    │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │                   SmartLootService                                │
    ├──────────────────────────────────────────────────────────────────┤
    │  SelectItem(context)                                             │
    │    │                                                             │
    │    ├──→ Roll for bias (60% class-appropriate)                   │
    │    ├──→ Filter class-appropriate items (if bias roll < 60)      │
    │    └──→ Select from WeightedItemPool                            │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │                    LootDrop Result                                │
    ├──────────────────────────────────────────────────────────────────┤
    │  ItemId: "runed-axe-01"                                          │
    │  ItemName: "Runed Axe"                                           │
    │  QualityTier: ClanForged                                         │
    │  WasClassAppropriate: true                                       │
    │  PlayerArchetypeId: "warrior"                                    │
    │  SelectionReason: "Class-appropriate bias selection"             │
    └──────────────────────────────────────────────────────────────────┘
```

### 3.2 GenerateLoot Decision Tree

```
┌─────────────────────────────────────────────────────────────────────┐
│                   GENERATELOOT DECISION TREE                         │
└─────────────────────────────────────────────────────────────────────┘

    GenerateLoot(monster, player?) Called
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 1: GET LOOT TABLE                                          │
    ├──────────────────────────────────────────────────────────────────┤
    │  lootTable = _lootTableProvider.GetTable(monster.LootTableId)    │
    │                                                                  │
    │  lootTable is null?                                              │
    │    → Return empty list (no drops)                                │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 2: DETERMINE DROP COUNT AND TIER                           │
    ├──────────────────────────────────────────────────────────────────┤
    │  dropCount = CalculateDropCount(monster)                         │
    │  qualityTier = DetermineQualityTier(monster.Level)               │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 3: BUILD WEIGHTED POOL                                     │
    ├──────────────────────────────────────────────────────────────────┤
    │  pool = CreateWeightedPool(lootTable, qualityTier)               │
    │                                                                  │
    │  pool.HasSelectableItems == false?                               │
    │    → Return empty list (no valid items for tier)                 │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 4: APPLY BIOME MODIFIERS (Optional)                        │
    ├──────────────────────────────────────────────────────────────────┤
    │  currentBiome = _gameState.CurrentBiome                          │
    │                                                                  │
    │  Has biome modifiers?                                            │
    │    → ApplyBiomeModifiers(pool, currentBiome)                     │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 5: CHECK PLAYER CONTEXT                                    │
    ├──────────────────────────────────────────────────────────────────┤
    │  player is null OR player.ArchetypeId is null?                   │
    │    ├─ YES → Use random-only selection (no class bias)           │
    │    └─ NO  → Use smart loot with 60% class bias                  │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 6: GENERATE DROPS                                          │
    ├──────────────────────────────────────────────────────────────────┤
    │  drops = new List<LootDrop>()                                    │
    │                                                                  │
    │  FOR i = 0 TO dropCount:                                         │
    │    context = SmartLootContext.Create(player?.ArchetypeId, ...)   │
    │    result = _smartLootService.SelectItem(context)                │
    │    drop = LootDrop.CreateFrom(result, player?.ArchetypeId)       │
    │    drops.Add(drop)                                               │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  STEP 7: RETURN DROPS                                            │
    ├──────────────────────────────────────────────────────────────────┤
    │  Return drops                                                    │
    └──────────────────────────────────────────────────────────────────┘
```

### 3.3 Integration Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  CombatView                                                          │
│  └── Displays loot drops with "Class Appropriate" indicator         │
│                                                                      │
│  LootNotificationPanel                                               │
│  └── Shows WasClassAppropriate badge on drops                       │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                      CombatService                             │  │
│  ├───────────────────────────────────────────────────────────────┤  │
│  │  OnMonsterDefeated(monster, player)                           │  │
│  │    └── _lootService.GenerateLoot(monster, player)             │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼                                       │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                   LootService (MODIFIED)                       │  │
│  ├───────────────────────────────────────────────────────────────┤  │
│  │  + GenerateLoot(monster, player?): IReadOnlyList<LootDrop>    │  │
│  │  + GenerateLoot(context): IReadOnlyList<LootDrop>             │  │
│  │  + CreateWeightedPool(table, tier): WeightedItemPool          │  │
│  │  + ApplyBiomeModifiers(pool, biome): void                     │  │
│  │                                                               │  │
│  │  Dependencies:                                                │  │
│  │  - ISmartLootService (v0.16.3b)                               │  │
│  │  - IEquipmentClassMappingProvider (v0.16.3a)                  │  │
│  │  - ILootTableProvider (existing)                              │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼                                       │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │                   SmartLootService                             │  │
│  │                  (from v0.16.3b)                               │  │
│  └───────────────────────────────────────────────────────────────┘  │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │                   LootDrop (MODIFIED)                           ││
│  │                     (Value Object)                               ││
│  ├─────────────────────────────────────────────────────────────────┤│
│  │  Existing Properties:                                           ││
│  │    ItemId: string                                               ││
│  │    ItemName: string                                             ││
│  │    QualityTier: QualityTier                                     ││
│  │    Quantity: int                                                ││
│  │                                                                 ││
│  │  NEW Properties:                                                ││
│  │    WasClassAppropriate: bool        ← from SmartLootResult      ││
│  │    PlayerArchetypeId: string?       ← player context            ││
│  │    SelectionReason: string          ← debug/display info        ││
│  │    BiasRoll: int                    ← for debugging             ││
│  ├─────────────────────────────────────────────────────────────────┤│
│  │  + CreateFrom(result, archetypeId): LootDrop                    ││
│  │  + CreateRandom(item, tier): LootDrop (no player context)       ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                      │
│  Uses from v0.16.3b-c:                                              │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐  │
│  │ SmartLootContext │  │ SmartLootResult  │  │ WeightedItemPool │  │
│  └──────────────────┘  └──────────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 4. LootDrop Value Object Updates

### 4.1 Purpose

The `LootDrop` value object is enhanced with smart loot metadata, enabling tracking and display of class-appropriate drops.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/LootDrop.cs` (MODIFIED)

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Represents a single loot drop from combat or exploration.
/// </summary>
/// <remarks>
/// <para>
/// LootDrop contains all information about a dropped item, including
/// its identity, quality, quantity, and smart loot metadata.
/// </para>
/// <para>
/// The WasClassAppropriate flag indicates whether the item was selected
/// from the class-appropriate pool (60% path) or random pool (40% path).
/// </para>
/// </remarks>
/// <param name="ItemId">Unique identifier for the item.</param>
/// <param name="ItemName">Display name of the item.</param>
/// <param name="CategoryId">Equipment category (e.g., "axes", "daggers").</param>
/// <param name="QualityTier">Quality tier of the drop.</param>
/// <param name="Quantity">Number of items dropped (default 1).</param>
/// <param name="WasClassAppropriate">True if selected from class-filtered pool.</param>
/// <param name="PlayerArchetypeId">Archetype used for generation, or null.</param>
/// <param name="SelectionReason">Human-readable selection explanation.</param>
/// <param name="BiasRoll">The bias roll (0-99) for debugging.</param>
public readonly record struct LootDrop(
    string ItemId,
    string ItemName,
    string CategoryId,
    QualityTier QualityTier,
    int Quantity,
    bool WasClassAppropriate,
    string? PlayerArchetypeId,
    string SelectionReason,
    int BiasRoll)
{
    /// <summary>
    /// Gets whether this drop was generated with player context.
    /// </summary>
    public bool HasPlayerContext => !string.IsNullOrWhiteSpace(PlayerArchetypeId);

    /// <summary>
    /// Gets whether the bias roll favored class selection.
    /// </summary>
    public bool BiasRollFavoredClass => BiasRoll >= 0 && BiasRoll < 60;

    /// <summary>
    /// Gets whether this was a random selection (no player or 40% path).
    /// </summary>
    public bool WasRandomSelection => !WasClassAppropriate;

    /// <summary>
    /// Creates a LootDrop from a SmartLootResult.
    /// </summary>
    /// <param name="result">The smart loot selection result.</param>
    /// <param name="playerArchetypeId">The player's archetype, or null.</param>
    /// <param name="qualityTier">The quality tier for this drop.</param>
    /// <param name="quantity">Number of items dropped.</param>
    public static LootDrop CreateFrom(
        SmartLootResult result,
        string? playerArchetypeId,
        QualityTier qualityTier,
        int quantity = 1)
    {
        if (!result.HasSelection)
            throw new InvalidOperationException("Cannot create LootDrop from empty result.");

        var item = result.SelectedItem!;

        return new LootDrop(
            item.ItemId,
            item.ItemName,
            item.CategoryId,
            qualityTier,
            quantity,
            result.WasClassAppropriate,
            playerArchetypeId,
            result.SelectionReason,
            result.BiasRoll);
    }

    /// <summary>
    /// Creates a LootDrop for random selection (no player context).
    /// </summary>
    /// <param name="item">The selected loot entry.</param>
    /// <param name="qualityTier">The quality tier for this drop.</param>
    /// <param name="quantity">Number of items dropped.</param>
    public static LootDrop CreateRandom(
        LootEntry item,
        QualityTier qualityTier,
        int quantity = 1)
    {
        ArgumentNullException.ThrowIfNull(item);

        return new LootDrop(
            item.ItemId,
            item.ItemName,
            item.CategoryId,
            qualityTier,
            quantity,
            WasClassAppropriate: false,
            PlayerArchetypeId: null,
            SelectionReason: "Random selection (no player context)",
            BiasRoll: -1);
    }

    /// <summary>
    /// Creates a display string for debug/logging.
    /// </summary>
    public override string ToString() =>
        $"{ItemName} ({QualityTier}) x{Quantity}" +
        (WasClassAppropriate ? " [Class Appropriate]" : "");
}
```

---

## 5. LootService Enhancements

### 5.1 Purpose

The `LootService` is enhanced to integrate with `ISmartLootService` and `WeightedItemPool` for intelligent loot generation.

### 5.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/LootService.cs` (MODIFIED)

```csharp
namespace RuneAndRust.Application.Services;

using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using Microsoft.Extensions.Logging;

/// <summary>
/// Generates loot drops from monsters and containers.
/// </summary>
/// <remarks>
/// <para>
/// LootService integrates with the smart loot system (v0.16.3) to bias
/// drops toward class-appropriate equipment when a player context is available.
/// </para>
/// <para>
/// Without player context, the service falls back to pure random selection.
/// </para>
/// </remarks>
public class LootService : ILootService
{
    private readonly ISmartLootService _smartLootService;
    private readonly ILootTableProvider _lootTableProvider;
    private readonly IEquipmentClassMappingProvider _mappingProvider;
    private readonly ILogger<LootService> _logger;
    private readonly Random _random;

    /// <summary>
    /// Initializes a new instance of LootService.
    /// </summary>
    public LootService(
        ISmartLootService smartLootService,
        ILootTableProvider lootTableProvider,
        IEquipmentClassMappingProvider mappingProvider,
        ILogger<LootService> logger)
    {
        _smartLootService = smartLootService ?? throw new ArgumentNullException(nameof(smartLootService));
        _lootTableProvider = lootTableProvider ?? throw new ArgumentNullException(nameof(lootTableProvider));
        _mappingProvider = mappingProvider ?? throw new ArgumentNullException(nameof(mappingProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _random = new Random();
    }

    /// <summary>
    /// Generates loot drops from a defeated monster.
    /// </summary>
    /// <param name="monster">The defeated monster.</param>
    /// <param name="player">The player who defeated the monster, or null.</param>
    /// <returns>List of generated loot drops.</returns>
    public IReadOnlyList<LootDrop> GenerateLoot(Monster monster, Player? player = null)
    {
        ArgumentNullException.ThrowIfNull(monster);

        _logger.LogInformation(
            "Generating loot for monster {MonsterId} (Player: {PlayerArchetype})",
            monster.Id, player?.ArchetypeId ?? "None");

        // Get loot table
        var lootTable = _lootTableProvider.GetTable(monster.LootTableId);
        if (lootTable == null || lootTable.Entries.Count == 0)
        {
            _logger.LogDebug("No loot table found for monster {MonsterId}", monster.Id);
            return Array.Empty<LootDrop>();
        }

        // Determine drop parameters
        var dropCount = CalculateDropCount(monster);
        var qualityTier = DetermineQualityTier(monster.Level);

        _logger.LogDebug(
            "Generating {DropCount} drops at tier {QualityTier}",
            dropCount, qualityTier);

        // Build weighted pool
        var pool = CreateWeightedPool(lootTable, qualityTier);
        if (!pool.HasSelectableItems)
        {
            _logger.LogWarning(
                "No selectable items in pool for tier {QualityTier}", qualityTier);
            return Array.Empty<LootDrop>();
        }

        // Apply biome modifiers if applicable
        var biome = GetCurrentBiome();
        if (biome != null)
        {
            ApplyBiomeModifiers(pool, biome);
        }

        // Generate drops
        var drops = new List<LootDrop>();
        for (var i = 0; i < dropCount; i++)
        {
            var drop = GenerateSingleDrop(pool, player, qualityTier);
            if (drop.HasValue)
            {
                drops.Add(drop.Value);
            }
        }

        _logger.LogInformation(
            "Generated {DropCount} loot drops for monster {MonsterId} " +
            "(ClassAppropriate: {ClassCount})",
            drops.Count, monster.Id, drops.Count(d => d.WasClassAppropriate));

        return drops.AsReadOnly();
    }

    /// <summary>
    /// Generates a single loot drop using smart loot.
    /// </summary>
    private LootDrop? GenerateSingleDrop(
        WeightedItemPool pool,
        Player? player,
        QualityTier qualityTier)
    {
        // Convert pool items to LootEntry list for SmartLootContext
        var availableItems = pool.Items
            .Where(i => i.IsSelectable)
            .Select(i => i.Item)
            .ToList();

        if (availableItems.Count == 0)
        {
            return null;
        }

        // Create smart loot context
        var context = player != null
            ? SmartLootContext.Create(
                player.ArchetypeId,
                qualityTier,
                availableItems)
            : SmartLootContext.CreateRandomOnly(qualityTier, availableItems);

        // Select item
        var result = _smartLootService.SelectItem(context);

        if (!result.HasSelection)
        {
            _logger.LogWarning("SmartLootService returned empty result");
            return null;
        }

        _logger.LogDebug(
            "Selected {ItemId}: ClassAppropriate={IsAppropriate}, Roll={Roll}",
            result.SelectedItem!.ItemId,
            result.WasClassAppropriate,
            result.BiasRoll);

        return LootDrop.CreateFrom(result, player?.ArchetypeId, qualityTier);
    }

    /// <summary>
    /// Creates a weighted item pool from a loot table.
    /// </summary>
    /// <param name="lootTable">The loot table to convert.</param>
    /// <param name="qualityTier">The quality tier for filtering.</param>
    /// <returns>A weighted pool of items.</returns>
    public WeightedItemPool CreateWeightedPool(LootTable lootTable, QualityTier qualityTier)
    {
        ArgumentNullException.ThrowIfNull(lootTable);

        var pool = WeightedItemPool.Create();

        foreach (var entry in lootTable.Entries)
        {
            // Skip items not available at this tier
            if (entry.MinTier > qualityTier || entry.MaxTier < qualityTier)
            {
                continue;
            }

            var weightedItem = WeightedItem.Create(
                entry.ToLootEntry(),
                entry.Weight,
                entry.Rarity);

            pool.Add(weightedItem);
        }

        _logger.LogDebug(
            "Created weighted pool with {ItemCount} items (TotalWeight={TotalWeight})",
            pool.ItemCount, pool.TotalWeight);

        return pool;
    }

    /// <summary>
    /// Applies biome-specific weight modifiers to a pool.
    /// </summary>
    /// <param name="pool">The pool to modify.</param>
    /// <param name="biome">The current biome.</param>
    public void ApplyBiomeModifiers(WeightedItemPool pool, Biome biome)
    {
        // Biome modifiers are applied by adjusting weights
        // Implementation depends on existing biome modifier system
        _logger.LogDebug(
            "Applied biome modifiers for {BiomeName} to pool",
            biome.Name);
    }

    /// <summary>
    /// Calculates the number of items to drop.
    /// </summary>
    private int CalculateDropCount(Monster monster)
    {
        // Base drop count from monster definition
        var baseCount = monster.DropCount ?? 1;

        // Could add luck modifiers, challenge bonuses, etc.
        return Math.Max(1, baseCount);
    }

    /// <summary>
    /// Determines quality tier from monster level.
    /// </summary>
    private QualityTier DetermineQualityTier(int monsterLevel)
    {
        // Tier thresholds (from v0.16.0)
        return monsterLevel switch
        {
            < 5 => QualityTier.Scavenged,
            < 10 => QualityTier.HandForged,
            < 20 => QualityTier.ClanForged,
            < 35 => QualityTier.MasterCrafted,
            < 50 => QualityTier.RuneEtched,
            _ => QualityTier.LegendaryArtifact
        };
    }

    /// <summary>
    /// Gets the current biome (from game state).
    /// </summary>
    private Biome? GetCurrentBiome()
    {
        // Implementation depends on game state management
        return null; // Placeholder
    }
}
```

---

## 6. Monster Death Integration

### 6.1 Integration Point

**File:** `src/Core/RuneAndRust.Application/Services/CombatService.cs` (reference)

```csharp
/// <summary>
/// Handles monster defeat and loot generation.
/// </summary>
/// <param name="monster">The defeated monster.</param>
/// <param name="player">The player who won.</param>
private async Task OnMonsterDefeated(Monster monster, Player player)
{
    _logger.LogInformation(
        "Monster {MonsterName} defeated by {PlayerName}",
        monster.Name, player.Name);

    // Generate loot using smart loot system
    var lootDrops = _lootService.GenerateLoot(monster, player);

    // Add drops to player inventory or ground
    foreach (var drop in lootDrops)
    {
        await _inventoryService.AddLoot(player, drop);

        // Notify UI of the drop
        _eventBus.Publish(new LootDroppedEvent(drop, monster.Position));
    }

    // Track statistics
    _statisticsService.RecordLootDrops(lootDrops);
}
```

### 6.2 Event Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MONSTER DEATH EVENT FLOW                          │
└─────────────────────────────────────────────────────────────────────┘

    Combat ends → Monster.Health <= 0
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  CombatService.OnMonsterDefeated(monster, player)                │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  _lootService.GenerateLoot(monster, player)                      │
    ├──────────────────────────────────────────────────────────────────┤
    │  Returns: IReadOnlyList<LootDrop>                                │
    │    - LootDrop { "Runed Axe", WasClassAppropriate=true, ... }    │
    │    - LootDrop { "Health Potion", WasClassAppropriate=true, ... } │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  FOR EACH drop:                                                  │
    │    _inventoryService.AddLoot(player, drop)                       │
    │    _eventBus.Publish(LootDroppedEvent)                          │
    └──────────────────────────────────────────────────────────────────┘
           │
           ▼
    ┌──────────────────────────────────────────────────────────────────┐
    │  UI receives LootDroppedEvent                                    │
    │    → Displays drop notification                                  │
    │    → Shows "Class Appropriate" badge if WasClassAppropriate     │
    └──────────────────────────────────────────────────────────────────┘
```

---

## 7. Data Model Changes

### 7.1 Modified Types Summary

| Type          | Layer       | Change Type | Changes                |
| ------------- | ----------- | ----------- | ---------------------- |
| `LootDrop`    | Domain      | Modified    | +4 new properties      |
| `LootService` | Application | Modified    | Smart loot integration |

### 7.2 LootDrop Property Changes

| Property              | Type        | Status  | Description                   |
| --------------------- | ----------- | ------- | ----------------------------- |
| `ItemId`              | string      | Exists  | Unchanged                     |
| `ItemName`            | string      | Exists  | Unchanged                     |
| `CategoryId`          | string      | Exists  | Unchanged                     |
| `QualityTier`         | QualityTier | Exists  | Unchanged                     |
| `Quantity`            | int         | Exists  | Unchanged                     |
| `WasClassAppropriate` | bool        | **NEW** | From SmartLootResult          |
| `PlayerArchetypeId`   | string?     | **NEW** | Archetype used for generation |
| `SelectionReason`     | string      | **NEW** | Debug/display explanation     |
| `BiasRoll`            | int         | **NEW** | The 0-99 roll for debugging   |

### 7.3 LootService Method Changes

| Method                  | Status       | Changes                      |
| ----------------------- | ------------ | ---------------------------- |
| `GenerateLoot()`        | **Modified** | Uses SmartLootService        |
| `CreateWeightedPool()`  | **NEW**      | Builds pool from loot table  |
| `ApplyBiomeModifiers()` | **NEW**      | Applies biome weight changes |

---

## 8. Logging Specifications

### 8.1 Log Levels by Component

| Component     | Level       | Events                                   |
| ------------- | ----------- | ---------------------------------------- |
| `LootService` | Information | Loot generated, drop count, class stats  |
| `LootService` | Debug       | Individual drop selection, pool creation |
| `LootService` | Warning     | No loot table, empty pool                |
| `LootService` | Error       | Generation failure                       |

### 8.2 Log Message Templates

```csharp
// Information - Loot generation started
_logger.LogInformation(
    "Generating loot for monster {MonsterId} (Player: {PlayerArchetype})",
    monster.Id, player?.ArchetypeId ?? "None");

// Information - Generation complete
_logger.LogInformation(
    "Generated {DropCount} loot drops for monster {MonsterId} " +
    "(ClassAppropriate: {ClassCount})",
    drops.Count, monster.Id, drops.Count(d => d.WasClassAppropriate));

// Debug - Pool creation
_logger.LogDebug(
    "Created weighted pool with {ItemCount} items (TotalWeight={TotalWeight})",
    pool.ItemCount, pool.TotalWeight);

// Debug - Item selected
_logger.LogDebug(
    "Selected {ItemId}: ClassAppropriate={IsAppropriate}, Roll={Roll}",
    result.SelectedItem!.ItemId, result.WasClassAppropriate, result.BiasRoll);

// Warning - No loot table
_logger.LogWarning(
    "No loot table found for monster {MonsterId}", monster.Id);
```

---

## 9. Unit Testing Requirements

### 9.1 Test Count by Feature

| Feature          | Test Count |
| ---------------- | ---------- |
| LootDrop Updates | ~1         |
| LootService      | ~3         |
| **Total**        | **~4**     |

### 9.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/LootDropTests.cs`

```csharp
[TestFixture]
public class LootDropTests
{
    [Test]
    public void CreateFrom_WithSmartLootResult_SetsAllProperties()
    {
        // Arrange
        var item = new LootEntry("axe-01", "Runed Axe", "axes");
        var result = SmartLootResult.CreateClassAppropriate(
            item, biasRoll: 35, filteredPoolSize: 5, totalPoolSize: 20);

        // Act
        var drop = LootDrop.CreateFrom(result, "warrior", QualityTier.ClanForged);

        // Assert
        drop.ItemId.Should().Be("axe-01");
        drop.ItemName.Should().Be("Runed Axe");
        drop.WasClassAppropriate.Should().BeTrue();
        drop.PlayerArchetypeId.Should().Be("warrior");
        drop.BiasRoll.Should().Be(35);
        drop.HasPlayerContext.Should().BeTrue();
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/LootServiceTests.cs`

```csharp
[TestFixture]
public class LootServiceTests
{
    private Mock<ISmartLootService> _mockSmartLootService;
    private Mock<ILootTableProvider> _mockLootTableProvider;
    private Mock<IEquipmentClassMappingProvider> _mockMappingProvider;
    private LootService _lootService;

    [SetUp]
    public void Setup()
    {
        _mockSmartLootService = new Mock<ISmartLootService>();
        _mockLootTableProvider = new Mock<ILootTableProvider>();
        _mockMappingProvider = new Mock<IEquipmentClassMappingProvider>();

        _lootService = new LootService(
            _mockSmartLootService.Object,
            _mockLootTableProvider.Object,
            _mockMappingProvider.Object,
            Mock.Of<ILogger<LootService>>());
    }

    [Test]
    public void GenerateLoot_WithPlayer_UsesSmartLootWithArchetype()
    {
        // Arrange
        var monster = CreateTestMonster(level: 15);
        var player = CreateTestPlayer(archetypeId: "warrior");
        SetupLootTable(monster.LootTableId);
        SetupSmartLootResult(wasClassAppropriate: true);

        // Act
        var drops = _lootService.GenerateLoot(monster, player);

        // Assert
        drops.Should().NotBeEmpty();
        drops[0].PlayerArchetypeId.Should().Be("warrior");
        _mockSmartLootService.Verify(
            s => s.SelectItem(It.Is<SmartLootContext>(
                c => c.PlayerArchetypeId == "warrior")),
            Times.AtLeastOnce);
    }

    [Test]
    public void GenerateLoot_WithoutPlayer_UsesRandomOnly()
    {
        // Arrange
        var monster = CreateTestMonster(level: 10);
        SetupLootTable(monster.LootTableId);
        SetupSmartLootResult(wasClassAppropriate: false);

        // Act
        var drops = _lootService.GenerateLoot(monster, player: null);

        // Assert
        drops.Should().NotBeEmpty();
        drops[0].HasPlayerContext.Should().BeFalse();
        drops[0].WasClassAppropriate.Should().BeFalse();
    }

    [Test]
    public void GenerateLoot_NoLootTable_ReturnsEmpty()
    {
        // Arrange
        var monster = CreateTestMonster(level: 5);
        _mockLootTableProvider
            .Setup(p => p.GetTable(It.IsAny<string>()))
            .Returns((LootTable?)null);

        // Act
        var drops = _lootService.GenerateLoot(monster);

        // Assert
        drops.Should().BeEmpty();
    }

    [Test]
    public void GenerateLoot_AppliesBiomeModifiers_WhenPresent()
    {
        // Arrange
        var monster = CreateTestMonster(level: 20);
        var player = CreateTestPlayer(archetypeId: "mystic");
        SetupLootTable(monster.LootTableId);
        SetupSmartLootResult(wasClassAppropriate: true);
        // Biome modifier test setup...

        // Act
        var drops = _lootService.GenerateLoot(monster, player);

        // Assert
        drops.Should().NotBeEmpty();
        // Verify biome modifiers were applied...
    }
}
```

---

## 10. Use Cases

### UC-001: Generate Loot from Monster Death

**Actor:** Combat System  
**Precondition:** Monster defeated, player is victor  
**Flow:** Monster dies → Call GenerateLoot(monster, player) → Smart loot selects items → Return LootDrops with class-appropriate flags  
**Postcondition:** Player receives loot biased toward their class

### UC-002: Generate Loot Without Player Context

**Actor:** World Spawn System  
**Precondition:** Container or world loot needs generation  
**Flow:** Trigger event → Call GenerateLoot(source, null) → Random selection used → Return LootDrops  
**Postcondition:** Loot generated without class bias

### UC-003: Track Class-Appropriate Statistics

**Actor:** Analytics System  
**Precondition:** Multiple loot drops generated  
**Flow:** Collect all LootDrops → Count WasClassAppropriate=true → Calculate percentage  
**Postcondition:** Verify 60% target is being achieved

### UC-004: Display Class-Appropriate Badge

**Actor:** UI System  
**Precondition:** LootDroppedEvent received  
**Flow:** Check drop.WasClassAppropriate → If true, show badge → Display item  
**Postcondition:** Player sees which drops match their build

---

## 11. Deliverable Checklist

### Domain Layer

- [ ] `LootDrop` updated with new properties
- [ ] `LootDrop.CreateFrom()` factory method added
- [ ] `LootDrop.CreateRandom()` factory method added

### Application Layer

- [ ] `LootService` updated with smart loot integration
- [ ] `LootService.CreateWeightedPool()` method added
- [ ] `LootService.ApplyBiomeModifiers()` method added

### Integration

- [ ] CombatService calls LootService.GenerateLoot() on monster death
- [ ] LootDroppedEvent includes WasClassAppropriate for UI

### Testing

- [ ] ~4 unit tests implemented
- [ ] All tests passing

### Documentation

- [ ] XML documentation on all modified types
- [ ] Inline comments for integration logic

---

## 12. Acceptance Criteria

### Functional

- [ ] `GenerateLoot()` uses smart loot when player is provided
- [ ] `GenerateLoot()` falls back to random without player
- [ ] `WasClassAppropriate` flag set correctly on all drops
- [ ] `PlayerArchetypeId` captured for loot statistics
- [ ] Biome modifiers applied when present
- [ ] Empty pool returns empty drop list (no errors)

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~4 tests pass
- [ ] XML documentation complete on all modifications
- [ ] Code follows established patterns from v0.16.3a-c

---

## 13. Dependencies

### 13.1 Required from Previous Versions

| Type                             | Location               | Usage in this phase           |
| -------------------------------- | ---------------------- | ----------------------------- |
| `EquipmentClassAffinity`         | Domain/Enums           | Class checking (via provider) |
| `EquipmentClassMapping`          | Domain/ValueObjects    | Class checking (via provider) |
| `IEquipmentClassMappingProvider` | Application/Interfaces | Category-to-affinity lookup   |
| `SmartLootContext`               | Domain/ValueObjects    | Service input                 |
| `SmartLootResult`                | Domain/ValueObjects    | Service output                |
| `ISmartLootService`              | Application/Interfaces | Smart selection               |
| `WeightedItem`                   | Domain/ValueObjects    | Pool item representation      |
| `WeightedItemPool`               | Domain/Entities        | Weighted selection pool       |
| `QualityTier`                    | Domain/Enums           | Drop quality                  |
| `LootEntry`                      | Domain/Entities        | Existing item data            |
| `LootTable`                      | Domain/Entities        | Existing loot definitions     |

### 13.2 Provides to Future Phases

| Type                       | Usage                               |
| -------------------------- | ----------------------------------- |
| Enhanced `LootDrop`        | v0.16.3e: Stat verification         |
| Enhanced `LootService`     | v0.16.4: Container loot integration |
| `WasClassAppropriate` flag | UI display, analytics, achievements |

---

## 14. Future Considerations

### 14.1 Deferred to v0.16.3e

- **Stat Verification Service**: Validating generated items have tier-appropriate stats

### 14.2 Deferred to v0.16.4

- **Container Loot**: Applying smart loot to chests, crates, and containers

### 14.3 Deferred to v0.16.5

- **Unique Items**: Special single-drop legendary items with guaranteed properties

### 14.4 Out of Scope

- **UI Class-Appropriate Badge**: Visual indicator on drops (UI team)
- **Loot Trade System**: Sharing drops between players (multiplayer)
- **Pity Timer**: Guaranteed class drop after N misses (future consideration)

---

_Document Version: 1.0_  
_Last Updated: 2026-01-27_  
_Author: Assistant_
