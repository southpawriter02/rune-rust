# v0.6.3a Design Specification: Command History

**Version:** 0.6.3a
**Parent:** v0.6.3 (Input Enhancements)
**Prerequisites:** v0.6.2b Complete (Combat Animations)
**Status:** Design Complete

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ICommandHistoryService Interface](#4-icommandhistoryservice-interface)
5. [CommandHistoryService Implementation](#5-commandhistoryservice-implementation)
6. [InputHandler Integration](#6-inputhandler-integration)
7. [Data Model](#7-data-model)
8. [Configuration](#8-configuration)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Dependencies](#14-dependencies)
15. [Future Considerations](#15-future-considerations)

---

## 1. Executive Summary

### Purpose

The Command History system provides arrow key navigation through previously entered commands. This quality-of-life feature enables quick repetition of commands without retyping, reducing input errors and speeding up gameplay. The history stores commands in-memory during a session with configurable size limits and duplicate handling.

### Key Deliverables

| Category | Items |
|----------|-------|
| **Interfaces** | ICommandHistoryService |
| **Services** | CommandHistoryService |
| **Updates** | InputHandler arrow key support |
| **Configuration** | input.json (commandHistory section) |
| **Tests** | ~10 new unit tests |

### Architectural Significance

This version establishes the **Input Enhancement Pattern** for improving user interaction:
- Session-based command recall
- Navigation state management
- Current input preservation during navigation
- Configurable history behavior

---

## 2. Feature Overview

```
v0.6.3a Features
├── ICommandHistoryService Interface
│   ├── Add() - Store command
│   ├── GetPrevious() - Up arrow
│   ├── GetNext() - Down arrow
│   ├── ResetNavigation() - Reset position
│   ├── Count property
│   ├── MaxSize property
│   ├── Clear()
│   └── GetAll()
├── CommandHistoryService Implementation
│   ├── In-memory history storage
│   ├── Configurable max size (default 100)
│   ├── Duplicate handling (move to front)
│   ├── Empty command exclusion
│   ├── Navigation index tracking
│   └── Current input preservation
├── InputHandler Integration
│   ├── Up arrow key detection
│   ├── Down arrow key detection
│   ├── History recall display
│   └── Input field update
└── Configuration
    ├── enabled setting
    ├── maxEntries setting
    ├── excludeEmpty setting
    └── moveDuplicatesToFront setting
```

---

## 3. Architecture Diagrams

### 3.1 Command History Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                  COMMAND HISTORY ARCHITECTURE                        │
└─────────────────────────────────────────────────────────────────────┘

    User Input                   History Service              Display
    ──────────                   ───────────────              ───────

    [Enter "attack skeleton"] ──────────┐
                                        │
                               ┌────────▼────────────────┐
                               │  CommandHistoryService  │
                               ├─────────────────────────┤
                               │  History:               │
                               │    [0] "attack skeleton"│◄── Most recent
                               │    [1] "look"           │
                               │    [2] "inventory"      │
                               │    [3] "go north"       │
                               │    ...                  │
                               │  CurrentIndex: -1       │◄── -1 = new input
                               └─────────────────────────┘
    
    [UP ARROW] ─────────────────────────▶ CurrentIndex: 0
                                         ──────────────────▶ "attack skeleton"
    
    [UP ARROW] ─────────────────────────▶ CurrentIndex: 1
                                         ──────────────────▶ "look"
    
    [DOWN ARROW] ───────────────────────▶ CurrentIndex: 0
                                         ──────────────────▶ "attack skeleton"
    
    [DOWN ARROW] ───────────────────────▶ CurrentIndex: -1
                                         ──────────────────▶ "" (empty/new)
```

### 3.2 History Navigation State

```
┌─────────────────────────────────────────────────────────────────────┐
│                    HISTORY NAVIGATION STATE                          │
└─────────────────────────────────────────────────────────────────────┘

    History Array (newest first):
    ┌─────────────────────────────────────────────────────────────────┐
    │  Index   │  Command              │  Description                 │
    ├──────────┼───────────────────────┼──────────────────────────────┤
    │    0     │  "attack skeleton"    │  Most recent                 │
    │    1     │  "look"               │                              │
    │    2     │  "inventory"          │                              │
    │    3     │  "go north"           │  Oldest                      │
    └─────────────────────────────────────────────────────────────────┘

    _currentIndex Values:
    ┌─────────────────────────────────────────────────────────────────┐
    │  Value   │  Meaning                                             │
    ├──────────┼──────────────────────────────────────────────────────┤
    │   -1     │  New input mode (no history selected)                │
    │    0     │  Viewing most recent command                         │
    │    1     │  Viewing second most recent                          │
    │   ...    │  ...                                                 │
    │  Count-1 │  Viewing oldest command                              │
    └─────────────────────────────────────────────────────────────────┘


    Navigation Flow:
    
            _currentIndex = -1 (new)
                    │
                    │ [UP ARROW]
                    ▼
            _currentIndex = 0 ◄──┐
                    │            │
                    │ [UP]       │ [DOWN]
                    ▼            │
            _currentIndex = 1 ───┘
                    │
                    │ [UP]
                    ▼
            _currentIndex = 2
                    │
                    │ ... (to Count-1, then stays)
                    ▼
            _currentIndex = Count-1 (oldest, stays here on UP)
```

### 3.3 Input Preservation Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                   INPUT PRESERVATION FLOW                            │
└─────────────────────────────────────────────────────────────────────┘

    User is typing:
    ┌─────────────────────────────────────────────────────┐
    │ > atta_                                             │
    └─────────────────────────────────────────────────────┘
    
    [UP ARROW pressed]
    ┌─────────────────────────────────────────────────────┐
    │ _tempInput = "atta"  ← Save current input           │
    │ _currentIndex = 0                                   │
    │ Return history[0] → "go north"                      │
    └─────────────────────────────────────────────────────┘
    
    Display shows:
    ┌─────────────────────────────────────────────────────┐
    │ > go north_                                         │
    └─────────────────────────────────────────────────────┘
    
    [DOWN ARROW pressed (back to new)]
    ┌─────────────────────────────────────────────────────┐
    │ _currentIndex = -1                                  │
    │ Return _tempInput → "atta"                          │
    │ _tempInput = null                                   │
    └─────────────────────────────────────────────────────┘
    
    Display shows (original restored):
    ┌─────────────────────────────────────────────────────┐
    │ > atta_                                             │
    └─────────────────────────────────────────────────────┘
```

---

## 4. ICommandHistoryService Interface

### 4.1 ICommandHistoryService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ICommandHistoryService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Manages command history for input recall via arrow keys.
/// </summary>
public interface ICommandHistoryService
{
    /// <summary>
    /// Adds a command to history.
    /// </summary>
    /// <remarks>
    /// Empty commands are ignored. Duplicates are moved to front.
    /// </remarks>
    /// <param name="command">The command text to add.</param>
    void Add(string command);
    
    /// <summary>
    /// Gets the previous command in history (up arrow).
    /// </summary>
    /// <returns>Previous command, or null if at oldest.</returns>
    string? GetPrevious();
    
    /// <summary>
    /// Gets the next command in history (down arrow).
    /// </summary>
    /// <returns>Next command, or null/empty if at newest.</returns>
    string? GetNext();
    
    /// <summary>
    /// Resets navigation to the end (new command position).
    /// </summary>
    /// <remarks>
    /// Called after a command is executed or when starting fresh.
    /// </remarks>
    void ResetNavigation();
    
    /// <summary>
    /// Saves the current input before navigating history.
    /// </summary>
    /// <param name="currentInput">The partially typed input to preserve.</param>
    void SaveCurrentInput(string currentInput);
    
    /// <summary>
    /// Gets the current history count.
    /// </summary>
    int Count { get; }
    
    /// <summary>
    /// Gets the maximum history size.
    /// </summary>
    int MaxSize { get; }
    
    /// <summary>
    /// Gets whether currently navigating history.
    /// </summary>
    bool IsNavigating { get; }
    
    /// <summary>
    /// Clears all history.
    /// </summary>
    void Clear();
    
    /// <summary>
    /// Gets all commands in history (newest first).
    /// </summary>
    IReadOnlyList<string> GetAll();
}
```

---

## 5. CommandHistoryService Implementation

### 5.1 CommandHistoryService Class

**File:** `src/Core/RuneAndRust.Application/Services/CommandHistoryService.cs`

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Manages command history with navigation support.
/// </summary>
public class CommandHistoryService : ICommandHistoryService
{
    private readonly List<string> _history = new();
    private readonly ILogger<CommandHistoryService> _logger;
    private readonly CommandHistorySettings _settings;
    
    private int _currentIndex = -1;
    private string? _tempInput;
    
    public int Count => _history.Count;
    public int MaxSize => _settings.MaxEntries;
    public bool IsNavigating => _currentIndex >= 0;
    
    public CommandHistoryService(
        IOptions<CommandHistorySettings> settings,
        ILogger<CommandHistoryService> logger)
    {
        _settings = settings.Value;
        _logger = logger;
    }
    
    /// <inheritdoc />
    public void Add(string command)
    {
        if (!_settings.Enabled) return;
        
        if (string.IsNullOrWhiteSpace(command))
        {
            if (_settings.ExcludeEmpty)
            {
                _logger.LogDebug("Empty command excluded from history");
                return;
            }
        }
        
        var trimmedCommand = command.Trim();
        
        // Handle duplicates
        if (_settings.MoveDuplicatesToFront)
        {
            var existingIndex = _history.IndexOf(trimmedCommand);
            if (existingIndex >= 0)
            {
                _history.RemoveAt(existingIndex);
                _logger.LogDebug("Duplicate command '{Command}' moved to front", 
                    trimmedCommand);
            }
        }
        else if (_history.Contains(trimmedCommand))
        {
            _logger.LogDebug("Duplicate command '{Command}' not added", 
                trimmedCommand);
            ResetNavigation();
            return;
        }
        
        // Add to front (most recent)
        _history.Insert(0, trimmedCommand);
        
        // Trim to max size
        while (_history.Count > MaxSize)
        {
            var removed = _history[^1];
            _history.RemoveAt(_history.Count - 1);
            _logger.LogDebug("History exceeded max size, removed oldest: '{Command}'", 
                removed);
        }
        
        _logger.LogDebug("Added command to history: '{Command}'. Total: {Count}", 
            trimmedCommand, _history.Count);
        
        ResetNavigation();
    }
    
    /// <inheritdoc />
    public string? GetPrevious()
    {
        if (_history.Count == 0)
        {
            return null;
        }
        
        if (_currentIndex < _history.Count - 1)
        {
            _currentIndex++;
            _logger.LogDebug("History navigated to index {Index}: '{Command}'", 
                _currentIndex, _history[_currentIndex]);
            return _history[_currentIndex];
        }
        
        // Already at oldest, stay there
        _logger.LogDebug("At oldest history entry, staying at index {Index}", 
            _currentIndex);
        return _history[_currentIndex];
    }
    
    /// <inheritdoc />
    public string? GetNext()
    {
        if (_currentIndex > 0)
        {
            _currentIndex--;
            _logger.LogDebug("History navigated to index {Index}: '{Command}'", 
                _currentIndex, _history[_currentIndex]);
            return _history[_currentIndex];
        }
        
        if (_currentIndex == 0)
        {
            // Move back to new input
            _currentIndex = -1;
            var restored = _tempInput ?? "";
            _tempInput = null;
            
            _logger.LogDebug("Returned to new input, restored: '{Input}'", restored);
            return restored;
        }
        
        // Already at new input position
        return null;
    }
    
    /// <inheritdoc />
    public void ResetNavigation()
    {
        _currentIndex = -1;
        _tempInput = null;
        _logger.LogDebug("History navigation reset");
    }
    
    /// <inheritdoc />
    public void SaveCurrentInput(string currentInput)
    {
        if (_currentIndex == -1)
        {
            _tempInput = currentInput;
            _logger.LogDebug("Saved current input for restoration: '{Input}'", 
                currentInput);
        }
    }
    
    /// <inheritdoc />
    public void Clear()
    {
        _history.Clear();
        ResetNavigation();
        _logger.LogInformation("Command history cleared");
    }
    
    /// <inheritdoc />
    public IReadOnlyList<string> GetAll()
    {
        return _history.AsReadOnly();
    }
}
```

### 5.2 CommandHistorySettings Record

**File:** `src/Core/RuneAndRust.Application/Configuration/CommandHistorySettings.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Settings for command history behavior.
/// </summary>
public record CommandHistorySettings
{
    /// <summary>
    /// Gets or sets whether command history is enabled.
    /// </summary>
    public bool Enabled { get; init; } = true;
    
    /// <summary>
    /// Gets or sets the maximum number of history entries.
    /// </summary>
    public int MaxEntries { get; init; } = 100;
    
    /// <summary>
    /// Gets or sets whether to exclude empty commands.
    /// </summary>
    public bool ExcludeEmpty { get; init; } = true;
    
    /// <summary>
    /// Gets or sets whether to move duplicates to front instead of ignoring.
    /// </summary>
    public bool MoveDuplicatesToFront { get; init; } = true;
}
```

---

## 6. InputHandler Integration

### 6.1 InputHandler Updates

**File:** `src/Presentation/RuneAndRust.TUI/Input/InputHandler.cs` (modifications)

```csharp
namespace RuneAndRust.Presentation.Input;

/// <summary>
/// Handles user input with history navigation support.
/// </summary>
public class InputHandler
{
    private readonly ICommandHistoryService _historyService;
    private readonly ITerminalService _terminal;
    private readonly ILogger<InputHandler> _logger;
    
    private string _currentInput = "";
    private int _cursorPosition = 0;
    
    public InputHandler(
        ICommandHistoryService historyService,
        ITerminalService terminal,
        ILogger<InputHandler> logger)
    {
        _historyService = historyService;
        _terminal = terminal;
        _logger = logger;
    }
    
    /// <summary>
    /// Reads a line of input with history support.
    /// </summary>
    /// <returns>The entered command, or null if cancelled.</returns>
    public string? ReadLine()
    {
        _currentInput = "";
        _cursorPosition = 0;
        
        while (true)
        {
            var key = Console.ReadKey(intercept: true);
            
            switch (key.Key)
            {
                case ConsoleKey.Enter:
                    return HandleEnter();
                
                case ConsoleKey.UpArrow:
                    HandleUpArrow();
                    break;
                
                case ConsoleKey.DownArrow:
                    HandleDownArrow();
                    break;
                
                case ConsoleKey.Backspace:
                    HandleBackspace();
                    break;
                
                case ConsoleKey.Delete:
                    HandleDelete();
                    break;
                
                case ConsoleKey.LeftArrow:
                    HandleLeftArrow();
                    break;
                
                case ConsoleKey.RightArrow:
                    HandleRightArrow();
                    break;
                
                case ConsoleKey.Home:
                    HandleHome();
                    break;
                
                case ConsoleKey.End:
                    HandleEnd();
                    break;
                
                case ConsoleKey.Escape:
                    return HandleEscape();
                
                default:
                    if (!char.IsControl(key.KeyChar))
                    {
                        HandleCharacter(key.KeyChar);
                    }
                    break;
            }
        }
    }
    
    private string HandleEnter()
    {
        var command = _currentInput.Trim();
        
        if (!string.IsNullOrEmpty(command))
        {
            _historyService.Add(command);
        }
        
        _historyService.ResetNavigation();
        _terminal.WriteLine("");
        
        return command;
    }
    
    private void HandleUpArrow()
    {
        // Save current input before first navigation
        if (!_historyService.IsNavigating)
        {
            _historyService.SaveCurrentInput(_currentInput);
        }
        
        var previous = _historyService.GetPrevious();
        if (previous != null)
        {
            SetInput(previous);
            _logger.LogDebug("Recalled from history: '{Command}'", previous);
        }
    }
    
    private void HandleDownArrow()
    {
        var next = _historyService.GetNext();
        if (next != null)
        {
            SetInput(next);
            _logger.LogDebug("Navigated forward to: '{Command}'", next);
        }
    }
    
    private void SetInput(string text)
    {
        // Clear current input display
        ClearInputLine();
        
        // Set new input
        _currentInput = text;
        _cursorPosition = text.Length;
        
        // Display new input
        _terminal.Write(text);
    }
    
    private void ClearInputLine()
    {
        _terminal.SetCursorPosition(0, Console.CursorTop);
        _terminal.Write(new string(' ', _currentInput.Length + 2)); // +2 for prompt
        _terminal.SetCursorPosition(0, Console.CursorTop);
        _terminal.Write("> ");
    }
    
    private void HandleCharacter(char c)
    {
        // If navigating history, any character input resets navigation
        if (_historyService.IsNavigating)
        {
            _historyService.ResetNavigation();
        }
        
        if (_cursorPosition < _currentInput.Length)
        {
            _currentInput = _currentInput.Insert(_cursorPosition, c.ToString());
        }
        else
        {
            _currentInput += c;
        }
        
        _cursorPosition++;
        RefreshInputDisplay();
    }
    
    private void HandleBackspace()
    {
        if (_cursorPosition > 0)
        {
            _currentInput = _currentInput.Remove(_cursorPosition - 1, 1);
            _cursorPosition--;
            RefreshInputDisplay();
        }
    }
    
    private void HandleDelete()
    {
        if (_cursorPosition < _currentInput.Length)
        {
            _currentInput = _currentInput.Remove(_cursorPosition, 1);
            RefreshInputDisplay();
        }
    }
    
    private void HandleLeftArrow()
    {
        if (_cursorPosition > 0)
        {
            _cursorPosition--;
            _terminal.SetCursorPosition(_cursorPosition + 2, Console.CursorTop);
        }
    }
    
    private void HandleRightArrow()
    {
        if (_cursorPosition < _currentInput.Length)
        {
            _cursorPosition++;
            _terminal.SetCursorPosition(_cursorPosition + 2, Console.CursorTop);
        }
    }
    
    private void HandleHome()
    {
        _cursorPosition = 0;
        _terminal.SetCursorPosition(2, Console.CursorTop);
    }
    
    private void HandleEnd()
    {
        _cursorPosition = _currentInput.Length;
        _terminal.SetCursorPosition(_cursorPosition + 2, Console.CursorTop);
    }
    
    private string? HandleEscape()
    {
        _historyService.ResetNavigation();
        return null;
    }
    
    private void RefreshInputDisplay()
    {
        ClearInputLine();
        _terminal.Write(_currentInput);
        _terminal.SetCursorPosition(_cursorPosition + 2, Console.CursorTop);
    }
}
```

---

## 7. Data Model

### 7.1 New Interfaces

| Interface | Layer | Description |
|-----------|-------|-------------|
| `ICommandHistoryService` | Application | History management interface |

### 7.2 New Services

| Service | Layer | Description |
|---------|-------|-------------|
| `CommandHistoryService` | Application | History implementation |

### 7.3 New Records

| Record | Layer | Description |
|--------|-------|-------------|
| `CommandHistorySettings` | Application | Configuration options |

### 7.4 Modified Components

| Component | Layer | Modifications |
|-----------|-------|---------------|
| `InputHandler` | Presentation | Arrow key handling, history integration |

---

## 8. Configuration

### 8.1 input.json (commandHistory section)

**File:** `config/input.json`

```json
{
  "$schema": "./schemas/input.schema.json",
  "commandHistory": {
    "enabled": true,
    "maxEntries": 100,
    "excludeEmpty": true,
    "moveDuplicatesToFront": true
  }
}
```

### 8.2 Configuration Schema

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | bool | true | Enable/disable history feature |
| `maxEntries` | int | 100 | Maximum commands to store |
| `excludeEmpty` | bool | true | Don't store empty commands |
| `moveDuplicatesToFront` | bool | true | Move duplicates to front vs ignore |

---

## 9. Logging Specifications

### 9.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `CommandHistoryService` | Debug | Add, navigate, save, reset |
| `CommandHistoryService` | Information | Clear |
| `InputHandler` | Debug | Recall, navigate |

### 9.2 Log Message Templates

```csharp
// CommandHistoryService
_logger.LogDebug("Empty command excluded from history");
_logger.LogDebug("Duplicate command '{Command}' moved to front", command);
_logger.LogDebug("Added command to history: '{Command}'. Total: {Count}", 
    command, count);
_logger.LogDebug("History navigated to index {Index}: '{Command}'", 
    index, command);
_logger.LogDebug("At oldest history entry, staying at index {Index}", index);
_logger.LogDebug("Returned to new input, restored: '{Input}'", input);
_logger.LogDebug("History navigation reset");
_logger.LogDebug("Saved current input for restoration: '{Input}'", input);
_logger.LogInformation("Command history cleared");

// InputHandler
_logger.LogDebug("Recalled from history: '{Command}'", command);
_logger.LogDebug("Navigated forward to: '{Command}'", command);
```

---

## 10. Unit Testing Requirements

### 10.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| CommandHistoryService Add | 3 |
| CommandHistoryService Navigation | 4 |
| CommandHistoryService Settings | 2 |
| InputHandler Integration | 1 |
| **Total** | **~10** |

### 10.2 Test Specifications

#### CommandHistoryServiceTests.cs

```csharp
[TestFixture]
public class CommandHistoryServiceTests
{
    // Add Tests
    [Test]
    public void Add_ValidCommand_AddsToHistory();
    
    [Test]
    public void Add_EmptyCommand_ExcludedWhenConfigured();
    
    [Test]
    public void Add_DuplicateCommand_MovedToFront();
    
    // Navigation Tests
    [Test]
    public void GetPrevious_ReturnsOlderCommand();
    
    [Test]
    public void GetPrevious_AtOldest_StaysAtOldest();
    
    [Test]
    public void GetNext_ReturnsNewerCommand();
    
    [Test]
    public void GetNext_AtNewest_ReturnsToNewInput();
    
    // Settings Tests
    [Test]
    public void Add_ExceedsMaxSize_RemovesOldest();
    
    [Test]
    public void SaveCurrentInput_PreservesAndRestores();
}
```

#### InputHandlerHistoryTests.cs

```csharp
[TestFixture]
public class InputHandlerHistoryTests
{
    [Test]
    public void HandleUpArrow_RecallsFromHistory();
}
```

---

## 11. Use Cases

### UC-001: Recall Previous Command
**Actor:** Player
**Flow:** Player presses Up arrow → GetPrevious() called → Previous command appears in input field

### UC-002: Navigate History Forward
**Actor:** Player
**Flow:** Player views history → Presses Down arrow → GetNext() called → Next command or empty shown

### UC-003: Return to New Input
**Actor:** Player
**Flow:** Player in history → Presses Down at newest → Returns to blank/preserved input

### UC-004: Execute Recalled Command
**Actor:** Player
**Flow:** Recall command via Up → Press Enter → Command executes → Add() called → Navigation reset

### UC-005: Preserve Partial Input
**Actor:** Player
**Flow:** Player typing "att" → Presses Up → Views history → Presses Down → "att" restored

---

## 12. Deliverable Checklist

### ICommandHistoryService Interface
- [ ] `ICommandHistoryService` interface created
- [ ] Add() method defined
- [ ] GetPrevious() method defined
- [ ] GetNext() method defined
- [ ] ResetNavigation() method defined
- [ ] SaveCurrentInput() method defined
- [ ] Count property defined
- [ ] MaxSize property defined
- [ ] IsNavigating property defined
- [ ] Clear() method defined
- [ ] GetAll() method defined

### CommandHistoryService Implementation
- [ ] `CommandHistoryService` class created
- [ ] In-memory history storage
- [ ] Add() with duplicate handling
- [ ] Add() with max size enforcement
- [ ] GetPrevious() navigation
- [ ] GetNext() navigation
- [ ] ResetNavigation() implementation
- [ ] SaveCurrentInput() implementation
- [ ] Clear() implementation
- [ ] GetAll() implementation

### Configuration
- [ ] `CommandHistorySettings` record created
- [ ] `config/input.json` commandHistory section

### InputHandler Updates
- [ ] Up arrow handling
- [ ] Down arrow handling
- [ ] History service integration
- [ ] Input preservation on navigation
- [ ] Navigation reset on Enter

### Testing
- [ ] ~10 unit tests implemented
- [ ] All tests passing

---

## 13. Acceptance Criteria

### Functional
- [ ] Commands are added to history on Enter
- [ ] Up arrow recalls previous command
- [ ] Down arrow moves forward in history
- [ ] Down arrow at end returns to new input
- [ ] History has configurable max size (default 100)
- [ ] Oldest commands removed when max exceeded
- [ ] Duplicates are moved to front (not duplicated)
- [ ] Empty commands are not added when configured
- [ ] Current input is preserved when navigating
- [ ] Preserved input restored when returning to new
- [ ] History navigation resets after command execution
- [ ] History can be disabled via configuration
- [ ] Clear() removes all history entries

### Quality
- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~10 unit tests pass
- [ ] XML documentation complete on all public members

---

## 14. Dependencies

### Required from Prior Versions

| Type | Location | Usage |
|------|----------|-------|
| `ITerminalService` | `Application/Interfaces/ITerminalService.cs` | Console ops |
| `InputHandler` | `Presentation/Input/InputHandler.cs` | Base to modify |

### Provides to v0.6.3b

| Type | Usage |
|------|-------|
| `InputHandler` (updated) | Tab completion will extend |
| Input enhancement pattern | Similar navigation structure |

---

## 15. Future Considerations

### Deferred to v0.6.3b
- **Tab Completion**: Auto-complete for commands, items, targets

### Deferred to Future
- **Persistent History**: Save history across sessions
- **History Search**: Ctrl+R style reverse search
- **History File**: Export/import history
- **Command Aliases**: History-based auto-aliases

### Out of Scope
- **Multi-line Commands**: History for multi-line input
- **Command Macros**: Stored command sequences

---

## Display Examples

### History Navigation

```
USAGE EXAMPLE:
──────────────

1. User types and executes commands:
   > attack skeleton     [Enter]  → Added to history
   > look               [Enter]  → Added to history  
   > inventory          [Enter]  → Added to history
   > go north           [Enter]  → Added to history

   History: ["go north", "inventory", "look", "attack skeleton"]
            (newest first)

2. User navigates with arrow keys:
   > _                          ← Current input (empty)
   
   [UP ARROW]
   > go north                   ← Recalled from history
   
   [UP ARROW]
   > inventory                  ← Previous command
   
   [UP ARROW]
   > look                       ← Previous command
   
   [DOWN ARROW]
   > inventory                  ← Move forward
   
   [DOWN ARROW]
   > go north                   ← Move forward
   
   [DOWN ARROW]
   > _                          ← Back to empty (new)


DUPLICATE HANDLING:
───────────────────

History: ["go north", "inventory", "look"]

User types: > look [Enter]

History becomes: ["look", "go north", "inventory"]
                 (look moved to front, not duplicated)


CURRENT INPUT PRESERVATION:
───────────────────────────

> atta_                         ← User typing (cursor at _)

[UP ARROW]
> go north                      ← History recalled

[DOWN ARROW]  
> atta_                         ← Original input restored!
```

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Assistant*
