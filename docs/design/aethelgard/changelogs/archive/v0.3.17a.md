# Changelog: v0.3.17a - The Console (Overlay UI)

**Release Date:** 2025-12-25

---

## Summary

v0.3.17a introduces a Quake-style debug console overlay accessible from any game phase via the `~` or `debug` command. This implementation establishes the foundation for developer tooling by providing a scrolling log buffer with command history navigation, built-in console commands, and a modal rendering loop using Spectre.Console. The architecture employs interface abstraction (IDebugConsoleRenderer in Core layer) to enable the Engine layer's CommandParser to trigger the console without creating a circular dependency on the Terminal layer. Thread-safe buffer management prepares the service for future integration with Serilog sinks and background logging. This release focuses exclusively on console infrastructure; cheat command execution (heal, god mode, teleport) is deferred to v0.3.17b.

Key architectural patterns introduced: Service abstraction for cross-layer communication, bounded buffer collections with automatic pruning (50 log entries, 20 command history), and modal input loops with raw keypress interception.

---

## New Files Created

### Core Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IDebugConsoleService.cs` | Defines the debug console state management contract with properties for visibility, log history, and command history. Specifies buffer limits (50 logs, 20 commands). |
| `RuneAndRust.Core/Interfaces/IDebugConsoleRenderer.cs` | Abstracts the console rendering layer, allowing Engine layer to trigger modal console loop without depending on Terminal layer implementation. |

### Engine Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/DebugConsoleService.cs` | Thread-safe implementation of IDebugConsoleService with lock-based synchronization for concurrent log access. Manages bounded log buffer and command history with automatic oldest-entry removal. |

### Terminal Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Terminal/Rendering/DebugConsoleRenderer.cs` | Implements IDebugConsoleRenderer using Spectre.Console for rendering. Provides modal input loop with Console.ReadKey for raw keyboard interception, supporting Enter, Backspace, Up/Down arrow navigation, Escape, and Tilde (~) keys. Renders 15 visible log lines with color-coded output. |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Engine/DebugConsoleServiceTests.cs` | Unit test suite validating toggle behavior, log formatting, buffer limit enforcement, command history, and clear operations. 12 tests with FluentAssertions and NSubstitute mocking. |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Engine/Services/CommandParser.cs` | Added field `_debugConsoleRenderer` (IDebugConsoleRenderer?). Updated constructor to accept optional `debugConsoleRenderer` parameter. Inserted phase-agnostic command interception at lines 303-316 to handle `~` and `debug` commands before phase-specific routing. |
| `RuneAndRust.Terminal/Program.cs` | Registered IDebugConsoleService and IDebugConsoleRenderer as Singleton services at lines 212-214 in dependency injection container. |

---

## Code Implementation Details

### IDebugConsoleService Interface

**Properties:**
- `bool IsVisible { get; }` - Current visibility state of debug console
- `IReadOnlyList<string> LogHistory { get; }` - Thread-safe read-only view of log buffer (max 50 entries)
- `IReadOnlyList<string> CommandHistory { get; }` - Thread-safe read-only view of command history (max 20 entries)

**Methods:**
```csharp
void Toggle()
void WriteLog(string message, string source = "System")
void SubmitCommand(string command)
void ClearLog()
```

**Behaviors:**
- LogHistory limited to 50 entries; oldest removed when exceeded
- CommandHistory limited to 20 entries; oldest removed when exceeded
- Default log source is "System" when not specified
- Empty/whitespace commands ignored by SubmitCommand

---

### IDebugConsoleRenderer Interface

**Methods:**
```csharp
void Run()
```

**Behaviors:**
- Runs modal console loop, blocking until user exits with ~ or Escape
- Handles all keyboard input and rendering internally

---

### DebugConsoleService Implementation

**Constants:**
- `MaxLogHistory = 50` - Maximum log buffer size
- `MaxCommandHistory = 20` - Maximum command history size

**Thread Safety:**
- Uses `lock (_lock)` pattern for all buffer access
- LogHistory and CommandHistory properties create defensive copies with `.ToList().AsReadOnly()`

**Log Entry Format:**
```
[HH:mm:ss] [Source] Message
```

**Key Behaviors:**
- Toggle() flips IsVisible and logs state change at Trace level
- WriteLog() formats entry with timestamp, adds to buffer, prunes if needed
- SubmitCommand() ignores null/empty input, logs at Debug level, writes to log with [User] source, adds to command history
- ClearLog() empties log buffer but preserves command history
- All operations log state changes via ILogger<DebugConsoleService>

**Dependency Injection:**
```csharp
public DebugConsoleService(ILogger<DebugConsoleService> logger)
```

---

### DebugConsoleRenderer Implementation

**Constants:**
- `VisibleLogLines = 15` - Number of log lines displayed in viewport

**Keyboard Handling:**
| Key | Behavior |
|-----|----------|
| Enter | Submit current input buffer, clear buffer, reset history index |
| Backspace | Remove last character from input buffer |
| Up Arrow | Navigate backward through command history (oldest to newest) |
| Down Arrow | Navigate forward through command history (newest back to current) |
| Escape / Tilde (~) | Close console and toggle visibility |
| Printable characters | Append to input buffer |

**Rendering Behavior:**
- Clears screen on each render cycle
- Displays Rule header with "[bold yellow]DEBUG CONSOLE[/]" in purple border
- Shows last 15 log entries from buffer
- Pads empty space to maintain consistent layout
- Displays input line with "> " prompt and blinking cursor
- Escapes markup to prevent injection

**Color Coding:**
| Log Source | Color |
|------------|-------|
| [User] | cyan |
| [Error] | red |
| [System] | grey |

**Built-in Commands (v0.3.17a):**
| Command | Action |
|---------|--------|
| help | Display available commands |
| clear | Clear log buffer (preserves command history) |
| exit | Close debug console |
| ~ | Close debug console |
| (other) | Display "Unknown command" error with help hint |

**Dependency Injection:**
```csharp
public DebugConsoleRenderer(IDebugConsoleService console)
```

**Startup Message:**
```
"Debug Console activated. Type 'help' for commands, '~' to exit."
```

---

### CommandParser Modifications

**New Field:**
```csharp
private readonly IDebugConsoleRenderer? _debugConsoleRenderer;
```

**Updated Constructor Signature:**
```csharp
public CommandParser(
    ILogger<CommandParser> logger,
    IInputHandler inputHandler,
    GameState gameState,
    IJournalService? journalService = null,
    ICombatService? combatService = null,
    IVictoryScreenRenderer? victoryRenderer = null,
    IRestService? restService = null,
    IRestScreenRenderer? restRenderer = null,
    IRoomRepository? roomRepository = null,
    IDebugConsoleRenderer? debugConsoleRenderer = null)  // NEW
```

**Phase-Agnostic Command Interception (lines 303-316):**
```csharp
// v0.3.17a: Debug console toggle (works in any phase)
if (command == "~" || command == "debug")
{
    if (_debugConsoleRenderer != null)
    {
        _logger.LogTrace("[DEBUG] Opening debug console");
        _debugConsoleRenderer.Run();
    }
    else
    {
        _inputHandler.DisplayError("Debug console not available.");
    }
    return ParseResult.None;
}
```

**Behavior:**
- Command check occurs before phase-specific switch statement
- Returns ParseResult.None to prevent further command processing
- Handles null renderer gracefully with error message
- Supports both `~` and `debug` aliases

---

## Logging Matrix

### DebugConsoleService

| Event | Level | Template |
|-------|-------|----------|
| Toggle visibility | Trace | `"[DEBUG] Console visibility set to {State}"` |
| Command submission | Debug | `"[DEBUG] User submitted: {Command}"` |
| Clear log buffer | Trace | `"[DEBUG] Log buffer cleared"` |

### CommandParser

| Event | Level | Template |
|-------|-------|----------|
| Open debug console | Trace | `"[DEBUG] Opening debug console"` |

---

## Test Coverage

**Summary:**
```
Total: 12 | Passed: 12 | Failed: 0 | Duration: 50ms
```

### Complete Test Inventory

#### DebugConsoleServiceTests (12 tests)

| Test Name | Description |
|-----------|-------------|
| Toggle_SwitchesVisibilityFalseToTrue | Verifies initial state is false and Toggle() sets to true |
| Toggle_SwitchesVisibilityTrueToFalse | Verifies Toggle() can switch from true back to false |
| WriteLog_AddsEntryToHistory | Confirms log entry is added to LogHistory collection |
| WriteLog_FormatsEntryWithTimestampAndSource | Validates regex pattern `\[\d{2}:\d{2}:\d{2}\]` and source/message presence |
| WriteLog_UsesDefaultSourceWhenNotSpecified | Asserts default "[System]" source when no source parameter provided |
| WriteLog_MaintainsBufferLimit_RemovesOldest | Adds 55 entries, confirms buffer capped at 50, validates "Message 6" is first and "Message 55" is last |
| SubmitCommand_AddsToCommandHistory | Confirms command added to CommandHistory collection |
| SubmitCommand_WritesToLogWithUserSource | Verifies log entry created with "[User]" source |
| SubmitCommand_IgnoresEmptyInput | Tests empty string, whitespace, and null inputs are ignored (no history/log entries) |
| CommandHistory_MaintainsLimit_RemovesOldest | Adds 25 commands, confirms buffer capped at 20, validates "command6" is first and "command25" is last |
| ClearLog_EmptiesLogBuffer | Verifies LogHistory.Count becomes 0 after ClearLog() |
| ClearLog_DoesNotClearCommandHistory | Confirms CommandHistory remains intact after ClearLog() |

**Mocking Strategy:**
- Uses NSubstitute to create `ILogger<DebugConsoleService>` mock
- No actual logging verification performed (state-based testing only)

**Assertion Library:**
- FluentAssertions for expressive assertions (`.Should().BeTrue()`, `.Should().HaveCount()`, etc.)

---

## DI Registration

**Location:** `RuneAndRust.Terminal/Program.cs` (lines 212-214)

```csharp
// Register Debug Console Services (v0.3.17a)
services.AddSingleton<IDebugConsoleService, DebugConsoleService>();
services.AddSingleton<IDebugConsoleRenderer, DebugConsoleRenderer>();
```

**Lifetime:**
- Singleton - Both services registered as Singleton to maintain state across game phases
- Singleton ensures log history and command history persist for entire application lifetime

**Justification:**
- Console state should persist across all game phases
- Log buffer accumulates entries from multiple phases
- Command history should be available across entire session

---

## Verification Results

### Build Output

```
Build succeeded.

    1 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.13
```

**Note:** Warning MSB3277 related to EntityFrameworkCore.Relational version conflict (9.0.1 vs 9.0.4) does not impact debug console functionality.

### Test Output

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
A total of 1 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:    12, Skipped:     0, Total:    12, Duration: 50 ms
```

---

## Directory Structure After Release

```
RuneAndRust.Core/
├── Interfaces/
│   ├── IDebugConsoleService.cs       [NEW]
│   └── IDebugConsoleRenderer.cs      [NEW]

RuneAndRust.Engine/
└── Services/
    ├── CommandParser.cs              [MODIFIED]
    └── DebugConsoleService.cs        [NEW]

RuneAndRust.Terminal/
├── Program.cs                        [MODIFIED]
└── Rendering/
    └── DebugConsoleRenderer.cs       [NEW]

RuneAndRust.Tests/
└── Engine/
    └── DebugConsoleServiceTests.cs   [NEW]
```

---

## Architecture Decisions

### 1. Interface Abstraction (IDebugConsoleRenderer in Core)

**Decision:** Created IDebugConsoleRenderer in Core layer despite being implemented only in Terminal layer.

**Rationale:**
- Avoids circular dependency: Engine layer's CommandParser needs to trigger console, but Terminal depends on Engine
- Follows Dependency Inversion Principle (DIP): Engine depends on abstraction, Terminal provides implementation
- Enables future alternative renderers (Avalonia UI, web-based, logging-only modes)

**Trade-off:**
- Adds interface in Core that only has one implementation currently
- Accepted because it maintains clean layering and extensibility

---

### 2. Command-Based Toggle vs. Global Hotkey

**Decision:** Console triggered via `~` or `debug` commands, not via raw keypress interception during normal gameplay.

**Rationale:**
- IInputHandler.GetInput() uses blocking Spectre.Console TextPrompt with no raw keypress access
- Adding global hotkey would require refactoring entire input system to use Console.ReadKey() throughout
- Command-based approach follows existing patterns (OptionsController also uses commands like "options")
- Minimal implementation cost for v0.3.17a

**Trade-off:**
- Less seamless than traditional ~ hotkey in other games
- User must type command and press Enter rather than single keypress
- Accepted for rapid prototyping; can be enhanced in future refactoring

**Future Consideration:**
- v0.4.x may refactor input system to support raw keypress interception
- Would enable instant console toggle with single ~ keypress

---

### 3. Thread-Safe Buffer with Lock Pattern

**Decision:** Used `lock (_lock)` synchronization in DebugConsoleService for all buffer access.

**Rationale:**
- Prepares for future Serilog sink integration that may write from background threads
- Defensive copies (`.ToList().AsReadOnly()`) prevent external mutation of collections
- Minimal performance impact for 50-entry buffer

**Thread-Safety Guarantees:**
- LogHistory property creates defensive copy under lock
- CommandHistory property creates defensive copy under lock
- WriteLog() atomically adds entry and prunes buffer
- SubmitCommand() uses WriteLog() for thread-safe log writes, then separately locks for command history

**Trade-off:**
- Slightly higher memory allocation due to defensive copies
- Accepted because buffer sizes are small (50 logs, 20 commands)

---

### 4. Bounded Buffers with Automatic Pruning

**Decision:** Log buffer capped at 50 entries, command history at 20 entries, both with automatic oldest-removal.

**Rationale:**
- Prevents unbounded memory growth during long play sessions
- 50 logs provide sufficient context (15 visible + 35 scrollback)
- 20 commands cover typical debug session workflow
- Simplifies memory management (no manual cleanup needed)

**Implementation:**
```csharp
if (_logHistory.Count > MaxLogHistory)
{
    _logHistory.RemoveAt(0);  // Remove oldest
}
```

**Trade-off:**
- Loses historical log data beyond 50 entries
- Accepted because debug console is for live debugging, not audit trail
- Serilog file sink provides persistent logging for audit purposes

---

### 5. Modal Rendering Loop Pattern

**Decision:** DebugConsoleRenderer.Run() blocks in modal loop until user exits, similar to OptionsController.

**Rationale:**
- Consistent with existing UI pattern in project
- Simplifies state management (no concurrent UI updates)
- Matches user expectation (console is focused overlay, not background window)

**Implementation:**
```csharp
while (_console.IsVisible)
{
    RenderConsoleScreen(inputBuffer);
    var key = Console.ReadKey(intercept: true);
    // ... process key ...
}
```

**Trade-off:**
- Blocks game loop while console is open
- Accepted because debug console is developer tool, not player-facing feature

---

### 6. Built-in Commands Only (v0.3.17a)

**Decision:** v0.3.17a implements only console management commands (help, clear, exit), deferring cheat commands to v0.3.17b.

**Rationale:**
- Separates console infrastructure from game state manipulation
- Enables testing of rendering, input, and buffer management independently
- Reduces scope for initial release

**Deferred to v0.3.17b:**
- `/heal` - Restore player HP to max
- `/god` - Toggle invincibility
- `/tp <room>` - Teleport to specified room
- `/spawn <enemy>` - Spawn enemy for combat testing
- `/reveal` - Reveal all map locations

**Architectural Impact:**
- v0.3.17b will require DebugConsoleRenderer to inject game services (IPlayerService, ICombatService, etc.)
- May introduce ICheatCommandExecutor service to separate command parsing from game logic

---

## Running Tests

### Run All Debug Console Tests
```bash
dotnet test --filter "FullyQualifiedName~DebugConsoleServiceTests"
```

### Run Specific Test
```bash
dotnet test --filter "FullyQualifiedName~WriteLog_MaintainsBufferLimit_RemovesOldest"
```

### Run All Tests (Project-Wide)
```bash
dotnet test
```

---

## Next Steps

### v0.3.17b - The Toolbox (Cheat Command Execution)

- **Parse Cheat Commands**: Extend DebugConsoleRenderer.ProcessCommand() to recognize `/heal`, `/god`, `/tp`, `/spawn`, `/reveal`
- **Inject Game Services**: Add IPlayerService, ICombatService, INavigationService to DebugConsoleRenderer constructor
- **Implement IsGodMode Flag**: Add `bool IsGodMode` to GameState, enforce in CombatService damage calculation
- **Teleport Command**: Implement `/tp <roomId>` to change GameState.CurrentRoomId
- **Spawn Command**: Implement `/spawn <enemyId>` to trigger combat with specified enemy
- **Reveal Command**: Implement `/reveal` to mark all rooms as visited in GameState
- **Write Tests**: Add DebugCheatCommandTests to validate command parsing and game state mutations
- **Update Help Text**: Add cheat command documentation to built-in `help` command output

### v0.3.18 - The Architect (Emergency Save & Crash Recovery)

- **Extend Emergency Save**: Integrate DebugConsoleService log buffer into emergency save payload
- **Crash Report Enhancement**: Include last 50 console log entries in crash reports for debugging
- **Serilog Sink**: Create custom Serilog sink that writes to IDebugConsoleService.WriteLog()
- **Auto-Open on Crash**: Modify CrashService to auto-open debug console on unhandled exceptions

---

## Usage Example

**Opening the Console:**
```
> ~
[DEBUG CONSOLE]
═══════════════════════════════════════════════════════════
[12:34:56] [System] Debug Console activated. Type 'help' for commands, '~' to exit.




(14 more empty lines)


═══════════════════════════════════════════════════════════
> _
```

**Using Help Command:**
```
> help
[12:35:02] [User] help
[12:35:02] [System] Available commands:
[12:35:02] [System]   help  - Show this help message
[12:35:02] [System]   clear - Clear the console log
[12:35:02] [System]   exit  - Close the debug console
[12:35:02] [System]   ~     - Close the debug console
```

**Command History Navigation:**
```
> help                    [Press Enter]
> clear                   [Press Enter]
> [Press Up Arrow]        → Input shows "clear"
> [Press Up Arrow]        → Input shows "help"
> [Press Down Arrow]      → Input shows "clear"
> [Press Down Arrow]      → Input clears (back to current)
```

**Unknown Command:**
```
> invalidcommand
[12:36:10] [User] invalidcommand
[12:36:10] [Error] Unknown command: invalidcommand
[12:36:10] [System] Type 'help' for available commands.
```

**Closing Console:**
```
> ~
[12:36:20] [System] Debug Console closed.
[Returns to previous game phase]
```

---

**End of Changelog v0.3.17a**
