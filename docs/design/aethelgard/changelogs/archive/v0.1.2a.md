> **Archived** - This changelog has been consolidated. See the complete version at [v0.1.2](../v0.1.x/v0.1.2.md).

# Changelog: v0.1.2a - The Burden of Survival (Foundation)

**Release Date:** December 18, 2025
**Total Tests:** 962 (149 new tests for v0.1.2a)

---

## Summary

Version 0.1.2a establishes the **Inventory System Foundation** - a complete data model for items, equipment, and character inventories using Entity Framework Core's Table-per-Hierarchy (TPH) pattern. This release introduces the core persistence layer for item management, quality tiers, equipment mechanics, and weight-based encumbrance calculations.

Key architectural additions:
- **TPH Inheritance Pattern**: Item base entity with Equipment subtype sharing a single database table via discriminator column
- **Quality Tiers**: Five-tier craftsmanship system (JuryRigged → MythForged) affecting stats and rarity
- **Equipment System**: Seven equipment slots with attribute bonuses, requirements, and soak/damage mechanics
- **Join Table Pattern**: InventoryItem entity managing many-to-many character-item relationships with stacking support
- **Burden Mechanics**: Three-tier encumbrance system (Light, Heavy, Overburdened) based on carried weight
- **Repository Layer**: TPH-aware queries for items, equipment, and inventory operations

This sub-version provides the foundational data structures required for loot generation, trading, and equipment management in future releases.

---

## New Files Created

### Core Layer - Enums

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Enums/QualityTier.cs` | Five craftsmanship tiers: JuryRigged(0), Scavenged(1), ClanForged(2), Optimized(3), MythForged(4) |
| `RuneAndRust.Core/Enums/EquipmentSlot.cs` | Seven equipment slots: MainHand, OffHand, Head, Body, Hands, Feet, Accessory |
| `RuneAndRust.Core/Enums/ItemType.cs` | Six item categories: Weapon, Armor, Consumable, Material, KeyItem, Junk |
| `RuneAndRust.Core/Enums/BurdenState.cs` | Three encumbrance states: Light(0), Heavy(1), Overburdened(2) |

### Core Layer - Entities

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Entities/Item.cs` | TPH base entity with identity, description, physical properties, quality, stacking support |
| `RuneAndRust.Core/Entities/Equipment.cs` | TPH subtype extending Item with slot, bonuses, requirements, combat properties |
| `RuneAndRust.Core/Entities/InventoryItem.cs` | Join entity for character-item relationships with quantity, position, equipped state |

### Core Layer - Interfaces

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IItemRepository.cs` | TPH-aware item queries: GetByQuality, GetByType, GetEquipmentBySlot, GetByName |
| `RuneAndRust.Core/Interfaces/IInventoryRepository.cs` | Inventory operations: GetByCharacterId, GetEquippedItems, GetTotalWeight, FindByItemName |

### Persistence Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Persistence/Repositories/ItemRepository.cs` | TPH-aware repository implementation with quality/type/slot filtering |
| `RuneAndRust.Persistence/Repositories/InventoryRepository.cs` | Join table operations with navigation property loading and weight calculations |

### Test Layer

| File | Purpose |
|------|---------|
| `RuneAndRust.Tests/Core/QualityTierTests.cs` | Enum validation (8 tests) |
| `RuneAndRust.Tests/Core/EquipmentSlotTests.cs` | Enum validation (9 tests) |
| `RuneAndRust.Tests/Core/ItemTypeTests.cs` | Enum validation (8 tests) |
| `RuneAndRust.Tests/Core/BurdenStateTests.cs` | Enum validation (7 tests) |
| `RuneAndRust.Tests/Core/ItemTests.cs` | Entity properties, defaults, stacking (15 tests) |
| `RuneAndRust.Tests/Core/EquipmentTests.cs` | TPH inheritance, bonuses, requirements (18 tests) |
| `RuneAndRust.Tests/Core/InventoryItemTests.cs` | Join entity behavior, navigation properties (10 tests) |
| `RuneAndRust.Tests/Integration/ItemPersistenceTests.cs` | TPH CRUD, discriminator queries (20 tests) |
| `RuneAndRust.Tests/Integration/InventoryPersistenceTests.cs` | Join table operations, weight calculations (18 tests) |

---

## Files Modified

| File | Change |
|------|--------|
| `RuneAndRust.Persistence/Data/RuneAndRustDbContext.cs` | Added `DbSet<Item>`, `DbSet<Equipment>`, `DbSet<InventoryItem>`; configured TPH with "ItemDiscriminator" column; added composite key and indexes for InventoryItems; configured JSON serialization for dictionaries |
| `RuneAndRust.Core/Entities/Character.cs` | Added `Inventory` navigation property (ICollection<InventoryItem>); added `EquipmentBonuses` dictionary; added `GetEffectiveAttribute()` method |
| `RuneAndRust.Core/Entities/InteractableObject.cs` | Added `HasBeenSearched` and `LootTier` properties for future loot integration |

---

## Code Implementation Details

### QualityTier Enum

Defines craftsmanship quality with exponential rarity scaling:

```csharp
public enum QualityTier
{
    /// <summary>
    /// Hastily repaired or barely functional equipment.
    /// Common in Safe zones. Lowest stats, prone to breakage.
    /// </summary>
    JuryRigged = 0,

    /// <summary>
    /// Standard salvaged goods recovered from ruins.
    /// The baseline tier found throughout the world.
    /// </summary>
    Scavenged = 1,

    /// <summary>
    /// Properly crafted by Dvergr smiths or equivalent artisans.
    /// Reliable quality with consistent performance.
    /// </summary>
    ClanForged = 2,

    /// <summary>
    /// Pre-Glitch technology or masterwork craftsmanship.
    /// Rare finds in dangerous areas. Superior stats.
    /// </summary>
    Optimized = 3,

    /// <summary>
    /// Legendary artifacts of unknown origin.
    /// Extraordinarily rare. Found only in Lethal zones.
    /// </summary>
    MythForged = 4
}
```

**Quality Progression:** JuryRigged (common) → Scavenged (baseline) → ClanForged (crafted) → Optimized (rare) → MythForged (legendary)

### EquipmentSlot Enum

Seven distinct equipment slots for character loadout:

```csharp
public enum EquipmentSlot
{
    MainHand = 0,    // Primary weapon hand
    OffHand = 1,     // Secondary hand (shields, off-hand weapons, torches)
    Head = 2,        // Helmets, hoods, masks
    Body = 3,        // Armor, robes, jackets
    Hands = 4,       // Gauntlets, gloves, bracers
    Feet = 5,        // Boots, greaves, sandals
    Accessory = 6    // Rings, amulets, belts
}
```

### ItemType Enum

Six functional categories determining item usage:

```csharp
public enum ItemType
{
    Weapon = 0,      // Offensive equipment
    Armor = 1,       // Defensive equipment
    Consumable = 2,  // Single-use items (potions, bandages)
    Material = 3,    // Crafting components
    KeyItem = 4,     // Quest-critical (cannot be dropped/sold)
    Junk = 5         // Salvage for Scrip only
}
```

### BurdenState Enum

Three-tier encumbrance system with movement penalties:

```csharp
public enum BurdenState
{
    /// <summary>
    /// Under 70% capacity. No penalties.
    /// Normal movement and full attribute access.
    /// </summary>
    Light = 0,

    /// <summary>
    /// Between 70% and 90% capacity.
    /// Applies -2 penalty to Finesse attribute.
    /// </summary>
    Heavy = 1,

    /// <summary>
    /// Over 90% capacity.
    /// Cannot move between rooms until weight is reduced.
    /// </summary>
    Overburdened = 2
}
```

**Burden Thresholds:**
- Light: 0-70% capacity (no penalty)
- Heavy: 70-90% capacity (-2 Finesse)
- Overburdened: 90%+ capacity (movement blocked)

### Item Entity (TPH Base)

Base entity for all items with physical properties and quality:

```csharp
public class Item
{
    // Identity
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;
    public ItemType ItemType { get; set; } = ItemType.Junk;

    // Description
    public string Description { get; set; } = string.Empty;
    public string? DetailedDescription { get; set; }

    // Physical Properties
    public int Weight { get; set; } = 0;           // In grams
    public int Value { get; set; } = 0;            // In Scrip

    // Quality
    public QualityTier Quality { get; set; } = QualityTier.Scavenged;

    // Stacking
    public bool IsStackable { get; set; } = false;
    public int MaxStackSize { get; set; } = 1;

    // Metadata
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;
}
```

**Key Behaviors:**
- Weight measured in grams for precision burden calculations
- Value represents Scrip (in-game currency)
- Default quality is Scavenged (tier 1)
- Non-stackable by default (MaxStackSize = 1)

### Equipment Entity (TPH Subtype)

Extends Item with combat properties and attribute modifiers:

```csharp
public class Equipment : Item
{
    // Equipment Properties
    public EquipmentSlot Slot { get; set; } = EquipmentSlot.MainHand;
    public Dictionary<CharacterAttribute, int> AttributeBonuses { get; set; } = new();

    // Combat Properties
    public int SoakBonus { get; set; } = 0;       // Damage reduction (armor)
    public int DamageDie { get; set; } = 0;       // Weapon damage die (0=non-weapon, 6=d6, 8=d8, etc.)

    // Requirements
    public Dictionary<CharacterAttribute, int> Requirements { get; set; } = new();

    // Helper Methods
    public int GetAttributeBonus(CharacterAttribute attribute);
    public bool MeetsRequirements(Character character);
}
```

**Key Behaviors:**
- `GetAttributeBonus()` returns 0 if attribute not in dictionary (TryGetValue pattern)
- `MeetsRequirements()` checks all requirements against character attributes
- `DamageDie` of 0 indicates non-weapon equipment
- `AttributeBonuses` and `Requirements` stored as JSONB in database

### InventoryItem Entity (Join Table)

Join entity managing character-item relationships:

```csharp
public class InventoryItem
{
    // Composite Primary Key
    public Guid CharacterId { get; set; }
    public Guid ItemId { get; set; }

    // Stack Properties
    public int Quantity { get; set; } = 1;
    public int SlotPosition { get; set; } = 0;    // UI ordering

    // Equipment State
    public bool IsEquipped { get; set; } = false;

    // Navigation Properties
    public Character Character { get; set; } = null!;
    public Item Item { get; set; } = null!;

    // Metadata
    public DateTime AddedAt { get; set; } = DateTime.UtcNow;
    public DateTime LastModified { get; set; } = DateTime.UtcNow;
}
```

**Key Behaviors:**
- Composite primary key (CharacterId, ItemId) prevents duplicate entries
- Quantity defaults to 1 for non-stackable items
- SlotPosition enables custom inventory sorting
- IsEquipped only valid for Equipment-type items
- Cascade delete on both Character and Item relationships

### Character Entity Extensions

Added inventory support and effective attribute calculation:

```csharp
// Navigation property for EF Core
public ICollection<InventoryItem> Inventory { get; set; } = new List<InventoryItem>();

// Equipment bonuses currently applied
public Dictionary<CharacterAttribute, int> EquipmentBonuses { get; set; } = new();

// Gets effective attribute including equipment bonuses
public int GetEffectiveAttribute(CharacterAttribute attribute)
{
    var baseValue = GetAttribute(attribute);
    var bonus = EquipmentBonuses.TryGetValue(attribute, out var equipBonus) ? equipBonus : 0;
    return baseValue + bonus;
}
```

**Key Behaviors:**
- `Inventory` collection loaded via navigation property
- `EquipmentBonuses` stored as JSONB in database
- `GetEffectiveAttribute()` combines base attribute + equipment bonus
- Returns base value if no equipment bonus exists

### IItemRepository Interface

TPH-aware repository contract for item operations:

```csharp
public interface IItemRepository : IRepository<Item>
{
    Task<IEnumerable<Item>> GetByQualityAsync(QualityTier quality);
    Task<IEnumerable<Item>> GetByTypeAsync(ItemType itemType);
    Task<Item?> GetByNameAsync(string name);

    // TPH-specific equipment queries
    Task<IEnumerable<Equipment>> GetAllEquipmentAsync();
    Task<IEnumerable<Equipment>> GetEquipmentBySlotAsync(EquipmentSlot slot);

    Task AddRangeAsync(IEnumerable<Item> items);
}
```

**Key Methods:**
- `GetByNameAsync()` uses case-insensitive, trimmed matching
- `GetAllEquipmentAsync()` queries `DbContext.Equipment` directly (TPH filtering)
- `GetEquipmentBySlotAsync()` filters Equipment subtype by slot
- All queries order results by Name alphabetically

### IInventoryRepository Interface

Inventory join table operations:

```csharp
public interface IInventoryRepository
{
    Task<IEnumerable<InventoryItem>> GetByCharacterIdAsync(Guid characterId);
    Task<IEnumerable<InventoryItem>> GetEquippedItemsAsync(Guid characterId);
    Task<InventoryItem?> GetEquippedInSlotAsync(Guid characterId, EquipmentSlot slot);
    Task<InventoryItem?> GetByCharacterAndItemAsync(Guid characterId, Guid itemId);
    Task<InventoryItem?> FindByItemNameAsync(Guid characterId, string itemName);

    // Weight and count calculations
    Task<int> GetTotalWeightAsync(Guid characterId);
    Task<int> GetItemCountAsync(Guid characterId);

    // CRUD operations
    Task AddAsync(InventoryItem inventoryItem);
    Task UpdateAsync(InventoryItem inventoryItem);
    Task RemoveAsync(Guid characterId, Guid itemId);
    Task ClearInventoryAsync(Guid characterId);
    Task SaveChangesAsync();
}
```

**Key Methods:**
- `GetTotalWeightAsync()` uses `SumAsync(ii => ii.Item.Weight * ii.Quantity)`
- `GetEquippedInSlotAsync()` casts Item to Equipment for slot filtering
- `FindByItemNameAsync()` performs case-insensitive search on Item.Name
- `ClearInventoryAsync()` removes all entries and calls SaveChangesAsync

### TPH Database Configuration

Entity Framework Core TPH setup in `RuneAndRustDbContext`:

```csharp
modelBuilder.Entity<Item>(entity =>
{
    entity.ToTable("Items");
    entity.HasKey(i => i.Id);

    // TPH discriminator column
    entity.HasDiscriminator<string>("ItemDiscriminator")
        .HasValue<Item>("Item")
        .HasValue<Equipment>("Equipment");

    // Indexes for efficient queries
    entity.HasIndex(i => i.Name);
    entity.HasIndex(i => i.Quality);
    entity.HasIndex(i => i.ItemType);
});

modelBuilder.Entity<Equipment>(entity =>
{
    entity.Property(e => e.Slot).IsRequired();

    // JSON storage for dictionaries
    entity.Property(e => e.AttributeBonuses)
        .HasColumnType("jsonb")
        .HasConversion(/* JSON serialization */);

    entity.Property(e => e.Requirements)
        .HasColumnType("jsonb")
        .HasConversion(/* JSON serialization */);

    entity.HasIndex(e => e.Slot);
});
```

**TPH Strategy:**
- Single "Items" table contains both Item and Equipment rows
- "ItemDiscriminator" column differentiates types ("Item" or "Equipment")
- Equipment-specific columns (Slot, AttributeBonuses, Requirements) null for base Items
- Indexes on Quality, ItemType, Slot for fast filtering

### InventoryItem Composite Key Configuration

```csharp
modelBuilder.Entity<InventoryItem>(entity =>
{
    entity.ToTable("InventoryItems");

    // Composite primary key
    entity.HasKey(ii => new { ii.CharacterId, ii.ItemId });

    // Relationships with cascade delete
    entity.HasOne(ii => ii.Character)
        .WithMany(c => c.Inventory)
        .HasForeignKey(ii => ii.CharacterId)
        .OnDelete(DeleteBehavior.Cascade);

    entity.HasOne(ii => ii.Item)
        .WithMany()
        .HasForeignKey(ii => ii.ItemId)
        .OnDelete(DeleteBehavior.Cascade);

    // Indexes
    entity.HasIndex(ii => ii.CharacterId);
    entity.HasIndex(ii => ii.IsEquipped);
});
```

---

## Logging Matrix (v0.1.2a)

### ItemRepository Logs

| Event | Level | Template |
|-------|-------|----------|
| Fetch by Quality | Debug | `"Fetching items with quality tier {Quality}"` |
| Retrieved by Quality | Debug | `"Retrieved {Count} items with quality tier {Quality}"` |
| Fetch by Type | Debug | `"Fetching items of type {ItemType}"` |
| Retrieved by Type | Debug | `"Retrieved {Count} items of type {ItemType}"` |
| Fetch Equipment by Slot | Debug | `"Fetching equipment for slot {Slot}"` |
| Retrieved Equipment by Slot | Debug | `"Retrieved {Count} equipment items for slot {Slot}"` |
| Search by Name | Debug | `"Searching for item by name '{ItemName}'"` |
| Item Not Found | Debug | `"Item '{ItemName}' not found"` |
| Item Found | Debug | `"Found item '{ItemName}' ({ItemId})"` |
| Fetch All Equipment | Debug | `"Fetching all equipment items"` |
| Retrieved All Equipment | Debug | `"Retrieved {Count} equipment items"` |
| Add Range | Debug | `"Adding {Count} items to database"` |
| Add Range Complete | Debug | `"Successfully added {Count} items to context"` |

### InventoryRepository Logs

| Event | Level | Template |
|-------|-------|----------|
| Fetch Inventory | Debug | `"Fetching inventory for character {CharacterId}"` |
| Retrieved Inventory | Debug | `"Retrieved {Count} inventory items for character {CharacterId}"` |
| Fetch Equipped Items | Debug | `"Fetching equipped items for character {CharacterId}"` |
| Retrieved Equipped Items | Debug | `"Retrieved {Count} equipped items for character {CharacterId}"` |
| Check Equipped in Slot | Debug | `"Checking equipped item in slot {Slot} for character {CharacterId}"` |
| No Item in Slot | Debug | `"No item equipped in slot {Slot} for character {CharacterId}"` |
| Found Equipped in Slot | Debug | `"Found equipped item '{ItemName}' in slot {Slot}"` |
| Fetch by Character and Item | Debug | `"Fetching inventory entry for character {CharacterId} and item {ItemId}"` |
| Entry Not Found | Debug | `"No inventory entry found for character {CharacterId} and item {ItemId}"` |
| Entry Found | Debug | `"Found inventory entry for item '{ItemName}'"` |
| Search by Item Name | Debug | `"Searching for item '{ItemName}' in inventory of character {CharacterId}"` |
| Item Not in Inventory | Debug | `"Item '{ItemName}' not found in inventory of character {CharacterId}"` |
| Item Found in Inventory | Debug | `"Found item '{ItemName}' in inventory"` |
| Calculate Total Weight | Debug | `"Calculating total inventory weight for character {CharacterId}"` |
| Total Weight Result | Debug | `"Total inventory weight for character {CharacterId}: {Weight}g"` |
| Count Slots | Debug | `"Counting inventory slots for character {CharacterId}"` |
| Slot Count Result | Debug | `"Character {CharacterId} has {Count} inventory slots used"` |
| Add Entry | Debug | `"Adding item {ItemId} to inventory of character {CharacterId}"` |
| Add Complete | Debug | `"Successfully added inventory entry to context"` |
| Update Entry | Debug | `"Updating inventory entry for character {CharacterId} and item {ItemId}"` |
| Update Complete | Debug | `"Successfully updated inventory entry in context"` |
| Remove Entry | Debug | `"Removing item {ItemId} from inventory of character {CharacterId}"` |
| Remove Complete | Debug | `"Successfully marked inventory entry for removal"` |
| Remove Non-Existent | Warning | `"Attempted to remove non-existent inventory entry for character {CharacterId} and item {ItemId}"` |
| Clear Inventory Start | Information | `"Clearing all inventory entries for character {CharacterId}"` |
| Clear Inventory Complete | Information | `"Cleared {Count} inventory entries for character {CharacterId}"` |
| Save Changes | Debug | `"Saving inventory changes to database"` |
| Save Changes Complete | Debug | `"Saved {ChangeCount} inventory changes to database"` |

---

## Complete Test Inventory

### Core/QualityTierTests.cs (8 tests)

| Test Name | Description |
|-----------|-------------|
| `QualityTier_ShouldHaveExactlyFiveValues` | Validates exactly 5 quality tiers exist |
| `QualityTier_ShouldContain_JuryRigged` | JuryRigged value is defined |
| `QualityTier_ShouldContain_Scavenged` | Scavenged value is defined |
| `QualityTier_ShouldContain_ClanForged` | ClanForged value is defined |
| `QualityTier_ShouldContain_Optimized` | Optimized value is defined |
| `QualityTier_ShouldContain_MythForged` | MythForged value is defined |
| `QualityTier_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4 in sequence |
| `QualityTier_ToString_ReturnsExpectedName` | ToString returns correct names (5 theory cases) |
| `QualityTier_Order_ShouldRepresentIncreasingQuality` | Each tier value > previous tier value |

### Core/EquipmentSlotTests.cs (9 tests)

| Test Name | Description |
|-----------|-------------|
| `EquipmentSlot_ShouldHaveExactlySevenValues` | Validates exactly 7 equipment slots exist |
| `EquipmentSlot_ShouldContain_MainHand` | MainHand value is defined |
| `EquipmentSlot_ShouldContain_OffHand` | OffHand value is defined |
| `EquipmentSlot_ShouldContain_Head` | Head value is defined |
| `EquipmentSlot_ShouldContain_Body` | Body value is defined |
| `EquipmentSlot_ShouldContain_Hands` | Hands value is defined |
| `EquipmentSlot_ShouldContain_Feet` | Feet value is defined |
| `EquipmentSlot_ShouldContain_Accessory` | Accessory value is defined |
| `EquipmentSlot_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4,5,6 in sequence |
| `EquipmentSlot_ToString_ReturnsExpectedName` | ToString returns correct names (7 theory cases) |

### Core/ItemTypeTests.cs (8 tests)

| Test Name | Description |
|-----------|-------------|
| `ItemType_ShouldHaveExactlySixValues` | Validates exactly 6 item types exist |
| `ItemType_ShouldContain_Weapon` | Weapon value is defined |
| `ItemType_ShouldContain_Armor` | Armor value is defined |
| `ItemType_ShouldContain_Consumable` | Consumable value is defined |
| `ItemType_ShouldContain_Material` | Material value is defined |
| `ItemType_ShouldContain_KeyItem` | KeyItem value is defined |
| `ItemType_ShouldContain_Junk` | Junk value is defined |
| `ItemType_EnumValues_ShouldBeSequential` | Values are 0,1,2,3,4,5 in sequence |
| `ItemType_ToString_ReturnsExpectedName` | ToString returns correct names (6 theory cases) |

### Core/BurdenStateTests.cs (7 tests)

| Test Name | Description |
|-----------|-------------|
| `BurdenState_ShouldHaveExactlyThreeValues` | Validates exactly 3 burden states exist |
| `BurdenState_ShouldContain_Light` | Light value is defined |
| `BurdenState_ShouldContain_Heavy` | Heavy value is defined |
| `BurdenState_ShouldContain_Overburdened` | Overburdened value is defined |
| `BurdenState_EnumValues_ShouldBeSequential` | Values are 0,1,2 in sequence |
| `BurdenState_ToString_ReturnsExpectedName` | ToString returns correct names (3 theory cases) |
| `BurdenState_Order_ShouldRepresentIncreasingSeverity` | Each state value > previous state value |

### Core/ItemTests.cs (15 tests)

| Test Name | Description |
|-----------|-------------|
| `Item_NewInstance_ShouldHaveUniqueId` | Each instance has unique GUID |
| `Item_DefaultName_ShouldBeEmpty` | Name defaults to empty string |
| `Item_DefaultItemType_ShouldBeJunk` | ItemType defaults to Junk |
| `Item_DefaultDescription_ShouldBeEmpty` | Description defaults to empty string |
| `Item_DetailedDescription_ShouldBeNullByDefault` | DetailedDescription defaults to null |
| `Item_DefaultWeight_ShouldBeZero` | Weight defaults to 0 grams |
| `Item_DefaultValue_ShouldBeZero` | Value defaults to 0 Scrip |
| `Item_DefaultQuality_ShouldBeScavenged` | Quality defaults to Scavenged (tier 1) |
| `Item_DefaultIsStackable_ShouldBeFalse` | IsStackable defaults to false |
| `Item_DefaultMaxStackSize_ShouldBeOne` | MaxStackSize defaults to 1 |
| `Item_CreatedAt_ShouldBeSetOnCreation` | Timestamp set on instantiation |
| `Item_LastModified_ShouldBeSetOnCreation` | LastModified set on instantiation |
| `Item_CanSetAllProperties` | All properties are settable |
| `Item_Weight_CanBeSetToGramValue` | Weight accepts gram values |
| `Item_Stackable_CanBeConfigured` | Stacking properties work together |

### Core/EquipmentTests.cs (18 tests)

| Test Name | Description |
|-----------|-------------|
| `Equipment_InheritsFromItem` | Equipment is subclass of Item (TPH) |
| `Equipment_DefaultSlot_ShouldBeMainHand` | Slot defaults to MainHand |
| `Equipment_AttributeBonuses_ShouldBeEmptyDictionary` | AttributeBonuses initializes to empty dictionary |
| `Equipment_DefaultSoakBonus_ShouldBeZero` | SoakBonus defaults to 0 |
| `Equipment_DefaultDamageDie_ShouldBeZero` | DamageDie defaults to 0 (non-weapon) |
| `Equipment_Requirements_ShouldBeEmptyDictionary` | Requirements initializes to empty dictionary |
| `Equipment_CanAddAttributeBonuses` | Can add bonuses to dictionary |
| `Equipment_CanAddRequirements` | Can add requirements to dictionary |
| `Equipment_GetAttributeBonus_ExistingAttribute_ReturnsBonus` | GetAttributeBonus returns value for existing key |
| `Equipment_GetAttributeBonus_NonExistingAttribute_ReturnsZero` | GetAttributeBonus returns 0 for missing key |
| `Equipment_MeetsRequirements_AllMet_ReturnsTrue` | Returns true when all requirements satisfied |
| `Equipment_MeetsRequirements_OneFails_ReturnsFalse` | Returns false if any requirement not met |
| `Equipment_MeetsRequirements_NoRequirements_ReturnsTrue` | Returns true when requirements dictionary empty |
| `Equipment_Weapon_CanSetDamageDie` | Weapon damage die can be set (d6, d8, d10) |
| `Equipment_Armor_CanSetSoakBonus` | Armor soak bonus can be set |
| `Equipment_Slot_AcceptsAllSlotValues` | All EquipmentSlot values valid (7 theory cases) |
| `Equipment_InheritsItemProperties` | Inherits Name, Quality, Weight, etc. from Item |
| `Equipment_CompleteConfiguration_ShouldSetAllProperties` | Full equipment setup works |

### Core/InventoryItemTests.cs (10 tests)

| Test Name | Description |
|-----------|-------------|
| `InventoryItem_DefaultCharacterId_ShouldBeEmpty` | CharacterId defaults to empty GUID |
| `InventoryItem_DefaultItemId_ShouldBeEmpty` | ItemId defaults to empty GUID |
| `InventoryItem_DefaultQuantity_ShouldBeOne` | Quantity defaults to 1 |
| `InventoryItem_DefaultSlotPosition_ShouldBeZero` | SlotPosition defaults to 0 |
| `InventoryItem_DefaultIsEquipped_ShouldBeFalse` | IsEquipped defaults to false |
| `InventoryItem_CanSetAllProperties` | All properties are settable |
| `InventoryItem_NavigationProperties_CanBeSet` | Character and Item navigation properties work |
| `InventoryItem_AddedAt_ShouldBeSetOnCreation` | Timestamp set on instantiation |
| `InventoryItem_LastModified_ShouldBeSetOnCreation` | LastModified set on instantiation |
| `InventoryItem_Quantity_CanBeGreaterThanOne` | Quantity supports stacking |

### Integration/ItemPersistenceTests.cs (20 tests)

| Test Name | Description |
|-----------|-------------|
| `AddAsync_ShouldPersistItem` | Basic item add and retrieve |
| `AddAsync_ShouldPersistAllItemProperties` | All Item properties persist correctly |
| `UpdateAsync_ShouldModifyItem` | Item update persists changes |
| `DeleteAsync_ShouldRemoveItem` | Item deletion works |
| `GetByQualityAsync_ReturnsItemsOfQuality` | Quality filtering returns correct items |
| `GetByQualityAsync_NoMatches_ReturnsEmptyList` | Quality filter with no matches returns empty |
| `GetByTypeAsync_ReturnsItemsOfType` | ItemType filtering returns correct items |
| `GetByNameAsync_FindsExactMatch` | Name search finds exact match |
| `GetByNameAsync_CaseInsensitive` | Name search is case-insensitive |
| `GetByNameAsync_NotFound_ReturnsNull` | Missing item returns null |
| `AddAsync_ShouldPersistEquipment` | Equipment (TPH subtype) persists |
| `AddAsync_ShouldPersistEquipmentWithBonuses` | Equipment dictionaries (bonuses, requirements) persist as JSON |
| `GetAllEquipmentAsync_ReturnsOnlyEquipment` | Returns only Equipment rows via TPH discriminator |
| `GetEquipmentBySlotAsync_ReturnsEquipmentForSlot` | Slot filtering returns correct equipment |
| `AddRangeAsync_AddsMultipleItems` | Bulk add operation works |
| `Equipment_LoadedFromDatabase_HasCorrectDiscriminator` | TPH discriminator correctly identifies Equipment |
| `Equipment_AttributeBonuses_LoadFromJson` | JSONB AttributeBonuses deserialize correctly |
| `Equipment_Requirements_LoadFromJson` | JSONB Requirements deserialize correctly |
| `Item_CanBeRetrievedAsBaseType` | Base Item query includes both Item and Equipment |
| `Equipment_InheritedProperties_Persist` | Equipment inherits and persists Item properties |

### Integration/InventoryPersistenceTests.cs (18 tests)

| Test Name | Description |
|-----------|-------------|
| `AddAsync_ShouldPersistInventoryEntry` | Basic inventory entry add and retrieve |
| `AddAsync_ShouldPersistAllProperties` | All InventoryItem properties persist |
| `GetByCharacterIdAsync_ReturnsAllInventoryItems` | Character inventory query returns all items |
| `GetByCharacterIdAsync_IncludesItemNavigation` | Item navigation property loaded via Include |
| `GetByCharacterIdAsync_ReturnsOrderedBySlotPosition` | Results ordered by SlotPosition ascending |
| `GetByCharacterIdAsync_EmptyInventory_ReturnsEmptyList` | Empty inventory returns empty list |
| `GetEquippedItemsAsync_ReturnsOnlyEquipped` | Filters to IsEquipped = true entries |
| `GetEquippedInSlotAsync_ReturnsEquippedItem` | Finds equipped item in specific slot |
| `GetEquippedInSlotAsync_EmptySlot_ReturnsNull` | Empty slot returns null |
| `FindByItemNameAsync_FindsItem` | Case-insensitive item name search works |
| `FindByItemNameAsync_CaseInsensitive` | Name search ignores case |
| `FindByItemNameAsync_NotFound_ReturnsNull` | Missing item returns null |
| `GetTotalWeightAsync_CalculatesTotalWeight` | SumAsync(Weight * Quantity) calculation correct |
| `GetTotalWeightAsync_EmptyInventory_ReturnsZero` | Empty inventory returns 0 weight |
| `GetItemCountAsync_CountsSlots` | Counts distinct inventory entries |
| `UpdateAsync_ShouldModifyEntry` | Update persists changes |
| `RemoveAsync_ShouldRemoveEntry` | Delete by composite key works |
| `ClearInventoryAsync_RemovesAllEntries` | Character inventory cleared |
| `ClearInventoryAsync_DoesNotAffectOtherCharacters` | Clear isolated to single character |

---

## DI Registration

No new services were registered in this sub-version. This release focuses on foundational data structures and repository implementations. Future sub-versions (v0.1.2b and beyond) will introduce InventoryService and related business logic services.

---

## Database Schema Additions

### Items Table (TPH)

```sql
CREATE TABLE "Items" (
    "Id" uuid NOT NULL PRIMARY KEY,
    "ItemDiscriminator" character varying(13) NOT NULL,  -- 'Item' or 'Equipment'
    "Name" character varying(100) NOT NULL,
    "ItemType" integer NOT NULL,
    "Description" character varying(500) NOT NULL,
    "DetailedDescription" character varying(1000),
    "Weight" integer NOT NULL,
    "Value" integer NOT NULL,
    "Quality" integer NOT NULL,
    "IsStackable" boolean NOT NULL,
    "MaxStackSize" integer NOT NULL,
    "CreatedAt" timestamp with time zone NOT NULL,
    "LastModified" timestamp with time zone NOT NULL,

    -- Equipment-specific columns (null for base Items)
    "Slot" integer,
    "SoakBonus" integer,
    "DamageDie" integer,
    "AttributeBonuses" jsonb,
    "Requirements" jsonb
);

CREATE INDEX "IX_Items_Name" ON "Items" ("Name");
CREATE INDEX "IX_Items_Quality" ON "Items" ("Quality");
CREATE INDEX "IX_Items_ItemType" ON "Items" ("ItemType");
CREATE INDEX "IX_Items_Slot" ON "Items" ("Slot");
```

### InventoryItems Table

```sql
CREATE TABLE "InventoryItems" (
    "CharacterId" uuid NOT NULL,
    "ItemId" uuid NOT NULL,
    "Quantity" integer NOT NULL,
    "SlotPosition" integer NOT NULL,
    "IsEquipped" boolean NOT NULL,
    "AddedAt" timestamp with time zone NOT NULL,
    "LastModified" timestamp with time zone NOT NULL,

    PRIMARY KEY ("CharacterId", "ItemId"),

    CONSTRAINT "FK_InventoryItems_Characters"
        FOREIGN KEY ("CharacterId")
        REFERENCES "Characters" ("Id")
        ON DELETE CASCADE,

    CONSTRAINT "FK_InventoryItems_Items"
        FOREIGN KEY ("ItemId")
        REFERENCES "Items" ("Id")
        ON DELETE CASCADE
);

CREATE INDEX "IX_InventoryItems_CharacterId" ON "InventoryItems" ("CharacterId");
CREATE INDEX "IX_InventoryItems_IsEquipped" ON "InventoryItems" ("IsEquipped");
```

### Characters Table Modifications

```sql
ALTER TABLE "Characters"
ADD COLUMN "EquipmentBonuses" jsonb NOT NULL DEFAULT '{}'::jsonb;
```

### InteractableObjects Table Modifications

```sql
ALTER TABLE "InteractableObjects"
ADD COLUMN "HasBeenSearched" boolean NOT NULL DEFAULT false,
ADD COLUMN "LootTier" integer NULL;
```

---

## Build Verification

```
Build started...
Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:03.42
```

---

## Test Results

```
Test run for RuneAndRust.Tests.dll (.NETCoreApp,Version=v9.0)
Starting test execution, please wait...

Passed!  - Failed:     0
           Passed:   962
           Skipped:    0
           Total:    962
           Duration: 483 ms
```

**v0.1.2a Specific Tests:**
```
Passed!  - Failed:     0
           Passed:   149
           Skipped:    0
           Total:    149
           Duration: 470 ms
```

---

## Directory Structure After v0.1.2a

```
RuneAndRust/
├── RuneAndRust.Core/
│   ├── Entities/
│   │   ├── Character.cs               [MODIFIED]
│   │   ├── Equipment.cs               [NEW]
│   │   ├── InteractableObject.cs     [MODIFIED]
│   │   ├── InventoryItem.cs          [NEW]
│   │   ├── Item.cs                   [NEW]
│   │   ├── Room.cs
│   │   └── SaveGame.cs
│   ├── Enums/
│   │   ├── Attribute.cs
│   │   ├── ArchetypeType.cs
│   │   ├── BiomeType.cs
│   │   ├── BurdenState.cs            [NEW]
│   │   ├── DangerLevel.cs
│   │   ├── Direction.cs
│   │   ├── EquipmentSlot.cs          [NEW]
│   │   ├── GamePhase.cs
│   │   ├── ItemType.cs               [NEW]
│   │   ├── LineageType.cs
│   │   ├── ObjectType.cs
│   │   ├── PendingGameAction.cs
│   │   └── QualityTier.cs            [NEW]
│   ├── Interfaces/
│   │   ├── IDiceService.cs
│   │   ├── IInputHandler.cs
│   │   ├── IInventoryRepository.cs   [NEW]
│   │   ├── IItemRepository.cs        [NEW]
│   │   ├── IRepository.cs
│   │   ├── ISaveGameRepository.cs
│   │   └── IStatCalculationService.cs
│   └── Models/
│       ├── Character.cs
│       ├── ExaminationResult.cs
│       └── GameState.cs
├── RuneAndRust.Engine/
│   └── Services/
│       ├── CommandParser.cs
│       ├── DescriptorEngine.cs
│       ├── DiceService.cs
│       ├── DungeonGenerator.cs
│       ├── GameService.cs
│       ├── InteractionService.cs
│       ├── NavigationService.cs
│       ├── ObjectSpawner.cs
│       ├── SaveManager.cs
│       └── StatCalculationService.cs
├── RuneAndRust.Persistence/
│   ├── Data/
│   │   └── RuneAndRustDbContext.cs   [MODIFIED]
│   └── Repositories/
│       ├── GenericRepository.cs
│       ├── InteractableObjectRepository.cs
│       ├── InventoryRepository.cs    [NEW]
│       ├── ItemRepository.cs         [NEW]
│       ├── RoomRepository.cs
│       └── SaveGameRepository.cs
├── RuneAndRust.Terminal/
│   ├── Program.cs
│   └── Services/
│       └── TerminalInputHandler.cs
├── RuneAndRust.Tests/
│   ├── Core/
│   │   ├── AttributeTests.cs
│   │   ├── ArchetypeTypeTests.cs
│   │   ├── BiomeTypeTests.cs
│   │   ├── BurdenStateTests.cs       [NEW]
│   │   ├── CharacterEntityTests.cs
│   │   ├── CharacterTests.cs
│   │   ├── CoordinateTests.cs
│   │   ├── DangerLevelTests.cs
│   │   ├── DirectionTests.cs
│   │   ├── EquipmentSlotTests.cs     [NEW]
│   │   ├── EquipmentTests.cs         [NEW]
│   │   ├── ExaminationResultTests.cs
│   │   ├── GamePhaseTests.cs
│   │   ├── GameStateTests.cs
│   │   ├── InteractableObjectTests.cs
│   │   ├── InventoryItemTests.cs     [NEW]
│   │   ├── ItemTests.cs              [NEW]
│   │   ├── ItemTypeTests.cs          [NEW]
│   │   ├── LineageTypeTests.cs
│   │   ├── ObjectTypeTests.cs
│   │   ├── PendingGameActionTests.cs
│   │   ├── QualityTierTests.cs       [NEW]
│   │   └── RoomTests.cs
│   ├── Engine/
│   │   ├── CharacterFactoryTests.cs
│   │   ├── CommandParserTests.cs
│   │   ├── DerivedStatsTests.cs
│   │   ├── DescriptorEngineTests.cs
│   │   ├── DiceServiceTests.cs
│   │   ├── DungeonGeneratorTests.cs
│   │   ├── GameLoopTests.cs
│   │   ├── GameServiceTests.cs
│   │   ├── InteractionServiceTests.cs
│   │   ├── NavigationServiceTests.cs
│   │   ├── ObjectSpawnerTests.cs
│   │   ├── SaveManagerTests.cs
│   │   └── StatCalculationServiceTests.cs
│   └── Integration/
│       ├── CharacterPersistenceTests.cs
│       ├── InteractableObjectPersistenceTests.cs
│       ├── InventoryPersistenceTests.cs [NEW]
│       ├── ItemPersistenceTests.cs      [NEW]
│       ├── PersistenceTests.cs
│       └── RoomPersistenceTests.cs
└── docs/
    └── changelogs/
        ├── CHANGELOG_GENERATION_RULES.md
        ├── v0.0.2.md
        ├── v0.0.3.md
        ├── v0.0.4.md
        ├── v0.1.1.md
        └── v0.1.2a.md                   [NEW]
```

---

## Running Tests

```bash
# Run all tests
dotnet test RuneAndRust.Tests

# Run only v0.1.2a new tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~QualityTierTests|FullyQualifiedName~EquipmentSlotTests|FullyQualifiedName~ItemTypeTests|FullyQualifiedName~BurdenStateTests|FullyQualifiedName~ItemTests|FullyQualifiedName~EquipmentTests|FullyQualifiedName~InventoryItemTests|FullyQualifiedName~ItemPersistenceTests|FullyQualifiedName~InventoryPersistenceTests"

# Run Core entity tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~Core.ItemTests|FullyQualifiedName~Core.EquipmentTests|FullyQualifiedName~Core.InventoryItemTests"

# Run Integration persistence tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~ItemPersistenceTests|FullyQualifiedName~InventoryPersistenceTests"

# Run enum validation tests
dotnet test RuneAndRust.Tests --filter "FullyQualifiedName~QualityTierTests|FullyQualifiedName~EquipmentSlotTests|FullyQualifiedName~ItemTypeTests|FullyQualifiedName~BurdenStateTests"
```

---

## Test Summary by Category

| Category | Test Count |
|----------|------------|
| Core/QualityTierTests | 8 |
| Core/EquipmentSlotTests | 9 |
| Core/ItemTypeTests | 8 |
| Core/BurdenStateTests | 7 |
| Core/ItemTests | 15 |
| Core/EquipmentTests | 18 |
| Core/InventoryItemTests | 10 |
| Integration/ItemPersistenceTests | 20 |
| Integration/InventoryPersistenceTests | 18 |
| **v0.1.2a New Tests** | **149** |
| **Total (All Tests)** | **962** |

---

## Next Steps (v0.1.2b: Inventory Service Layer)

Planned features for the next sub-version:

- **InventoryService**: Business logic layer for inventory operations
  - `AddItemAsync()` - Add items to character inventory with stacking support
  - `RemoveItemAsync()` - Remove items with quantity handling
  - `EquipItemAsync()` - Equip items with requirement validation and bonus application
  - `UnequipItemAsync()` - Unequip items and recalculate bonuses
  - `GetBurdenStateAsync()` - Calculate encumbrance based on total weight
  - `CanMoveAsync()` - Check if character can move (not overburdened)

- **Weight Calculations**: Capacity system based on Might attribute
  - Max capacity formula: `(Might * 5000) grams` (e.g., Might 5 = 25kg capacity)
  - Light threshold: 70% capacity
  - Heavy threshold: 90% capacity

- **Equipment Bonus Aggregation**: Update `Character.EquipmentBonuses` dictionary when equipping/unequipping
  - Recalculate all equipped items' AttributeBonuses
  - Update Character.EquipmentBonuses property
  - Persist changes via repository

- **Commands**: Terminal commands for inventory management
  - `inventory` / `inv` - List all inventory items
  - `equip <item>` - Equip an item from inventory
  - `unequip <slot>` - Remove equipped item
  - `drop <item>` - Remove item from inventory

- **Tests**: 40+ new tests for InventoryService
  - Add/remove item logic with stacking
  - Equip/unequip with requirement validation
  - Burden state calculations
  - Bonus aggregation accuracy

**Target Test Count for v0.1.2b:** 1000+ total tests
