# v0.10.4 Monster Groups - Scope Breakdown

**Version:** 0.10.4
**Theme:** Advanced Encounters
**Prerequisites:** v0.10.3c Complete (Combo System - Zone Control)
**Total Estimated Tests:** ~35 new tests

---

## Executive Summary

The Advanced Encounters sub-version implements boss fights with phases and unique abilities, and coordinated monster groups that use tactical behaviors. Bosses transition through phases as their health drops, gaining new abilities and behaviors. Monster groups coordinate attacks and use tactics like flanking, focus fire, and synergy buffs.

Key focus areas:
- **Boss Phases**: Health-threshold phase transitions with unique abilities
- **Boss Mechanics**: Enrage, transition effects, vulnerability windows
- **Monster Groups**: Coordinated tactics and group synergies

The work is divided into **three sub-parts**:

| Part | Name | Focus | Est. Tests |
|------|------|-------|------------|
| v0.10.4a | Boss Definitions | BossDefinition, phases, configuration | ~12 |
| v0.10.4b | Boss Mechanics | Phase transitions, enrage, vulnerability | ~12 |
| v0.10.4c | Monster Groups | Group tactics, flanking, synergies | ~11 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.x)

| Feature | Location | Notes |
|---------|----------|-------|
| Monster | `Domain/Entities/Monster.cs` | Monster entity |
| MonsterDefinition | `Domain/Definitions/MonsterDefinition.cs` | Monster templates |
| MonsterAI | `Application/Services/MonsterAIService.cs` | AI behavior |
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid-based combat |
| FlankingService | `Application/Services/FlankingService.cs` | Flanking bonuses |

### Already Implemented (from v0.10.1-v0.10.4)

| Feature | Location | Notes |
|---------|----------|-------|
| IBuffDebuffService | `Application/Interfaces/IBuffDebuffService.cs` | Status effects |
| CombatService | `Application/Services/CombatService.cs` | Combat flow |
| ZoneEffectService | `Application/Services/ZoneEffectService.cs` | Area effects |
| EventBus | `Application/Services/EventBus.cs` | Event system |

### Needs Implementation (v0.10.4)

| Feature | Part | Notes |
|---------|------|-------|
| BossDefinition | v0.10.4a | Boss templates |
| BossPhase | v0.10.4a | Phase definitions |
| IBossMechanicsService | v0.10.4b | Boss interface |
| BossMechanicsService | v0.10.4b | Phase transitions |
| MonsterGroupDefinition | v0.10.3c | Group templates |
| IMonsterGroupService | v0.10.3c | Group interface |
| MonsterGroupService | v0.10.3c | Group tactics |

---

## Feature Analysis & Categorization

### Boss Definition Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| BossDefinition entity | Medium | Domain | **v0.10.4a** |
| BossPhase entity | Medium | Definition | **v0.10.4a** |
| Phase abilities | Low | Abilities | **v0.10.4a** |
| Phase behaviors | Low | AI | **v0.10.4a** |
| bosses.json config | Medium | Config | **v0.10.4a** |
| IBossProvider | Low | Config | **v0.10.4a** |

### Boss Mechanics Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| IBossMechanicsService | Medium | Application | **v0.10.4b** |
| BossMechanicsService | High | Service | **v0.10.4b** |
| Phase transitions | High | Health tracking | **v0.10.4b** |
| Transition effects | Medium | Combat | **v0.10.4b** |
| Enrage mechanics | Medium | Stats | **v0.10.4b** |
| Vulnerability windows | Medium | Timing | **v0.10.4b** |

### Monster Group Features

| Feature | Complexity | Dependencies | Assigned Part |
|---------|------------|--------------|---------------|
| MonsterGroupDefinition | Medium | Domain | **v0.10.3c** |
| IMonsterGroupService | Medium | Application | **v0.10.3c** |
| MonsterGroupService | High | AI, Grid | **v0.10.3c** |
| Flank tactics | High | Grid, Position | **v0.10.3c** |
| Focus fire | Medium | Target selection | **v0.10.3c** |
| Group synergies | Medium | Buffs | **v0.10.3c** |

---

## Part Definitions

---

## v0.10.4a: Boss Definitions

[v0.10.4a Design Specification](v0.10.4a-design-specification.md)

### Overview

Define the boss structure with phases, abilities per phase, behaviors, and transition configurations. Bosses are loaded from JSON configuration and extend base monster definitions with phase mechanics.

### Scope

**In Scope:**
- `BossDefinition` entity
- `BossPhase` entity
- Base monster reference
- Phase definitions (number, name, health threshold)
- Phase-specific abilities
- Phase-specific behaviors
- Transition text and effects
- Stat modifiers per phase
- Summon configuration
- Loot tables
- `IBossProvider` interface
- `BossProvider` implementation
- `bosses.json` configuration

**Out of Scope:**
- Phase transition logic (v0.10.4b)
- Monster groups (v0.10.3c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 2 | `BossDefinition`, `BossPhase` |
| Interfaces | 1 | `IBossProvider` |
| Infrastructure | 1 | `BossProvider` |
| Configuration | 1 | `bosses.json` |
| Unit Tests | ~12 | Boss loading, phase validation |

### Boss Definition Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    BOSS DEFINITION ARCHITECTURE                      │
└─────────────────────────────────────────────────────────────────────┘

     Configuration                        Domain
     ─────────────                        ──────

   bosses.json                   ┌─────────────────────────────┐
   ┌─────────────────┐           │       BossDefinition        │
   │ {                │           ├─────────────────────────────┤
   │   "bossId": ..., │  ─────▶   │ + BossId: string            │
   │   "name": ...,   │           │ + Name: string              │
   │   "baseMonster":,│           │ + BaseMonsterDefinitionId   │
   │   "phases": [...],│          │ + Phases: List<BossPhase>   │
   │   "loot": [...]  │           │ + Loot: List<LootEntry>     │
   │ }                │           └──────────────┬──────────────┘
   └─────────────────┘                           │ contains
                                                 ▼
                                  ┌─────────────────────────────┐
                                  │         BossPhase           │
                                  ├─────────────────────────────┤
                                  │ + PhaseNumber: int          │
                                  │ + Name: string              │
                                  │ + HealthThreshold: int (%)  │
                                  │ + Abilities: List<string>   │
                                  │ + Behavior: BossBehavior    │
                                  │ + StatModifiers: dict       │
                                  │ + TransitionText: string?   │
                                  │ + TransitionEffect: string? │
                                  │ + SummonConfig: SummonDef?  │
                                  └─────────────────────────────┘


    BOSS: SKELETON KING - PHASE DIAGRAM
    ────────────────────────────────────

    HP: 100%              HP: 66%              HP: 33%
    ┌───────────┐        ┌───────────┐        ┌───────────┐
    │  PHASE 1  │   ▶    │  PHASE 2  │   ▶    │  PHASE 3  │
    │  "Rise"   │        │  "Legion" │        │  "Fury"   │
    └───────────┘        └───────────┘        └───────────┘
    
    Abilities:           Abilities:           Abilities:
    • Bone Strike        • Summon Skeletons   • Death Nova (AoE)
    • Soul Drain         • Bone Strike x2     • Enrage (+50% dmg)
                         • Dark Shield        • All Phase 1 & 2
    
    Behavior:            Behavior:            Behavior:
    Standard melee       Summons adds         Aggressive, fast
                         every 2 turns        No more summons
```

### BossDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a boss encounter with multiple phases.
/// </summary>
public class BossDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string BossId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public string BaseMonsterDefinitionId { get; private set; } = null!;
    public IReadOnlyList<BossPhase> Phases { get; private set; } = [];
    public IReadOnlyList<LootEntry> Loot { get; private set; } = [];
    public string? TitleText { get; private set; }
    public string? IconPath { get; private set; }
    
    private BossDefinition() { }
    
    public static BossDefinition Create(
        string bossId,
        string name,
        string description,
        string baseMonsterDefinitionId,
        IEnumerable<BossPhase> phases)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(bossId);
        ArgumentException.ThrowIfNullOrWhiteSpace(baseMonsterDefinitionId);
        
        var phaseList = phases.ToList();
        if (phaseList.Count == 0)
            throw new ArgumentException("Boss must have at least one phase");
        
        return new BossDefinition
        {
            Id = Guid.NewGuid(),
            BossId = bossId.ToLowerInvariant(),
            Name = name,
            Description = description,
            BaseMonsterDefinitionId = baseMonsterDefinitionId.ToLowerInvariant(),
            Phases = phaseList.OrderBy(p => p.PhaseNumber).ToList()
        };
    }
    
    /// <summary>Gets the phase for a given health percentage.</summary>
    public BossPhase GetPhaseForHealth(int healthPercent)
    {
        return Phases
            .OrderByDescending(p => p.HealthThreshold)
            .First(p => healthPercent <= p.HealthThreshold);
    }
    
    /// <summary>Gets the starting phase (highest threshold).</summary>
    public BossPhase GetStartingPhase()
    {
        return Phases.OrderByDescending(p => p.HealthThreshold).First();
    }
    
    /// <summary>Gets the total number of phases.</summary>
    public int PhaseCount => Phases.Count;
}
```

### BossPhase Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A single phase in a boss fight.
/// </summary>
public class BossPhase
{
    public int PhaseNumber { get; set; }
    public string Name { get; set; } = null!;
    public string? Description { get; set; }
    public int HealthThreshold { get; set; }
    public IReadOnlyList<string> AbilityIds { get; set; } = [];
    public BossBehavior Behavior { get; set; } = BossBehavior.Aggressive;
    public Dictionary<string, float> StatModifiers { get; set; } = new();
    public string? TransitionText { get; set; }
    public string? TransitionEffectId { get; set; }
    public SummonConfiguration? SummonConfig { get; set; }
    public string? IconPath { get; set; }
    
    /// <summary>Checks if this phase has a stat modifier.</summary>
    public float GetStatModifier(string statId)
    {
        return StatModifiers.TryGetValue(statId, out var mod) ? mod : 1.0f;
    }
    
    /// <summary>Whether this phase has transition effects.</summary>
    public bool HasTransition => TransitionText is not null || TransitionEffectId is not null;
}

/// <summary>
/// Boss behavior patterns.
/// </summary>
public enum BossBehavior
{
    Aggressive,  // Focus on damage
    Tactical,    // Use abilities strategically
    Defensive,   // Prioritize self-preservation
    Enraged,     // All-out attack, ignore defense
    Summoner     // Focus on summoning minions
}

/// <summary>
/// Configuration for boss summoning abilities.
/// </summary>
public class SummonConfiguration
{
    public string MonsterDefinitionId { get; set; } = null!;
    public int Count { get; set; } = 1;
    public int IntervalTurns { get; set; } = 2;
    public int MaxActive { get; set; } = 4;
}
```

### Boss Configuration

```json
{
  "$schema": "./schemas/bosses.schema.json",
  "bosses": [
    {
      "bossId": "skeleton-king",
      "name": "Skeleton King",
      "description": "The undead lord of the crypt",
      "baseMonsterDefinitionId": "skeleton-lord",
      "titleText": "The Skeleton King Awakens!",
      "phases": [
        {
          "phaseNumber": 1,
          "name": "Rise",
          "description": "The king awakens from his slumber",
          "healthThreshold": 100,
          "abilityIds": ["bone-strike", "soul-drain"],
          "behavior": "Aggressive"
        },
        {
          "phaseNumber": 2,
          "name": "Legion",
          "description": "The king calls forth his minions",
          "healthThreshold": 66,
          "abilityIds": ["bone-strike", "summon-skeletons", "dark-shield"],
          "behavior": "Summoner",
          "summonConfig": {
            "monsterDefinitionId": "skeleton-warrior",
            "count": 2,
            "intervalTurns": 2,
            "maxActive": 4
          },
          "transitionText": "The Skeleton King raises his arms! Bones rise from the ground!",
          "transitionEffectId": "knockback-all-2"
        },
        {
          "phaseNumber": 3,
          "name": "Fury",
          "description": "The king enters a rage",
          "healthThreshold": 33,
          "abilityIds": ["bone-strike", "soul-drain", "death-nova"],
          "behavior": "Enraged",
          "statModifiers": {
            "damage": 1.5,
            "attackSpeed": 1.25,
            "defense": 0.75
          },
          "transitionText": "The Skeleton King's eyes blaze with unholy fury!"
        }
      ],
      "loot": [
        { "itemId": "crown-of-bones", "chance": 0.25 },
        { "itemId": "soul-gem", "chance": 0.5 },
        { "itemId": "gold", "amount": 500, "chance": 1.0 }
      ],
      "icon": "icons/bosses/skeleton-king.png"
    },
    {
      "bossId": "dragon-wyrm",
      "name": "Volcanic Wyrm",
      "description": "An ancient dragon of fire",
      "baseMonsterDefinitionId": "fire-dragon",
      "titleText": "The Wyrm Descends!",
      "phases": [
        {
          "phaseNumber": 1,
          "name": "Descent",
          "healthThreshold": 100,
          "abilityIds": ["fire-breath", "claw-attack", "wing-buffet"],
          "behavior": "Aggressive"
        },
        {
          "phaseNumber": 2,
          "name": "Inferno",
          "healthThreshold": 50,
          "abilityIds": ["fire-breath", "meteor-storm", "lava-pool"],
          "behavior": "Tactical",
          "transitionText": "The Wyrm roars! The ground cracks with molten fury!",
          "transitionEffectId": "create-lava-zones"
        },
        {
          "phaseNumber": 3,
          "name": "Desperation",
          "healthThreshold": 20,
          "abilityIds": ["fire-breath", "meteor-storm", "supernova"],
          "behavior": "Enraged",
          "statModifiers": {
            "damage": 2.0,
            "defense": 0.5
          },
          "transitionText": "The Wyrm prepares to unleash its final fury!"
        }
      ],
      "loot": [
        { "itemId": "dragon-scale", "chance": 0.75 },
        { "itemId": "fire-heart", "chance": 0.33 }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] BossDefinition loads from JSON
- [ ] Phases define health thresholds
- [ ] Phase abilities specified per phase
- [ ] Phase behaviors define AI pattern
- [ ] Stat modifiers per phase
- [ ] Transition text and effects defined
- [ ] Summon configuration per phase
- [ ] GetPhaseForHealth returns correct phase
- [ ] Loot tables defined
- [ ] Base monster referenced
- [ ] ~12 unit tests pass

---

## v0.10.4b: Boss Mechanics

[v0.10.4b Design Specification](v0.10.4b-design-specification.md)

### Overview

Implement the boss mechanics service that manages phase transitions, applies transition effects, handles enrage mechanics, and creates vulnerability windows. The service monitors boss health and triggers phase changes with appropriate effects.

### Scope

**In Scope:**
- `IBossMechanicsService` interface
- `BossMechanicsService` implementation
- Active boss state tracking
- Phase transition detection
- Transition effect execution
- Knockback all players effect
- Summon minions effect
- Enrage stat application
- Vulnerability window timing
- Phase-specific ability selection
- Boss health events
- Phase transition events
- Boss defeat handling

**Out of Scope:**
- Boss definitions (v0.10.4a)
- Monster groups (v0.10.3c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Interfaces | 1 | `IBossMechanicsService` |
| Services | 1 | `BossMechanicsService` |
| State Tracking | 1 | `ActiveBossState` |
| Events | 4 | Phase changed, vulnerable, enraged, defeated |
| Unit Tests | ~12 | Phase transitions, effects tests |

### Boss Mechanics Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    BOSS MECHANICS ARCHITECTURE                       │
└─────────────────────────────────────────────────────────────────────┘

                      ┌───────────────────────────┐
                      │      Combat System         │
                      │   (Damage, Turn events)    │
                      └───────────────┬───────────┘
                                      │ OnDamageDealt
                                      ▼
                      ┌───────────────────────────┐
                      │   IBossMechanicsService    │
                      ├───────────────────────────┤
                      │ + SpawnBoss(bossId, pos)  │
                      │ + OnBossDamaged(boss)     │
                      │ + GetCurrentPhase(boss)   │
                      │ + IsVulnerable(boss)      │
                      │ + GetBossState(boss)      │
                      │ + TickBoss(boss)          │
                      └───────────────┬───────────┘
                                      │
                      ┌───────────────┴───────────┐
                      │     BossMechanicsService   │
                      ├───────────────────────────┤
                      │ - _activeBosses: Dict     │
                      │ - _bossProvider           │
                      │                           │
                      │ + CheckPhaseTransition    │
                      │ + ExecuteTransitionEffect │
                      │ + ApplyPhaseModifiers     │
                      │ + UpdateBossAbilities     │
                      │ + ProcessVulnerability    │
                      └───────────────────────────┘


    PHASE TRANSITION FLOW
    ─────────────────────

    Boss HP drops (67% → 65%)
            │
            ▼
    ┌──────────────────────────────────────┐
    │ 1. Check health threshold           │
    │    → Current: 65%, Phase 2 at 66%   │
    │    → TRANSITION TRIGGERED           │
    └──────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────┐
    │ 2. Execute transition effects       │
    │    → Display transition text        │
    │    → Knockback all players          │
    │    → Heal minions (if any)          │
    └──────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────┐
    │ 3. Apply new phase modifiers        │
    │    → Update stat modifiers          │
    │    → Change ability pool            │
    │    → Update AI behavior             │
    └──────────────────────────────────────┘
            │
            ▼
    ┌──────────────────────────────────────┐
    │ 4. Fire phase transition event      │
    │    → PhaseChangedEvent(boss, 1→2)   │
    └──────────────────────────────────────┘


    VULNERABILITY WINDOW
    ────────────────────

    After major ability:
    ┌─────────────────────────────────────┐
    │ Boss: "Death Nova" (exhausted)      │
    │                                     │
    │ ★ VULNERABLE ★ (2 turns)           │
    │ • +50% damage taken                 │
    │ • Cannot use abilities              │
    │                                     │
    │ Countdown: 2 → 1 → 0 → Normal      │
    └─────────────────────────────────────┘
```

### IBossMechanicsService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing boss encounter mechanics.
/// </summary>
public interface IBossMechanicsService
{
    /// <summary>Spawns a boss at a grid position.</summary>
    /// <param name="bossId">The boss definition ID.</param>
    /// <param name="position">Grid position to spawn at.</param>
    /// <returns>The spawned boss monster.</returns>
    Monster SpawnBoss(string bossId, GridPosition position);
    
    /// <summary>Called when a boss takes damage.</summary>
    /// <param name="boss">The boss that was damaged.</param>
    /// <param name="damage">Amount of damage taken.</param>
    void OnBossDamaged(Monster boss, int damage);
    
    /// <summary>Gets the current phase for a boss.</summary>
    BossPhase GetCurrentPhase(Monster boss);
    
    /// <summary>Gets the active boss state.</summary>
    ActiveBossState? GetBossState(Monster boss);
    
    /// <summary>Checks if boss is in vulnerable state.</summary>
    bool IsVulnerable(Monster boss);
    
    /// <summary>Gets the vulnerability multiplier.</summary>
    float GetVulnerabilityMultiplier(Monster boss);
    
    /// <summary>Makes a boss vulnerable for a duration.</summary>
    void SetVulnerable(Monster boss, int turns);
    
    /// <summary>Called each turn to update boss state.</summary>
    void TickBoss(Monster boss);
    
    /// <summary>Gets abilities available in current phase.</summary>
    IReadOnlyList<string> GetAvailableAbilities(Monster boss);
    
    /// <summary>Checks if this monster is a boss.</summary>
    bool IsBoss(Monster monster);
    
    /// <summary>Gets all active bosses in combat.</summary>
    IReadOnlyList<Monster> GetActiveBosses();
}
```

### BossMechanicsService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class BossMechanicsService : IBossMechanicsService
{
    private readonly IBossProvider _bossProvider;
    private readonly IMonsterProvider _monsterProvider;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEnvironmentalCombatService _environmentalService;
    private readonly IMonsterSpawnService _spawnService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<BossMechanicsService> _logger;
    
    private readonly Dictionary<Guid, ActiveBossState> _activeBosses = new();
    
    public BossMechanicsService(
        IBossProvider bossProvider,
        IMonsterProvider monsterProvider,
        IBuffDebuffService buffDebuffService,
        IEnvironmentalCombatService environmentalService,
        IMonsterSpawnService spawnService,
        IEventBus eventBus,
        ILogger<BossMechanicsService> logger)
    {
        _bossProvider = bossProvider;
        _monsterProvider = monsterProvider;
        _buffDebuffService = buffDebuffService;
        _environmentalService = environmentalService;
        _spawnService = spawnService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public Monster SpawnBoss(string bossId, GridPosition position)
    {
        var bossdef = _bossProvider.GetBoss(bossId);
        if (bossdef is null)
            throw new ArgumentException($"Boss not found: {bossId}");
        
        // Create monster from base definition
        var monsterDef = _monsterProvider.GetMonster(bossdef.BaseMonsterDefinitionId);
        var boss = _spawnService.Spawn(monsterDef!, position);
        
        // Mark as boss
        boss.SetBossId(bossId);
        
        // Initialize boss state
        var startingPhase = bossdef.GetStartingPhase();
        var state = new ActiveBossState(bossId, startingPhase.PhaseNumber);
        _activeBosses[boss.Id] = state;
        
        // Apply initial phase abilities
        UpdateBossAbilities(boss, startingPhase);
        
        _logger.LogInformation("Spawned boss {Boss} at {Position}", bossdef.Name, position);
        _eventBus.Publish(new BossSpawnedEvent(boss.Id, bossId, bossdef.TitleText));
        
        return boss;
    }
    
    public void OnBossDamaged(Monster boss, int damage)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
            return;
        
        var bossdef = _bossProvider.GetBoss(state.BossId);
        if (bossdef is null) return;
        
        var healthPercent = (int)((boss.Health / (float)boss.MaxHealth) * 100);
        var currentPhase = bossdef.GetPhaseForHealth(healthPercent);
        
        // Check for phase transition
        if (currentPhase.PhaseNumber != state.CurrentPhaseNumber)
        {
            TransitionToPhase(boss, state, bossdef, currentPhase);
        }
        
        // Check for defeat
        if (boss.Health <= 0)
        {
            OnBossDefeated(boss, bossdef);
        }
    }
    
    private void TransitionToPhase(
        Monster boss, 
        ActiveBossState state, 
        BossDefinition bossdef, 
        BossPhase newPhase)
    {
        var oldPhaseNumber = state.CurrentPhaseNumber;
        state.CurrentPhaseNumber = newPhase.PhaseNumber;
        
        _logger.LogInformation("{Boss} transitioning from phase {Old} to {New}",
            bossdef.Name, oldPhaseNumber, newPhase.PhaseNumber);
        
        // Execute transition effects
        if (newPhase.HasTransition)
        {
            ExecuteTransitionEffect(boss, newPhase);
        }
        
        // Apply new phase modifiers
        ApplyPhaseModifiers(boss, newPhase);
        
        // Update available abilities
        UpdateBossAbilities(boss, newPhase);
        
        _eventBus.Publish(new BossPhaseChangedEvent(
            boss.Id, 
            state.BossId, 
            oldPhaseNumber, 
            newPhase.PhaseNumber,
            newPhase.Name,
            newPhase.TransitionText));
    }
    
    private void ExecuteTransitionEffect(Monster boss, BossPhase phase)
    {
        if (phase.TransitionEffectId is null) return;
        
        switch (phase.TransitionEffectId)
        {
            case "knockback-all-2":
                // Knockback all players 2 cells
                var players = GetPlayersInCombat();
                foreach (var player in players)
                {
                    _environmentalService.Knockback(player, boss.Position, 2);
                }
                break;
            
            case "heal-minions":
                // Heal all summoned minions
                foreach (var minion in GetBossMinions(boss))
                {
                    minion.Heal(minion.MaxHealth / 2);
                }
                break;
            
            case "create-lava-zones":
                // Create lava zones around boss
                CreateHazardZonesAroundBoss(boss, "lava", 3);
                break;
        }
        
        _logger.LogDebug("Executed transition effect: {Effect}", phase.TransitionEffectId);
    }
    
    private void ApplyPhaseModifiers(Monster boss, BossPhase phase)
    {
        // Remove old modifiers
        _buffDebuffService.ClearEffects(boss, EffectType.StatModifier);
        
        // Apply new phase modifiers
        foreach (var (statId, multiplier) in phase.StatModifiers)
        {
            var modValue = (int)((multiplier - 1.0f) * 100); // Convert 1.5 to +50
            _buffDebuffService.ApplyStatModifier(boss, statId, modValue, $"phase:{phase.PhaseNumber}");
        }
        
        // Update behavior
        boss.SetBehavior(phase.Behavior);
    }
    
    private void UpdateBossAbilities(Monster boss, BossPhase phase)
    {
        boss.SetAvailableAbilities(phase.AbilityIds.ToList());
    }
    
    public bool IsVulnerable(Monster boss)
    {
        return _activeBosses.TryGetValue(boss.Id, out var state) && state.VulnerableTurns > 0;
    }
    
    public float GetVulnerabilityMultiplier(Monster boss)
    {
        return IsVulnerable(boss) ? 1.5f : 1.0f;
    }
    
    public void SetVulnerable(Monster boss, int turns)
    {
        if (_activeBosses.TryGetValue(boss.Id, out var state))
        {
            state.VulnerableTurns = turns;
            _eventBus.Publish(new BossVulnerableEvent(boss.Id, turns));
            _logger.LogInformation("{Boss} is now vulnerable for {Turns} turns", boss.Name, turns);
        }
    }
    
    public void TickBoss(Monster boss)
    {
        if (!_activeBosses.TryGetValue(boss.Id, out var state))
            return;
        
        // Decrement vulnerability
        if (state.VulnerableTurns > 0)
        {
            state.VulnerableTurns--;
            if (state.VulnerableTurns == 0)
            {
                _eventBus.Publish(new BossVulnerabilityEndedEvent(boss.Id));
            }
        }
        
        // Check for summoning
        var bossdef = _bossProvider.GetBoss(state.BossId);
        var phase = bossdef?.Phases.FirstOrDefault(p => p.PhaseNumber == state.CurrentPhaseNumber);
        
        if (phase?.SummonConfig is not null)
        {
            state.TurnsSinceLastSummon++;
            if (state.TurnsSinceLastSummon >= phase.SummonConfig.IntervalTurns)
            {
                TrySummonMinions(boss, phase.SummonConfig);
                state.TurnsSinceLastSummon = 0;
            }
        }
    }
    
    private void OnBossDefeated(Monster boss, BossDefinition bossdef)
    {
        _activeBosses.Remove(boss.Id);
        _eventBus.Publish(new BossDefeatedEvent(boss.Id, bossdef.BossId, bossdef.Loot));
        _logger.LogInformation("Boss {Boss} defeated!", bossdef.Name);
    }
}
```

### ActiveBossState Class

```csharp
namespace RuneAndRust.Application.Tracking;

/// <summary>
/// Tracks the active state of a boss in combat.
/// </summary>
public class ActiveBossState
{
    public string BossId { get; }
    public int CurrentPhaseNumber { get; set; }
    public int VulnerableTurns { get; set; }
    public int TurnsSinceLastSummon { get; set; }
    public List<Guid> SummonedMinionIds { get; } = new();
    
    public ActiveBossState(string bossId, int startingPhase)
    {
        BossId = bossId;
        CurrentPhaseNumber = startingPhase;
    }
}
```

### Acceptance Criteria

- [ ] SpawnBoss creates boss from definition
- [ ] Boss starts in first phase
- [ ] Damage triggers phase check
- [ ] Phase transitions at threshold
- [ ] Transition text displayed
- [ ] Transition effects execute
- [ ] Knockback effect works
- [ ] Phase modifiers applied
- [ ] Abilities update per phase
- [ ] Vulnerability window works
- [ ] Enrage modifiers stack
- [ ] Boss defeat event fires
- [ ] ~12 unit tests pass

---

## v0.10.3c: Monster Groups

[v0.10.3c Design Specification](v0.10.3c-design-specification.md)

### Overview

Implement coordinated monster group behaviors with tactics like flanking, focus fire, and group synergies. Groups share information and coordinate their actions for more challenging encounters.

### Scope

**In Scope:**
- `MonsterGroupDefinition` entity
- `GroupTactic` enum
- `GroupSynergy` entity
- `IMonsterGroupService` interface
- `MonsterGroupService` implementation
- Flank tactic (surround target)
- Focus fire tactic (target lowest HP)
- Protect tactic (guard leader/caster)
- Group synergy buffs
- Leader bonuses
- Coordinated ability usage
- Group spawning
- `monster-groups.json` configuration

**Out of Scope:**
- Boss definitions (v0.10.4a)
- Boss mechanics (v0.10.4b)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Entities | 2 | `MonsterGroupDefinition`, `GroupSynergy` |
| Enums | 1 | `GroupTactic` |
| Interfaces | 1 | `IMonsterGroupService` |
| Services | 1 | `MonsterGroupService` |
| Configuration | 1 | `monster-groups.json` |
| Unit Tests | ~11 | Tactics, synergy tests |

### Monster Group Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MONSTER GROUP ARCHITECTURE                        │
└─────────────────────────────────────────────────────────────────────┘

     Configuration                        Domain
     ─────────────                        ──────

   monster-groups.json           ┌─────────────────────────────┐
   ┌─────────────────┐           │   MonsterGroupDefinition    │
   │ {                │           ├─────────────────────────────┤
   │   "groupId": ...,│  ─────▶   │ + GroupId: string           │
   │   "name": ...,   │           │ + Name: string              │
   │   "members": [...],         │ + Members: List<GMember>    │
   │   "tactics": [...],         │ + Tactics: List<GroupTactic>│
   │   "synergies": [..]         │ + Synergies: List<Synergy>  │
   │ }                │           └─────────────────────────────┘
   └─────────────────┘


    GOBLIN WARBAND (Group of 4)
    ───────────────────────────

    Before tactics:                 After tactics (flank):
    ┌───┬───┬───┬───┬───┐          ┌───┬───┬───┬───┬───┐
    │ G │   │   │   │   │          │   │   │ G │   │   │
    ├───┼───┼───┼───┼───┤          ├───┼───┼───┼───┼───┤
    │ G │   │ @ │   │   │   ▶      │   │ G │ @ │ G │   │
    ├───┼───┼───┼───┼───┤          ├───┼───┼───┼───┼───┤
    │ G │   │   │   │   │          │   │   │ G │   │   │
    ├───┼───┼───┼───┼───┤          └───┴───┴───┴───┴───┘
    │ G │   │   │   │   │
    └───┴───┴───┴───┴───┘          Goblins surround player
                                   for flanking bonuses!


    GROUP SYNERGIES
    ───────────────

    ┌─────────────────────────────────────────────────┐
    │ GOBLIN WARBAND SYNERGIES                        │
    ├─────────────────────────────────────────────────┤
    │ • Shaman buffs all goblins (+1 attack)         │
    │ • When one goblin hits, others get advantage   │
    │ • Focus fire on lowest HP player ally          │
    │ • Pack Mentality: +1 damage per ally adjacent  │
    └─────────────────────────────────────────────────┘
```

### MonsterGroupDefinition Entity

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// Defines a coordinated group of monsters.
/// </summary>
public class MonsterGroupDefinition : IEntity
{
    public Guid Id { get; private set; }
    public string GroupId { get; private set; } = null!;
    public string Name { get; private set; } = null!;
    public string Description { get; private set; } = null!;
    public IReadOnlyList<GroupMember> Members { get; private set; } = [];
    public IReadOnlyList<GroupTactic> Tactics { get; private set; } = [];
    public IReadOnlyList<GroupSynergy> Synergies { get; private set; } = [];
    public string? LeaderRole { get; private set; }
    public int MinSize { get; private set; }
    public int MaxSize { get; private set; }
    
    private MonsterGroupDefinition() { }
    
    public static MonsterGroupDefinition Create(
        string groupId,
        string name,
        string description,
        IEnumerable<GroupMember> members)
    {
        var memberList = members.ToList();
        return new MonsterGroupDefinition
        {
            Id = Guid.NewGuid(),
            GroupId = groupId.ToLowerInvariant(),
            Name = name,
            Description = description,
            Members = memberList,
            MinSize = memberList.Count,
            MaxSize = memberList.Count
        };
    }
    
    /// <summary>Gets the leader member if defined.</summary>
    public GroupMember? GetLeader()
    {
        return Members.FirstOrDefault(m => m.Role == LeaderRole);
    }
}
```

### GroupMember and Synergy Entities

```csharp
namespace RuneAndRust.Domain.Definitions;

/// <summary>
/// A member definition within a monster group.
/// </summary>
public class GroupMember
{
    public string MonsterDefinitionId { get; set; } = null!;
    public int Count { get; set; } = 1;
    public string? Role { get; set; }
    public GridOffset? PreferredPosition { get; set; }
}

/// <summary>
/// A synergy effect that applies to group members.
/// </summary>
public class GroupSynergy
{
    public string SynergyId { get; set; } = null!;
    public string Name { get; set; } = null!;
    public string Description { get; set; } = null!;
    public SynergyTrigger Trigger { get; set; }
    public string? SourceRole { get; set; }
    public string? StatusEffectId { get; set; }
    public int? AttackBonus { get; set; }
    public int? DamageBonus { get; set; }
    public bool AppliesToAllMembers { get; set; }
}

/// <summary>
/// When a synergy effect triggers.
/// </summary>
public enum SynergyTrigger
{
    Always,        // Always active
    OnAllyHit,     // When any ally lands a hit
    OnAllyDamaged, // When any ally takes damage
    OnLeaderCommand, // Leader uses command ability
    PerAdjacentAlly  // Bonus per adjacent ally
}

/// <summary>
/// Relative grid position offset.
/// </summary>
public record GridOffset(int DeltaX, int DeltaY);
```

### GroupTactic Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Tactical behaviors for monster groups.
/// </summary>
public enum GroupTactic
{
    Flank,         // Attempt to surround targets
    FocusFire,     // All attack same target
    ProtectLeader, // Defend the group leader
    ProtectCaster, // Defend spellcasters
    Swarm,         // Close in on all sides
    Retreat,       // Fall back when damaged
    Ambush,        // Wait for opportunity
    HitAndRun      // Attack then disengage
}
```

### IMonsterGroupService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for coordinating monster group behaviors.
/// </summary>
public interface IMonsterGroupService
{
    /// <summary>Spawns a monster group at a position.</summary>
    /// <param name="groupId">The group definition ID.</param>
    /// <param name="centerPosition">Center position for the group.</param>
    /// <returns>List of spawned monsters.</returns>
    IReadOnlyList<Monster> SpawnGroup(string groupId, GridPosition centerPosition);
    
    /// <summary>Gets the group a monster belongs to.</summary>
    MonsterGroupInstance? GetGroupForMonster(Monster monster);
    
    /// <summary>Determines the best move for a group member.</summary>
    GroupMoveDecision DetermineMove(Monster monster);
    
    /// <summary>Determines the target for a group member.</summary>
    ICombatant? DetermineTarget(Monster monster, IEnumerable<ICombatant> possibleTargets);
    
    /// <summary>Applies synergy effects to group members.</summary>
    void ApplySynergies(MonsterGroupInstance group);
    
    /// <summary>Called when a group member hits a target.</summary>
    void OnGroupMemberHit(Monster attacker, ICombatant target);
    
    /// <summary>Called when a group member dies.</summary>
    void OnGroupMemberDeath(Monster monster);
    
    /// <summary>Gets flanking positions around a target.</summary>
    IReadOnlyList<GridPosition> GetFlankingPositions(ICombatant target, int groupSize);
}
```

### MonsterGroupService Implementation

```csharp
namespace RuneAndRust.Application.Services;

public class MonsterGroupService : IMonsterGroupService
{
    private readonly IMonsterGroupProvider _groupProvider;
    private readonly IMonsterSpawnService _spawnService;
    private readonly ICombatGrid _grid;
    private readonly IFlankingService _flankingService;
    private readonly IBuffDebuffService _buffDebuffService;
    private readonly IEventBus _eventBus;
    private readonly ILogger<MonsterGroupService> _logger;
    
    private readonly Dictionary<Guid, MonsterGroupInstance> _activeGroups = new();
    private readonly Dictionary<Guid, Guid> _monsterToGroup = new();
    
    public MonsterGroupService(
        IMonsterGroupProvider groupProvider,
        IMonsterSpawnService spawnService,
        ICombatGrid grid,
        IFlankingService flankingService,
        IBuffDebuffService buffDebuffService,
        IEventBus eventBus,
        ILogger<MonsterGroupService> logger)
    {
        _groupProvider = groupProvider;
        _spawnService = spawnService;
        _grid = grid;
        _flankingService = flankingService;
        _buffDebuffService = buffDebuffService;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public IReadOnlyList<Monster> SpawnGroup(string groupId, GridPosition centerPosition)
    {
        var groupDef = _groupProvider.GetGroup(groupId);
        if (groupDef is null)
            throw new ArgumentException($"Monster group not found: {groupId}");
        
        var spawnedmonsters = new List<Monster>();
        var positions = GetSpawnPositions(centerPosition, groupDef.Members.Sum(m => m.Count));
        var posIndex = 0;
        
        foreach (var member in groupDef.Members)
        {
            for (int i = 0; i < member.Count; i++)
            {
                var monster = _spawnService.SpawnByDefinitionId(
                    member.MonsterDefinitionId, 
                    positions[posIndex++]);
                monster.SetGroupRole(member.Role);
                spawnedMonsters.Add(monster);
            }
        }
        
        var groupInstance = new MonsterGroupInstance(groupId, groupDef, spawnedMonsters);
        _activeGroups[groupInstance.Id] = groupInstance;
        
        foreach (var monster in spawnedMonsters)
        {
            _monsterToGroup[monster.Id] = groupInstance.Id;
        }
        
        // Apply initial synergies
        ApplySynergies(groupInstance);
        
        _logger.LogInformation("Spawned group {Group} with {Count} members",
            groupDef.Name, spawnedMonsters.Count);
        
        return spawnedMonsters;
    }
    
    public GroupMoveDecision DetermineMove(Monster monster)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
            return GroupMoveDecision.NoGroup();
        
        var groupDef = groupInstance.Definition;
        var target = groupInstance.CurrentTarget;
        
        if (target is null)
            return GroupMoveDecision.NoTarget();
        
        // Check tactics in priority order
        foreach (var tactic in groupDef.Tactics)
        {
            switch (tactic)
            {
                case GroupTactic.Flank:
                    var flankPos = GetBestFlankingPosition(monster, target, groupInstance);
                    if (flankPos is not null)
                    {
                        return GroupMoveDecision.MoveTo(flankPos.Value, tactic);
                    }
                    break;
                
                case GroupTactic.ProtectLeader:
                    var leader = groupInstance.GetLeader();
                    if (leader is not null && monster != leader)
                    {
                        var protectPos = GetProtectionPosition(monster, leader);
                        if (protectPos is not null)
                        {
                            return GroupMoveDecision.MoveTo(protectPos.Value, tactic);
                        }
                    }
                    break;
                
                case GroupTactic.Swarm:
                    var swarmPos = GetClosestPositionToTarget(monster, target);
                    return GroupMoveDecision.MoveTo(swarmPos, tactic);
            }
        }
        
        return GroupMoveDecision.NoAction();
    }
    
    public ICombatant? DetermineTarget(Monster monster, IEnumerable<ICombatant> possibleTargets)
    {
        var groupInstance = GetGroupForMonster(monster);
        if (groupInstance is null)
            return possibleTargets.FirstOrDefault();
        
        var groupDef = groupInstance.Definition;
        var targets = possibleTargets.ToList();
        
        // Focus fire: all attack same target
        if (groupDef.Tactics.Contains(GroupTactic.FocusFire))
        {
            // Pick lowest HP target
            groupInstance.CurrentTarget ??= targets
                .OrderBy(t => t.Health)
                .FirstOrDefault();
            
            return groupInstance.CurrentTarget;
        }
        
        // Default: nearest target
        return targets
            .OrderBy(t => GridPosition.Distance(monster.Position, t.Position))
            .FirstOrDefault();
    }
    
    public void OnGroupMemberHit(Monster attacker, ICombatant target)
    {
        var groupInstance = GetGroupForMonster(attacker);
        if (groupInstance is null) return;
        
        // Apply OnAllyHit synergies
        foreach (var synergy in groupInstance.Definition.Synergies
            .Where(s => s.Trigger == SynergyTrigger.OnAllyHit))
        {
            foreach (var member in groupInstance.AliveMembers.Where(m => m != attacker))
            {
                if (synergy.AttackBonus.HasValue)
                {
                    member.AddTemporaryBonus("attack", synergy.AttackBonus.Value, 1);
                }
            }
        }
    }
    
    private GridPosition? GetBestFlankingPosition(
        Monster monster, 
        ICombatant target,
        MonsterGroupInstance group)
    {
        var flankPositions = _flankingService.GetFlankingPositions(target.Position);
        var allyPositions = group.AliveMembers
            .Where(m => m != monster)
            .Select(m => m.Position)
            .ToHashSet();
        
        // Find unoccupied flanking position
        foreach (var pos in flankPositions)
        {
            if (_grid.IsPassable(pos) && !allyPositions.Contains(pos))
            {
                return pos;
            }
        }
        
        return null;
    }
}
```

### Monster Group Configuration

```json
{
  "$schema": "./schemas/monster-groups.schema.json",
  "monsterGroups": [
    {
      "groupId": "goblin-warband",
      "name": "Goblin Warband",
      "description": "A coordinated group of goblin raiders",
      "members": [
        { "monsterDefinitionId": "goblin-warrior", "count": 3, "role": "melee" },
        { "monsterDefinitionId": "goblin-shaman", "count": 1, "role": "leader" }
      ],
      "tactics": ["Flank", "FocusFire", "ProtectLeader"],
      "leaderRole": "leader",
      "synergies": [
        {
          "synergyId": "shaman-blessing",
          "name": "Shaman's Blessing",
          "description": "Shaman buffs all allies",
          "trigger": "Always",
          "sourceRole": "leader",
          "attackBonus": 1,
          "appliesToAllMembers": true
        },
        {
          "synergyId": "pack-tactics",
          "name": "Pack Tactics",
          "description": "Advantage when ally hits",
          "trigger": "OnAllyHit",
          "attackBonus": 2
        },
        {
          "synergyId": "pack-mentality",
          "name": "Pack Mentality",
          "description": "+1 damage per adjacent ally",
          "trigger": "PerAdjacentAlly",
          "damageBonus": 1
        }
      ]
    },
    {
      "groupId": "skeleton-patrol",
      "name": "Skeleton Patrol",
      "description": "Undead warriors protecting their domain",
      "members": [
        { "monsterDefinitionId": "skeleton-warrior", "count": 2, "role": "melee" },
        { "monsterDefinitionId": "skeleton-archer", "count": 2, "role": "ranged" }
      ],
      "tactics": ["FocusFire", "ProtectCaster"],
      "synergies": [
        {
          "synergyId": "undead-coordination",
          "name": "Undead Coordination",
          "description": "All skeletons attack same target",
          "trigger": "Always"
        }
      ]
    },
    {
      "groupId": "bandit-ambush",
      "name": "Bandit Ambush Team",
      "description": "Opportunistic bandits",
      "members": [
        { "monsterDefinitionId": "bandit-rogue", "count": 2, "role": "striker" },
        { "monsterDefinitionId": "bandit-thug", "count": 2, "role": "melee" }
      ],
      "tactics": ["Ambush", "Flank", "HitAndRun"],
      "synergies": [
        {
          "synergyId": "sneak-attack-setup",
          "name": "Sneak Attack Setup",
          "description": "Strikers get bonus after ally hit",
          "trigger": "OnAllyHit",
          "damageBonus": 2,
          "sourceRole": "striker"
        }
      ]
    }
  ]
}
```

### Acceptance Criteria

- [ ] SpawnGroup creates group with members
- [ ] Group roles assigned correctly
- [ ] Flank tactic positions around target
- [ ] FocusFire targets same enemy
- [ ] ProtectLeader positions near leader
- [ ] Synergies apply bonuses
- [ ] OnAllyHit triggers advantage
- [ ] PerAdjacentAlly scales correctly
- [ ] Leader provides group buffs
- [ ] Group tracks target
- [ ] Member death updates group
- [ ] ~11 unit tests pass

---

## Dependencies & Prerequisites

```
v0.10.3c (Zone Control) - REQUIRED
    │
    └── Combo System complete ────────────────────────────────────────────┐
                                                                          │
v0.10.4 (Advanced Encounters)                                             │
    │                                                                     │
    ├── v0.10.4a: Boss Definitions ───────────────────────────────────────┤
    │       Dependencies: Domain, Monster definitions                     │
    │       Provides: BossDefinition, phases, configuration               │
    │                                                                     │
    ├── v0.10.4b: Boss Mechanics ─────────────────────────────────────────┤
    │       Dependencies: v0.10.4a (bosses), Combat service               │
    │       Provides: IBossMechanicsService, phase transitions            │
    │                                                                     │
    └── v0.10.3c: Monster Groups ─────────────────────────────────────────┘
            Dependencies: Monster AI, Flanking service
            Provides: IMonsterGroupService, coordinated tactics
```

---

## Estimated Effort Summary

| Part | New Files | Modified Files | Est. Tests | Complexity |
|------|-----------|----------------|------------|------------|
| v0.10.4a | ~4 | ~1 | ~12 | Medium |
| v0.10.4b | ~3 | ~3 | ~12 | High |
| v0.10.3c | ~4 | ~2 | ~11 | High |
| **Total** | **~11** | **~6** | **~35** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Phase transition bugs | High | Medium | State machine testing |
| Boss difficulty balance | Medium | Medium | Configurable values |
| Group AI performance | Medium | Low | Limit group size |
| Flank position calculation | Low | Low | Use existing service |

---

## Design Decisions (Confirmed)

### Boss Phases

| Decision | Value | Notes |
|----------|-------|-------|
| **Threshold Type** | Health percentage | Clear, predictable |
| **Phase Direction** | Descending only | No reverse transitions |
| **Transition Effect** | Immediate | During damage event |

### Boss Mechanics

| Decision | Value | Notes |
|----------|-------|-------|
| **Vulnerability Duration** | Turns | Configurable |
| **Vulnerability Multiplier** | 1.5x damage | Significant |
| **Summon Limit** | Per phase config | MaxActive field |

### Monster Groups

| Decision | Value | Notes |
|----------|-------|-------|
| **Group Size** | 2-6 typical | Performance |
| **Flank Priority** | Highest tactic | First matched |
| **Focus Target** | Lowest HP | Coordinated |

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.10.4a Design Spec** - Create detailed design for Boss Definitions
3. **v0.10.4a Implementation** - Build boss structure
4. **v0.10.4b Design Spec** - Create specification for Boss Mechanics
5. **v0.10.4b Implementation** - Build phase transitions
6. **v0.10.3c Design Spec** - Create specification for Monster Groups
7. **v0.10.3c Implementation** - Build group tactics

---

*This scope breakdown completes the v0.10.0 Advanced Combat & Ability Trees series. Boss encounters with phase transitions and monster groups with coordinated tactics create challenging, memorable encounters that require tactical thinking.*
