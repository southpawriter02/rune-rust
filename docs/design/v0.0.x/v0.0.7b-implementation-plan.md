# v0.0.7b Implementation Plan: Weapon System

**Version:** 0.0.7b
**Parent:** v0.0.7 (Equipment System)
**Prerequisites:** v0.0.7a Complete (Core Equipment Infrastructure), v0.0.5c Complete (Combat Integration)
**Status:** Ready for Implementation
**Target Tests:** ~209 -> ~224 (+15 tests)

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Dependencies from Previous Phases](#dependencies-from-previous-phases)
3. [Current System Analysis](#current-system-analysis)
4. [Detailed Implementation](#detailed-implementation)
5. [Flow Diagrams](#flow-diagrams)
6. [Testing Strategy](#testing-strategy)
7. [Logging Strategy](#logging-strategy)
8. [Implementation Checklist](#implementation-checklist)
9. [Acceptance Criteria](#acceptance-criteria)
10. [Risk Assessment](#risk-assessment)
11. [File Summary](#file-summary)

---

## Executive Summary

### Purpose

Implement weapon types with distinct damage dice pools and integrate with the combat system so equipped weapons determine attack damage. This phase transforms weapons from simple inventory items into combat-affecting equipment with unique characteristics per weapon type.

### Scope

**In Scope:**
- `WeaponType` enum (Sword, Axe, Dagger, Staff)
- `WeaponBonuses` value object for weapon-specific stat bonuses
- `DamageDice`, `WeaponType?`, `WeaponBonuses` properties on `Item` entity
- Update `CombatService` to use equipped weapon's damage dice via `DiceService`
- Unarmed combat with reduced base damage (1d4)
- `weapons.json` configuration file with weapon definitions
- Combat output showing weapon name in attack messages
- `WeaponDto` for weapon display

**Out of Scope:**
- Armor defense bonuses (v0.0.7c)
- General stat modifiers from equipment (v0.0.7c)
- Equipment requirements (v0.0.7c)
- Two-handed weapons (future)
- Dual-wielding (future)

### Key Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Damage dice storage | String notation (e.g., "1d8") | Uses existing DicePool.Parse() from v0.0.5 |
| Weapon bonuses | Separate value object | Clean separation, extensible for future stat types |
| Unarmed damage | 1d4 static dice pool | Incentivizes weapon acquisition without being useless |
| Combat integration | DiceService injection | Consistent dice rolling, testable, loggable |

---

## Dependencies from Previous Phases

### Dependencies from v0.0.7a (Core Equipment Infrastructure)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `EquipmentSlot` | `Domain/Enums/EquipmentSlot.cs` | Check `EquipmentSlot.Weapon` |
| `Player.Equipment` | `Domain/Entities/Player.cs` | Get equipped weapon via dictionary |
| `Player.GetEquippedItem()` | `Domain/Entities/Player.cs` | Retrieve weapon for damage calculation |
| `EquipmentService` | `Domain/Services/EquipmentService.cs` | Extended with weapon-specific validation |
| `Item.EquipmentSlot` | `Domain/Entities/Item.cs` | Nullable slot property on items |
| `Item.IsEquippable` | `Domain/Entities/Item.cs` | Check if item can be equipped |

### Dependencies from v0.0.5 (Dice System)

| Type | Location | Usage in this phase |
|------|----------|---------------------|
| `DicePool` | `Domain/ValueObjects/DicePool.cs` | Parse weapon damage dice notation |
| `DicePool.Parse()` | `Domain/ValueObjects/DicePool.cs` | Convert "1d8" string to DicePool |
| `DiceService` | `Application/Services/DiceService.cs` | Roll damage dice in combat |
| `DiceService.Roll()` | `Application/Services/DiceService.cs` | Execute dice roll, return result |

---

## Current System Analysis

### Existing CombatService

**Location:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

**Current Flow:**
```
ResolveCombatRound(player, monster)
    ├── Player attacks first
    │   └── CalculateDamage(player.Stats.Attack, monster.Stats.Defense)
    │       └── baseDamage = max(1, attack - defense) + variance(-2 to +2)
    ├── Monster counterattacks if alive
    │   └── Same damage formula
    └── Return CombatResult
```

**Current Limitation:**
- Uses static `Stats.Attack` value directly
- No weapon-based damage dice
- No distinction between armed/unarmed combat

### New Combat Flow (with Weapons)

```
ResolveCombatRound(player, monster)
    ├── STEP 1: Get Weapon Info (NEW)
    │   ├── weapon = player.GetEquippedItem(EquipmentSlot.Weapon)
    │   ├── Has weapon? Use weapon.DamageDice, weapon.WeaponBonuses
    │   └── No weapon? Use UnarmedDamageDice (1d4)
    │
    ├── STEP 2: Attack Roll (NEW)
    │   ├── Roll 1d10 + Finesse + Weapon Attack Modifier
    │   ├── Compare to Monster Defense
    │   └── Determine hit/miss/critical
    │
    ├── STEP 3: Damage Roll (if hit) (NEW)
    │   ├── Roll Weapon Dice (doubled on critical)
    │   ├── + Might + Weapon Bonus
    │   ├── - Monster Armor Reduction
    │   └── Apply damage to monster
    │
    ├── STEP 4: Monster Counterattack
    │   └── (Unchanged - static formula for now)
    │
    └── STEP 5: Return Result
```

---

## Detailed Implementation

### Domain Layer

#### 1. WeaponType.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/WeaponType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Defines the type of weapon, affecting combat style and bonuses.
/// </summary>
/// <remarks>
/// Each weapon type has distinct characteristics:
/// - Swords: Balanced, reliable damage
/// - Axes: High damage, accuracy penalty
/// - Daggers: Low damage, Finesse bonus
/// - Staffs: Moderate damage, Will bonus
/// </remarks>
public enum WeaponType
{
    /// <summary>Balanced melee weapons. Standard damage, no special modifiers.</summary>
    Sword,

    /// <summary>Heavy chopping weapons. Higher damage dice, attack roll penalty.</summary>
    Axe,

    /// <summary>Quick, precise weapons. Lower damage dice, Finesse bonus.</summary>
    Dagger,

    /// <summary>Magic-focused weapons. Moderate damage, Will bonus.</summary>
    Staff
}
```

#### 2. WeaponBonuses.cs (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/WeaponBonuses.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents stat bonuses provided by a weapon when equipped.
/// </summary>
/// <param name="Might">Bonus to Might attribute.</param>
/// <param name="Fortitude">Bonus to Fortitude attribute.</param>
/// <param name="Will">Bonus to Will attribute.</param>
/// <param name="Wits">Bonus to Wits attribute.</param>
/// <param name="Finesse">Bonus to Finesse attribute.</param>
/// <param name="AttackModifier">Flat bonus/penalty to attack rolls.</param>
public readonly record struct WeaponBonuses(
    int Might = 0,
    int Fortitude = 0,
    int Will = 0,
    int Wits = 0,
    int Finesse = 0,
    int AttackModifier = 0)
{
    /// <summary>Returns true if this weapon provides any bonuses.</summary>
    public bool HasBonuses => Might != 0 || Fortitude != 0 || Will != 0 ||
                              Wits != 0 || Finesse != 0 || AttackModifier != 0;

    /// <summary>Creates an empty bonuses instance (no bonuses).</summary>
    public static WeaponBonuses None => new();

    /// <summary>Creates bonuses for a Finesse-based weapon.</summary>
    public static WeaponBonuses ForFinesse(int bonus) => new(Finesse: bonus);

    /// <summary>Creates bonuses for a Will-based weapon.</summary>
    public static WeaponBonuses ForWill(int bonus) => new(Will: bonus);

    /// <summary>Creates bonuses with an attack modifier.</summary>
    public static WeaponBonuses ForAttack(int modifier) => new(AttackModifier: modifier);

    /// <summary>Returns a display string of non-zero bonuses.</summary>
    public override string ToString()
    {
        var parts = new List<string>();
        if (Might != 0) parts.Add($"{(Might > 0 ? "+" : "")}{Might} Might");
        if (Fortitude != 0) parts.Add($"{(Fortitude > 0 ? "+" : "")}{Fortitude} Fortitude");
        if (Will != 0) parts.Add($"{(Will > 0 ? "+" : "")}{Will} Will");
        if (Wits != 0) parts.Add($"{(Wits > 0 ? "+" : "")}{Wits} Wits");
        if (Finesse != 0) parts.Add($"{(Finesse > 0 ? "+" : "")}{Finesse} Finesse");
        if (AttackModifier != 0) parts.Add($"{(AttackModifier > 0 ? "+" : "")}{AttackModifier} Attack");
        return parts.Count > 0 ? string.Join(", ", parts) : "None";
    }
}
```

#### 3. Item.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Entities/Item.cs`

**Changes:**
1. Add `DamageDice` property (string, nullable)
2. Add `WeaponType?` property
3. Add `WeaponBonuses` property
4. Add `IsWeapon` computed property
5. Add `GetDamageDicePool()` method
6. Update constructor with new parameters
7. Update `CreateSword()` factory with weapon properties
8. Add factory methods for each weapon type

```csharp
// Add new properties after existing ones:

/// <summary>
/// Gets the damage dice notation for this weapon (e.g., "1d8", "2d6").
/// </summary>
public string? DamageDice { get; private set; }

/// <summary>
/// Gets the type of weapon this item is, or null if not a weapon.
/// </summary>
public WeaponType? WeaponType { get; private set; }

/// <summary>
/// Gets the stat bonuses provided by this weapon when equipped.
/// </summary>
public WeaponBonuses WeaponBonuses { get; private set; } = WeaponBonuses.None;

/// <summary>
/// Gets whether this item is a weapon.
/// </summary>
public bool IsWeapon => WeaponType.HasValue && EquipmentSlot == Enums.EquipmentSlot.Weapon;

/// <summary>
/// Gets the parsed damage dice pool for combat calculations.
/// </summary>
public DicePool? GetDamageDicePool()
{
    if (string.IsNullOrWhiteSpace(DamageDice))
        return null;
    return DicePool.Parse(DamageDice);
}

// Update constructor to accept weapon properties:
public Item(
    string name,
    string description,
    ItemType type,
    int value = 0,
    ItemEffect effect = ItemEffect.None,
    int effectValue = 0,
    int effectDuration = 0,
    EquipmentSlot? equipmentSlot = null,
    string? damageDice = null,           // NEW
    WeaponType? weaponType = null,       // NEW
    WeaponBonuses? weaponBonuses = null) // NEW
{
    Id = Guid.NewGuid();
    Name = name ?? throw new ArgumentNullException(nameof(name));
    Description = description ?? throw new ArgumentNullException(nameof(description));
    Type = type;
    Value = value;
    Effect = effect;
    EffectValue = effectValue;
    EffectDuration = effectDuration;
    EquipmentSlot = equipmentSlot;
    DamageDice = damageDice;
    WeaponType = weaponType;
    WeaponBonuses = weaponBonuses ?? WeaponBonuses.None;
}

// Update factory method:
public static Item CreateSword() => new(
    "Rusty Sword",
    "An old sword covered in rust. Still sharp enough to cut.",
    ItemType.Weapon,
    value: 5,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d8",
    weaponType: Enums.WeaponType.Sword
);

// Add new factory methods for each weapon type:
public static Item CreateIronSword() => new(
    "Iron Sword",
    "A standard iron sword. Reliable and balanced.",
    ItemType.Weapon,
    value: 50,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d8",
    weaponType: Enums.WeaponType.Sword
);

public static Item CreateBattleAxe() => new(
    "Battle Axe",
    "A heavy two-handed axe. Hits hard but swings slow.",
    ItemType.Weapon,
    value: 75,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d10",
    weaponType: Enums.WeaponType.Axe,
    weaponBonuses: WeaponBonuses.ForAttack(-1)
);

public static Item CreateSteelDagger() => new(
    "Steel Dagger",
    "A quick, precise blade favored by rogues.",
    ItemType.Weapon,
    value: 40,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d4",
    weaponType: Enums.WeaponType.Dagger,
    weaponBonuses: WeaponBonuses.ForFinesse(2)
);

public static Item CreateOakStaff() => new(
    "Oak Staff",
    "A sturdy wooden staff imbued with minor magic.",
    ItemType.Weapon,
    value: 45,
    equipmentSlot: Enums.EquipmentSlot.Weapon,
    damageDice: "1d6",
    weaponType: Enums.WeaponType.Staff,
    weaponBonuses: WeaponBonuses.ForWill(2)
);
```

#### 4. CombatService.cs (MODIFY)

**File:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs`

**Changes:**
1. Add `DiceService?` dependency
2. Add static `UnarmedDamageDice` and `DefaultWeaponDice` pools
3. Add `GetPlayerDamageDice()` method
4. Add `GetPlayerWeaponName()` method
5. Add `GetWeaponAttackModifier()` method
6. Add `GetWeaponBonuses()` method
7. Add `ResolveCombatRoundWithDice()` private method
8. Modify `ResolveCombatRound()` to use dice when DiceService available

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.Services;

/// <summary>
/// Handles combat resolution between players and monsters.
/// </summary>
public class CombatService
{
    /// <summary>
    /// Default damage dice for unarmed combat.
    /// </summary>
    public static readonly DicePool UnarmedDamageDice = DicePool.D4();

    /// <summary>
    /// Default damage dice when no weapon system is active (fallback).
    /// </summary>
    public static readonly DicePool DefaultWeaponDice = DicePool.D6();

    private readonly Random _random = new();
    private readonly ILogger<CombatService> _logger;
    private readonly DiceService? _diceService;

    /// <summary>
    /// Creates a new combat service instance.
    /// </summary>
    public CombatService(ILogger<CombatService>? logger = null, DiceService? diceService = null)
    {
        _logger = logger ?? NullLogger<CombatService>.Instance;
        _diceService = diceService;
        _logger.LogDebug("CombatService initialized with DiceService: {HasDiceService}", _diceService != null);
    }

    /// <summary>
    /// Gets the damage dice pool for a player based on their equipped weapon.
    /// </summary>
    public DicePool GetPlayerDamageDice(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);

        var equippedWeapon = player.GetEquippedItem(EquipmentSlot.Weapon);

        if (equippedWeapon == null)
        {
            _logger.LogDebug("Player {Player} has no weapon equipped, using unarmed dice: {Dice}",
                player.Name, UnarmedDamageDice);
            return UnarmedDamageDice;
        }

        var weaponDice = equippedWeapon.GetDamageDicePool();
        if (weaponDice == null)
        {
            _logger.LogWarning(
                "Equipped weapon {Weapon} has no damage dice, using default: {Dice}",
                equippedWeapon.Name, DefaultWeaponDice);
            return DefaultWeaponDice;
        }

        _logger.LogDebug("Player {Player} using weapon {Weapon} with dice: {Dice}",
            player.Name, equippedWeapon.Name, weaponDice);

        return weaponDice.Value;
    }

    /// <summary>
    /// Gets the equipped weapon's name for combat messages.
    /// </summary>
    public string GetPlayerWeaponName(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);
        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.Name ?? "fists";
    }

    /// <summary>
    /// Gets the attack roll modifier from the player's equipped weapon.
    /// </summary>
    public int GetWeaponAttackModifier(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);
        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.WeaponBonuses.AttackModifier ?? 0;
    }

    /// <summary>
    /// Gets total attribute bonuses from the player's equipped weapon.
    /// </summary>
    public WeaponBonuses GetWeaponBonuses(Player player)
    {
        ArgumentNullException.ThrowIfNull(player);
        var weapon = player.GetEquippedItem(EquipmentSlot.Weapon);
        return weapon?.WeaponBonuses ?? WeaponBonuses.None;
    }

    /// <summary>
    /// Resolves a single round of combat between a player and a monster.
    /// </summary>
    public CombatResult ResolveCombatRound(Player player, Monster monster)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentNullException.ThrowIfNull(monster);

        var weaponName = GetPlayerWeaponName(player);
        _logger.LogDebug(
            "Resolving combat round - Player: {PlayerName} with {Weapon} vs Monster: {MonsterName}",
            player.Name, weaponName, monster.Name);

        // Use dice-based combat if DiceService available
        if (_diceService != null)
        {
            return ResolveCombatRoundWithDice(player, monster);
        }

        // Legacy static combat (fallback)
        return ResolveCombatRoundStatic(player, monster);
    }

    /// <summary>
    /// Resolves combat using dice-based mechanics.
    /// </summary>
    private CombatResult ResolveCombatRoundWithDice(Player player, Monster monster)
    {
        // Get weapon info
        var damageDice = GetPlayerDamageDice(player);
        var weaponAttackMod = GetWeaponAttackModifier(player);
        var weaponBonuses = GetWeaponBonuses(player);

        // Calculate effective Finesse (base + weapon bonus)
        var effectiveFinesse = player.Attributes.Finesse + weaponBonuses.Finesse;

        // Attack roll: 1d10 + Finesse + Weapon Attack Modifier
        var attackRoll = _diceService!.Roll(DicePool.D10());
        var attackTotal = attackRoll.Total + effectiveFinesse + weaponAttackMod;

        var isHit = attackTotal >= monster.Stats.Defense || attackRoll.IsNaturalMax;
        var isCriticalHit = attackRoll.IsNaturalMax;
        var isCriticalMiss = attackRoll.IsNaturalOne;

        int playerDamage = 0;

        if (isHit && !isCriticalMiss)
        {
            // Double dice on critical hit
            var actualDamageDice = isCriticalHit
                ? damageDice with { Count = damageDice.Count * 2 }
                : damageDice;

            // Calculate effective Might (base + weapon bonus)
            var effectiveMight = player.Attributes.Might + weaponBonuses.Might;

            // Damage roll: Weapon Dice + Might - Armor
            var damageRoll = _diceService.Roll(actualDamageDice);
            var armorReduction = monster.Stats.Defense / 2;
            playerDamage = Math.Max(1, damageRoll.Total + effectiveMight - armorReduction);

            monster.TakeDamage(playerDamage);

            _logger.LogDebug(
                "Player attack: Roll={Roll}+{Finesse}+{WeaponMod}={Total} vs DEF {Defense} -> HIT. " +
                "Damage: {DamageDice}={DamageRoll}+{Might}-{Armor}={FinalDamage}",
                attackRoll.Total, effectiveFinesse, weaponAttackMod, attackTotal, monster.Stats.Defense,
                actualDamageDice, damageRoll.Total, effectiveMight, armorReduction, playerDamage);
        }
        else
        {
            _logger.LogDebug(
                "Player attack: Roll={Roll}+{Finesse}+{WeaponMod}={Total} vs DEF {Defense} -> MISS",
                attackRoll.Total, effectiveFinesse, weaponAttackMod, attackTotal, monster.Stats.Defense);
        }

        // Monster counterattack
        var monsterDamage = 0;
        if (monster.IsAlive)
        {
            monsterDamage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
            player.TakeDamage(monsterDamage);
        }

        return new CombatResult(
            DamageDealt: playerDamage,
            DamageReceived: monsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Resolves combat using static calculations (legacy).
    /// </summary>
    private CombatResult ResolveCombatRoundStatic(Player player, Monster monster)
    {
        var playerDamage = CalculateDamage(player.Stats.Attack, monster.Stats.Defense);
        monster.TakeDamage(playerDamage);

        var monsterDamage = 0;
        if (monster.IsAlive)
        {
            monsterDamage = CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
            player.TakeDamage(monsterDamage);
        }

        return new CombatResult(
            DamageDealt: playerDamage,
            DamageReceived: monsterDamage,
            MonsterDefeated: monster.IsDefeated,
            PlayerDefeated: player.IsDead
        );
    }

    /// <summary>
    /// Calculates damage using static formula (legacy).
    /// </summary>
    private int CalculateDamage(int attack, int defense)
    {
        var baseDamage = Math.Max(1, attack - defense);
        var variance = _random.Next(-2, 3);
        return Math.Max(1, baseDamage + variance);
    }

    // ... existing methods (MonsterAttack, GetCombatDescription, etc.)
}
```

### Application Layer

#### 5. WeaponDto.cs (NEW)

**File:** `src/Core/RuneAndRust.Application/DTOs/WeaponDto.cs`

```csharp
using RuneAndRust.Domain.Entities;

namespace RuneAndRust.Application.DTOs;

/// <summary>
/// DTO for displaying weapon information.
/// </summary>
/// <param name="Name">The weapon's display name.</param>
/// <param name="WeaponType">The type of weapon (Sword, Axe, etc.).</param>
/// <param name="DamageDice">The damage dice notation (e.g., "1d8").</param>
/// <param name="Description">The weapon's description.</param>
/// <param name="Bonuses">String representation of weapon bonuses.</param>
public record WeaponDto(
    string Name,
    string WeaponType,
    string DamageDice,
    string Description,
    string? Bonuses = null)
{
    /// <summary>
    /// Creates a WeaponDto from an Item.
    /// </summary>
    public static WeaponDto? FromItem(Item item)
    {
        if (!item.IsWeapon || item.WeaponType == null)
            return null;

        return new WeaponDto(
            item.Name,
            item.WeaponType.Value.ToString(),
            item.DamageDice ?? "1d4",
            item.Description,
            item.WeaponBonuses.HasBonuses ? item.WeaponBonuses.ToString() : null);
    }
}
```

### Configuration

#### 6. weapons.json (NEW)

**File:** `config/weapons.json`

```json
{
  "$schema": "weapons.schema.json",
  "weapons": [
    {
      "id": "rusty_sword",
      "name": "Rusty Sword",
      "description": "An old sword covered in rust. Still sharp enough to cut.",
      "weaponType": "Sword",
      "damageDice": "1d8",
      "value": 5
    },
    {
      "id": "iron_sword",
      "name": "Iron Sword",
      "description": "A standard iron sword. Reliable and balanced.",
      "weaponType": "Sword",
      "damageDice": "1d8",
      "value": 50
    },
    {
      "id": "steel_sword",
      "name": "Steel Sword",
      "description": "A finely crafted steel sword with excellent balance.",
      "weaponType": "Sword",
      "damageDice": "1d8+1",
      "value": 150
    },
    {
      "id": "battle_axe",
      "name": "Battle Axe",
      "description": "A heavy two-handed axe. Hits hard but swings slow.",
      "weaponType": "Axe",
      "damageDice": "1d10",
      "attackModifier": -1,
      "value": 75
    },
    {
      "id": "great_axe",
      "name": "Great Axe",
      "description": "An enormous axe capable of devastating blows.",
      "weaponType": "Axe",
      "damageDice": "2d6",
      "attackModifier": -2,
      "value": 200
    },
    {
      "id": "steel_dagger",
      "name": "Steel Dagger",
      "description": "A quick, precise blade favored by rogues.",
      "weaponType": "Dagger",
      "damageDice": "1d4",
      "statBonuses": { "finesse": 2 },
      "value": 40
    },
    {
      "id": "assassins_blade",
      "name": "Assassin's Blade",
      "description": "A wickedly sharp dagger perfect for striking vital points.",
      "weaponType": "Dagger",
      "damageDice": "1d4+2",
      "statBonuses": { "finesse": 3 },
      "value": 250
    },
    {
      "id": "oak_staff",
      "name": "Oak Staff",
      "description": "A sturdy wooden staff imbued with minor magic.",
      "weaponType": "Staff",
      "damageDice": "1d6",
      "statBonuses": { "will": 2 },
      "value": 45
    },
    {
      "id": "arcane_staff",
      "name": "Arcane Staff",
      "description": "A staff crackling with magical energy.",
      "weaponType": "Staff",
      "damageDice": "1d6+1",
      "statBonuses": { "will": 4 },
      "value": 300
    }
  ]
}
```

---

## Flow Diagrams

### Combat Round Flow (with Weapons)

```
ResolveCombatRound(player, monster)
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 1: GET WEAPON INFO                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  weapon = player.GetEquippedItem(EquipmentSlot.Weapon)                      │
│  ├── Has weapon? Use weapon.DamageDice, weapon.WeaponBonuses                │
│  └── No weapon? Use UnarmedDamageDice (1d4), no bonuses                     │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 2: ATTACK ROLL                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  Roll 1d10 + Finesse (base + weapon bonus) + Weapon Attack Modifier         │
│  Compare to Monster Defense:                                                 │
│  ├── Total >= Defense OR Natural 10 → HIT                                   │
│  ├── Natural 10 → CRITICAL HIT                                              │
│  └── Natural 1 → CRITICAL MISS (always misses)                              │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 3: DAMAGE ROLL (if hit)                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  Dice = Weapon Damage Dice (doubled on critical)                            │
│  Roll Weapon Dice + Might (base + weapon bonus) - Monster Defense / 2       │
│  = Final Damage (minimum 1)                                                 │
│  monster.TakeDamage(finalDamage)                                            │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                    STEP 4: MONSTER COUNTERATTACK                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  If monster.IsAlive: Calculate monster damage (static formula for now)      │
└─────────────────────────────────────────────────────────────────────────────┘
                │
                ▼
            Return CombatResult
```

---

## Testing Strategy

### Test Organization

```
tests/
├── RuneAndRust.Domain.UnitTests/
│   ├── Enums/
│   │   └── WeaponTypeTests.cs              (3 tests)
│   ├── ValueObjects/
│   │   └── WeaponBonusesTests.cs           (7 tests)
│   ├── Entities/
│   │   └── ItemWeaponTests.cs              (5 tests) - add to existing ItemTests
│   └── Services/
│       └── CombatServiceWeaponTests.cs     (8 tests)
```

### Test Files (~15 tests total)

#### WeaponTypeTests.cs (3 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Enums/WeaponTypeTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.UnitTests.Enums;

[TestFixture]
public class WeaponTypeTests
{
    [Test]
    public void WeaponType_ContainsAllExpectedValues()
    {
        // Assert
        Enum.GetValues<WeaponType>().Should().HaveCount(4);
        Enum.IsDefined(WeaponType.Sword).Should().BeTrue();
        Enum.IsDefined(WeaponType.Axe).Should().BeTrue();
        Enum.IsDefined(WeaponType.Dagger).Should().BeTrue();
        Enum.IsDefined(WeaponType.Staff).Should().BeTrue();
    }

    [Test]
    [TestCase("Sword", WeaponType.Sword)]
    [TestCase("sword", WeaponType.Sword)]
    [TestCase("DAGGER", WeaponType.Dagger)]
    public void TryParse_ValidWeaponType_ReturnsTrue(string input, WeaponType expected)
    {
        // Act
        var success = Enum.TryParse<WeaponType>(input, ignoreCase: true, out var result);

        // Assert
        success.Should().BeTrue();
        result.Should().Be(expected);
    }

    [Test]
    [TestCase("InvalidWeapon")]
    [TestCase("Bow")]
    [TestCase("")]
    public void TryParse_InvalidWeaponType_ReturnsFalse(string input)
    {
        // Act
        var success = Enum.TryParse<WeaponType>(input, ignoreCase: true, out _);

        // Assert
        success.Should().BeFalse();
    }
}
```

#### WeaponBonusesTests.cs (7 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/WeaponBonusesTests.cs`

```csharp
using FluentAssertions;
using NUnit.Framework;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class WeaponBonusesTests
{
    [Test]
    public void None_HasNoBonuses()
    {
        // Act
        var bonuses = WeaponBonuses.None;

        // Assert
        bonuses.HasBonuses.Should().BeFalse();
        bonuses.Might.Should().Be(0);
        bonuses.Finesse.Should().Be(0);
        bonuses.AttackModifier.Should().Be(0);
    }

    [Test]
    public void ForFinesse_CreatesFinesseBonus()
    {
        // Act
        var bonuses = WeaponBonuses.ForFinesse(2);

        // Assert
        bonuses.HasBonuses.Should().BeTrue();
        bonuses.Finesse.Should().Be(2);
        bonuses.Might.Should().Be(0);
    }

    [Test]
    public void ForWill_CreatesWillBonus()
    {
        // Act
        var bonuses = WeaponBonuses.ForWill(3);

        // Assert
        bonuses.HasBonuses.Should().BeTrue();
        bonuses.Will.Should().Be(3);
    }

    [Test]
    public void ForAttack_CreatesAttackModifier()
    {
        // Act
        var bonuses = WeaponBonuses.ForAttack(-1);

        // Assert
        bonuses.HasBonuses.Should().BeTrue();
        bonuses.AttackModifier.Should().Be(-1);
    }

    [Test]
    public void HasBonuses_WithNonZeroValue_ReturnsTrue()
    {
        // Arrange
        var bonuses = new WeaponBonuses(Might: 1);

        // Assert
        bonuses.HasBonuses.Should().BeTrue();
    }

    [Test]
    public void HasBonuses_WithAllZeros_ReturnsFalse()
    {
        // Arrange
        var bonuses = new WeaponBonuses();

        // Assert
        bonuses.HasBonuses.Should().BeFalse();
    }

    [Test]
    public void ToString_FormatsCorrectly()
    {
        // Arrange
        var bonuses = new WeaponBonuses(Might: 2, Finesse: -1, AttackModifier: 1);

        // Act
        var result = bonuses.ToString();

        // Assert
        result.Should().Contain("+2 Might");
        result.Should().Contain("-1 Finesse");
        result.Should().Contain("+1 Attack");
    }
}
```

#### ItemWeaponTests.cs (5 tests) - extend existing ItemTests

```csharp
// Add to existing tests/RuneAndRust.Domain.UnitTests/Entities/ItemTests.cs

[Test]
public void CreateSword_HasWeaponProperties()
{
    // Act
    var sword = Item.CreateSword();

    // Assert
    sword.IsWeapon.Should().BeTrue();
    sword.WeaponType.Should().Be(WeaponType.Sword);
    sword.DamageDice.Should().Be("1d8");
    sword.EquipmentSlot.Should().Be(EquipmentSlot.Weapon);
}

[Test]
public void CreateBattleAxe_HasAttackPenalty()
{
    // Act
    var axe = Item.CreateBattleAxe();

    // Assert
    axe.WeaponType.Should().Be(WeaponType.Axe);
    axe.WeaponBonuses.AttackModifier.Should().Be(-1);
}

[Test]
public void IsWeapon_WithWeaponItem_ReturnsTrue()
{
    // Arrange
    var sword = Item.CreateSword();

    // Assert
    sword.IsWeapon.Should().BeTrue();
}

[Test]
public void IsWeapon_WithNonWeaponItem_ReturnsFalse()
{
    // Arrange
    var potion = Item.CreateHealthPotion();

    // Assert
    potion.IsWeapon.Should().BeFalse();
}

[Test]
public void GetDamageDicePool_ReturnsValidPool()
{
    // Arrange
    var sword = Item.CreateSword();

    // Act
    var dicePool = sword.GetDamageDicePool();

    // Assert
    dicePool.Should().NotBeNull();
    dicePool!.Value.Count.Should().Be(1);
    dicePool.Value.Sides.Should().Be(8);
}
```

#### CombatServiceWeaponTests.cs (8 tests)

**File:** `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceWeaponTests.cs`

```csharp
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using NUnit.Framework;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Services;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.Services;

[TestFixture]
public class CombatServiceWeaponTests
{
    private CombatService _service = null!;

    [SetUp]
    public void SetUp()
    {
        _service = new CombatService(NullLogger<CombatService>.Instance);
    }

    private static Player CreateTestPlayer()
    {
        return new Player("TestHero");
    }

    [Test]
    public void GetPlayerDamageDice_WithWeapon_ReturnsWeaponDice()
    {
        // Arrange
        var player = CreateTestPlayer();
        var sword = Item.CreateSword();
        player.Inventory.TryAdd(sword);
        // Assume EquipmentService.TryEquip exists from v0.0.7a
        player.TryEquip(sword);

        // Act
        var dice = _service.GetPlayerDamageDice(player);

        // Assert
        dice.Sides.Should().Be(8); // 1d8 for sword
    }

    [Test]
    public void GetPlayerDamageDice_Unarmed_ReturnsD4()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var dice = _service.GetPlayerDamageDice(player);

        // Assert
        dice.Should().Be(CombatService.UnarmedDamageDice);
        dice.Sides.Should().Be(4);
    }

    [Test]
    public void GetPlayerWeaponName_WithWeapon_ReturnsName()
    {
        // Arrange
        var player = CreateTestPlayer();
        var sword = Item.CreateSword();
        player.TryEquip(sword);

        // Act
        var name = _service.GetPlayerWeaponName(player);

        // Assert
        name.Should().Be("Rusty Sword");
    }

    [Test]
    public void GetPlayerWeaponName_Unarmed_ReturnsFists()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var name = _service.GetPlayerWeaponName(player);

        // Assert
        name.Should().Be("fists");
    }

    [Test]
    public void GetWeaponAttackModifier_WithModifier_ReturnsValue()
    {
        // Arrange
        var player = CreateTestPlayer();
        var axe = Item.CreateBattleAxe();
        player.TryEquip(axe);

        // Act
        var modifier = _service.GetWeaponAttackModifier(player);

        // Assert
        modifier.Should().Be(-1);
    }

    [Test]
    public void GetWeaponAttackModifier_NoWeapon_ReturnsZero()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var modifier = _service.GetWeaponAttackModifier(player);

        // Assert
        modifier.Should().Be(0);
    }

    [Test]
    public void GetWeaponBonuses_WithBonuses_ReturnsBonuses()
    {
        // Arrange
        var player = CreateTestPlayer();
        var dagger = Item.CreateSteelDagger();
        player.TryEquip(dagger);

        // Act
        var bonuses = _service.GetWeaponBonuses(player);

        // Assert
        bonuses.HasBonuses.Should().BeTrue();
        bonuses.Finesse.Should().Be(2);
    }

    [Test]
    public void GetWeaponBonuses_NoWeapon_ReturnsNone()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var bonuses = _service.GetWeaponBonuses(player);

        // Assert
        bonuses.Should().Be(WeaponBonuses.None);
    }
}
```

---

## Logging Strategy

### Log Levels by Operation

| Operation | Level | Example |
|-----------|-------|---------|
| Weapon lookup | Debug | "Player {Player} using weapon {Weapon} with dice: {Dice}" |
| No weapon equipped | Debug | "Player {Player} has no weapon equipped, using unarmed dice" |
| Attack roll | Debug | "Attack: Roll={Roll}+{Finesse}+{WeaponMod}={Total} vs DEF {Defense}" |
| Damage roll | Debug | "Damage: {DamageDice}={DamageRoll}+{Might}-{Armor}={FinalDamage}" |
| Combat result | Information | "Combat round complete - Dealt: {DamageDealt}, Received: {DamageReceived}" |
| Invalid weapon dice | Warning | "Equipped weapon {Weapon} has no damage dice, using default" |

---

## Implementation Checklist

### Phase 1: Domain Layer - Enums & Value Objects
- [ ] Create `src/Core/RuneAndRust.Domain/Enums/WeaponType.cs`
- [ ] Create `src/Core/RuneAndRust.Domain/ValueObjects/WeaponBonuses.cs`

### Phase 2: Domain Layer - Entity Modifications
- [ ] Modify `src/Core/RuneAndRust.Domain/Entities/Item.cs`
  - [ ] Add `DamageDice` property
  - [ ] Add `WeaponType?` property
  - [ ] Add `WeaponBonuses` property
  - [ ] Add `IsWeapon` computed property
  - [ ] Add `GetDamageDicePool()` method
  - [ ] Update constructor with new parameters
  - [ ] Update `CreateSword()` factory
  - [ ] Add `CreateIronSword()` factory
  - [ ] Add `CreateBattleAxe()` factory
  - [ ] Add `CreateSteelDagger()` factory
  - [ ] Add `CreateOakStaff()` factory

### Phase 3: Domain Layer - Service Modifications
- [ ] Modify `src/Core/RuneAndRust.Domain/Services/CombatService.cs`
  - [ ] Add `DiceService?` dependency to constructor
  - [ ] Add `UnarmedDamageDice` static field
  - [ ] Add `DefaultWeaponDice` static field
  - [ ] Add `GetPlayerDamageDice()` method
  - [ ] Add `GetPlayerWeaponName()` method
  - [ ] Add `GetWeaponAttackModifier()` method
  - [ ] Add `GetWeaponBonuses()` method
  - [ ] Add `ResolveCombatRoundWithDice()` private method
  - [ ] Modify `ResolveCombatRound()` to branch based on DiceService availability

### Phase 4: Application Layer
- [ ] Create `src/Core/RuneAndRust.Application/DTOs/WeaponDto.cs`
- [ ] Modify renderer to show weapon info in combat output (if applicable)

### Phase 5: Configuration
- [ ] Create `config/weapons.json` with 9 weapon definitions

### Phase 6: Testing
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Enums/WeaponTypeTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/ValueObjects/WeaponBonusesTests.cs`
- [ ] Add weapon tests to `tests/RuneAndRust.Domain.UnitTests/Entities/ItemTests.cs`
- [ ] Create `tests/RuneAndRust.Domain.UnitTests/Services/CombatServiceWeaponTests.cs`

### Phase 7: Validation
- [ ] All ~15 new tests pass
- [ ] All existing tests pass
- [ ] Build completes with 0 errors
- [ ] Build completes with 0 warnings

---

## Acceptance Criteria

### WeaponType Enum
- [ ] Contains Sword, Axe, Dagger, Staff values
- [ ] Can be parsed from strings (case-insensitive)

### WeaponBonuses Value Object
- [ ] `None` returns instance with all zeros
- [ ] `ForFinesse()`, `ForWill()`, `ForAttack()` factory methods work
- [ ] `HasBonuses` correctly identifies non-zero values
- [ ] `ToString()` formats bonuses for display

### Item Entity
- [ ] Has `DamageDice` property (nullable string)
- [ ] Has `WeaponType` property (nullable)
- [ ] Has `WeaponBonuses` property
- [ ] `IsWeapon` returns true only for weapon items with Weapon slot
- [ ] `GetDamageDicePool()` parses and returns valid DicePool
- [ ] Factory methods create weapons with correct properties

### CombatService
- [ ] `GetPlayerDamageDice()` returns weapon dice when equipped
- [ ] `GetPlayerDamageDice()` returns 1d4 when unarmed
- [ ] `GetPlayerWeaponName()` returns weapon name or "fists"
- [ ] `GetWeaponAttackModifier()` returns weapon attack modifier
- [ ] `GetWeaponBonuses()` returns weapon stat bonuses
- [ ] Combat uses weapon dice for damage rolls when DiceService available
- [ ] Weapon bonuses apply to effective stats in combat
- [ ] Critical hits double damage dice

### Configuration
- [ ] `weapons.json` loads successfully
- [ ] All 9 weapons defined with correct properties

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| DicePool.Parse() format incompatible | High | Low | Verify DicePool notation from v0.0.5 matches design |
| Player.GetEquippedItem() not implemented | High | Low | Prerequisite v0.0.7a must be complete |
| DiceService not injectable | Medium | Low | Design allows null DiceService with fallback |
| Attribute names don't match | Medium | Medium | Verify PlayerAttributes from existing codebase |
| Combat balance issues | Low | Medium | Values from design spec, adjustable via config |

---

## File Summary

### Files to Create (New)

| File | Purpose | Est. Lines |
|------|---------|------------|
| `src/Core/RuneAndRust.Domain/Enums/WeaponType.cs` | Weapon type enum | ~25 |
| `src/Core/RuneAndRust.Domain/ValueObjects/WeaponBonuses.cs` | Weapon bonuses value object | ~55 |
| `src/Core/RuneAndRust.Application/DTOs/WeaponDto.cs` | Weapon display DTO | ~30 |
| `config/weapons.json` | Weapon definitions | ~90 |
| `tests/.../Enums/WeaponTypeTests.cs` | Enum tests | ~40 |
| `tests/.../ValueObjects/WeaponBonusesTests.cs` | Value object tests | ~80 |
| `tests/.../Services/CombatServiceWeaponTests.cs` | Combat integration tests | ~150 |

### Files to Modify

| File | Changes |
|------|---------|
| `src/Core/RuneAndRust.Domain/Entities/Item.cs` | Add DamageDice, WeaponType, WeaponBonuses properties; update constructor; add factory methods (~60 lines) |
| `src/Core/RuneAndRust.Domain/Services/CombatService.cs` | Add DiceService dependency, weapon methods, dice-based combat (~150 lines) |
| `tests/RuneAndRust.Domain.UnitTests/Entities/ItemTests.cs` | Add weapon property tests (~40 lines) |

### Final Metrics

| Metric | Before | After |
|--------|--------|-------|
| Unit Tests | ~209 | ~224 |
| WeaponType values | 0 | 4 |
| Weapon factory methods | 1 | 5 |

---

## Next Steps

After completing this phase:

1. **v0.0.7c (Armor & Stat Modifiers)** - Armor defense bonuses, combined stat modifiers from all equipment
2. **v0.0.7d (Equipment Requirements)** - Level/stat requirements for equipping items

---

*This implementation plan provides the detailed blueprint for v0.0.7b Weapon System. It builds on v0.0.7a (Core Equipment Infrastructure) and integrates with v0.0.5's dice system to provide meaningful combat differentiation based on equipped weapons.*
