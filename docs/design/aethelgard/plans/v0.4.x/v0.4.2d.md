# Implementation Plan: v0.4.2d - The Parley (TUI & Game Loop Integration)

**Status:** Ready for Implementation
**Theme:** "The Parley"
**Scope:** DialogueController for input handling, DialogueScreenRenderer for TUI display, GamePhase.Dialogue integration, "talk" command parsing
**Depends On:** v0.4.2c (DialogueService, DialogueViewModel)

---

## Executive Summary

v0.4.2d integrates the **Dialogue System into the Terminal UI** — the final connection between the DialogueService logic and player interaction. This release enables players to initiate conversations with NPCs using the `talk` command and navigate branching dialogue using keyboard controls.

**Key Features:**
- **DialogueController:** Key-based input handling (Up/Down/Enter/Escape) following SagaController pattern
- **DialogueScreenRenderer:** Spectre.Console-based TUI with NPC speaker, dialogue text, and selectable options
- **GamePhase.Dialogue:** New game phase for modal dialogue state
- **"talk" Command:** New exploration command to initiate dialogue with NPCs
- **Phase Integration:** GameService loop updates for dialogue rendering and input

**Layers Touched:** Core (Enums, ViewModels, Interfaces), Engine (GameService, CommandParser), Terminal (Controllers, Rendering), Tests
**Patterns Used:** Controller pattern, Renderer pattern, Phase state machine, ParseResult flags
**Target Test Count:** 35 unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [GamePhase Extension](#3-gamephase-extension)
4. [ViewModel Definitions](#4-viewmodel-definitions)
5. [Interface Definitions](#5-interface-definitions)
6. [DialogueController Implementation](#6-dialoguecontroller-implementation)
7. [DialogueScreenRenderer Implementation](#7-dialoguescreenrenderer-implementation)
8. [CommandParser Extensions](#8-commandparser-extensions)
9. [GameService Integration](#9-gameservice-integration)
10. [ParseResult Extensions](#10-parseresult-extensions)
11. [DI Registration](#11-di-registration)
12. [Logging Matrix](#12-logging-matrix)
13. [Test Coverage Plan](#13-test-coverage-plan)
14. [Code Examples](#14-code-examples)
15. [Error Handling](#15-error-handling)
16. [Changelog Template](#16-changelog-template)
17. [Critical Files](#17-critical-files)
18. [Implementation Order](#18-implementation-order)
19. [Design Decisions](#19-design-decisions)
20. [UI Mockup](#20-ui-mockup)

---

## 1. Decision Trees

### 1.1 Talk Command Flow (Exploration Phase)

```
User enters: "talk <npc_name>"
                │
                ▼
    ┌───────────────────────────────┐
    │ CommandParser.HandleExploration│
    │ extracts target from command  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Target provided?              │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       No              Yes
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Display error:  │  │ Return ParseResult with:      │
│ "Talk to whom?" │  │ RequiresDialogue = true       │
└─────────────────┘  │ DialogueTarget = target       │
                     └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ GameService receives result   │
                    │ Checks RequiresDialogue flag  │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ ResolveNpcDialogueTree()      │
                    │ Match target to NPC in room   │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ NPC found with dialogue?      │
                    └───────────────────────────────┘
                                 │
                         ┌───────┴───────┐
                        No              Yes
                         │                │
                         ▼                ▼
                 ┌─────────────────┐  ┌───────────────────────────────┐
                 │ Display message:│  │ DialogueService.StartDialogue │
                 │ "Cannot talk to │  │ Async(character, treeId)      │
                 │  {target}"      │  └───────────────────────────────┘
                 └─────────────────┘              │
                                                  ▼
                                    ┌───────────────────────────────┐
                                    │ Dialogue available?           │
                                    └───────────────────────────────┘
                                                  │
                                          ┌───────┴───────┐
                                         No              Yes
                                          │                │
                                          ▼                ▼
                                  ┌─────────────────┐  ┌───────────────────────────────┐
                                  │ Display error   │  │ Set GamePhase.Dialogue        │
                                  │ from result     │  │ Initialize DialogueController │
                                  │ (NPC refuses)   │  │ Mark render required          │
                                  └─────────────────┘  └───────────────────────────────┘
```

### 1.2 Dialogue Phase Input Handling

```
GameService main loop (Phase == Dialogue)
                │
                ▼
    ┌───────────────────────────────┐
    │ Read key from IInputService   │
    │ ReadNextFiltered()            │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Extract ConsoleKey from event │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ DialogueController.HandleInput│
    │ (key, character)              │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Switch on key:                │
    └───────────────────────────────┘
                │
    ┌───────────┼───────────┬───────────┬───────────┐
    │           │           │           │           │
  UpArrow   DownArrow    Enter      Escape      Other
    │           │           │           │           │
    ▼           ▼           ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│ Decrement│ │Increment│ │ Call    │ │ Call    │ │ Ignore  │
│ Selected │ │Selected │ │ Select  │ │ EndDlg  │ │ key     │
│ Index    │ │Index    │ │ Option  │ │ Async   │ │         │
│ (clamped)│ │(clamped)│ │ Async   │ │         │ │         │
└─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
    │           │           │           │           │
    └───────────┴───────────┴───────────┴───────────┘
                            │
                            ▼
                ┌───────────────────────────────┐
                │ Determine next GamePhase      │
                └───────────────────────────────┘
                            │
                    ┌───────┴───────┐
              Stay in Dialogue  Exit to Exploration
                    │                │
                    ▼                ▼
            ┌─────────────────┐ ┌─────────────────┐
            │ Return          │ │ Return          │
            │ GamePhase       │ │ GamePhase       │
            │ .Dialogue       │ │ .Exploration    │
            └─────────────────┘ └─────────────────┘
                            │
                            ▼
                ┌───────────────────────────────┐
                │ Set _renderRequired = true    │
                │ Loop continues                │
                └───────────────────────────────┘
```

### 1.3 DialogueController.HandleInput Flow

```
HandleInput(ConsoleKey key, Character character)
                │
                ▼
    ┌───────────────────────────────┐
    │ Log key at Trace level        │
    │ "[Dialogue TUI] Key: {key}"   │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Get current viewModel from    │
    │ DialogueService               │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ viewModel is null?            │
    │ (no active dialogue)          │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Log warning     │  │ Switch on key                 │
│ Return          │  └───────────────────────────────┘
│ Exploration     │              │
└─────────────────┘      ┌───────┴───────┬───────────┬───────────┐
                         │               │           │           │
                    UpArrow/W      DownArrow/S   Enter/Space   Esc/Q
                         │               │           │           │
                         ▼               ▼           ▼           ▼
                    ┌─────────┐     ┌─────────┐ ┌─────────────┐ ┌─────────────┐
                    │ Move    │     │ Move    │ │ Get option  │ │ Log exit    │
                    │ selection     │ selection │ at index    │ │ Reset index │
                    │ up (-1) │     │ down(+1)│ │ Check avail │ │ EndDialogue │
                    └─────────┘     └─────────┘ └─────────────┘ │ (Cancel)    │
                         │               │           │         │ Return      │
                         │               │           │         │ Exploration │
                         │               │           ▼         └─────────────┘
                         │               │     ┌───────────────────┐
                         │               │     │ Option available? │
                         │               │     └───────────────────┘
                         │               │           │
                         │               │   ┌───────┴───────┐
                         │               │  No              Yes
                         │               │   │                │
                         │               │   ▼                ▼
                         │               │ ┌─────────┐  ┌───────────────┐
                         │               │ │ Play    │  │ SelectOption  │
                         │               │ │ "locked"│  │ Async(optId)  │
                         │               │ │ feedback│  └───────────────┘
                         │               │ └─────────┘        │
                         │               │   │                ▼
                         │               │   │        ┌───────────────────┐
                         │               │   │        │ Result complete?  │
                         │               │   │        └───────────────────┘
                         │               │   │                │
                         │               │   │        ┌───────┴───────┐
                         │               │   │       Yes              No
                         │               │   │        │                │
                         │               │   │        ▼                ▼
                         │               │   │  ┌─────────────┐  ┌─────────────┐
                         │               │   │  │ Reset index │  │ Reset index │
                         │               │   │  │ Return      │  │ Return      │
                         │               │   │  │ Exploration │  │ Dialogue    │
                         │               │   │  └─────────────┘  └─────────────┘
                         └───────────────┴───┴────────┬─────────────┘
                                                      │
                                                      ▼
                                        ┌───────────────────────────────┐
                                        │ Return GamePhase.Dialogue     │
                                        │ (default: stay in dialogue)   │
                                        └───────────────────────────────┘
```

### 1.4 Dialogue Rendering Flow

```
RenderCurrentPhaseAsync() (Phase == Dialogue)
                │
                ▼
    ┌───────────────────────────────┐
    │ Get DialogueViewModel from    │
    │ BuildDialogueViewModel()      │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ viewModel is null?            │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Skip rendering  │  │ DialogueScreenRenderer.Render │
│ Log warning     │  │ (viewModel)                   │
└─────────────────┘  └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ AnsiConsole.Clear()           │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ RenderHeader(npcName, title)  │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ RenderDialogueText(text)      │
                    │ - Word-wrap long text         │
                    │ - Apply theme colors          │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ RenderOptions(options, index) │
                    │ - Selection indicator ">"     │
                    │ - Locked option styling       │
                    │ - Number prefixes             │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ RenderFooter()                │
                    │ "[↑↓ Navigate | Enter Select  │
                    │   | Esc Exit]"                │
                    └───────────────────────────────┘
                                 │
                                 ▼
                    ┌───────────────────────────────┐
                    │ Log render at Trace level     │
                    └───────────────────────────────┘
```

### 1.5 NPC Resolution Flow

```
ResolveNpcDialogueTreeAsync(targetName, roomId)
                │
                ▼
    ┌───────────────────────────────┐
    │ Get NPCs in current room      │
    │ from NpcRepository or         │
    │ Room.Npcs collection          │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Fuzzy match target to NPC name│
    │ Case-insensitive, partial     │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Match found?                  │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       No              Yes
        │                │
        ▼                ▼
┌─────────────────┐  ┌───────────────────────────────┐
│ Return null     │  │ NPC has DialogueTreeId?       │
│ (no NPC found)  │  └───────────────────────────────┘
└─────────────────┘              │
                         ┌───────┴───────┐
                        No              Yes
                         │                │
                         ▼                ▼
                 ┌─────────────────┐  ┌───────────────────────────────┐
                 │ Return null     │  │ Return NPC.DialogueTreeId     │
                 │ (NPC has no     │  │ (e.g., "npc_old_scavenger")   │
                 │  dialogue)      │  └───────────────────────────────┘
                 └─────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Terminal | `RuneAndRust.Terminal/Controllers/DialogueController.cs` | Key-based input handling |
| Terminal | `RuneAndRust.Terminal/Rendering/IDialogueScreenRenderer.cs` | Renderer interface |
| Terminal | `RuneAndRust.Terminal/Rendering/DialogueScreenRenderer.cs` | TUI implementation |
| Core | `RuneAndRust.Core/ViewModels/DialogueTuiViewModel.cs` | TUI-specific view model |
| Tests | `RuneAndRust.Tests/Terminal/DialogueControllerTests.cs` | 20 unit tests |
| Tests | `RuneAndRust.Tests/Terminal/DialogueScreenRendererTests.cs` | 15 unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Core/Enums/GamePhase.cs` | Add `Dialogue = 5` |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Add `ParseResult` properties, "talk" command handling |
| `RuneAndRust.Engine/Services/GameService.cs` | Add dialogue phase rendering and input handling |
| `RuneAndRust.Terminal/Program.cs` | Register `IDialogueScreenRenderer`, `DialogueController` |

---

## 3. GamePhase Extension

**Modify:** `RuneAndRust.Core/Enums/GamePhase.cs`

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Represents the high-level state of the application loop.
/// Controls what input is valid and how the game responds.
/// </summary>
/// <remarks>See: SPEC-UI-001 for UI Framework System design.</remarks>
public enum GamePhase
{
    /// <summary>
    /// The main menu phase. Player can start a new game or quit.
    /// </summary>
    MainMenu = 0,

    /// <summary>
    /// The exploration phase. Player navigates the world.
    /// </summary>
    Exploration = 1,

    /// <summary>
    /// The combat phase. Player engages in turn-based combat.
    /// </summary>
    Combat = 2,

    /// <summary>
    /// The quit phase. Signals the game loop to terminate.
    /// </summary>
    Quit = 3,

    /// <summary>
    /// The Saga progression menu ("The Shrine").
    /// Allows players to view Legend progress and spend PP on attribute upgrades.
    /// </summary>
    /// <remarks>See: v0.4.0c (The Shrine) for Saga UI implementation.</remarks>
    SagaMenu = 4,

    /// <summary>
    /// The dialogue phase. Player engages in conversation with NPC.
    /// Uses key-based modal input for navigation and selection.
    /// </summary>
    /// <remarks>See: v0.4.2d (The Parley) for Dialogue TUI implementation.</remarks>
    Dialogue = 5
}
```

---

## 4. ViewModel Definitions

### 4.1 DialogueTuiViewModel

**File:** `RuneAndRust.Core/ViewModels/DialogueTuiViewModel.cs`

```csharp
namespace RuneAndRust.Core.ViewModels;

/// <summary>
/// View model for dialogue TUI rendering, extending DialogueViewModel with selection state.
/// </summary>
/// <remarks>See: v0.4.2d (The Parley) for Dialogue TUI implementation.</remarks>
public record DialogueTuiViewModel(
    Guid SessionId,
    string NpcName,
    string? NpcTitle,
    string SpeakerName,
    string Text,
    bool IsTerminalNode,
    IReadOnlyList<DialogueOptionTuiViewModel> Options,
    int SelectedIndex)
{
    /// <summary>
    /// Combined speaker display (e.g., "Old Scavenger, Iron-Bane Elder").
    /// </summary>
    public string SpeakerDisplay => string.IsNullOrEmpty(NpcTitle)
        ? SpeakerName
        : $"{SpeakerName}, {NpcTitle}";

    /// <summary>
    /// Number of selectable options.
    /// </summary>
    public int OptionCount => Options.Count;

    /// <summary>
    /// Gets the currently selected option, or null if no options.
    /// </summary>
    public DialogueOptionTuiViewModel? SelectedOption =>
        Options.Count > 0 && SelectedIndex >= 0 && SelectedIndex < Options.Count
            ? Options[SelectedIndex]
            : null;

    /// <summary>
    /// Whether there are any available (non-locked) options.
    /// </summary>
    public bool HasAvailableOptions => Options.Any(o => o.IsAvailable);

    /// <summary>
    /// Creates from DialogueViewModel with selection state.
    /// </summary>
    public static DialogueTuiViewModel FromDialogueViewModel(
        Models.DialogueViewModel vm,
        int selectedIndex)
    {
        var options = vm.Options
            .Select(o => new DialogueOptionTuiViewModel(
                o.OptionId,
                o.Text,
                o.DisplayOrder,
                o.IsVisible,
                o.IsAvailable,
                o.IsTerminal,
                o.LockHint,
                o.LockReason))
            .ToList();

        return new DialogueTuiViewModel(
            vm.SessionId,
            vm.NpcName,
            vm.NpcTitle,
            vm.SpeakerName,
            vm.Text,
            vm.IsTerminalNode,
            options,
            selectedIndex);
    }
}

/// <summary>
/// Option view model for TUI with index tracking.
/// </summary>
public record DialogueOptionTuiViewModel(
    Guid OptionId,
    string Text,
    int DisplayOrder,
    bool IsVisible,
    bool IsAvailable,
    bool IsTerminal,
    string? LockHint,
    string? LockReason)
{
    /// <summary>
    /// Display text with lock indicator if locked.
    /// </summary>
    public string DisplayText => IsAvailable
        ? Text
        : $"[{LockHint ?? "LOCKED"}] {Text}";
}
```

---

## 5. Interface Definitions

### 5.1 IDialogueScreenRenderer

**File:** `RuneAndRust.Terminal/Rendering/IDialogueScreenRenderer.cs`

```csharp
using RuneAndRust.Core.ViewModels;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Interface for dialogue TUI rendering using Spectre.Console.
/// </summary>
/// <remarks>See: v0.4.2d (The Parley) for Dialogue TUI implementation.</remarks>
public interface IDialogueScreenRenderer
{
    /// <summary>
    /// Renders the dialogue screen with speaker, text, and selectable options.
    /// </summary>
    /// <param name="viewModel">The dialogue state to render.</param>
    void Render(DialogueTuiViewModel viewModel);

    /// <summary>
    /// Plays a brief feedback effect for locked option selection attempt.
    /// </summary>
    /// <param name="lockReason">The reason the option is locked.</param>
    void PlayLockedFeedback(string lockReason);
}
```

---

## 6. DialogueController Implementation

**File:** `RuneAndRust.Terminal/Controllers/DialogueController.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.ViewModels;
using RuneAndRust.Terminal.Rendering;

namespace RuneAndRust.Terminal.Controllers;

/// <summary>
/// Controller for dialogue TUI input handling (v0.4.2d).
/// Manages option selection and navigation via keyboard.
/// </summary>
/// <remarks>See: v0.4.2d (The Parley) for Dialogue TUI implementation.</remarks>
public class DialogueController
{
    private readonly IDialogueService _dialogueService;
    private readonly IDialogueScreenRenderer _renderer;
    private readonly ILogger<DialogueController> _logger;

    /// <summary>
    /// Gets the currently selected option index (0-based).
    /// </summary>
    public int SelectedIndex { get; private set; }

    /// <summary>
    /// Gets the last selected option ID (for result retrieval).
    /// </summary>
    public Guid? LastSelectedOptionId { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="DialogueController"/> class.
    /// </summary>
    /// <param name="dialogueService">The dialogue service for conversation logic.</param>
    /// <param name="renderer">The renderer for locked feedback.</param>
    /// <param name="logger">The logger for traceability.</param>
    public DialogueController(
        IDialogueService dialogueService,
        IDialogueScreenRenderer renderer,
        ILogger<DialogueController> logger)
    {
        _dialogueService = dialogueService;
        _renderer = renderer;
        _logger = logger;
    }

    /// <summary>
    /// Processes a keypress and returns the resulting game phase.
    /// </summary>
    /// <param name="key">The key that was pressed.</param>
    /// <param name="character">The character in dialogue.</param>
    /// <returns>The game phase to transition to (Dialogue to stay, Exploration to exit).</returns>
    public async Task<GamePhase> HandleInputAsync(ConsoleKey key, Character character)
    {
        _logger.LogTrace("[Dialogue TUI] Key pressed: {Key}", key);

        // Get current dialogue state
        var viewModel = _dialogueService.GetCurrentState();
        if (viewModel == null)
        {
            _logger.LogWarning("[Dialogue TUI] HandleInput called with no active dialogue");
            return GamePhase.Exploration;
        }

        var optionCount = viewModel.Options.Count;

        switch (key)
        {
            case ConsoleKey.UpArrow:
            case ConsoleKey.W:
                if (SelectedIndex > 0)
                {
                    SelectedIndex--;
                    _logger.LogTrace("[Dialogue TUI] Selection moved up to index {Index}", SelectedIndex);
                }
                break;

            case ConsoleKey.DownArrow:
            case ConsoleKey.S:
                if (SelectedIndex < optionCount - 1)
                {
                    SelectedIndex++;
                    _logger.LogTrace("[Dialogue TUI] Selection moved down to index {Index}", SelectedIndex);
                }
                break;

            case ConsoleKey.Enter:
            case ConsoleKey.Spacebar:
                return await HandleSelectionAsync(viewModel);

            case ConsoleKey.Escape:
            case ConsoleKey.Q:
                _logger.LogInformation("[Dialogue TUI] Player cancelled dialogue via Escape");
                await _dialogueService.EndDialogueAsync(DialogueEndReason.PlayerCancel);
                ResetSelection();
                return GamePhase.Exploration;

            // Number keys for quick selection (1-9)
            case ConsoleKey.D1:
            case ConsoleKey.D2:
            case ConsoleKey.D3:
            case ConsoleKey.D4:
            case ConsoleKey.D5:
            case ConsoleKey.D6:
            case ConsoleKey.D7:
            case ConsoleKey.D8:
            case ConsoleKey.D9:
                var numIndex = (int)key - (int)ConsoleKey.D1;
                if (numIndex < optionCount)
                {
                    SelectedIndex = numIndex;
                    return await HandleSelectionAsync(viewModel);
                }
                break;
        }

        return GamePhase.Dialogue; // Stay in dialogue
    }

    /// <summary>
    /// Handles the selection of the currently highlighted option.
    /// </summary>
    private async Task<GamePhase> HandleSelectionAsync(Models.DialogueViewModel viewModel)
    {
        if (SelectedIndex < 0 || SelectedIndex >= viewModel.Options.Count)
        {
            _logger.LogWarning("[Dialogue TUI] Invalid selection index: {Index}", SelectedIndex);
            return GamePhase.Dialogue;
        }

        var selectedOption = viewModel.Options[SelectedIndex];

        // Check if option is available
        if (!selectedOption.IsAvailable)
        {
            _logger.LogDebug("[Dialogue TUI] Attempted to select locked option: {OptionId}", selectedOption.OptionId);
            _renderer.PlayLockedFeedback(selectedOption.LockReason ?? "Requirements not met");
            return GamePhase.Dialogue;
        }

        // Select the option
        _logger.LogInformation("[Dialogue TUI] Selecting option: '{Text}'",
            TruncateText(selectedOption.Text, 30));

        LastSelectedOptionId = selectedOption.OptionId;
        var result = await _dialogueService.SelectOptionAsync(selectedOption.OptionId);

        if (!result.IsSuccess)
        {
            _logger.LogWarning("[Dialogue TUI] Option selection failed: {Error}", result.ErrorMessage);
            return GamePhase.Dialogue;
        }

        // Reset selection for next node
        ResetSelection();

        // Check if dialogue ended
        if (result.IsDialogueComplete)
        {
            _logger.LogInformation("[Dialogue TUI] Dialogue completed via terminal option");
            return GamePhase.Exploration;
        }

        return GamePhase.Dialogue;
    }

    /// <summary>
    /// Builds a TUI-specific view model with current selection state.
    /// </summary>
    /// <returns>The view model for rendering, or null if not in dialogue.</returns>
    public DialogueTuiViewModel? BuildTuiViewModel()
    {
        var viewModel = _dialogueService.GetCurrentState();
        if (viewModel == null)
        {
            return null;
        }

        // Clamp selection to valid range
        if (viewModel.Options.Count > 0)
        {
            SelectedIndex = Math.Clamp(SelectedIndex, 0, viewModel.Options.Count - 1);
        }

        return DialogueTuiViewModel.FromDialogueViewModel(viewModel, SelectedIndex);
    }

    /// <summary>
    /// Resets the selection to the first option.
    /// Called when entering dialogue or transitioning nodes.
    /// </summary>
    public void ResetSelection()
    {
        SelectedIndex = 0;
        LastSelectedOptionId = null;
    }

    /// <summary>
    /// Gets whether dialogue is currently active.
    /// </summary>
    public bool IsInDialogue => _dialogueService.IsInDialogue;

    private static string TruncateText(string text, int maxLength)
    {
        if (text.Length <= maxLength) return text;
        return text[..(maxLength - 3)] + "...";
    }
}
```

---

## 7. DialogueScreenRenderer Implementation

**File:** `RuneAndRust.Terminal/Rendering/DialogueScreenRenderer.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Core.Interfaces;
using RuneAndRust.Core.ViewModels;
using Spectre.Console;

namespace RuneAndRust.Terminal.Rendering;

/// <summary>
/// Renders the dialogue TUI using Spectre.Console (v0.4.2d).
/// Displays NPC speaker, dialogue text, and selectable options with keyboard navigation.
/// </summary>
/// <remarks>See: v0.4.2d (The Parley) for Dialogue TUI implementation.</remarks>
public class DialogueScreenRenderer : IDialogueScreenRenderer
{
    private readonly IThemeService _theme;
    private readonly ILogger<DialogueScreenRenderer> _logger;

    /// <summary>
    /// Maximum width for dialogue text before wrapping.
    /// </summary>
    private const int MaxTextWidth = 70;

    /// <summary>
    /// Initializes a new instance of the <see cref="DialogueScreenRenderer"/> class.
    /// </summary>
    /// <param name="theme">The theme service for color configuration.</param>
    /// <param name="logger">The logger for traceability.</param>
    public DialogueScreenRenderer(IThemeService theme, ILogger<DialogueScreenRenderer> logger)
    {
        _theme = theme;
        _logger = logger;
    }

    /// <inheritdoc/>
    public void Render(DialogueTuiViewModel vm)
    {
        AnsiConsole.Clear();

        // Header - NPC name and title
        RenderHeader(vm.SpeakerDisplay);

        // Dialogue text panel
        RenderDialogueText(vm.Text, vm.SpeakerName);

        // Options list with selection
        RenderOptions(vm.Options, vm.SelectedIndex);

        // Footer - Control hints
        RenderFooter();

        _logger.LogTrace("[Dialogue TUI] Rendered. Selected: {Index}, Options: {Count}",
            vm.SelectedIndex, vm.OptionCount);
    }

    /// <inheritdoc/>
    public void PlayLockedFeedback(string lockReason)
    {
        // Brief visual feedback for attempting to select locked option
        AnsiConsole.MarkupLine($"\n[red]Cannot select: {Markup.Escape(lockReason)}[/]");
        Thread.Sleep(500); // Brief pause for user to see message
    }

    // ═══════════════════════════════════════════════════════════════════════
    // Private Render Methods
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Renders the header with speaker name and decorative rule.
    /// </summary>
    private void RenderHeader(string speakerDisplay)
    {
        var speakerColor = _theme.GetColor("DialogueSpeakerColor") ?? "cyan";

        AnsiConsole.Write(new Rule($"[bold {speakerColor}]\u2726 {Markup.Escape(speakerDisplay)} \u2726[/]")
            .RuleStyle(speakerColor));
        AnsiConsole.WriteLine();
    }

    /// <summary>
    /// Renders the dialogue text in a panel with word wrapping.
    /// </summary>
    private void RenderDialogueText(string text, string speakerName)
    {
        var textColor = _theme.GetColor("DialogueTextColor") ?? "white";
        var borderColor = _theme.GetColor("DialogueBorderColor") ?? "grey";

        // Word-wrap the text
        var wrappedText = WrapText(text, MaxTextWidth);

        // Create dialogue panel
        var panel = new Panel(new Markup($"[{textColor}]{Markup.Escape(wrappedText)}[/]"))
            .Header($"[grey]{Markup.Escape(speakerName)} says:[/]")
            .Border(BoxBorder.Rounded)
            .BorderColor(Color.Grey)
            .Padding(1, 0, 1, 0)
            .Expand();

        AnsiConsole.Write(panel);
        AnsiConsole.WriteLine();
    }

    /// <summary>
    /// Renders the options list with selection indicator and lock status.
    /// </summary>
    private void RenderOptions(IReadOnlyList<DialogueOptionTuiViewModel> options, int selectedIndex)
    {
        if (options.Count == 0)
        {
            AnsiConsole.MarkupLine("[grey](No responses available)[/]");
            return;
        }

        var selectedColor = _theme.GetColor("DialogueSelectedColor") ?? "yellow";
        var availableColor = _theme.GetColor("DialogueOptionColor") ?? "white";
        var lockedColor = _theme.GetColor("DialogueLockedColor") ?? "dim grey";

        for (int i = 0; i < options.Count; i++)
        {
            var option = options[i];
            var isSelected = i == selectedIndex;

            // Selection indicator
            var indicator = isSelected ? ">" : " ";

            // Determine color based on state
            string color;
            string prefix;

            if (!option.IsAvailable)
            {
                color = lockedColor;
                prefix = $"[{option.LockHint ?? "LOCKED"}]";
            }
            else if (isSelected)
            {
                color = selectedColor;
                prefix = "";
            }
            else
            {
                color = availableColor;
                prefix = "";
            }

            // Build the option line
            var numberLabel = i + 1; // 1-indexed for display
            var optionText = Markup.Escape(option.Text);

            if (option.IsAvailable)
            {
                if (isSelected)
                {
                    AnsiConsole.MarkupLine($"[bold {color}]{indicator} {numberLabel}. {optionText}[/]");
                }
                else
                {
                    AnsiConsole.MarkupLine($"[{color}]  {numberLabel}. {optionText}[/]");
                }
            }
            else
            {
                // Locked option with hint
                AnsiConsole.MarkupLine(
                    $"[{color}]  {numberLabel}. [{option.LockHint ?? "LOCKED"}] {optionText}[/]");
            }
        }

        AnsiConsole.WriteLine();
    }

    /// <summary>
    /// Renders the footer with control hints.
    /// </summary>
    private static void RenderFooter()
    {
        AnsiConsole.MarkupLine("[dim]\u2191\u2193 Navigate  \u2502  Enter: Select  \u2502  1-9: Quick Select  \u2502  Esc: Exit[/]");
    }

    /// <summary>
    /// Wraps text to the specified width.
    /// </summary>
    private static string WrapText(string text, int maxWidth)
    {
        if (string.IsNullOrEmpty(text) || text.Length <= maxWidth)
            return text;

        var words = text.Split(' ');
        var lines = new List<string>();
        var currentLine = "";

        foreach (var word in words)
        {
            if (currentLine.Length + word.Length + 1 <= maxWidth)
            {
                currentLine += (currentLine.Length > 0 ? " " : "") + word;
            }
            else
            {
                if (currentLine.Length > 0)
                    lines.Add(currentLine);
                currentLine = word;
            }
        }

        if (currentLine.Length > 0)
            lines.Add(currentLine);

        return string.Join("\n", lines);
    }
}
```

---

## 8. CommandParser Extensions

**Add to:** `RuneAndRust.Engine/Services/CommandParser.cs`

### 8.1 ParseResult Properties

Add to the `ParseResult` class:

```csharp
/// <summary>
/// Gets or sets whether the command requires dialogue initiation (v0.4.2d).
/// </summary>
public bool RequiresDialogue { get; set; }

/// <summary>
/// Gets or sets the target NPC name for dialogue commands (v0.4.2d).
/// </summary>
public string? DialogueTarget { get; set; }
```

### 8.2 Talk Command Handling

Add to `HandleExplorationAsync()` method (after examine handling, around line 460):

```csharp
// Check for talk command with target (v0.4.2d)
if (command.StartsWith("talk ") || command.StartsWith("speak ") || command.StartsWith("converse "))
{
    var target = ExtractTarget(command, new[] { "talk ", "speak ", "converse " });
    if (!string.IsNullOrWhiteSpace(target))
    {
        _logger.LogDebug("[CommandParser] Talk command for NPC: {Target}", target);
        state.TurnCount++;
        return new ParseResult
        {
            RequiresDialogue = true,
            DialogueTarget = target
        };
    }
    else
    {
        _inputHandler.DisplayError("Talk to whom? Specify an NPC name.");
        return ParseResult.None;
    }
}

// Handle standalone "talk" without target
if (command == "talk" || command == "speak" || command == "converse")
{
    _inputHandler.DisplayError("Talk to whom? Usage: talk <npc name>");
    return ParseResult.None;
}
```

---

## 9. GameService Integration

**Modify:** `RuneAndRust.Engine/Services/GameService.cs`

### 9.1 Add Field Declarations

Add to the class fields:

```csharp
private readonly IDialogueService? _dialogueService;
private readonly IDialogueScreenRenderer? _dialogueRenderer;
private readonly DialogueController? _dialogueController;
```

### 9.2 Update Constructor

Add parameters and assignments:

```csharp
public GameService(
    // ... existing parameters ...
    IDialogueService? dialogueService = null,
    IDialogueScreenRenderer? dialogueRenderer = null,
    DialogueController? dialogueController = null)
{
    // ... existing assignments ...
    _dialogueService = dialogueService;
    _dialogueRenderer = dialogueRenderer;
    _dialogueController = dialogueController;
}
```

### 9.3 Update RenderCurrentPhaseAsync()

Add dialogue phase rendering:

```csharp
private async Task RenderCurrentPhaseAsync()
{
    _logger.LogTrace("[GameLoop] Rendering phase: {Phase}", _state.Phase);

    if (_state.Phase == GamePhase.Combat && _combatRenderer != null)
    {
        // ... existing combat rendering ...
    }
    else if (_state.Phase == GamePhase.Exploration && _explorationRenderer != null)
    {
        // ... existing exploration rendering ...
    }
    else if (_state.Phase == GamePhase.SagaMenu && _sagaRenderer != null)
    {
        // ... existing saga rendering ...
    }
    // v0.4.2d: Add Dialogue phase rendering
    else if (_state.Phase == GamePhase.Dialogue && _dialogueRenderer != null && _dialogueController != null)
    {
        var viewModel = _dialogueController.BuildTuiViewModel();
        if (viewModel != null)
        {
            _dialogueRenderer.Render(viewModel);
        }
        else
        {
            _logger.LogWarning("[GameLoop] Dialogue phase but no viewModel available");
        }
    }
}
```

### 9.4 Update Main Loop Input Handling

Add dialogue phase input handling (after SagaMenu handling):

```csharp
// 4. Handle phase-specific input (v0.4.0c: SagaMenu uses key-based input)
if (_state.Phase == GamePhase.SagaMenu && _inputService != null)
{
    // ... existing saga input handling ...
}
// v0.4.2d: Add Dialogue phase input handling
else if (_state.Phase == GamePhase.Dialogue && _inputService != null && _dialogueController != null)
{
    var inputEvent = _inputService.ReadNextFiltered();
    var key = inputEvent switch
    {
        RawKeyEvent rawKey => rawKey.KeyInfo.Key,
        ActionEvent actionEvent when actionEvent.SourceKey.HasValue => actionEvent.SourceKey.Value,
        _ => ConsoleKey.NoName
    };

    _state.Phase = await HandleDialogueInputAsync(key);
    _renderRequired = true;
}
else
{
    // Standard text-based input for other phases
    // ... existing text input handling ...
}
```

### 9.5 Add HandleDialogueInputAsync Method

```csharp
/// <summary>
/// Handles input while in the Dialogue phase (v0.4.2d).
/// Processes navigation and selection commands, returns new phase.
/// </summary>
/// <param name="key">The key that was pressed.</param>
/// <returns>The game phase to transition to.</returns>
private async Task<GamePhase> HandleDialogueInputAsync(ConsoleKey key)
{
    if (_state.CurrentCharacter == null || _dialogueController == null)
    {
        _logger.LogWarning("[GameLoop] HandleDialogueInput called with null character/controller");
        return GamePhase.Exploration;
    }

    return await _dialogueController.HandleInputAsync(key, _state.CurrentCharacter);
}
```

### 9.6 Handle RequiresDialogue in ParseResult Processing

Add after existing ParseResult handling (around where RequiresExamine is handled):

```csharp
// v0.4.2d: Handle dialogue initiation
if (result.RequiresDialogue && !string.IsNullOrEmpty(result.DialogueTarget) && _dialogueService != null)
{
    await HandleDialogueInitiationAsync(result.DialogueTarget);
}

// New method:
/// <summary>
/// Handles initiating dialogue with an NPC (v0.4.2d).
/// </summary>
/// <param name="targetName">The name of the NPC to talk to.</param>
private async Task HandleDialogueInitiationAsync(string targetName)
{
    if (_state.CurrentCharacter == null || _state.CurrentRoomId == null)
    {
        _inputHandler?.DisplayError("Cannot initiate dialogue without an active character.");
        return;
    }

    // Resolve NPC dialogue tree from target name
    var treeId = await ResolveNpcDialogueTreeAsync(targetName, _state.CurrentRoomId.Value);
    if (string.IsNullOrEmpty(treeId))
    {
        _inputHandler?.DisplayMessage($"There is no one named '{targetName}' here to talk to.");
        return;
    }

    // Start dialogue
    var result = await _dialogueService!.StartDialogueAsync(_state.CurrentCharacter, treeId);
    if (result.IsSuccess)
    {
        _logger.LogInformation("[GameLoop] Entering Dialogue phase with {NpcTree}", treeId);
        _state.Phase = GamePhase.Dialogue;
        _dialogueController?.ResetSelection();
        _renderRequired = true;
    }
    else
    {
        _inputHandler?.DisplayMessage(result.ErrorMessage ?? "Cannot speak with that character.");
    }
}

/// <summary>
/// Resolves an NPC target name to a dialogue tree ID (v0.4.2d).
/// Matches against NPCs in the current room.
/// </summary>
private async Task<string?> ResolveNpcDialogueTreeAsync(string targetName, Guid roomId)
{
    // Get NPCs in the current room
    var room = await _roomRepository?.GetByIdAsync(roomId);
    if (room?.Npcs == null || room.Npcs.Count == 0)
    {
        return null;
    }

    // Fuzzy match by name (case-insensitive, partial match)
    var targetLower = targetName.ToLowerInvariant();
    var matchedNpc = room.Npcs.FirstOrDefault(npc =>
        npc.Name.ToLowerInvariant().Contains(targetLower) ||
        targetLower.Contains(npc.Name.ToLowerInvariant().Split(' ')[0]));

    if (matchedNpc == null)
    {
        _logger.LogDebug("[GameLoop] No NPC matched '{Target}' in room {RoomId}", targetName, roomId);
        return null;
    }

    // Check if NPC has dialogue
    if (string.IsNullOrEmpty(matchedNpc.DialogueTreeId))
    {
        _logger.LogDebug("[GameLoop] NPC '{NpcName}' has no dialogue tree", matchedNpc.Name);
        _inputHandler?.DisplayMessage($"{matchedNpc.Name} has nothing to say.");
        return null;
    }

    return matchedNpc.DialogueTreeId;
}
```

### 9.7 Update GetPhasePrompt()

```csharp
private string GetPhasePrompt()
{
    return _state.Phase switch
    {
        GamePhase.MainMenu => "[MENU]",
        GamePhase.Exploration => "[EXPLORE]",
        GamePhase.Combat => "[COMBAT]",
        GamePhase.SagaMenu => "[SHRINE]",
        GamePhase.Dialogue => "[DIALOGUE]", // v0.4.2d
        _ => "[???]"
    };
}
```

---

## 10. ParseResult Extensions

**Modify:** `RuneAndRust.Engine/Services/CommandParser.cs` (ParseResult class, around line 14)

```csharp
/// <summary>
/// Represents the result of parsing a command, indicating if async follow-up is needed.
/// Uses boolean flags for deferred execution - the parser signals intent, the caller executes.
/// </summary>
/// <remarks>See: SPEC-INPUT-001, Section "ParseResult Class" for property inventory.</remarks>
public class ParseResult
{
    // ... existing properties ...

    /// <summary>
    /// Gets or sets whether the command requires dialogue initiation (v0.4.2d).
    /// </summary>
    public bool RequiresDialogue { get; set; }

    /// <summary>
    /// Gets or sets the target NPC name for dialogue commands (v0.4.2d).
    /// </summary>
    public string? DialogueTarget { get; set; }

    // ... existing static members ...
}
```

---

## 11. DI Registration

**Add to:** `RuneAndRust.Terminal/Program.cs`

```csharp
// ═══════════════════════════════════════════════════════════════════════════
// Dialogue TUI (v0.4.2d - The Parley)
// ═══════════════════════════════════════════════════════════════════════════
services.AddSingleton<IDialogueScreenRenderer, DialogueScreenRenderer>();
services.AddScoped<DialogueController>();
```

---

## 12. Logging Matrix

### DialogueController Logging

| Event | Level | Template |
|-------|-------|----------|
| Key pressed | Trace | `[Dialogue TUI] Key pressed: {Key}` |
| No active dialogue | Warn | `[Dialogue TUI] HandleInput called with no active dialogue` |
| Selection moved up | Trace | `[Dialogue TUI] Selection moved up to index {Index}` |
| Selection moved down | Trace | `[Dialogue TUI] Selection moved down to index {Index}` |
| Player cancelled | Info | `[Dialogue TUI] Player cancelled dialogue via Escape` |
| Invalid selection index | Warn | `[Dialogue TUI] Invalid selection index: {Index}` |
| Locked option attempt | Debug | `[Dialogue TUI] Attempted to select locked option: {OptionId}` |
| Option selected | Info | `[Dialogue TUI] Selecting option: '{Text}'` |
| Selection failed | Warn | `[Dialogue TUI] Option selection failed: {Error}` |
| Dialogue completed | Info | `[Dialogue TUI] Dialogue completed via terminal option` |

### DialogueScreenRenderer Logging

| Event | Level | Template |
|-------|-------|----------|
| Render complete | Trace | `[Dialogue TUI] Rendered. Selected: {Index}, Options: {Count}` |

### GameService Dialogue Logging

| Event | Level | Template |
|-------|-------|----------|
| No viewModel | Warn | `[GameLoop] Dialogue phase but no viewModel available` |
| Null character/controller | Warn | `[GameLoop] HandleDialogueInput called with null character/controller` |
| Entering dialogue | Info | `[GameLoop] Entering Dialogue phase with {NpcTree}` |
| NPC not matched | Debug | `[GameLoop] No NPC matched '{Target}' in room {RoomId}` |
| NPC no dialogue | Debug | `[GameLoop] NPC '{NpcName}' has no dialogue tree` |

### CommandParser Dialogue Logging

| Event | Level | Template |
|-------|-------|----------|
| Talk command | Debug | `[CommandParser] Talk command for NPC: {Target}` |

---

## 13. Test Coverage Plan

### Test Class Structure

**File 1:** `RuneAndRust.Tests/Terminal/DialogueControllerTests.cs` (20 tests)
**File 2:** `RuneAndRust.Tests/Terminal/DialogueScreenRendererTests.cs` (15 tests)

### Test Inventory (35 tests)

#### DialogueController - Navigation Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInput_UpArrow_DecrementsSelectedIndex` | Selection moves up |
| `HandleInput_UpArrow_ClampsAtZero` | Cannot go below 0 |
| `HandleInput_DownArrow_IncrementsSelectedIndex` | Selection moves down |
| `HandleInput_DownArrow_ClampsAtMax` | Cannot exceed option count |
| `HandleInput_WKey_DecrementsSelectedIndex` | W key alternative |
| `HandleInput_SKey_IncrementsSelectedIndex` | S key alternative |

#### DialogueController - Selection Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInput_Enter_SelectsCurrentOption` | Enter confirms selection |
| `HandleInput_Space_SelectsCurrentOption` | Space confirms selection |
| `HandleInput_Enter_LockedOption_PlaysFeedback` | Locked option rejection |
| `HandleInput_NumberKey_SelectsDirectly` | Quick number selection |
| `HandleInput_NumberKey_OutOfRange_Ignored` | Invalid number ignored |
| `HandleInput_Selection_ResetsIndex` | Index resets after selection |

#### DialogueController - Exit Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInput_Escape_EndsDialogue` | Escape exits dialogue |
| `HandleInput_QKey_EndsDialogue` | Q key exits dialogue |
| `HandleInput_Escape_ReturnsExploration` | Returns correct phase |
| `HandleInput_TerminalOption_ReturnsExploration` | Terminal completes |

#### DialogueController - State Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `HandleInput_NoDialogue_ReturnsExploration` | Graceful null handling |
| `BuildTuiViewModel_ReturnsNull_WhenNoDialogue` | Null when inactive |
| `BuildTuiViewModel_IncludesSelectedIndex` | Index propagated |
| `ResetSelection_SetsIndexToZero` | Reset functionality |

#### DialogueScreenRenderer - Render Tests (10 tests)

| Test Name | Description |
|-----------|-------------|
| `Render_DisplaysNpcName` | Speaker name shown |
| `Render_DisplaysNpcTitle_WhenPresent` | Title included |
| `Render_DisplaysDialogueText` | Text rendered |
| `Render_WrapsLongText` | Word wrapping works |
| `Render_DisplaysOptions` | All options shown |
| `Render_HighlightsSelectedOption` | Selection indicator |
| `Render_ShowsLockedOptions_WithHint` | Lock hints displayed |
| `Render_DisplaysFooter` | Control hints shown |
| `Render_HandlesEmptyOptions` | Empty options gracefully |
| `Render_UsesThemeColors` | Theme integration |

#### DialogueScreenRenderer - Feedback Tests (5 tests)

| Test Name | Description |
|-----------|-------------|
| `PlayLockedFeedback_DisplaysReason` | Lock reason shown |
| `Render_NumberLabels_StartAtOne` | 1-indexed display |
| `Render_EscapesMarkup_InText` | No markup injection |
| `Render_EscapesMarkup_InOptions` | Safe option text |
| `Render_QuickSelectHint_InFooter` | 1-9 hint shown |

---

## 14. Code Examples

### 14.1 Test Example - DialogueController

```csharp
public class DialogueControllerTests
{
    private readonly Mock<IDialogueService> _mockService;
    private readonly Mock<IDialogueScreenRenderer> _mockRenderer;
    private readonly Mock<ILogger<DialogueController>> _mockLogger;
    private readonly DialogueController _sut;

    public DialogueControllerTests()
    {
        _mockService = new Mock<IDialogueService>();
        _mockRenderer = new Mock<IDialogueScreenRenderer>();
        _mockLogger = new Mock<ILogger<DialogueController>>();

        _sut = new DialogueController(
            _mockService.Object,
            _mockRenderer.Object,
            _mockLogger.Object);
    }

    [Fact]
    public async Task HandleInput_UpArrow_DecrementsSelectedIndex()
    {
        // Arrange
        var vm = CreateTestViewModel(3);
        _mockService.Setup(s => s.GetCurrentState()).Returns(vm);
        _sut.SelectedIndex = 1; // Start in middle

        // Act
        await _sut.HandleInputAsync(ConsoleKey.UpArrow, CreateTestCharacter());

        // Assert
        _sut.SelectedIndex.Should().Be(0);
    }

    [Fact]
    public async Task HandleInput_UpArrow_ClampsAtZero()
    {
        // Arrange
        var vm = CreateTestViewModel(3);
        _mockService.Setup(s => s.GetCurrentState()).Returns(vm);
        _sut.SelectedIndex = 0; // Already at top

        // Act
        await _sut.HandleInputAsync(ConsoleKey.UpArrow, CreateTestCharacter());

        // Assert
        _sut.SelectedIndex.Should().Be(0); // Stays at 0
    }

    [Fact]
    public async Task HandleInput_Enter_LockedOption_PlaysFeedback()
    {
        // Arrange
        var vm = CreateTestViewModelWithLockedOption();
        _mockService.Setup(s => s.GetCurrentState()).Returns(vm);
        _sut.SelectedIndex = 0; // Select the locked option

        // Act
        var result = await _sut.HandleInputAsync(ConsoleKey.Enter, CreateTestCharacter());

        // Assert
        result.Should().Be(GamePhase.Dialogue); // Stay in dialogue
        _mockRenderer.Verify(r => r.PlayLockedFeedback(It.IsAny<string>()), Times.Once);
        _mockService.Verify(s => s.SelectOptionAsync(It.IsAny<Guid>()), Times.Never);
    }

    [Fact]
    public async Task HandleInput_Escape_EndsDialogue()
    {
        // Arrange
        var vm = CreateTestViewModel(3);
        _mockService.Setup(s => s.GetCurrentState()).Returns(vm);
        _mockService.Setup(s => s.EndDialogueAsync(DialogueEndReason.PlayerCancel))
            .ReturnsAsync(DialogueEndResult.Success(
                Guid.NewGuid(), "Test NPC", DialogueEndReason.PlayerCancel,
                TimeSpan.FromSeconds(10), 1, 0));

        // Act
        var result = await _sut.HandleInputAsync(ConsoleKey.Escape, CreateTestCharacter());

        // Assert
        result.Should().Be(GamePhase.Exploration);
        _mockService.Verify(s => s.EndDialogueAsync(DialogueEndReason.PlayerCancel), Times.Once);
    }

    [Fact]
    public async Task HandleInput_NumberKey_SelectsDirectly()
    {
        // Arrange
        var vm = CreateTestViewModel(3);
        _mockService.Setup(s => s.GetCurrentState()).Returns(vm);
        _mockService.Setup(s => s.SelectOptionAsync(It.IsAny<Guid>()))
            .ReturnsAsync(DialogueStepResult.Continue(vm, null));

        // Act
        var result = await _sut.HandleInputAsync(ConsoleKey.D2, CreateTestCharacter());

        // Assert
        _sut.SelectedIndex.Should().Be(0); // Reset after selection
        _mockService.Verify(s => s.SelectOptionAsync(vm.Options[1].OptionId), Times.Once);
    }

    private static Character CreateTestCharacter() => new()
    {
        Id = Guid.NewGuid(),
        Name = "Test Character"
    };

    private static DialogueViewModel CreateTestViewModel(int optionCount)
    {
        var options = Enumerable.Range(0, optionCount)
            .Select(i => DialogueOptionViewModel.Available(
                Guid.NewGuid(),
                $"Option {i + 1}",
                i,
                false))
            .ToList();

        return new DialogueViewModel(
            Guid.NewGuid(),
            "Test NPC",
            "Elder",
            "Test NPC",
            "Hello, traveler.",
            false,
            options);
    }

    private static DialogueViewModel CreateTestViewModelWithLockedOption()
    {
        var options = new List<DialogueOptionViewModel>
        {
            DialogueOptionViewModel.Locked(
                Guid.NewGuid(),
                "Locked option",
                0,
                false,
                "WITS 6",
                "Requires Wits 6 or higher")
        };

        return new DialogueViewModel(
            Guid.NewGuid(),
            "Test NPC",
            null,
            "Test NPC",
            "Hello.",
            false,
            options);
    }
}
```

### 14.2 Test Example - DialogueScreenRenderer

```csharp
public class DialogueScreenRendererTests
{
    private readonly Mock<IThemeService> _mockTheme;
    private readonly Mock<ILogger<DialogueScreenRenderer>> _mockLogger;
    private readonly DialogueScreenRenderer _sut;

    public DialogueScreenRendererTests()
    {
        _mockTheme = new Mock<IThemeService>();
        _mockLogger = new Mock<ILogger<DialogueScreenRenderer>>();

        // Setup default theme colors
        _mockTheme.Setup(t => t.GetColor(It.IsAny<string>())).Returns("white");

        _sut = new DialogueScreenRenderer(
            _mockTheme.Object,
            _mockLogger.Object);
    }

    [Fact]
    public void Render_UsesThemeColors()
    {
        // Arrange
        var vm = CreateTestTuiViewModel();
        _mockTheme.Setup(t => t.GetColor("DialogueSpeakerColor")).Returns("cyan");

        // Act & Assert (no exception)
        _sut.Render(vm);

        // Verify theme was consulted
        _mockTheme.Verify(t => t.GetColor("DialogueSpeakerColor"), Times.Once);
    }

    [Fact]
    public void Render_HandlesEmptyOptions()
    {
        // Arrange
        var vm = new DialogueTuiViewModel(
            Guid.NewGuid(),
            "Test NPC",
            null,
            "Test NPC",
            "Farewell.",
            true, // Terminal node
            new List<DialogueOptionTuiViewModel>(),
            0);

        // Act & Assert (no exception)
        _sut.Render(vm);
    }

    private static DialogueTuiViewModel CreateTestTuiViewModel()
    {
        var options = new List<DialogueOptionTuiViewModel>
        {
            new(Guid.NewGuid(), "Hello", 0, true, true, false, null, null),
            new(Guid.NewGuid(), "Goodbye", 1, true, true, true, null, null)
        };

        return new DialogueTuiViewModel(
            Guid.NewGuid(),
            "Test NPC",
            "Elder",
            "Test NPC",
            "Welcome to my shop.",
            false,
            options,
            0);
    }
}
```

---

## 15. Error Handling

### Error Categories

| Category | Handling | Recovery |
|----------|----------|----------|
| **No NPC Found** | Display message to user | Stay in Exploration |
| **NPC Has No Dialogue** | Display message to user | Stay in Exploration |
| **NPC Refuses (Hostile)** | Display service error message | Stay in Exploration |
| **No Active Dialogue** | Return to Exploration | Exit dialogue phase |
| **Invalid Option Index** | Log warning, stay in dialogue | Await valid input |
| **Locked Option Selected** | Play feedback, stay in dialogue | Await valid input |
| **Service Error** | Log warning, display message | Stay in dialogue |

### Error Messages

```csharp
// NPC resolution errors
"There is no one named '{targetName}' here to talk to."
"{npcName} has nothing to say."

// Dialogue service errors (from v0.4.2c)
"Already in dialogue. End current conversation first."
"NPC refuses to speak with you." // Hostile disposition
"Dialogue tree is corrupted."

// Input errors
"Talk to whom? Specify an NPC name."
"Talk to whom? Usage: talk <npc name>"
```

---

## 16. Changelog Template

```markdown
# Changelog: v0.4.2d - The Parley (TUI & Game Loop Integration)

**Release Date:** [DATE]
**Total Tests:** [N] (35 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.2d](#directory-structure-after-v042d)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Commands Reference](#commands-reference)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.2d implements the **Dialogue TUI integration** — the final connection between
the DialogueService logic and player interaction...

## Commands Reference

### New Exploration Commands

| Command | Aliases | Action |
|---------|---------|--------|
| `talk <npc>` | `speak <npc>`, `converse <npc>` | Initiate dialogue with named NPC |

### Dialogue Phase Controls

| Key | Action |
|-----|--------|
| `↑` / `W` | Move selection up |
| `↓` / `S` | Move selection down |
| `Enter` / `Space` | Select highlighted option |
| `1-9` | Quick select option by number |
| `Esc` / `Q` | Exit dialogue (cancel) |

[Continue following CHANGELOG_GENERATION_RULES.md format]
```

---

## 17. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/ViewModels/DialogueTuiViewModel.cs` | TUI view model |
| 2 | `RuneAndRust.Terminal/Rendering/IDialogueScreenRenderer.cs` | Renderer interface |
| 3 | `RuneAndRust.Terminal/Rendering/DialogueScreenRenderer.cs` | TUI rendering |
| 4 | `RuneAndRust.Terminal/Controllers/DialogueController.cs` | Input handling |
| 5 | `RuneAndRust.Tests/Terminal/DialogueControllerTests.cs` | 20 tests |
| 6 | `RuneAndRust.Tests/Terminal/DialogueScreenRendererTests.cs` | 15 tests |

### Files to Modify (Priority Order)

| Priority | File | Change |
|----------|------|--------|
| 1 | `RuneAndRust.Core/Enums/GamePhase.cs` | Add `Dialogue = 5` |
| 2 | `RuneAndRust.Engine/Services/CommandParser.cs` | Add ParseResult properties, talk command |
| 3 | `RuneAndRust.Engine/Services/GameService.cs` | Add dialogue phase handling |
| 4 | `RuneAndRust.Terminal/Program.cs` | Register DI services |

---

## 18. Implementation Order

1. **Update GamePhase Enum** (add Dialogue = 5)
2. **Create DialogueTuiViewModel** (Core)
3. **Create IDialogueScreenRenderer Interface** (Terminal)
4. **Create DialogueScreenRenderer** (Terminal)
5. **Create DialogueController** (Terminal)
6. **Update ParseResult** (add RequiresDialogue, DialogueTarget)
7. **Update CommandParser** (add talk command handling)
8. **Update GameService** (add dialogue phase rendering and input)
9. **Register in DI** (Program.cs)
10. **Write Unit Tests** (35 tests)
11. **Run Build and Tests**
12. **Generate Changelog**

---

## 19. Design Decisions

### Why Key-Based Input for Dialogue?

**Problem:** Dialogue requires modal navigation (up/down selection) rather than text commands.

**Decision:** Use key-based input via `IInputService` (like SagaMenu).

**Rationale:**
- Matches SagaMenu pattern (v0.4.0c)
- More intuitive for menu navigation
- Faster response than parsing text
- Allows number keys for quick selection
- Consistent with RPG dialogue conventions

### Why Separate DialogueTuiViewModel?

**Problem:** DialogueViewModel from v0.4.2c doesn't include selection state.

**Decision:** Create `DialogueTuiViewModel` that wraps with selection index.

**Rationale:**
- Keeps service-layer ViewModel clean
- TUI-specific concerns isolated to Terminal layer
- Easy to test selection state independently
- Factory method keeps construction simple

### Why ResetSelection After Each Selection?

**Problem:** After selecting an option and moving to a new node, where should selection be?

**Decision:** Reset to index 0 after every successful selection.

**Rationale:**
- New node = fresh start
- Prevents confusion from previous position
- First option is usually the "default" or most common choice
- Matches player expectations

### Why Quick Number Selection (1-9)?

**Problem:** Navigating with arrows is slow for experienced players.

**Decision:** Allow number keys 1-9 to directly select and confirm options.

**Rationale:**
- Power user feature
- Speeds up gameplay for returning players
- Common pattern in classic RPGs
- No interference with other keys (not alphabetic)

### Why Fuzzy NPC Name Matching?

**Problem:** Players may not type exact NPC names.

**Decision:** Case-insensitive partial matching for NPC resolution.

**Rationale:**
- "talk old" matches "Old Scavenger"
- "talk scav" matches "Old Scavenger"
- Reduces player frustration
- Follows examine/search pattern

---

## 20. UI Mockup

```
╭─────────────────────────────────────────────────────────────────────────╮
│                ✦ Old Scavenger, Iron-Bane Elder ✦                       │
╰─────────────────────────────────────────────────────────────────────────╯

╭── Old Scavenger says: ──────────────────────────────────────────────────╮
│ Hah! Another young fool stumbling through the ruins. You've got         │
│ that look about you - fresh blood, burning curiosity, no sense          │
│ of what lurks in the deeper halls. I've seen hundreds like you          │
│ come and go. Mostly go.                                                 │
│                                                                         │
│ What brings you to my corner of this forsaken pit?                      │
╰─────────────────────────────────────────────────────────────────────────╯

> 1. I seek knowledge of the old ways.
  2. I'm looking for supplies.
  3. What can you tell me about the dangers here?
  4. [WITS 6] I notice the markings on your arm...
  5. I should go. Farewell.

↑↓ Navigate  │  Enter: Select  │  1-9: Quick Select  │  Esc: Exit
```

### Locked Option Display

```
  4. [WITS 6] I notice the markings on your arm...
```
When the player doesn't meet WITS 6 requirement, this option appears dimmed/grey and selecting it shows:

```
Cannot select: Requires Wits 6 or higher
```

### Terminal Option Selected

When selecting option 5 (farewell), the dialogue ends and returns to Exploration phase with the room description re-rendered.

---

## Appendix A: Phase Transition Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        GAME PHASE TRANSITIONS                           │
└─────────────────────────────────────────────────────────────────────────┘

                              ┌────────────┐
                              │ MainMenu   │
                              └────────────┘
                                    │
                                    │ "new" / "load"
                                    ▼
    ┌────────────────────────────────────────────────────────────────┐
    │                                                                │
    │                      ┌─────────────────┐                       │
    │                      │  Exploration    │◄──────────────────┐   │
    │                      └─────────────────┘                   │   │
    │                             │     │                        │   │
    │              "talk <npc>"   │     │ "shrine"               │   │
    │                             ▼     ▼                        │   │
    │                      ┌─────────┐ ┌─────────┐              │   │
    │                      │Dialogue │ │SagaMenu │              │   │
    │                      └─────────┘ └─────────┘              │   │
    │                             │           │                  │   │
    │               Esc/Terminal  │           │ Esc              │   │
    │                             └─────┬─────┘                  │   │
    │                                   │                        │   │
    │                                   └────────────────────────┘   │
    │                                                                │
    │                             Combat                             │
    │                        (not shown - separate flow)             │
    └────────────────────────────────────────────────────────────────┘
```

---

## Appendix B: Input Event Processing

```
IInputService.ReadNextFiltered()
                │
                ▼
    ┌───────────────────────────────┐
    │ Returns IInputEvent           │
    │ (RawKeyEvent or ActionEvent)  │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Pattern match to ConsoleKey:  │
    │                               │
    │ RawKeyEvent rawKey =>         │
    │   rawKey.KeyInfo.Key          │
    │                               │
    │ ActionEvent action =>         │
    │   action.SourceKey.Value      │
    │                               │
    │ _ => ConsoleKey.NoName        │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Pass to DialogueController    │
    │ .HandleInputAsync(key, char)  │
    └───────────────────────────────┘
```

---

## Appendix C: NPC Entity Requirements

For dialogue to work, NPCs need a `DialogueTreeId` property:

```csharp
public class Npc
{
    // ... existing properties ...

    /// <summary>
    /// The dialogue tree ID for this NPC (v0.4.2d).
    /// References a DialogueTree.TreeId for conversation lookup.
    /// Null if NPC has no dialogue.
    /// </summary>
    public string? DialogueTreeId { get; set; }
}
```

And rooms need to track NPCs:

```csharp
public class Room
{
    // ... existing properties ...

    /// <summary>
    /// NPCs present in this room.
    /// </summary>
    public ICollection<Npc> Npcs { get; set; } = new List<Npc>();
}
```

These may already exist or may need to be added as part of v0.4.2e (Seeding & Integration).
