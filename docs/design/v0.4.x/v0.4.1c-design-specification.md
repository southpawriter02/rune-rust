# v0.4.1c Design Specification: Environmental Hazards

**Version:** 0.4.1c
**Phase Name:** Environmental Hazards
**Parent Version:** v0.4.1 (Traps & Environmental Hazards)
**Prerequisites:** v0.4.1b Complete (Trap Mechanics)
**Estimated Tests:** ~25 unit tests

---

## 1. Overview

### 1.1 Purpose

Implement persistent environmental hazards that affect players who remain in or pass through dangerous zones. Hazards deal ongoing damage or apply status effects each turn, with saving throws allowing players to reduce or avoid damage. This phase completes the Traps & Environmental Hazards system by adding area-based dangers that persist beyond single trigger events.

### 1.2 Current State

The following infrastructure exists from prior versions:

| Component | Location | Status |
|-----------|----------|--------|
| `Trap` entity | `Domain/Entities/Trap.cs` | From v0.4.1a |
| `TrapState` enum | `Domain/Enums/TrapState.cs` | From v0.4.1a |
| `TriggerType` enum | `Domain/Enums/TriggerType.cs` | From v0.4.1a |
| `TrapEffect` value object | `Domain/ValueObjects/TrapEffect.cs` | From v0.4.1b |
| `TrapEffectResult` value object | `Domain/ValueObjects/TrapEffectResult.cs` | From v0.4.1b |
| `ITrapService` | `Application/Interfaces/ITrapService.cs` | From v0.4.1a/b |
| `TrapService` | `Application/Services/TrapService.cs` | From v0.4.1a/b |
| `Room.Traps` collection | `Domain/Entities/Room.cs` | From v0.4.1a |
| `DiceService` | `Application/Services/DiceService.cs` | Complete |
| `StatusEffectService` | `Application/Services/StatusEffectService.cs` | Complete |
| `DamageCalculationService` | `Application/Services/DamageCalculationService.cs` | Complete |
| `TurnProcessingService` | `Application/Services/TurnProcessingService.cs` | Complete |

### 1.3 Scope

**In Scope:**
- `HazardZone` entity for area effects
- `HazardDefinition` for JSON configuration
- `HazardType` enum (PoisonGas, Fire, Ice, Spikes, AcidPool, Darkness)
- `SavingThrow` value object for mitigation dice checks
- `HazardEffectResult` value object for processing results
- `Room.HazardZones` collection and management methods
- Poison gas zones (damage over time, poisoned status effect)
- Fire zones (fire damage each turn, burning status effect)
- Ice/cold zones (cold damage, chilled/slowed status effect)
- Spike floors (damage on entry/movement only)
- Acid pools (acid damage, corroded status effect)
- Saving throws (dice check to halve/negate damage)
- Hazard visibility in room descriptions
- Turn-based hazard processing via TurnProcessingService
- Hazard duration (permanent vs temporary)
- `IHazardService` interface and `HazardService` implementation
- Configuration schema for hazard definitions

**Out of Scope:**
- Light-based hazards affecting visibility (v0.4.3)
- Weather effects (v0.4.3)
- Spreading/expanding hazards (future)
- Player-created hazards (future)
- Hazard interaction with NPCs/monsters (v0.5.x)

### 1.4 Design Goals

1. **Persistent Danger**: Hazards remain active and affect players each turn
2. **Save Mechanics**: Allow players to mitigate damage through saving throws
3. **Variety**: Support multiple hazard types with distinct effects
4. **Configuration Driven**: Hazard types defined in JSON
5. **Turn Integration**: Process hazards during turn processing phase
6. **Visibility**: Players can see active hazards in room descriptions
7. **Testability**: Clean separation enables comprehensive unit testing

---

## 2. Data Model

### 2.1 HazardType Enum (NEW)

**File:** `src/Core/RuneAndRust.Domain/Enums/HazardType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of environmental hazards.
/// </summary>
public enum HazardType
{
    /// <summary>
    /// Poisonous gas that damages and poisons creatures within.
    /// </summary>
    PoisonGas,

    /// <summary>
    /// Fire or flames that burn creatures within.
    /// </summary>
    Fire,

    /// <summary>
    /// Extreme cold that damages and slows creatures within.
    /// </summary>
    Ice,

    /// <summary>
    /// Sharp spikes that damage creatures moving through.
    /// </summary>
    Spikes,

    /// <summary>
    /// Corrosive acid that damages and corrodes equipment.
    /// </summary>
    AcidPool,

    /// <summary>
    /// Magical darkness that obscures vision (no damage).
    /// </summary>
    Darkness,

    /// <summary>
    /// Electrical energy that shocks creatures within.
    /// </summary>
    Electricity,

    /// <summary>
    /// Holy or radiant energy (damages undead).
    /// </summary>
    Radiant,

    /// <summary>
    /// Necrotic energy that drains life force.
    /// </summary>
    Necrotic
}
```

### 2.2 SavingThrow Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SavingThrow.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines a saving throw to avoid or reduce an effect.
/// </summary>
public readonly record struct SavingThrow
{
    /// <summary>
    /// Gets the attribute used for the save (e.g., "Fortitude", "Agility", "Will").
    /// </summary>
    public string Attribute { get; init; }

    /// <summary>
    /// Gets the DC to beat for success.
    /// </summary>
    public int DC { get; init; }

    /// <summary>
    /// Gets whether a successful save completely negates the effect (true) or halves damage (false).
    /// </summary>
    public bool Negates { get; init; }

    /// <summary>
    /// Creates a saving throw.
    /// </summary>
    /// <param name="attribute">The attribute used for the save.</param>
    /// <param name="dc">The DC to beat.</param>
    /// <param name="negates">Whether success negates (true) or halves (false) the effect.</param>
    /// <returns>A new SavingThrow.</returns>
    public static SavingThrow Create(string attribute, int dc, bool negates = false) => new()
    {
        Attribute = attribute,
        DC = dc,
        Negates = negates
    };

    /// <summary>
    /// Creates a Fortitude save (resisting poison, disease, physical effects).
    /// </summary>
    /// <param name="dc">The DC to beat.</param>
    /// <param name="negates">Whether success negates the effect.</param>
    /// <returns>A new SavingThrow.</returns>
    public static SavingThrow Fortitude(int dc, bool negates = false) => Create("Fortitude", dc, negates);

    /// <summary>
    /// Creates an Agility save (dodging, reflexes).
    /// </summary>
    /// <param name="dc">The DC to beat.</param>
    /// <param name="negates">Whether success negates the effect.</param>
    /// <returns>A new SavingThrow.</returns>
    public static SavingThrow Agility(int dc, bool negates = false) => Create("Agility", dc, negates);

    /// <summary>
    /// Creates a Will save (mental effects, fear, charm).
    /// </summary>
    /// <param name="dc">The DC to beat.</param>
    /// <param name="negates">Whether success negates the effect.</param>
    /// <returns>A new SavingThrow.</returns>
    public static SavingThrow Will(int dc, bool negates = false) => Create("Will", dc, negates);

    /// <summary>
    /// Creates a Wits save (awareness, perception-based avoidance).
    /// </summary>
    /// <param name="dc">The DC to beat.</param>
    /// <param name="negates">Whether success negates the effect.</param>
    /// <returns>A new SavingThrow.</returns>
    public static SavingThrow Wits(int dc, bool negates = false) => Create("Wits", dc, negates);
}
```

### 2.3 HazardZone Entity (NEW)

**File:** `src/Core/RuneAndRust.Domain/Entities/HazardZone.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a persistent environmental hazard in a room.
/// </summary>
public class HazardZone : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this hazard zone.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this hazard.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown to players.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the type of this hazard.
    /// </summary>
    public HazardType HazardType { get; private set; }

    /// <summary>
    /// Gets whether this hazard is currently active.
    /// </summary>
    public bool IsActive { get; private set; } = true;

    /// <summary>
    /// Gets the damage dice expression dealt each turn (null if no per-turn damage).
    /// </summary>
    public string? DamagePerTurnDice { get; private set; }

    /// <summary>
    /// Gets the damage type for per-turn damage.
    /// </summary>
    public string? DamageType { get; private set; }

    /// <summary>
    /// Gets the damage dice expression dealt on entry (null if no entry damage).
    /// </summary>
    public string? EntryDamageDice { get; private set; }

    /// <summary>
    /// Gets status effects applied each turn while in the hazard.
    /// </summary>
    public IReadOnlyList<string> StatusEffects { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the duration in turns for applied status effects.
    /// </summary>
    public int StatusDuration { get; private set; } = 3;

    /// <summary>
    /// Gets the saving throw to reduce damage/effects (null if no save allowed).
    /// </summary>
    public SavingThrow? Save { get; private set; }

    /// <summary>
    /// Gets whether this hazard affects the entire room.
    /// </summary>
    public bool AffectsWholeRoom { get; private set; } = true;

    /// <summary>
    /// Gets the remaining duration in turns (-1 = permanent).
    /// </summary>
    public int Duration { get; private set; } = -1;

    /// <summary>
    /// Gets whether this hazard is permanent (never expires).
    /// </summary>
    public bool IsPermanent => Duration < 0;

    /// <summary>
    /// Gets whether this hazard has expired.
    /// </summary>
    public bool IsExpired => !IsPermanent && Duration <= 0;

    /// <summary>
    /// Gets whether damage is dealt on entry to the zone.
    /// </summary>
    public bool DamageOnEntry => !string.IsNullOrEmpty(EntryDamageDice);

    /// <summary>
    /// Gets whether damage is dealt each turn while in the zone.
    /// </summary>
    public bool DamagePerTurn => !string.IsNullOrEmpty(DamagePerTurnDice);

    /// <summary>
    /// Gets whether this hazard applies status effects.
    /// </summary>
    public bool AppliesStatus => StatusEffects.Count > 0;

    /// <summary>
    /// Gets whether this hazard has a saving throw.
    /// </summary>
    public bool HasSave => Save.HasValue;

    /// <summary>
    /// Gets keywords for referencing this hazard.
    /// </summary>
    public IReadOnlyList<string> Keywords { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the message displayed when the hazard affects a player.
    /// </summary>
    public string? EffectMessage { get; private set; }

    private HazardZone() { }

    /// <summary>
    /// Creates a new hazard zone.
    /// </summary>
    /// <param name="definitionId">The definition ID from configuration.</param>
    /// <param name="name">The display name.</param>
    /// <param name="description">The description shown to players.</param>
    /// <param name="hazardType">The type of hazard.</param>
    /// <param name="damagePerTurnDice">Damage dice per turn (e.g., "1d6").</param>
    /// <param name="damageType">The damage type.</param>
    /// <param name="entryDamageDice">Damage dice on entry.</param>
    /// <param name="statusEffects">Status effects to apply.</param>
    /// <param name="statusDuration">Duration of status effects.</param>
    /// <param name="save">The saving throw configuration.</param>
    /// <param name="duration">Duration in turns (-1 for permanent).</param>
    /// <param name="keywords">Keywords for referencing.</param>
    /// <param name="effectMessage">Message when hazard affects player.</param>
    /// <returns>A new HazardZone instance.</returns>
    public static HazardZone Create(
        string definitionId,
        string name,
        string description,
        HazardType hazardType,
        string? damagePerTurnDice = null,
        string? damageType = null,
        string? entryDamageDice = null,
        IEnumerable<string>? statusEffects = null,
        int statusDuration = 3,
        SavingThrow? save = null,
        int duration = -1,
        IEnumerable<string>? keywords = null,
        string? effectMessage = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new HazardZone
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            Description = description,
            HazardType = hazardType,
            DamagePerTurnDice = damagePerTurnDice,
            DamageType = damageType,
            EntryDamageDice = entryDamageDice,
            StatusEffects = statusEffects?.ToList() ?? new List<string>(),
            StatusDuration = statusDuration,
            Save = save,
            Duration = duration,
            Keywords = keywords?.ToList() ?? new List<string> { name.ToLowerInvariant() },
            EffectMessage = effectMessage
        };
    }

    /// <summary>
    /// Creates a hazard zone from a definition.
    /// </summary>
    /// <param name="definition">The hazard definition.</param>
    /// <returns>A new HazardZone instance.</returns>
    public static HazardZone FromDefinition(HazardDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);

        SavingThrow? save = null;
        if (definition.Save != null)
        {
            save = SavingThrow.Create(
                definition.Save.Attribute,
                definition.Save.DC,
                definition.Save.Negates);
        }

        return new HazardZone
        {
            Id = Guid.NewGuid(),
            DefinitionId = definition.Id,
            Name = definition.Name,
            Description = definition.Description,
            HazardType = definition.HazardType,
            DamagePerTurnDice = definition.DamagePerTurn?.Dice,
            DamageType = definition.DamagePerTurn?.DamageType ?? definition.EntryDamage?.DamageType,
            EntryDamageDice = definition.EntryDamage?.Dice,
            StatusEffects = definition.StatusEffects?.ToList() ?? new List<string>(),
            StatusDuration = definition.StatusDuration,
            Save = save,
            AffectsWholeRoom = definition.AffectsWholeRoom,
            Duration = definition.Duration,
            Keywords = definition.Keywords?.ToList() ?? new List<string> { definition.Name.ToLowerInvariant() },
            EffectMessage = definition.EffectMessage
        };
    }

    /// <summary>
    /// Processes a turn tick, reducing duration for temporary hazards.
    /// </summary>
    /// <returns>True if the hazard expired this turn.</returns>
    public bool ProcessTurnTick()
    {
        if (IsPermanent)
            return false;

        Duration--;

        if (Duration <= 0)
        {
            IsActive = false;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Deactivates this hazard zone.
    /// </summary>
    public void Deactivate()
    {
        IsActive = false;
    }

    /// <summary>
    /// Reactivates this hazard zone with optional new duration.
    /// </summary>
    /// <param name="newDuration">New duration in turns, or null to keep existing.</param>
    public void Reactivate(int? newDuration = null)
    {
        IsActive = true;
        if (newDuration.HasValue)
        {
            Duration = newDuration.Value;
        }
    }

    /// <summary>
    /// Checks if a keyword matches this hazard.
    /// </summary>
    /// <param name="keyword">The keyword to check.</param>
    /// <returns>True if the keyword matches.</returns>
    public bool MatchesKeyword(string keyword)
    {
        return Keywords.Any(k => k.Equals(keyword, StringComparison.OrdinalIgnoreCase)) ||
               Name.Contains(keyword, StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Gets a description of the hazard type for display.
    /// </summary>
    /// <returns>A human-readable hazard type description.</returns>
    public string GetHazardTypeDescription()
    {
        return HazardType switch
        {
            HazardType.PoisonGas => "Poisonous gas fills the area",
            HazardType.Fire => "Flames burn throughout the area",
            HazardType.Ice => "Bitter cold permeates the area",
            HazardType.Spikes => "Sharp spikes cover the ground",
            HazardType.AcidPool => "Corrosive acid pools on the floor",
            HazardType.Darkness => "Magical darkness obscures vision",
            HazardType.Electricity => "Electrical energy crackles through the air",
            HazardType.Radiant => "Radiant energy fills the area",
            HazardType.Necrotic => "Necrotic energy drains life force",
            _ => "An unknown hazard affects this area"
        };
    }
}
```

### 2.4 HazardDefinition (NEW)

**File:** `src/Core/RuneAndRust.Domain/Definitions/HazardDefinition.cs`

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Configuration definition for a hazard type.
/// </summary>
public class HazardDefinition
{
    /// <summary>
    /// Gets or sets the unique identifier for this definition.
    /// </summary>
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the display name of hazards created from this definition.
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the description shown to players.
    /// </summary>
    public string Description { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the type of hazard.
    /// </summary>
    public HazardType HazardType { get; set; }

    /// <summary>
    /// Gets or sets the damage dealt each turn (null if no per-turn damage).
    /// </summary>
    public HazardDamageDefinition? DamagePerTurn { get; set; }

    /// <summary>
    /// Gets or sets the damage dealt on entry (null if no entry damage).
    /// </summary>
    public HazardDamageDefinition? EntryDamage { get; set; }

    /// <summary>
    /// Gets or sets status effects applied while in the hazard.
    /// </summary>
    public List<string> StatusEffects { get; set; } = new();

    /// <summary>
    /// Gets or sets the duration of applied status effects in turns.
    /// </summary>
    public int StatusDuration { get; set; } = 3;

    /// <summary>
    /// Gets or sets the saving throw configuration.
    /// </summary>
    public HazardSaveDefinition? Save { get; set; }

    /// <summary>
    /// Gets or sets whether this hazard affects the entire room.
    /// </summary>
    public bool AffectsWholeRoom { get; set; } = true;

    /// <summary>
    /// Gets or sets the duration in turns (-1 for permanent).
    /// </summary>
    public int Duration { get; set; } = -1;

    /// <summary>
    /// Gets or sets keywords for referencing this hazard.
    /// </summary>
    public List<string> Keywords { get; set; } = new();

    /// <summary>
    /// Gets or sets the message displayed when the hazard affects a player.
    /// </summary>
    public string? EffectMessage { get; set; }
}

/// <summary>
/// Configuration for hazard damage.
/// </summary>
public class HazardDamageDefinition
{
    /// <summary>
    /// Gets or sets the damage dice expression (e.g., "1d6").
    /// </summary>
    public string Dice { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the damage type (e.g., "poison", "fire").
    /// </summary>
    public string DamageType { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets flat bonus damage.
    /// </summary>
    public int Bonus { get; set; }
}

/// <summary>
/// Configuration for hazard saving throw.
/// </summary>
public class HazardSaveDefinition
{
    /// <summary>
    /// Gets or sets the attribute used for the save.
    /// </summary>
    public string Attribute { get; set; } = string.Empty;

    /// <summary>
    /// Gets or sets the DC to beat.
    /// </summary>
    public int DC { get; set; }

    /// <summary>
    /// Gets or sets whether a successful save negates (true) or halves (false) the effect.
    /// </summary>
    public bool Negates { get; set; }
}
```

### 2.5 HazardEffectResult Value Object (NEW)

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/HazardEffectResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the result of applying a hazard's effect to a target.
/// </summary>
public readonly record struct HazardEffectResult
{
    /// <summary>
    /// Gets the hazard that caused this effect.
    /// </summary>
    public string HazardName { get; init; }

    /// <summary>
    /// Gets the total damage dealt.
    /// </summary>
    public int DamageDealt { get; init; }

    /// <summary>
    /// Gets the damage type.
    /// </summary>
    public string? DamageType { get; init; }

    /// <summary>
    /// Gets whether a save was attempted.
    /// </summary>
    public bool SaveAttempted { get; init; }

    /// <summary>
    /// Gets whether the save was successful.
    /// </summary>
    public bool SaveSucceeded { get; init; }

    /// <summary>
    /// Gets the save roll total.
    /// </summary>
    public int? SaveRoll { get; init; }

    /// <summary>
    /// Gets the save DC.
    /// </summary>
    public int? SaveDC { get; init; }

    /// <summary>
    /// Gets the save attribute used.
    /// </summary>
    public string? SaveAttribute { get; init; }

    /// <summary>
    /// Gets the status effects applied.
    /// </summary>
    public IReadOnlyList<string> StatusEffectsApplied { get; init; }

    /// <summary>
    /// Gets the message to display.
    /// </summary>
    public string Message { get; init; }

    /// <summary>
    /// Gets the individual damage dice rolls.
    /// </summary>
    public IReadOnlyList<int> DamageRolls { get; init; }

    /// <summary>
    /// Gets whether the effect was completely negated.
    /// </summary>
    public bool WasNegated { get; init; }

    /// <summary>
    /// Creates a result for damage dealt.
    /// </summary>
    public static HazardEffectResult DamageResult(
        string hazardName,
        int damage,
        string damageType,
        IEnumerable<int> rolls,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        HazardName = hazardName,
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        StatusEffectsApplied = Array.Empty<string>(),
        WasNegated = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for status effects applied.
    /// </summary>
    public static HazardEffectResult StatusResult(
        string hazardName,
        IEnumerable<string> effects,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        HazardName = hazardName,
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        StatusEffectsApplied = effects.ToList(),
        WasNegated = false,
        Message = message
    };

    /// <summary>
    /// Creates a result where the save completely negated the effect.
    /// </summary>
    public static HazardEffectResult Negated(
        string hazardName,
        int saveRoll,
        int saveDC,
        string saveAttribute,
        string message) => new()
    {
        HazardName = hazardName,
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = true,
        SaveSucceeded = true,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        StatusEffectsApplied = Array.Empty<string>(),
        WasNegated = true,
        Message = message
    };

    /// <summary>
    /// Creates a combined result with damage and status effects.
    /// </summary>
    public static HazardEffectResult Combined(
        string hazardName,
        int damage,
        string? damageType,
        IEnumerable<int> rolls,
        IEnumerable<string> statusEffects,
        string message,
        bool saveAttempted = false,
        bool saveSucceeded = false,
        int? saveRoll = null,
        int? saveDC = null,
        string? saveAttribute = null) => new()
    {
        HazardName = hazardName,
        DamageDealt = damage,
        DamageType = damageType,
        DamageRolls = rolls.ToList(),
        SaveAttempted = saveAttempted,
        SaveSucceeded = saveSucceeded,
        SaveRoll = saveRoll,
        SaveDC = saveDC,
        SaveAttribute = saveAttribute,
        StatusEffectsApplied = statusEffects.ToList(),
        WasNegated = false,
        Message = message
    };

    /// <summary>
    /// Creates a result for no effect (hazard inactive or not applicable).
    /// </summary>
    public static HazardEffectResult NoEffect(string hazardName) => new()
    {
        HazardName = hazardName,
        DamageDealt = 0,
        DamageType = null,
        DamageRolls = Array.Empty<int>(),
        SaveAttempted = false,
        SaveSucceeded = false,
        StatusEffectsApplied = Array.Empty<string>(),
        WasNegated = false,
        Message = string.Empty
    };
}
```

---

## 3. Room Modifications

### 3.1 Room Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs`

Add the following members:

```csharp
// Add private field
private readonly List<HazardZone> _hazardZones = new();

// Add public properties

/// <summary>
/// Gets the hazard zones in this room.
/// </summary>
public IReadOnlyList<HazardZone> HazardZones => _hazardZones;

/// <summary>
/// Gets whether this room has any hazard zones.
/// </summary>
public bool HasHazards => _hazardZones.Count > 0;

/// <summary>
/// Gets whether this room has any active hazards.
/// </summary>
public bool HasActiveHazards => _hazardZones.Any(h => h.IsActive);

// Add methods

/// <summary>
/// Adds a hazard zone to this room.
/// </summary>
/// <param name="hazard">The hazard zone to add.</param>
public void AddHazardZone(HazardZone hazard)
{
    ArgumentNullException.ThrowIfNull(hazard);
    _hazardZones.Add(hazard);
}

/// <summary>
/// Removes a hazard zone from this room.
/// </summary>
/// <param name="hazard">The hazard zone to remove.</param>
/// <returns>True if the hazard was removed.</returns>
public bool RemoveHazardZone(HazardZone hazard)
{
    return _hazardZones.Remove(hazard);
}

/// <summary>
/// Gets all active hazard zones.
/// </summary>
/// <returns>Enumerable of active hazard zones.</returns>
public IEnumerable<HazardZone> GetActiveHazards()
{
    return _hazardZones.Where(h => h.IsActive);
}

/// <summary>
/// Gets a hazard zone by keyword.
/// </summary>
/// <param name="keyword">The keyword to search for.</param>
/// <returns>The matching hazard zone, or null if not found.</returns>
public HazardZone? GetHazardByKeyword(string keyword)
{
    return _hazardZones.FirstOrDefault(h => h.IsActive && h.MatchesKeyword(keyword));
}

/// <summary>
/// Gets hazard zones by type.
/// </summary>
/// <param name="hazardType">The hazard type to filter by.</param>
/// <returns>Enumerable of matching hazard zones.</returns>
public IEnumerable<HazardZone> GetHazardsByType(HazardType hazardType)
{
    return _hazardZones.Where(h => h.IsActive && h.HazardType == hazardType);
}

/// <summary>
/// Removes all expired (inactive) hazard zones.
/// </summary>
/// <returns>The number of hazards removed.</returns>
public int RemoveExpiredHazards()
{
    return _hazardZones.RemoveAll(h => !h.IsActive && h.IsExpired);
}
```

---

## 4. Services

### 4.1 IHazardService Interface (NEW)

**File:** `src/Core/RuneAndRust.Application/Interfaces/IHazardService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing environmental hazards and their effects.
/// </summary>
public interface IHazardService
{
    /// <summary>
    /// Gets a description of active hazards in a room for room descriptions.
    /// </summary>
    /// <param name="room">The room to describe.</param>
    /// <returns>A formatted description of active hazards.</returns>
    string GetRoomHazardsDescription(Room room);

    /// <summary>
    /// Finds a hazard zone by keyword in a room.
    /// </summary>
    /// <param name="room">The room to search.</param>
    /// <param name="keyword">The keyword to search for.</param>
    /// <returns>The matching hazard zone, or null if not found.</returns>
    HazardZone? FindHazard(Room room, string keyword);

    /// <summary>
    /// Examines a hazard zone.
    /// </summary>
    /// <param name="hazard">The hazard to examine.</param>
    /// <returns>A detailed description of the hazard.</returns>
    string ExamineHazard(HazardZone hazard);

    /// <summary>
    /// Processes entry hazard effects when a player enters a room.
    /// </summary>
    /// <param name="room">The room being entered.</param>
    /// <param name="player">The player entering.</param>
    /// <returns>Results for each hazard that affected the player.</returns>
    IEnumerable<HazardEffectResult> ProcessEntryHazards(Room room, Player player);

    /// <summary>
    /// Processes per-turn hazard effects for a player in a room.
    /// </summary>
    /// <param name="room">The room the player is in.</param>
    /// <param name="player">The player to process hazards for.</param>
    /// <returns>Results for each hazard that affected the player.</returns>
    IEnumerable<HazardEffectResult> ProcessTurnHazards(Room room, Player player);

    /// <summary>
    /// Processes a single hazard's effect on a player.
    /// </summary>
    /// <param name="hazard">The hazard zone.</param>
    /// <param name="player">The player affected.</param>
    /// <param name="isEntry">Whether this is entry damage (true) or per-turn damage (false).</param>
    /// <returns>The result of applying the hazard effect.</returns>
    HazardEffectResult ApplyHazardEffect(HazardZone hazard, Player player, bool isEntry);

    /// <summary>
    /// Processes turn ticks for all hazards in a room (handles duration countdown).
    /// </summary>
    /// <param name="room">The room to process.</param>
    /// <returns>Messages about hazards that expired.</returns>
    IEnumerable<string> ProcessHazardTurnTicks(Room room);

    /// <summary>
    /// Gets statistics about hazards in a room.
    /// </summary>
    /// <param name="room">The room to analyze.</param>
    /// <returns>A summary of hazard states.</returns>
    HazardRoomSummary GetRoomHazardSummary(Room room);

    /// <summary>
    /// Performs a saving throw for a player against a hazard.
    /// </summary>
    /// <param name="player">The player making the save.</param>
    /// <param name="save">The saving throw configuration.</param>
    /// <returns>The saving throw result.</returns>
    SavingThrowResult PerformSavingThrow(Player player, SavingThrow save);
}

/// <summary>
/// Summary of hazard states in a room.
/// </summary>
public readonly record struct HazardRoomSummary
{
    /// <summary>Gets the total number of hazard zones.</summary>
    public int Total { get; init; }

    /// <summary>Gets the number of active hazard zones.</summary>
    public int Active { get; init; }

    /// <summary>Gets the number of permanent hazards.</summary>
    public int Permanent { get; init; }

    /// <summary>Gets the number of temporary hazards.</summary>
    public int Temporary { get; init; }

    /// <summary>Gets the number of expired/inactive hazards.</summary>
    public int Expired { get; init; }
}

/// <summary>
/// Result of a saving throw.
/// </summary>
public readonly record struct SavingThrowResult
{
    /// <summary>Gets the total roll (dice + modifier).</summary>
    public int Total { get; init; }

    /// <summary>Gets the individual dice rolls.</summary>
    public IReadOnlyList<int> Rolls { get; init; }

    /// <summary>Gets the attribute modifier applied.</summary>
    public int Modifier { get; init; }

    /// <summary>Gets the DC that was checked against.</summary>
    public int DC { get; init; }

    /// <summary>Gets whether the save was successful.</summary>
    public bool Success { get; init; }

    /// <summary>Gets the attribute used for the save.</summary>
    public string Attribute { get; init; }
}
```

### 4.2 HazardService Implementation (NEW)

**File:** `src/Core/RuneAndRust.Application/Services/HazardService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text;

/// <summary>
/// Service for managing environmental hazards and their effects.
/// </summary>
public class HazardService : IHazardService
{
    private readonly ILogger<HazardService> _logger;
    private readonly IDiceService _diceService;
    private readonly IStatusEffectService _statusEffectService;

    /// <summary>
    /// Creates a new hazard service.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    /// <param name="diceService">The dice service for rolling.</param>
    /// <param name="statusEffectService">The status effect service.</param>
    public HazardService(
        ILogger<HazardService> logger,
        IDiceService diceService,
        IStatusEffectService statusEffectService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _statusEffectService = statusEffectService ?? throw new ArgumentNullException(nameof(statusEffectService));
    }

    /// <inheritdoc />
    public string GetRoomHazardsDescription(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var activeHazards = room.GetActiveHazards().ToList();
        if (!activeHazards.Any())
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        sb.AppendLine("Environmental Hazards:");

        foreach (var hazard in activeHazards)
        {
            var durationInfo = hazard.IsPermanent ? "" : $" ({hazard.Duration} turns remaining)";
            sb.AppendLine($"  {hazard.Name}{durationInfo} - {hazard.GetHazardTypeDescription()}");
        }

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public HazardZone? FindHazard(Room room, string keyword)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentException.ThrowIfNullOrWhiteSpace(keyword);

        var hazard = room.GetHazardByKeyword(keyword);

        if (hazard != null)
        {
            _logger.LogDebug("Found hazard {HazardName} by keyword '{Keyword}'", hazard.Name, keyword);
        }
        else
        {
            _logger.LogDebug("No hazard found for keyword '{Keyword}'", keyword);
        }

        return hazard;
    }

    /// <inheritdoc />
    public string ExamineHazard(HazardZone hazard)
    {
        ArgumentNullException.ThrowIfNull(hazard);

        var sb = new StringBuilder();
        sb.AppendLine(hazard.Name);
        sb.AppendLine(hazard.Description);
        sb.AppendLine();
        sb.AppendLine($"Type: {hazard.GetHazardTypeDescription()}");
        sb.AppendLine($"Status: {(hazard.IsActive ? "Active" : "Inactive")}");

        if (!hazard.IsPermanent)
        {
            sb.AppendLine($"Duration: {hazard.Duration} turns remaining");
        }
        else
        {
            sb.AppendLine("Duration: Permanent");
        }

        if (hazard.DamagePerTurn)
        {
            sb.AppendLine($"Damage per turn: {hazard.DamagePerTurnDice} {hazard.DamageType}");
        }

        if (hazard.DamageOnEntry)
        {
            sb.AppendLine($"Entry damage: {hazard.EntryDamageDice} {hazard.DamageType}");
        }

        if (hazard.AppliesStatus)
        {
            sb.AppendLine($"Effects: {string.Join(", ", hazard.StatusEffects)}");
        }

        if (hazard.HasSave)
        {
            var saveInfo = hazard.Save!.Value;
            var saveEffect = saveInfo.Negates ? "negates" : "halves damage";
            sb.AppendLine($"Save: {saveInfo.Attribute} DC {saveInfo.DC} ({saveEffect})");
        }

        _logger.LogDebug("Examined hazard {HazardName}", hazard.Name);

        return sb.ToString().TrimEnd();
    }

    /// <inheritdoc />
    public IEnumerable<HazardEffectResult> ProcessEntryHazards(Room room, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentNullException.ThrowIfNull(player);

        var results = new List<HazardEffectResult>();
        var activeHazards = room.GetActiveHazards().Where(h => h.DamageOnEntry);

        foreach (var hazard in activeHazards)
        {
            var result = ApplyHazardEffect(hazard, player, isEntry: true);
            if (result.DamageDealt > 0 || result.StatusEffectsApplied.Count > 0 || result.WasNegated)
            {
                results.Add(result);
            }
        }

        return results;
    }

    /// <inheritdoc />
    public IEnumerable<HazardEffectResult> ProcessTurnHazards(Room room, Player player)
    {
        ArgumentNullException.ThrowIfNull(room);
        ArgumentNullException.ThrowIfNull(player);

        var results = new List<HazardEffectResult>();
        var activeHazards = room.GetActiveHazards().Where(h => h.DamagePerTurn || h.AppliesStatus);

        foreach (var hazard in activeHazards)
        {
            var result = ApplyHazardEffect(hazard, player, isEntry: false);
            if (result.DamageDealt > 0 || result.StatusEffectsApplied.Count > 0 || result.WasNegated)
            {
                results.Add(result);
            }
        }

        return results;
    }

    /// <inheritdoc />
    public HazardEffectResult ApplyHazardEffect(HazardZone hazard, Player player, bool isEntry)
    {
        ArgumentNullException.ThrowIfNull(hazard);
        ArgumentNullException.ThrowIfNull(player);

        if (!hazard.IsActive)
        {
            return HazardEffectResult.NoEffect(hazard.Name);
        }

        var damageDice = isEntry ? hazard.EntryDamageDice : hazard.DamagePerTurnDice;
        if (string.IsNullOrEmpty(damageDice) && !hazard.AppliesStatus)
        {
            return HazardEffectResult.NoEffect(hazard.Name);
        }

        var messageBuilder = new StringBuilder();
        var totalDamage = 0;
        var damageRolls = new List<int>();
        var appliedEffects = new List<string>();
        var saveAttempted = false;
        var saveSucceeded = false;
        int? saveRoll = null;
        string? saveAttribute = null;

        // Add effect message
        if (!string.IsNullOrEmpty(hazard.EffectMessage))
        {
            messageBuilder.AppendLine(hazard.EffectMessage);
        }
        else
        {
            messageBuilder.AppendLine($"[ENVIRONMENTAL HAZARD: {hazard.Name}]");
            messageBuilder.AppendLine(hazard.GetHazardTypeDescription() + "!");
        }

        // Handle saving throw
        if (hazard.HasSave)
        {
            saveAttempted = true;
            var save = hazard.Save!.Value;
            var saveResult = PerformSavingThrow(player, save);
            saveRoll = saveResult.Total;
            saveSucceeded = saveResult.Success;
            saveAttribute = save.Attribute;

            messageBuilder.AppendLine();
            messageBuilder.AppendLine($"Saving Throw ({save.Attribute}): [{string.Join(",", saveResult.Rolls)}] + {saveResult.Modifier} = {saveResult.Total} vs DC {save.DC}");

            if (saveSucceeded)
            {
                if (save.Negates)
                {
                    messageBuilder.AppendLine("Save successful! You avoid the hazard's effects.");
                    _logger.LogInformation(
                        "Player saved against {HazardName} (rolled {Roll} vs DC {DC})",
                        hazard.Name, saveResult.Total, save.DC);

                    return HazardEffectResult.Negated(
                        hazard.Name,
                        saveResult.Total,
                        save.DC,
                        save.Attribute,
                        messageBuilder.ToString().TrimEnd());
                }
                else
                {
                    messageBuilder.AppendLine("Save successful! Damage halved.");
                }
            }
            else
            {
                messageBuilder.AppendLine("Save failed!");
            }
        }

        // Apply damage
        if (!string.IsNullOrEmpty(damageDice))
        {
            var damageResult = _diceService.Roll(damageDice);
            damageRolls.AddRange(damageResult.Rolls);
            totalDamage = damageResult.Total;

            // Halve damage on successful save (if save doesn't negate)
            if (saveSucceeded && hazard.HasSave && !hazard.Save!.Value.Negates)
            {
                totalDamage /= 2;
            }

            // Apply damage to player
            player.TakeDamage(totalDamage, hazard.DamageType);

            messageBuilder.AppendLine();
            var damageInfo = saveSucceeded && !hazard.Save!.Value.Negates
                ? $"[{string.Join(",", damageResult.Rolls)}] = {damageResult.Total} / 2 = {totalDamage}"
                : $"[{string.Join(",", damageResult.Rolls)}] = {totalDamage}";
            messageBuilder.AppendLine($"Damage: {damageInfo} {hazard.DamageType} damage");

            _logger.LogInformation(
                "Hazard {HazardName} dealt {Damage} {DamageType} damage to player",
                hazard.Name, totalDamage, hazard.DamageType);
        }

        // Apply status effects (only if save failed or no save required)
        if (hazard.AppliesStatus && !saveSucceeded)
        {
            foreach (var statusEffect in hazard.StatusEffects)
            {
                _statusEffectService.ApplyEffect(player, statusEffect, hazard.StatusDuration);
                appliedEffects.Add(statusEffect);
            }

            if (appliedEffects.Any())
            {
                messageBuilder.AppendLine();
                messageBuilder.AppendLine($"You are afflicted with: {string.Join(", ", appliedEffects)}");
            }
        }

        return HazardEffectResult.Combined(
            hazard.Name,
            totalDamage,
            hazard.DamageType,
            damageRolls,
            appliedEffects,
            messageBuilder.ToString().TrimEnd(),
            saveAttempted,
            saveSucceeded,
            saveRoll,
            hazard.Save?.DC,
            saveAttribute);
    }

    /// <inheritdoc />
    public IEnumerable<string> ProcessHazardTurnTicks(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var messages = new List<string>();

        foreach (var hazard in room.HazardZones.Where(h => h.IsActive && !h.IsPermanent))
        {
            if (hazard.ProcessTurnTick())
            {
                var expireMessage = $"The {hazard.Name} dissipates.";
                messages.Add(expireMessage);
                _logger.LogDebug("Hazard {HazardName} expired", hazard.Name);
            }
        }

        // Clean up expired hazards
        room.RemoveExpiredHazards();

        return messages;
    }

    /// <inheritdoc />
    public HazardRoomSummary GetRoomHazardSummary(Room room)
    {
        ArgumentNullException.ThrowIfNull(room);

        var hazards = room.HazardZones;

        return new HazardRoomSummary
        {
            Total = hazards.Count,
            Active = hazards.Count(h => h.IsActive),
            Permanent = hazards.Count(h => h.IsActive && h.IsPermanent),
            Temporary = hazards.Count(h => h.IsActive && !h.IsPermanent),
            Expired = hazards.Count(h => !h.IsActive)
        };
    }

    /// <inheritdoc />
    public SavingThrowResult PerformSavingThrow(Player player, SavingThrow save)
    {
        ArgumentNullException.ThrowIfNull(player);

        // Saving throw is 1d20 + attribute modifier vs DC
        var modifier = player.GetAttributeModifier(save.Attribute);
        var roll = _diceService.Roll("1d20");

        var total = roll.Total + modifier;
        var success = total >= save.DC;

        _logger.LogDebug(
            "Saving throw {Attribute}: rolled {Roll} + {Modifier} = {Total} vs DC {DC} ({Result})",
            save.Attribute, roll.Total, modifier, total, save.DC, success ? "Success" : "Failure");

        return new SavingThrowResult
        {
            Total = total,
            Rolls = roll.Rolls.ToList(),
            Modifier = modifier,
            DC = save.DC,
            Success = success,
            Attribute = save.Attribute
        };
    }
}
```

### 4.3 TurnProcessingService Integration

The TurnProcessingService needs to call hazard processing each turn:

```csharp
// In TurnProcessingService.ProcessTurn():

// Process hazard effects on player
var hazardResults = _hazardService.ProcessTurnHazards(currentRoom, player);
foreach (var result in hazardResults)
{
    messages.Add(result.Message);
}

// Process hazard duration ticks
var hazardExpireMessages = _hazardService.ProcessHazardTurnTicks(currentRoom);
messages.AddRange(hazardExpireMessages);

// Process trap resets (existing from v0.4.1a)
var trapResetMessages = _trapService.ProcessRoomTurnTick(currentRoom);
messages.AddRange(trapResetMessages);
```

---

## 5. Configuration

### 5.1 Hazard Configuration Schema (NEW)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/schemas/hazards.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Hazards Configuration",
  "description": "Configuration for environmental hazards in the game world",
  "type": "object",
  "properties": {
    "hazards": {
      "type": "array",
      "description": "List of hazard definitions",
      "items": {
        "$ref": "#/definitions/hazardDefinition"
      }
    }
  },
  "definitions": {
    "hazardDefinition": {
      "type": "object",
      "required": ["id", "name", "hazardType"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this hazard definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the hazard"
        },
        "description": {
          "type": "string",
          "description": "Description shown when examining the hazard"
        },
        "hazardType": {
          "type": "string",
          "description": "Type of environmental hazard",
          "enum": ["PoisonGas", "Fire", "Ice", "Spikes", "AcidPool", "Darkness", "Electricity", "Radiant", "Necrotic"]
        },
        "damagePerTurn": {
          "$ref": "#/definitions/hazardDamage",
          "description": "Damage dealt each turn while in the hazard"
        },
        "entryDamage": {
          "$ref": "#/definitions/hazardDamage",
          "description": "Damage dealt when entering the hazard"
        },
        "statusEffects": {
          "type": "array",
          "description": "Status effects applied while in the hazard",
          "items": {
            "type": "string"
          }
        },
        "statusDuration": {
          "type": "integer",
          "description": "Duration of applied status effects in turns",
          "minimum": 1,
          "default": 3
        },
        "save": {
          "$ref": "#/definitions/hazardSave",
          "description": "Saving throw to reduce or avoid damage"
        },
        "affectsWholeRoom": {
          "type": "boolean",
          "description": "Whether the hazard affects the entire room",
          "default": true
        },
        "duration": {
          "type": "integer",
          "description": "Duration in turns (-1 for permanent)",
          "default": -1
        },
        "keywords": {
          "type": "array",
          "description": "Keywords for referencing this hazard",
          "items": {
            "type": "string"
          }
        },
        "effectMessage": {
          "type": "string",
          "description": "Custom message when hazard affects a player"
        }
      }
    },
    "hazardDamage": {
      "type": "object",
      "required": ["dice", "damageType"],
      "properties": {
        "dice": {
          "type": "string",
          "description": "Damage dice expression (e.g., '1d6')"
        },
        "damageType": {
          "type": "string",
          "description": "Type of damage (e.g., 'poison', 'fire')"
        },
        "bonus": {
          "type": "integer",
          "description": "Flat bonus damage",
          "default": 0
        }
      }
    },
    "hazardSave": {
      "type": "object",
      "required": ["attribute", "dc"],
      "properties": {
        "attribute": {
          "type": "string",
          "description": "Attribute used for the save (e.g., 'Fortitude', 'Agility')"
        },
        "dc": {
          "type": "integer",
          "description": "DC to beat for success",
          "minimum": 1
        },
        "negates": {
          "type": "boolean",
          "description": "Whether success negates (true) or halves (false) the effect",
          "default": false
        }
      }
    }
  }
}
```

### 5.2 Sample Hazard Configuration (NEW)

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Configuration/hazards.json`

```json
{
  "$schema": "./schemas/hazards.schema.json",
  "hazards": [
    {
      "id": "poison-gas-weak",
      "name": "Poison Gas",
      "description": "A sickly green mist fills the area, making it difficult to breathe. The gas burns your lungs with each breath.",
      "hazardType": "PoisonGas",
      "damagePerTurn": {
        "dice": "1d6",
        "damageType": "poison"
      },
      "statusEffects": ["poisoned"],
      "statusDuration": 3,
      "save": {
        "attribute": "Fortitude",
        "dc": 12,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["gas", "poison", "mist", "fumes"],
      "effectMessage": "The poisonous fumes burn your lungs!"
    },
    {
      "id": "poison-gas-strong",
      "name": "Toxic Cloud",
      "description": "A dense cloud of deadly poison fills the chamber. Even a moment's exposure could be fatal.",
      "hazardType": "PoisonGas",
      "damagePerTurn": {
        "dice": "2d6",
        "damageType": "poison"
      },
      "statusEffects": ["poisoned", "weakened"],
      "statusDuration": 5,
      "save": {
        "attribute": "Fortitude",
        "dc": 15,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["cloud", "toxic", "deadly gas"],
      "effectMessage": "The toxic cloud sears your lungs and burns your eyes!"
    },
    {
      "id": "floor-flames",
      "name": "Floor Flames",
      "description": "Flames lick across the floor from cracks in the stone. The heat is intense and unavoidable.",
      "hazardType": "Fire",
      "damagePerTurn": {
        "dice": "2d6",
        "damageType": "fire"
      },
      "statusEffects": ["burning"],
      "statusDuration": 2,
      "save": {
        "attribute": "Agility",
        "dc": 11,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["fire", "flames", "burning floor"],
      "effectMessage": "The flames burn at your feet!"
    },
    {
      "id": "fire-pit",
      "name": "Raging Inferno",
      "description": "A massive fire fills this area, the flames reaching ceiling height. Only the foolhardy would enter.",
      "hazardType": "Fire",
      "damagePerTurn": {
        "dice": "3d6",
        "damageType": "fire"
      },
      "entryDamage": {
        "dice": "2d6",
        "damageType": "fire"
      },
      "statusEffects": ["burning"],
      "statusDuration": 3,
      "save": {
        "attribute": "Agility",
        "dc": 14,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["inferno", "fire pit", "raging fire"],
      "effectMessage": "The raging inferno engulfs you!"
    },
    {
      "id": "freezing-cold",
      "name": "Freezing Cold",
      "description": "Bitter cold permeates this area. Frost covers every surface and your breath forms clouds in the air.",
      "hazardType": "Ice",
      "damagePerTurn": {
        "dice": "1d4",
        "damageType": "cold"
      },
      "statusEffects": ["chilled"],
      "statusDuration": 2,
      "save": {
        "attribute": "Fortitude",
        "dc": 10,
        "negates": true
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["cold", "ice", "frost", "freezing"],
      "effectMessage": "The intense cold saps your strength."
    },
    {
      "id": "ice-cavern",
      "name": "Glacial Chamber",
      "description": "The air here is so cold it burns. Ice encrusts the walls and floor, making movement treacherous.",
      "hazardType": "Ice",
      "damagePerTurn": {
        "dice": "1d6",
        "damageType": "cold"
      },
      "statusEffects": ["chilled", "slowed"],
      "statusDuration": 3,
      "save": {
        "attribute": "Fortitude",
        "dc": 13,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["glacial", "ice cavern", "frozen"],
      "effectMessage": "The glacial cold bites deep into your bones!"
    },
    {
      "id": "spike-floor",
      "name": "Spike Floor",
      "description": "Sharp metal spikes protrude from the floor at irregular intervals. Careful movement is essential.",
      "hazardType": "Spikes",
      "entryDamage": {
        "dice": "1d8",
        "damageType": "piercing"
      },
      "save": {
        "attribute": "Agility",
        "dc": 13,
        "negates": true
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["spikes", "spike floor", "spiky"],
      "effectMessage": "Sharp spikes jab at your feet!"
    },
    {
      "id": "spike-pit",
      "name": "Spiked Floor Hazard",
      "description": "The entire floor is covered in rusty, jagged spikes. Moving through here will be painful.",
      "hazardType": "Spikes",
      "entryDamage": {
        "dice": "2d6",
        "damageType": "piercing"
      },
      "statusEffects": ["bleeding"],
      "statusDuration": 3,
      "save": {
        "attribute": "Agility",
        "dc": 15,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["spikes", "spiked floor", "rusty spikes"],
      "effectMessage": "The rusty spikes tear at your flesh!"
    },
    {
      "id": "acid-pool",
      "name": "Acid Pool",
      "description": "A pool of caustic acid covers the floor. The acrid smell burns your nostrils.",
      "hazardType": "AcidPool",
      "damagePerTurn": {
        "dice": "2d4",
        "damageType": "acid"
      },
      "statusEffects": ["corroded"],
      "statusDuration": 3,
      "save": {
        "attribute": "Agility",
        "dc": 12,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["acid", "pool", "caustic"],
      "effectMessage": "The acid burns and corrodes everything it touches!"
    },
    {
      "id": "electrical-field",
      "name": "Electrical Field",
      "description": "Crackling energy fills the air. Arcs of electricity jump between metal surfaces.",
      "hazardType": "Electricity",
      "damagePerTurn": {
        "dice": "1d8",
        "damageType": "lightning"
      },
      "statusEffects": ["stunned"],
      "statusDuration": 1,
      "save": {
        "attribute": "Agility",
        "dc": 13,
        "negates": true
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["electricity", "lightning", "sparks"],
      "effectMessage": "Electricity arcs through your body!"
    },
    {
      "id": "temporary-flame-burst",
      "name": "Flame Burst",
      "description": "A burst of fire temporarily fills the area, slowly dissipating.",
      "hazardType": "Fire",
      "damagePerTurn": {
        "dice": "3d6",
        "damageType": "fire"
      },
      "save": {
        "attribute": "Agility",
        "dc": 14,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": 3,
      "keywords": ["flame burst", "fire burst"],
      "effectMessage": "The lingering flames continue to burn!"
    },
    {
      "id": "necrotic-aura",
      "name": "Necrotic Aura",
      "description": "An aura of death pervades this area. Life energy slowly drains from all living things.",
      "hazardType": "Necrotic",
      "damagePerTurn": {
        "dice": "1d6",
        "damageType": "necrotic"
      },
      "statusEffects": ["weakened"],
      "statusDuration": 3,
      "save": {
        "attribute": "Will",
        "dc": 14,
        "negates": false
      },
      "affectsWholeRoom": true,
      "duration": -1,
      "keywords": ["necrotic", "death aura", "draining"],
      "effectMessage": "The necrotic energy drains your life force!"
    }
  ]
}
```

---

## 6. Command Integration

### 6.1 Room Description Integration

Update room descriptions to include active hazards:

```csharp
// In room description building:

public string GetFullRoomDescription(Room room)
{
    var sb = new StringBuilder();

    // Room name and description
    sb.AppendLine(room.Name);
    sb.AppendLine(room.Description);

    // Interactive objects
    var objectsDesc = _interactionService.GetRoomObjectsDescription(room);
    if (!string.IsNullOrEmpty(objectsDesc))
    {
        sb.AppendLine();
        sb.AppendLine(objectsDesc);
    }

    // Visible traps (from v0.4.1a)
    var trapsDesc = _trapService.GetRoomTrapsDescription(room);
    if (!string.IsNullOrEmpty(trapsDesc))
    {
        sb.AppendLine();
        sb.AppendLine(trapsDesc);
    }

    // Active hazards (NEW)
    var hazardsDesc = _hazardService.GetRoomHazardsDescription(room);
    if (!string.IsNullOrEmpty(hazardsDesc))
    {
        sb.AppendLine();
        sb.AppendLine(hazardsDesc);
    }

    // Exits
    // ...

    return sb.ToString();
}
```

### 6.2 Room Entry Integration

Update movement logic to check for entry hazards:

```csharp
public MoveResult TryMove(Direction direction, Room currentRoom, Room newRoom, Player player)
{
    // ... existing movement validation ...

    // Check for entry traps (from v0.4.1b)
    var trapResult = _trapService.CheckEntryTraps(newRoom, player);

    // Check for entry hazards (NEW)
    var entryHazardResults = _hazardService.ProcessEntryHazards(newRoom, player);

    var messages = new List<string>();

    if (trapResult != null)
    {
        var (trigger, effect) = trapResult.Value;
        messages.Add(trigger.Message);
        if (effect != null)
        {
            messages.Add(effect.Value.Message);
        }
    }

    foreach (var hazardResult in entryHazardResults)
    {
        messages.Add(hazardResult.Message);
    }

    // Check if player died
    if (player.IsDead)
    {
        messages.Add("You have died!");
        return MoveResult.SucceededButDied(newRoom, string.Join("\n\n", messages));
    }

    // Passive trap detection (from v0.4.1b)
    var detectionResult = _trapService.PassivePerceptionCheck(newRoom, player);
    if (detectionResult.DetectedAny)
    {
        messages.Add(detectionResult.Message);
    }

    if (messages.Any())
    {
        return MoveResult.SucceededWithEffects(newRoom, string.Join("\n\n", messages));
    }

    return MoveResult.Succeeded(newRoom);
}
```

### 6.3 Examine Hazard Command

The examine command should work with hazards:

```csharp
// In GameSessionService or CommandProcessor:

private string ProcessExamineCommand(string[] args, Room currentRoom)
{
    if (args.Length == 0)
    {
        return "Examine what?";
    }

    var keyword = string.Join(" ", args);

    // Check for traps first (only visible ones)
    var trap = _trapService.FindTrap(currentRoom, keyword);
    if (trap != null)
    {
        return _trapService.ExamineTrap(trap);
    }

    // Check for hazards (NEW)
    var hazard = _hazardService.FindHazard(currentRoom, keyword);
    if (hazard != null)
    {
        return _hazardService.ExamineHazard(hazard);
    }

    // Fall through to existing examine logic for objects, items, etc.
    // ...
}
```

---

## 7. User Experience

### 7.1 Room with Environmental Hazard

```
You enter the Toxic Chamber. A sickly green mist
fills the room, making it difficult to breathe.

[ENVIRONMENTAL HAZARD: Poison Gas]
The poisonous fumes burn your lungs!

Saving Throw (Fortitude): [8] + 2 = 10 vs DC 12
Save failed!

Damage: [4] = 4 poison damage
You are afflicted with: poisoned

---

Toxic Chamber
Ancient vents in the walls continuously release
a toxic green gas into this chamber.

Environmental Hazards:
  Poison Gas - Poisonous gas fills the area

Exits: south
```

### 7.2 Hazard with Successful Save (Halves Damage)

```
=== END OF TURN ===

[ENVIRONMENTAL HAZARD: Poison Gas]
The poisonous fumes burn your lungs!

Saving Throw (Fortitude): [11] + 2 = 13 vs DC 12
Save successful! Damage halved.

Damage: [5] = 5 / 2 = 2 poison damage
```

### 7.3 Hazard with Successful Save (Negates)

```
=== END OF TURN ===

[ENVIRONMENTAL HAZARD: Freezing Cold]
The intense cold saps your strength.

Saving Throw (Fortitude): [9] + 2 = 11 vs DC 10
Save successful! You avoid the hazard's effects.
```

### 7.4 Fire Zone Entry

```
> north

You step into the Burning Hall.

[ENVIRONMENTAL HAZARD: Floor Flames]
The flames burn at your feet!

Saving Throw (Agility): [5] + 3 = 8 vs DC 11
Save failed!

Damage: [4, 5] = 9 fire damage
You are afflicted with: burning

---

Burning Hall
Flames lick across the floor from cracks in the stone.
The heat is oppressive and seems unnatural.

Environmental Hazards:
  Floor Flames - Flames burn throughout the area

Exits: south, east
```

### 7.5 Spike Floor (Entry Damage Only)

```
> east

You move carefully across the spike-covered floor.

[ENVIRONMENTAL HAZARD: Spike Floor]
Sharp spikes jab at your feet!

Saving Throw (Agility): [4] + 3 = 7 vs DC 13
Save failed!

Damage: [6] = 6 piercing damage

---

Spiked Corridor
Sharp metal spikes protrude from the floor at
irregular intervals. Careful movement is essential.

Environmental Hazards:
  Spike Floor - Sharp spikes cover the ground

Exits: west
```

### 7.6 Examining a Hazard

```
> examine poison gas

Poison Gas
A sickly green mist fills the area, making it difficult
to breathe. The gas burns your lungs with each breath.

Type: Poisonous gas fills the area
Status: Active
Duration: Permanent

Damage per turn: 1d6 poison
Effects: poisoned
Save: Fortitude DC 12 (halves damage)
```

### 7.7 Temporary Hazard Expiring

```
=== END OF TURN ===

[ENVIRONMENTAL HAZARD: Flame Burst]
The lingering flames continue to burn!

Saving Throw (Agility): [12] + 3 = 15 vs DC 14
Save successful! Damage halved.

Damage: [3, 5, 2] = 10 / 2 = 5 fire damage

The Flame Burst dissipates.
```

### 7.8 Multiple Hazards in Room

```
You enter the Chamber of Torment.

[ENVIRONMENTAL HAZARD: Necrotic Aura]
The necrotic energy drains your life force!

Saving Throw (Will): [7] + 1 = 8 vs DC 14
Save failed!

Damage: [4] = 4 necrotic damage
You are afflicted with: weakened

[ENVIRONMENTAL HAZARD: Freezing Cold]
The intense cold saps your strength.

Saving Throw (Fortitude): [12] + 2 = 14 vs DC 10
Save successful! You avoid the hazard's effects.

---

Chamber of Torment
A place of ancient suffering. Cold mists swirl
around pools of dark energy that drain life itself.

Environmental Hazards:
  Necrotic Aura - Necrotic energy drains life force
  Freezing Cold - Bitter cold permeates the area

Exits: west
```

---

## 8. Acceptance Criteria

### 8.1 Functional Requirements

- [ ] `HazardType` enum contains all expected hazard types
- [ ] `SavingThrow` value object stores attribute, DC, and negates flag
- [ ] `HazardZone` entity tracks all hazard properties
- [ ] `HazardZone.FromDefinition()` creates hazards from configuration
- [ ] `HazardZone.ProcessTurnTick()` handles duration countdown
- [ ] `HazardDefinition` supports JSON configuration
- [ ] `Room.HazardZones` collection manages hazards
- [ ] `Room.GetActiveHazards()` returns only active hazards
- [ ] `Room.GetHazardByKeyword()` finds hazards by keyword
- [ ] `HazardService.ProcessEntryHazards()` applies entry damage
- [ ] `HazardService.ProcessTurnHazards()` applies per-turn damage
- [ ] `HazardService.PerformSavingThrow()` rolls saves correctly
- [ ] Successful saves halve damage (when negates=false)
- [ ] Successful saves negate damage (when negates=true)
- [ ] Status effects apply only on failed saves
- [ ] Temporary hazards expire after duration
- [ ] Active hazards appear in room descriptions
- [ ] Examine command works with hazards
- [ ] Entry hazards trigger when entering rooms
- [ ] Per-turn hazards process during turn processing
- [ ] Configuration schema validates hazard definitions
- [ ] ~25 unit tests pass

### 8.2 Non-Functional Requirements

- [ ] Entity properties are properly encapsulated
- [ ] Services follow DI patterns
- [ ] Logging follows established patterns
- [ ] Configuration is JSON-driven
- [ ] All public methods have XML documentation

---

## 9. Test Specifications

### 9.1 HazardType Enum Tests (~2 tests)

| Test Name | Description |
|-----------|-------------|
| `HazardType_HasAllExpectedValues` | Verify all hazard types exist |
| `HazardType_CanCastToInt` | Values can be compared numerically |

### 9.2 SavingThrow Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidParameters_ReturnsResult` | Valid creation |
| `Fortitude_CreatesFortitudeSave` | Factory method |
| `Agility_CreatesAgilitySave` | Factory method |
| `Negates_DefaultsToFalse` | Default negates value |

### 9.3 HazardZone Entity Tests (~8 tests)

| Test Name | Description |
|-----------|-------------|
| `Create_WithValidParameters_ReturnsHazard` | Valid creation |
| `Create_WithNullDefinitionId_ThrowsException` | Null ID rejected |
| `FromDefinition_CreatesCorrectHazard` | Definition mapping |
| `ProcessTurnTick_WhenPermanent_ReturnsFalse` | Permanent doesn't tick |
| `ProcessTurnTick_WhenTemporary_DecrementsDuration` | Duration countdown |
| `ProcessTurnTick_WhenExpired_ReturnsTrue` | Expiration detection |
| `Deactivate_SetsIsActiveFalse` | Deactivation |
| `MatchesKeyword_FindsMatchingKeyword` | Keyword matching |

### 9.4 Room HazardZone Collection Tests (~4 tests)

| Test Name | Description |
|-----------|-------------|
| `AddHazardZone_AddsToCollection` | Adding hazards |
| `RemoveHazardZone_RemovesFromCollection` | Removing hazards |
| `GetActiveHazards_ReturnsOnlyActive` | Active filtering |
| `GetHazardByKeyword_FindsHazard` | Keyword lookup |

### 9.5 HazardService Tests (~7 tests)

| Test Name | Description |
|-----------|-------------|
| `ProcessEntryHazards_WithEntryDamage_AppliesDamage` | Entry damage |
| `ProcessTurnHazards_WithPerTurnDamage_AppliesDamage` | Turn damage |
| `ApplyHazardEffect_WithSave_RollsSave` | Save rolling |
| `ApplyHazardEffect_SuccessfulSave_HalvesDamage` | Save halves |
| `ApplyHazardEffect_SuccessfulSave_NegatesWhenConfigured` | Save negates |
| `ApplyHazardEffect_FailedSave_AppliesFullDamage` | Full damage on fail |
| `ProcessHazardTurnTicks_ExpiresTemporaryHazards` | Expiration processing |

---

## 10. Dependencies

### 10.1 Required Prior Work

| Dependency | Version | Status | Notes |
|------------|---------|--------|-------|
| Trap entity | v0.4.1a | Complete | Pattern reference |
| TrapEffect value object | v0.4.1b | Complete | Pattern reference |
| TrapService | v0.4.1a/b | Complete | Pattern reference |
| Room.Traps | v0.4.1a | Complete | Collection pattern |
| DiceService | v0.0.x | Complete | Damage/save rolls |
| StatusEffectService | v0.0.x | Complete | Status application |
| Player.TakeDamage | v0.0.x | Complete | Damage handling |
| Player.GetAttributeModifier | v0.0.x | Complete | Save modifiers |
| TurnProcessingService | v0.0.x | Complete | Turn integration |

### 10.2 External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Microsoft.Extensions.Logging | 9.0.x | Logging |
| System.Text.Json | 9.0.x | Configuration parsing |

---

## 11. Files Summary

### 11.1 New Files

| File | Purpose |
|------|---------|
| `Domain/Enums/HazardType.cs` | Hazard type enum |
| `Domain/Entities/HazardZone.cs` | Core hazard entity |
| `Domain/Definitions/HazardDefinition.cs` | Hazard configuration definition |
| `Domain/ValueObjects/SavingThrow.cs` | Saving throw value object |
| `Domain/ValueObjects/HazardEffectResult.cs` | Effect result value object |
| `Application/Interfaces/IHazardService.cs` | Service interface |
| `Application/Services/HazardService.cs` | Service implementation |
| `Configuration/schemas/hazards.schema.json` | JSON schema |
| `Configuration/hazards.json` | Hazard definitions |
| `Tests/HazardTypeTests.cs` | Type enum tests |
| `Tests/SavingThrowTests.cs` | Saving throw tests |
| `Tests/HazardZoneTests.cs` | Entity tests |
| `Tests/HazardServiceTests.cs` | Service tests |
| `Tests/RoomHazardTests.cs` | Room integration tests |

### 11.2 Modified Files

| File | Changes |
|------|---------|
| `Domain/Entities/Room.cs` | Add HazardZones collection and methods |
| `Application/Services/TurnProcessingService.cs` | Integrate hazard processing |
| `Application/Services/GameSessionService.cs` | Integrate hazard examination, entry hazards |
| `Infrastructure/DependencyInjection.cs` | Register HazardService |
| `Presentation/GameView.cs` | Display hazards in room descriptions |

---

## 12. Future Considerations

### 12.1 v0.4.2 Integration (Puzzles)

Environmental hazards can integrate with puzzles:
- Puzzle completion can deactivate hazards
- Levers/switches can toggle hazard states
- Correct paths through hazards as puzzle elements

### 12.2 v0.4.3 Integration (Light & Skills)

- Darkness hazard affects visibility
- Light sources can dispel darkness hazards
- Fire hazards provide light
- Skills can help avoid or mitigate hazards

### 12.3 Future Enhancements

- **Spreading Hazards**: Fire that spreads to adjacent rooms
- **Interacting Hazards**: Fire and ice cancel each other
- **Player-Created Hazards**: Spells or items that create hazards
- **NPC/Monster Hazard Interaction**: Monsters affected by hazards
- **Hazard Immunity**: Some creatures immune to certain hazard types

### 12.4 Integration Points

- **Combat System**: Hazard damage uses same damage pipeline
- **Status Effects**: Hazard effects use existing StatusEffectService
- **Save System**: Saving throws use attribute modifiers
- **Turn Processing**: Hazards processed each turn automatically

---

*This design specification completes the Traps & Environmental Hazards system by adding persistent area-based dangers with saving throw mechanics, enabling challenging rooms that require careful movement and strategic decisions.*
