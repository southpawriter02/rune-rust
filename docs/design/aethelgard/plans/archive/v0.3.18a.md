> **Archived** - This plan has been consolidated. See the complete version at [v0.3.18](../v0.3.x/v0.3.18.md).

# v0.3.18a: The Garbage Collector

This sub-version focuses on reducing Heap Allocations in the "Hot Paths" of the engine—specifically the Render Loop and Pathfinding—to prevent Garbage Collection stutters during long play sessions or high-speed simulations.

Goal: Implement object pooling for high-frequency objects and convert core math primitives to stack-allocated structs to reduce GC pressure.
1. Architecture & Data Flow
	•	Struct Promotion: Convert Coordinate from a record (reference type) to a readonly record struct (value type). This removes header overhead and allows arrays of Coordinates to be packed in memory, significantly speeding up the Dynamic Room Engine and Pathfinding [Source 1784].
	•	StringBuilder Pooling: Implement a singleton StringBuilderPool to manage text buffer reuse in CombatScreenRendererand LogFormatter.
	•	List Pooling: Implement ListPool<T> for temporary collections used in ViewModels (e.g., VisibleObjects lists in ExplorationViewModel), preventing valid lists from being discarded every frame.
Data Flow: The Zero-Alloc Render Logic
	1	Render Request: GameLoop triggers CombatScreenRenderer.
	2	Lease: Renderer requests a StringBuilder from the Pool.
	3	Build: Renderer formats the frame (thousands of operations).
	4	Output: String is sent to AnsiConsole.
	5	Return: StringBuilder is cleared and returned to the Pool.

2. Logic Decision Trees
A. Allocation Optimization Logic Input: Class/Record identified in Profiler
	1	Is it Immutable? (e.g., AttackResult record)
	◦	Yes: Cannot pool easily. Action: Optimize constructor, ensure it is short-lived (Gen 0 GC).
	2	Is it Mutable & Reusable? (e.g., StringBuilder, List<T>)
	◦	Yes: Action: Implement Object Pool.
	3	Is it Small & High Volume? (e.g., Coordinate)
	◦	Yes: Action: Convert to readonly record struct.
B. Pool Access Logic Input: Method needs temporary buffer
	1	Check Size: Is the estimated size < 512 chars?
	◦	Yes: Use Span<char> on the Stack (stackalloc) if possible (advanced).
	◦	No: Rent from StringBuilderPool.
	2	Post-Process:
	◦	Return: Call Return() in a finally block to ensure the pool doesn't leak.

3. Code Implementation
A. Coordinate Struct Refactor File: RuneAndRust.Core/ValueObjects/Coordinate.cs Refactor from Reference Type to Value Type for stack allocation.
namespace RuneAndRust.Core.ValueObjects;

// Changed from 'public record' to 'public readonly record struct'
// This change makes Coordinate a value type, removing heap allocation overhead.
public readonly record struct Coordinate(int X, int Y, int Z)
{
    public static Coordinate Origin => new(0, 0, 0);

    // Optimized offset using in-place values
    public Coordinate Offset(int x, int y, int z) => new(X + x, Y + y, Z + z);
}
B. StringBuilder Pool Service File: RuneAndRust.Engine/Performance/TextBufferPool.cs
using System.Text;
using Microsoft.Extensions.ObjectPool;

public class TextBufferPool
{
    private readonly ObjectPool<StringBuilder> _pool;

    public TextBufferPool()
    {
        var provider = new DefaultObjectPoolProvider();
        // Policy resets the builder (Clear) upon return
        _pool = provider.CreateStringBuilderPool();
    }

    public StringBuilder Get() => _pool.Get();

    public string GetStringAndReturn(StringBuilder sb)
    {
        var result = sb.ToString();
        _pool.Return(sb);
        return result;
    }
}
C. Render Integration Example File: RuneAndRust.Terminal/Rendering/CombatScreenRenderer.cs
public void Render(CombatViewModel vm)
{
    // Rent builder
    var sb = _textBufferPool.Get();

    try
    {
        // Build complex layout string
        sb.Append(RenderHeader(vm.PlayerStats));
        sb.Append(RenderTurnOrder(vm.TurnOrder));

        // Output
        AnsiConsole.Write(sb.ToString());
    }
    finally
    {
        // Ensure return even if render crashes
        _textBufferPool.Return(sb);
    }
}

4. Deliverable Checklist (v0.3.18a)
	•	Core:
	◦	[ ] Refactor Coordinate to readonly record struct.
	◦	[ ] Verify no regression in IRoomRepository caused by struct change (EF Core handles value types differently).
	•	Engine:
	◦	[ ] Add Microsoft.Extensions.ObjectPool NuGet package.
	◦	[ ] Implement TextBufferPool singleton.
	◦	[ ] Implement ListPool<T> helper.
	•	Terminal:
	◦	[ ] Inject TextBufferPool into CombatScreenRenderer.
	◦	[ ] Inject TextBufferPool into ExplorationScreenRenderer.
	◦	[ ] Replace string concatenation (+) with pooled builders in hot paths.
	•	Tests:
	◦	[ ] Verify Coordinate equality behavior remains consistent.
	◦	[ ] Verify Pooled objects are cleared (empty) when reused.

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Pool
Exhaustion
Warning
"[Perf] TextBufferPool limit reached, creating temporary instance."
-
Perf
Render
Verbose
"[Perf] RenderFrame allocated {Bytes} bytes."
Bytes
Note: Performance logging should generally be kept to Verbose/Trace to avoid creating allocation pressure via the logs themselves.

6. Testing Strategy
Unit Tests (PerformanceTests.cs):
	•	Pool_Resets_Content:
	◦	Get SB -> Append "Test" -> Return -> Get SB.
	◦	Assert: SB.Length is 0 (Clean).
	•	Struct_Equality:
	◦	Coord A (1,1,1) == Coord B (1,1,1).
	◦	Assert: True (Value equality preserved).
Benchmark (BenchmarkDotNet):
	•	Scenario: Coordinate_List_Memory.
	◦	Create List<Coordinate> (10,000 items).
	◦	Measure Heap Allocation (Should be near zero for Struct, High for Class).

7. Draft Changelog (v0.3.18a)
# Changelog: v0.3.18a - The Garbage Collector

**Release Date:** 2026-01-XX

## Summary
The first phase of the "Auditor" milestone focuses on memory optimization. By converting core spatial primitives to value types and implementing buffer pooling, we have significantly reduced the "Garbage Collection" pressure during long play sessions.

## Changes
- **Core:** Converted `Coordinate` from `record class` to `record struct`. This makes spatial data stack-allocated, drastically reducing heap fragmentation during dungeon generation.
- **Engine:** Implemented `TextBufferPool`. The render loop now reuses `StringBuilder` instances instead of allocating new strings every frame.
- **Terminal:** Refactored `CombatScreenRenderer` to use pooled buffers.
Would you like to proceed to v0.3.18b: The Hot Path (Pathfinding & AI)?
