# v0.3.14a: The Palette (Theme Standardization)

This milestone focuses on visual consistency and flow. It eliminates hardcoded styling to ensure the Theme System (v0.3.9b) works universally, and introduces screen transitions to reduce the jarring "snap" between game phases.
To manage the distinct tasks of refactoring versus new feature development, this version is split into two sub-versions:
	•	v0.3.14a: The Palette (Theme Standardization) – Auditing and refactoring all renderers to enforce semantic coloring.
	•	v0.3.14b: The Flow (Animations & Transitions) – Implementing visual transitions between game states.

Goal: Conduct a comprehensive audit of all Terminal Renderers to identify and replace hardcoded ANSI/Spectre colors with semantic lookups from IThemeService. Ensure high-contrast and colorblind modes function for 100% of the UI.
1. Architecture & Data Flow
The Standardization Pipeline
	1	Audit: Identify all instances of [red], Color.Red, or raw ANSI codes in the Terminal project.
	2	Definition: Map every hardcoded color to a Semantic Role (e.g., "red" -> "DangerColor" or "EnemyColor").
	3	Expansion: Update ThemeService default palettes to include missing roles.
	4	Refactor: Update Renderers to request colors dynamically.
2. Logic Decision Trees
A. Color Replacement Logic Input: Hardcoded Color usage found in code (e.g., "gold1")
	1	Analyze Context: What does this color represent?
	◦	Currency? -> Map to EconomyColor.
	◦	Highlight? -> Map to HighlightColor.
	◦	Border? -> Map to BorderColor.
	2	Check Service: Does IThemeService have this key?
	◦	No: Add key to ThemeType palettes (Standard, HighContrast, etc.).
	3	Refactor: Replace string literal with _themeService.GetColor("Key").
3. Deliverable Checklist
	•	Core:
	◦	[ ] Expand ThemeService definitions with new semantic keys: EconomyColor, HighlightColor, DimColor, InputColor, BorderActive, BorderInactive.
	•	Terminal:
	◦	[ ] Refactor ExplorationScreenRenderer (Remove hardcoded biome colors if not using helper).
	◦	[ ] Refactor InventoryScreenRenderer (Use BorderActive/BorderInactive for focus).
	◦	[ ] Refactor CraftingScreenRenderer (Standardize recipe availability colors).
	◦	[ ] Refactor JournalScreenRenderer (Standardize tab colors).
	•	Tests:
	◦	[ ] ThemeService_ReturnsValidColor_ForNewKeys: Verify new keys don't return fallback grey.
4. Code Implementation
A. Renderer Refactor Example File: RuneAndRust.Terminal/Rendering/InventoryScreenRenderer.cs
// BEFORE
var border = isFocused ? Color.Yellow : Color.Grey;

// AFTER
var borderRole = isFocused ? "BorderActive" : "BorderInactive";
var border = _themeService.GetColor(borderRole);
5. Testing Strategy
	•	Visual Regression Test:
	◦	Switch to "High Contrast" theme.
	◦	Navigate to Inventory, Crafting, and Journal.
	◦	Pass Condition: No "dim" colors (grey/dark blue) remain. All text is White/Yellow on Black.

v0.3.14b: The Flow (Animations & Transitions)
Goal: Implement the ScreenTransitionService to render ASCII visual effects (Wipes, Dissolves, Static) when switching Game Phases, smoothing the jarring context switch between Exploration and Combat.
1. Architecture & Data Flow
The Transition Pipeline
	1	Trigger: GameService detects a Phase change (e.g., Exploration -> Combat).
	2	Interception: Before calling the new Renderer, call TransitionService.PlayTransition(TransitionType.StaticNoise).
	3	Rendering:
	◦	AnsiConsole.Live starts.
	◦	Render Frame 0 (Current Screen).
	◦	Over 500ms, progressively replace characters with "Noise" characters (#, %, &).
	◦	Clear screen.
	4	Handoff: Control returns to GameService to render the new Phase.
2. Logic Decision Trees
A. Transition Selection Logic Input: OldPhase, NewPhase
	1	Exploration -> Combat: Play TransitionType.Shatter (Screen "cracks" and falls away).
	2	Combat -> Exploration (Victory): Play TransitionType.Dissolve (Fade to clear).
	3	Any -> Menu: Play TransitionType.SlideLeft.
	4	Settings Check:
	◦	Is GameSettings.ReduceMotion true?
	◦	Yes: Skip animation. Clear screen instantly.
3. Deliverable Checklist
	•	Core:
	◦	[ ] Define TransitionType enum.
	◦	[ ] Define ITransitionService interface.
	•	Terminal:
	◦	[ ] Implement ScreenTransitionService using AnsiConsole.Live.
	◦	[ ] Create ShatterEffect logic (randomly removing characters).
	◦	[ ] Create StaticEffect logic (replacing chars with random symbols).
	•	Engine:
	◦	[ ] Update GameService to await PlayTransition on phase change.
4. Code Implementation
A. Transition Service File: RuneAndRust.Terminal/Services/ScreenTransitionService.cs
public async Task PlayTransitionAsync(TransitionType type)
{
    if (GameSettings.ReduceMotion) {
        AnsiConsole.Clear();
        return;
    }

    // Capture current screen buffer (simulated) or generate noise
    await AnsiConsole.Live(new Text("")).StartAsync(async ctx =>
    {
        for(int i=0; i < 10; i++)
        {
            var frame = GenerateNoiseFrame(intensity: i * 10);
            ctx.UpdateTarget(frame);
            await Task.Delay(50);
        }
    });

    AnsiConsole.Clear();
}
5. Logging Requirements
System
Event
Level
Message Template
Properties
Transition
Start
Trace
"[VFX] Starting transition: {Type}"
Type
Transition
Skip
Trace
"[VFX] Transition skipped (ReduceMotion)"
-
6. Testing Strategy
	•	Unit Tests:
	◦	PlayTransition_ReduceMotionEnabled_DoesNotRender: Verify logic skip.
	•	Manual QA:
	◦	Enter Combat. Verify "Shatter" effect plays.
	◦	Enable Reduce Motion. Enter Combat. Verify instant switch.

Draft Changelog (v0.3.14)
# v0.3.14 Changelog: The Experience
**Release Date:** 2026-02-10

## Summary
This release focuses on "Juice" and consistency. We have standardized the color palette across the entire application to fully support High Contrast and Colorblind themes, and added visual transitions between game states to reduce cognitive load during context switches.

## New Features
*   **Screen Transitions:** Added "Shatter" and "Dissolve" ASCII animations when entering/exiting combat.
*   **Full Theme Support:** Every UI element now respects the selected Color Theme (Standard, High Contrast, Protanopia, etc.).

## Technical Changes
*   Refactored all Renderers to use `IThemeService`.
*   Implemented `ScreenTransitionService` with `AnsiConsole.Live`.