# v0.5.3 Tactical Positioning - Scope Breakdown

**Version:** 0.5.3
**Theme:** Tactical Positioning
**Prerequisites:** v0.5.2 Complete (Terrain & Cover)
**Total Estimated Tests:** ~90 new tests

---

## Executive Summary

The Tactical Positioning version introduces advanced positioning mechanics that reward strategic movement and punish careless positioning. Flanking provides attack bonuses when allies coordinate attacks from opposite sides. Opportunity attacks trigger when enemies leave threatened squares without disengaging. Area effects allow spells and abilities to target multiple grid cells with configurable shapes. This version leverages the full grid infrastructure from v0.5.0-v0.5.2.

Key focus areas:
- **Flanking System**: Facing direction and flanking bonuses for coordinated attacks
- **Opportunity Attacks**: Threatened squares and reactions to enemy movement
- **Area Effects**: Multi-cell targeting with circle, cone, line, and square shapes
- **Tactical Integration**: Full combat system integration with all positioning mechanics

The work is divided into **three sub-phases**:

| Phase | Name | Focus | Est. Tests |
|-------|------|-------|------------|
| v0.5.3a | Flanking System | FacingDirection, flanking detection, flanking bonuses | ~30 |
| v0.5.3b | Opportunity Attacks | Threatened squares, disengage action, reaction attacks | ~30 |
| v0.5.3c | Area Effects | AoE shapes, targeting, resolution, display | ~30 |

---

## Existing Infrastructure

### Already Implemented (from v0.5.2)

| Feature | Location | Notes |
|---------|----------|-------|
| TerrainService | `Application/Services/TerrainService.cs` | Terrain calculations |
| CoverService | `Application/Services/CoverService.cs` | Cover calculations |
| TerrainType enum | `Domain/Enums/TerrainType.cs` | Terrain categories |
| CoverType enum | `Domain/Enums/CoverType.cs` | Cover categories |
| CoverObject | `Domain/Entities/CoverObject.cs` | Cover on grid |

### Already Implemented (from v0.5.1)

| Feature | Location | Notes |
|---------|----------|-------|
| RangeService | `Application/Services/RangeService.cs` | Range validation |
| LineOfSightService | `Application/Services/LineOfSightService.cs` | LOS calculations |
| RangeType enum | `Domain/Enums/RangeType.cs` | Melee/Ranged/Reach |
| GetLineCells | `LineOfSightService` | Bresenham cells |

### Already Implemented (from v0.5.0)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatGrid | `Domain/Entities/CombatGrid.cs` | Grid management |
| GridPosition | `Domain/ValueObjects/GridPosition.cs` | X,Y coordinates |
| GridCell | `Domain/ValueObjects/GridCell.cs` | Cell state |
| MovementService | `Application/Services/MovementService.cs` | Movement system |
| CombatGridService | `Application/Services/CombatGridService.cs` | Grid operations |
| GridRenderer | `Presentation/Adapters/GridRenderer.cs` | ASCII display |
| GetAdjacentCells | `CombatGrid` | Adjacent cell lookup |
| DistanceTo | `GridPosition` | Chebyshev distance |

### Already Implemented (from prior versions)

| Feature | Location | Notes |
|---------|----------|-------|
| CombatService | `Application/Services/CombatService.cs` | Combat processing |
| AbilityDefinition | `Domain/Definitions/AbilityDefinition.cs` | Ability config |
| AbilityService | `Application/Services/AbilityService.cs` | Ability execution |
| Monster entities | `Domain/Entities/Monster.cs` | Monster combatants |
| Player entity | `Domain/Entities/Player.cs` | Player combatant |
| DiceService | `Application/Services/DiceService.cs` | Dice rolling |

### Needs Implementation (v0.5.3)

| Feature | Phase | Notes |
|---------|-------|-------|
| FacingDirection enum | v0.5.3a | N, NE, E, SE, S, SW, W, NW |
| Entity facing | v0.5.3a | Direction creatures face |
| FlankingService | v0.5.3a | Flanking calculations |
| Flanking bonus | v0.5.3a | Attack/damage bonus |
| ThreatService | v0.5.3b | Threatened square tracking |
| Opportunity attacks | v0.5.3b | Reaction attacks on movement |
| Disengage action | v0.5.3b | Move without triggering |
| AreaEffectShape enum | v0.5.3c | Circle, Cone, Line, Square |
| AreaEffect value object | v0.5.3c | Shape and radius |
| AreaEffectService | v0.5.3c | AoE targeting/resolution |
| AoE on abilities | v0.5.3c | AbilityDefinition.AreaEffect |

---

## Feature Analysis & Categorization

### Flanking Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| FacingDirection enum | Low | None | **v0.5.3a** |
| Creature facing property | Medium | GridPosition | **v0.5.3a** |
| Auto-face on attack | Medium | CombatService | **v0.5.3a** |
| IFlankingService interface | Low | None | **v0.5.3a** |
| FlankingService | High | GridPosition, facing | **v0.5.3a** |
| Flanking detection | High | Adjacent positions | **v0.5.3a** |
| Flanking bonus (configurable) | Medium | FlankingService | **v0.5.3a** |
| Flanking display | Medium | GridRenderer | **v0.5.3a** |

### Opportunity Attack Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| IThreatService interface | Low | None | **v0.5.3b** |
| ThreatService | High | GridPosition, melee range | **v0.5.3b** |
| Threatened squares | Medium | Adjacent cells, weapons | **v0.5.3b** |
| Threat tracking | High | Monster positions | **v0.5.3b** |
| Opportunity attack trigger | High | MovementService | **v0.5.3b** |
| Reaction system | Medium | Turn tracking | **v0.5.3b** |
| Disengage action | Medium | CommandHandler | **v0.5.3b** |
| Threat display | Medium | GridRenderer | **v0.5.3b** |

### Area Effect Features

| Feature | Complexity | Dependencies | Assigned Phase |
|---------|------------|--------------|----------------|
| AreaEffectShape enum | Low | None | **v0.5.3c** |
| AreaEffect value object | Medium | GridPosition | **v0.5.3c** |
| IAreaEffectService interface | Low | None | **v0.5.3c** |
| AreaEffectService | High | Grid, LOS | **v0.5.3c** |
| Circle shape | Medium | Distance calculation | **v0.5.3c** |
| Cone shape | High | Direction, angle | **v0.5.3c** |
| Line shape | Medium | Bresenham's | **v0.5.3c** |
| Square shape | Low | Bounding positions | **v0.5.3c** |
| AoE targeting UI | High | CommandHandler | **v0.5.3c** |
| AoE display | Medium | GridRenderer | **v0.5.3c** |
| AbilityDefinition.AreaEffect | Medium | Configuration | **v0.5.3c** |

---

## Phase Definitions

---

## v0.5.3a: Flanking System

[v0.5.3a Design Specification](v0.5.3a-design-specification.md)

### Overview

Establish the flanking system including facing direction, flanking detection, and configurable flanking bonuses. Creatures have a facing direction that updates when they attack. Flanking is achieved when two allies are on opposite sides of an enemy.

### Scope

**In Scope:**
- `FacingDirection` enum (N, NE, E, SE, S, SW, W, NW)
- Creature facing property (Player and Monster)
- Auto-face toward target on attack
- `IFlankingService` interface
- `FlankingService` for flanking calculations
- Flanking detection (opposite sides)
- Configurable flanking bonus (attack/damage)
- Flanking configuration in JSON
- Flanking indicator in grid display
- Combat message for flanking bonus

**Out of Scope:**
- Opportunity attacks (v0.5.3b)
- Area effects (v0.5.3c)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Enums | 1 | `FacingDirection` |
| Domain Entity Updates | 2 | Player.Facing, Monster.Facing |
| Application Interfaces | 1 | `IFlankingService` |
| Application Services | 1 | `FlankingService` |
| CombatService Updates | 1 | Flanking bonus in attack |
| Configuration | 1 | `combat.json` (flanking section) |
| Unit Tests | ~30 | Facing, flanking detection tests |

### FacingDirection Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Cardinal and ordinal directions for creature facing.
/// </summary>
public enum FacingDirection
{
    /// <summary>
    /// North (up on grid, decreasing Y).
    /// </summary>
    North,

    /// <summary>
    /// Northeast (up-right on grid).
    /// </summary>
    NorthEast,

    /// <summary>
    /// East (right on grid, increasing X).
    /// </summary>
    East,

    /// <summary>
    /// Southeast (down-right on grid).
    /// </summary>
    SouthEast,

    /// <summary>
    /// South (down on grid, increasing Y).
    /// </summary>
    South,

    /// <summary>
    /// Southwest (down-left on grid).
    /// </summary>
    SouthWest,

    /// <summary>
    /// West (left on grid, decreasing X).
    /// </summary>
    West,

    /// <summary>
    /// Northwest (up-left on grid).
    /// </summary>
    NorthWest
}
```

### FacingDirection Extensions

```csharp
namespace RuneAndRust.Domain.Extensions;

/// <summary>
/// Extension methods for FacingDirection.
/// </summary>
public static class FacingDirectionExtensions
{
    /// <summary>
    /// Gets the opposite direction.
    /// </summary>
    public static FacingDirection GetOpposite(this FacingDirection direction)
    {
        return direction switch
        {
            FacingDirection.North => FacingDirection.South,
            FacingDirection.NorthEast => FacingDirection.SouthWest,
            FacingDirection.East => FacingDirection.West,
            FacingDirection.SouthEast => FacingDirection.NorthWest,
            FacingDirection.South => FacingDirection.North,
            FacingDirection.SouthWest => FacingDirection.NorthEast,
            FacingDirection.West => FacingDirection.East,
            FacingDirection.NorthWest => FacingDirection.SouthEast,
            _ => FacingDirection.North
        };
    }

    /// <summary>
    /// Gets the direction from one position to another.
    /// </summary>
    public static FacingDirection GetDirectionTo(GridPosition from, GridPosition to)
    {
        var dx = to.X - from.X;
        var dy = to.Y - from.Y;

        // Normalize to -1, 0, 1
        var nx = dx == 0 ? 0 : dx / Math.Abs(dx);
        var ny = dy == 0 ? 0 : dy / Math.Abs(dy);

        return (nx, ny) switch
        {
            (0, -1) => FacingDirection.North,
            (1, -1) => FacingDirection.NorthEast,
            (1, 0) => FacingDirection.East,
            (1, 1) => FacingDirection.SouthEast,
            (0, 1) => FacingDirection.South,
            (-1, 1) => FacingDirection.SouthWest,
            (-1, 0) => FacingDirection.West,
            (-1, -1) => FacingDirection.NorthWest,
            _ => FacingDirection.North
        };
    }

    /// <summary>
    /// Checks if two directions are opposite.
    /// </summary>
    public static bool IsOpposite(this FacingDirection direction, FacingDirection other)
    {
        return direction.GetOpposite() == other;
    }

    /// <summary>
    /// Checks if a direction is adjacent (within 45 degrees).
    /// </summary>
    public static bool IsAdjacent(this FacingDirection direction, FacingDirection other)
    {
        var diff = Math.Abs((int)direction - (int)other);
        return diff == 1 || diff == 7; // Wrap around for N/NW
    }

    /// <summary>
    /// Checks if a position is behind another position relative to facing.
    /// </summary>
    public static bool IsBehind(GridPosition attacker, GridPosition target, FacingDirection targetFacing)
    {
        var attackDirection = GetDirectionTo(target, attacker);
        return attackDirection.IsOpposite(targetFacing);
    }

    /// <summary>
    /// Checks if a position is to the side of another position relative to facing.
    /// </summary>
    public static bool IsSide(GridPosition attacker, GridPosition target, FacingDirection targetFacing)
    {
        var attackDirection = GetDirectionTo(target, attacker);
        var opposite = targetFacing.GetOpposite();

        // Side is perpendicular to facing (90 degrees)
        var facing = (int)targetFacing;
        var attack = (int)attackDirection;

        var diff = Math.Abs(facing - attack);
        return diff == 2 || diff == 6; // 90 degrees on either side
    }
}
```

### Entity Facing Modifications

```
MODIFY: Player
├── ADD: Facing: FacingDirection (default: South)
├── ADD: SetFacing(FacingDirection): void
└── ADD: FaceToward(GridPosition): void

MODIFY: Monster
├── ADD: Facing: FacingDirection (default: North)
├── ADD: SetFacing(FacingDirection): void
└── ADD: FaceToward(GridPosition): void

MODIFY: CombatGrid
├── ADD: GetEntityFacing(Guid): FacingDirection?
├── ADD: SetEntityFacing(Guid, FacingDirection): void
└── ADD: FaceEntityToward(Guid, GridPosition): void
```

### IFlankingService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for flanking calculations.
/// </summary>
public interface IFlankingService
{
    /// <summary>
    /// Checks if an attacker is flanking a target.
    /// </summary>
    FlankingResult CheckFlanking(Guid attackerId, Guid targetId);

    /// <summary>
    /// Checks if an attacker at a position is flanking a target.
    /// </summary>
    FlankingResult CheckFlanking(
        GridPosition attackerPosition,
        GridPosition targetPosition,
        FacingDirection targetFacing,
        IEnumerable<GridPosition> allyPositions);

    /// <summary>
    /// Gets the flanking bonus for an attack.
    /// </summary>
    int GetFlankingAttackBonus(Guid attackerId, Guid targetId);

    /// <summary>
    /// Gets the flanking damage bonus for an attack.
    /// </summary>
    int GetFlankingDamageBonus(Guid attackerId, Guid targetId);

    /// <summary>
    /// Gets all positions that would provide flanking against a target.
    /// </summary>
    IEnumerable<GridPosition> GetFlankingPositions(Guid targetId);

    /// <summary>
    /// Gets positions where allies are providing flanking.
    /// </summary>
    IEnumerable<GridPosition> GetAllyFlankingPositions(Guid attackerId, Guid targetId);

    /// <summary>
    /// Checks if attacking from behind (bonus damage).
    /// </summary>
    bool IsAttackingFromBehind(Guid attackerId, Guid targetId);

    /// <summary>
    /// Checks if attacking from the side.
    /// </summary>
    bool IsAttackingFromSide(Guid attackerId, Guid targetId);
}

/// <summary>
/// Result of a flanking check.
/// </summary>
public readonly record struct FlankingResult
{
    /// <summary>
    /// Gets whether flanking is occurring.
    /// </summary>
    public bool IsFlanking { get; init; }

    /// <summary>
    /// Gets the type of flanking (none, side, behind).
    /// </summary>
    public FlankingType FlankingType { get; init; }

    /// <summary>
    /// Gets the attack bonus from flanking.
    /// </summary>
    public int AttackBonus { get; init; }

    /// <summary>
    /// Gets the damage bonus from flanking.
    /// </summary>
    public int DamageBonus { get; init; }

    /// <summary>
    /// Gets the ally providing the flank.
    /// </summary>
    public Guid? FlankingAllyId { get; init; }

    /// <summary>
    /// Gets a message describing the flanking.
    /// </summary>
    public string Message { get; init; }
}

/// <summary>
/// Types of flanking positions.
/// </summary>
public enum FlankingType
{
    /// <summary>
    /// No flanking advantage.
    /// </summary>
    None,

    /// <summary>
    /// Attacking from the side.
    /// </summary>
    Side,

    /// <summary>
    /// Attacking from behind.
    /// </summary>
    Behind,

    /// <summary>
    /// Full flank with ally on opposite side.
    /// </summary>
    Flanked
}
```

### FlankingService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for flanking calculations.
/// </summary>
public class FlankingService : IFlankingService
{
    private readonly ICombatGridService _gridService;
    private readonly ICombatStateService _combatStateService;
    private readonly IConfigurationProvider _configProvider;
    private readonly ILogger<FlankingService> _logger;

    // Configuration values
    private int _flankingAttackBonus = 2;
    private int _flankingDamageBonus = 0;
    private int _behindAttackBonus = 2;
    private int _behindDamageBonus = 2;

    public FlankingService(
        ICombatGridService gridService,
        ICombatStateService combatStateService,
        IConfigurationProvider configProvider,
        ILogger<FlankingService> logger)
    {
        _gridService = gridService;
        _combatStateService = combatStateService;
        _configProvider = configProvider;
        _logger = logger;

        LoadConfiguration();
    }

    private void LoadConfiguration()
    {
        var combatConfig = _configProvider.GetCombatConfiguration();
        if (combatConfig?.Flanking != null)
        {
            _flankingAttackBonus = combatConfig.Flanking.AttackBonus;
            _flankingDamageBonus = combatConfig.Flanking.DamageBonus;
            _behindAttackBonus = combatConfig.Flanking.BehindAttackBonus;
            _behindDamageBonus = combatConfig.Flanking.BehindDamageBonus;
        }
    }

    /// <inheritdoc />
    public FlankingResult CheckFlanking(Guid attackerId, Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
        {
            return new FlankingResult
            {
                IsFlanking = false,
                FlankingType = FlankingType.None,
                Message = "No active grid."
            };
        }

        var attackerPos = grid.GetEntityPosition(attackerId);
        var targetPos = grid.GetEntityPosition(targetId);

        if (!attackerPos.HasValue || !targetPos.HasValue)
        {
            return new FlankingResult
            {
                IsFlanking = false,
                FlankingType = FlankingType.None,
                Message = "Entity not on grid."
            };
        }

        // Must be adjacent (melee range) for flanking
        if (attackerPos.Value.DistanceTo(targetPos.Value) > 1)
        {
            return new FlankingResult
            {
                IsFlanking = false,
                FlankingType = FlankingType.None,
                Message = "Must be adjacent to flank."
            };
        }

        var targetFacing = grid.GetEntityFacing(targetId) ?? FacingDirection.North;
        var allyPositions = GetAlliedPositions(attackerId, grid);

        return CheckFlanking(attackerPos.Value, targetPos.Value, targetFacing, allyPositions);
    }

    /// <inheritdoc />
    public FlankingResult CheckFlanking(
        GridPosition attackerPosition,
        GridPosition targetPosition,
        FacingDirection targetFacing,
        IEnumerable<GridPosition> allyPositions)
    {
        // Check for ally on opposite side (true flanking)
        var oppositeDir = FacingDirectionExtensions.GetDirectionTo(targetPosition, attackerPosition).GetOpposite();
        var flankedByAlly = false;
        Guid? flankingAlly = null;

        foreach (var allyPos in allyPositions)
        {
            if (allyPos.DistanceTo(targetPosition) != 1)
                continue; // Must be adjacent

            var allyDir = FacingDirectionExtensions.GetDirectionTo(targetPosition, allyPos);

            // Check if ally is on opposite side from attacker
            if (allyDir.IsOpposite(FacingDirectionExtensions.GetDirectionTo(targetPosition, attackerPosition)))
            {
                flankedByAlly = true;
                break;
            }
        }

        // Check if attacking from behind
        var isBehind = FacingDirectionExtensions.IsBehind(attackerPosition, targetPosition, targetFacing);

        // Check if attacking from side
        var isSide = FacingDirectionExtensions.IsSide(attackerPosition, targetPosition, targetFacing);

        // Determine flanking result
        if (flankedByAlly)
        {
            return new FlankingResult
            {
                IsFlanking = true,
                FlankingType = FlankingType.Flanked,
                AttackBonus = _flankingAttackBonus,
                DamageBonus = _flankingDamageBonus,
                FlankingAllyId = flankingAlly,
                Message = $"Flanking! (+{_flankingAttackBonus} attack)"
            };
        }

        if (isBehind)
        {
            return new FlankingResult
            {
                IsFlanking = true,
                FlankingType = FlankingType.Behind,
                AttackBonus = _behindAttackBonus,
                DamageBonus = _behindDamageBonus,
                Message = $"Attacking from behind! (+{_behindAttackBonus} attack, +{_behindDamageBonus} damage)"
            };
        }

        if (isSide)
        {
            return new FlankingResult
            {
                IsFlanking = false,
                FlankingType = FlankingType.Side,
                AttackBonus = 0,
                DamageBonus = 0,
                Message = "Attacking from the side."
            };
        }

        return new FlankingResult
        {
            IsFlanking = false,
            FlankingType = FlankingType.None,
            AttackBonus = 0,
            DamageBonus = 0,
            Message = "No flanking advantage."
        };
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetFlankingPositions(Guid targetId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        var targetPos = grid.GetEntityPosition(targetId);
        if (!targetPos.HasValue)
            yield break;

        // Return all adjacent cells that could provide flanking
        foreach (var cell in grid.GetAdjacentCells(targetPos.Value))
        {
            if (!cell.IsOccupied && cell.IsPassable)
            {
                yield return cell.Position;
            }
        }
    }

    private IEnumerable<GridPosition> GetAlliedPositions(Guid attackerId, CombatGrid grid)
    {
        var combatState = _combatStateService.GetCurrentCombat();
        if (combatState == null)
            yield break;

        var attacker = combatState.GetCombatant(attackerId);
        if (attacker == null)
            yield break;

        // Get positions of all allies (same faction)
        foreach (var combatant in combatState.Combatants)
        {
            if (combatant.Id == attackerId)
                continue;

            // Same faction = ally (both players or both monsters)
            if (combatant.IsPlayer == attacker.IsPlayer)
            {
                var pos = grid.GetEntityPosition(combatant.Id);
                if (pos.HasValue)
                    yield return pos.Value;
            }
        }
    }

    // ... other methods ...
}
```

### CombatService Flanking Integration

```csharp
// Update CombatService attack calculation:

public AttackResult ProcessAttack(Guid attackerId, Guid targetId, Item weapon)
{
    // ... existing attack logic ...

    // Get cover bonus (from v0.5.2)
    var coverResult = _coverService.GetCoverBetween(attackerId, targetId);

    // Get flanking bonus
    var flankingResult = _flankingService.CheckFlanking(attackerId, targetId);

    // Auto-face toward target after attack
    var grid = _gridService.GetActiveGrid();
    grid?.FaceEntityToward(attackerId, targetPosition);

    // Apply modifiers
    var attackModifier = weapon.AttackBonus + flankingResult.AttackBonus;
    var targetDefense = target.Defense + coverResult.DefenseBonus;

    // Roll attack
    var roll = _diceService.Roll(weapon.AttackDice);
    var total = roll.Total + attackModifier;

    var hit = total >= targetDefense;

    // Apply flanking damage bonus on hit
    var damage = 0;
    if (hit)
    {
        var damageRoll = _diceService.Roll(weapon.DamageDice);
        damage = damageRoll.Total + weapon.DamageBonus + flankingResult.DamageBonus;
    }

    // Build result message
    var message = new StringBuilder();
    if (flankingResult.IsFlanking)
    {
        message.AppendLine($"[Flanking: {flankingResult.Message}]");
    }
    if (coverResult.DefenseBonus > 0)
    {
        message.AppendLine($"[Cover: +{coverResult.DefenseBonus} defense]");
    }

    // ... rest of attack ...
}
```

### User-Facing Changes

**Flanking Attack:**
```
> attack goblin

You strike the Goblin with your Iron Sword!

[Flanking: Your ally is on the opposite side! (+2 attack)]
[Attack Roll: 2d6 + 3 + 2 (flank) = 14 vs AC 11]
Hit! 8 damage to Goblin.

The Goblin turns to face you.
```

**Attacking From Behind:**
```
> attack skeleton

You sneak up behind the Skeleton with your Dagger!

[Backstab: Attacking from behind! (+2 attack, +2 damage)]
[Attack Roll: 2d6 + 4 + 2 (behind) = 15 vs AC 10]
Hit! 9 damage (5 + 2 + 2 backstab) to Skeleton.
```

**Grid with Facing Indicators:**
```
Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . . . . .
2 . . M↓. . . . .     @ = You (facing: S)
3 . A→. . . M←. .     M = Monster (arrows show facing)
4 . . . @↓. . . .     A = Ally
5 . . . . . . . .     ↑↓←→ = Facing direction

Flanking Opportunity:
  Move to D2 to flank Skeleton at C2 with Ally at B3

You (D4) | HP: 25/30 | Move: 4/4
```

### Configuration Example

```json
{
  "$schema": "../schemas/combat.schema.json",
  "flanking": {
    "enabled": true,
    "attackBonus": 2,
    "damageBonus": 0,
    "behindAttackBonus": 2,
    "behindDamageBonus": 2,
    "requiresAlly": true,
    "allyMustBeAdjacent": true,
    "description": "Flanking provides +2 attack when ally is on opposite side"
  }
}
```

### Acceptance Criteria

- [ ] FacingDirection enum has all 8 directions
- [ ] Player and Monster have Facing property
- [ ] Creatures auto-face toward attack target
- [ ] Flanking detected when ally on opposite side
- [ ] Flanking provides +2 attack bonus (configurable)
- [ ] Attacking from behind provides bonus damage
- [ ] FlankingService calculates flanking correctly
- [ ] Grid display shows facing indicators
- [ ] Combat messages show flanking bonuses
- [ ] Flanking configuration loads from JSON
- [ ] ~30 unit tests pass

---

## v0.5.3b: Opportunity Attacks

[v0.5.3b Design Specification](v0.5.3b-design-specification.md)

### Overview

Implement the opportunity attack system including threatened squares, reaction tracking, and the disengage action. Creatures with melee weapons threaten adjacent squares. Moving out of a threatened square triggers an opportunity attack. The disengage action allows safe movement without triggering attacks.

### Scope

**In Scope:**
- `IThreatService` interface
- `ThreatService` for threat calculations
- Threatened square tracking
- Opportunity attack triggers
- Reaction system (one reaction per round)
- Reaction reset on turn start
- `DisengageCommand` to avoid opportunity attacks
- Threat display on grid
- Opportunity attack execution
- Configuration for opportunity attacks

**Out of Scope:**
- Area effects (v0.5.3c)
- Reach weapons extending threat (simplification)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Application Interfaces | 1 | `IThreatService` |
| Application Services | 1 | `ThreatService` |
| Combat State Updates | 1 | ReactionUsed tracking |
| Movement Service Updates | 1 | Opportunity attack checks |
| Commands | 1 | `DisengageCommand` |
| Configuration | 1 | `combat.json` (opportunity attacks) |
| Unit Tests | ~30 | Threat, reaction tests |

### IThreatService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for tracking threatened squares and opportunity attacks.
/// </summary>
public interface IThreatService
{
    /// <summary>
    /// Gets all squares threatened by an entity.
    /// </summary>
    IEnumerable<GridPosition> GetThreatenedSquares(Guid entityId);

    /// <summary>
    /// Gets all entities threatening a position.
    /// </summary>
    IEnumerable<Guid> GetThreateningEntities(GridPosition position);

    /// <summary>
    /// Checks if a position is threatened by enemies of an entity.
    /// </summary>
    bool IsPositionThreatened(GridPosition position, Guid movingEntityId);

    /// <summary>
    /// Checks if moving from one position to another triggers opportunity attacks.
    /// </summary>
    OpportunityAttackCheckResult CheckOpportunityAttacks(
        Guid movingEntityId,
        GridPosition from,
        GridPosition to);

    /// <summary>
    /// Executes opportunity attacks against a moving entity.
    /// </summary>
    IEnumerable<OpportunityAttackResult> ExecuteOpportunityAttacks(
        Guid movingEntityId,
        GridPosition from,
        GridPosition to);

    /// <summary>
    /// Checks if an entity has used their reaction this round.
    /// </summary>
    bool HasUsedReaction(Guid entityId);

    /// <summary>
    /// Marks an entity as having used their reaction.
    /// </summary>
    void UseReaction(Guid entityId);

    /// <summary>
    /// Resets all reactions for a new round.
    /// </summary>
    void ResetReactions();

    /// <summary>
    /// Checks if an entity is disengaging this turn.
    /// </summary>
    bool IsDisengaging(Guid entityId);

    /// <summary>
    /// Marks an entity as disengaging for this turn.
    /// </summary>
    void SetDisengaging(Guid entityId);

    /// <summary>
    /// Clears disengage status at end of turn.
    /// </summary>
    void ClearDisengaging(Guid entityId);
}

/// <summary>
/// Result of checking for opportunity attacks.
/// </summary>
public readonly record struct OpportunityAttackCheckResult
{
    /// <summary>
    /// Gets whether any opportunity attacks would trigger.
    /// </summary>
    public bool TriggersOpportunityAttacks { get; init; }

    /// <summary>
    /// Gets the entities that would make opportunity attacks.
    /// </summary>
    public IReadOnlyList<Guid> AttackingEntities { get; init; }

    /// <summary>
    /// Gets whether the entity is disengaging (no attacks trigger).
    /// </summary>
    public bool IsDisengaging { get; init; }

    /// <summary>
    /// Gets a warning message about opportunity attacks.
    /// </summary>
    public string Message { get; init; }
}

/// <summary>
/// Result of an executed opportunity attack.
/// </summary>
public readonly record struct OpportunityAttackResult
{
    /// <summary>
    /// Gets the attacking entity.
    /// </summary>
    public Guid AttackerId { get; init; }

    /// <summary>
    /// Gets the attacker name.
    /// </summary>
    public string AttackerName { get; init; }

    /// <summary>
    /// Gets whether the attack hit.
    /// </summary>
    public bool Hit { get; init; }

    /// <summary>
    /// Gets the damage dealt.
    /// </summary>
    public int Damage { get; init; }

    /// <summary>
    /// Gets the attack roll details.
    /// </summary>
    public string AttackRoll { get; init; }

    /// <summary>
    /// Gets the result message.
    /// </summary>
    public string Message { get; init; }
}
```

### ThreatService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for tracking threatened squares and opportunity attacks.
/// </summary>
public class ThreatService : IThreatService
{
    private readonly ICombatGridService _gridService;
    private readonly ICombatStateService _combatStateService;
    private readonly ICombatService _combatService;
    private readonly ILogger<ThreatService> _logger;

    private readonly HashSet<Guid> _usedReactions = new();
    private readonly HashSet<Guid> _disengaging = new();

    public ThreatService(
        ICombatGridService gridService,
        ICombatStateService combatStateService,
        ICombatService combatService,
        ILogger<ThreatService> logger)
    {
        _gridService = gridService;
        _combatStateService = combatStateService;
        _combatService = combatService;
        _logger = logger;
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetThreatenedSquares(Guid entityId)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        var position = grid.GetEntityPosition(entityId);
        if (!position.HasValue)
            yield break;

        // Check if entity has melee weapon equipped
        var combatant = _combatStateService.GetCombatant(entityId);
        if (combatant == null || !HasMeleeWeapon(combatant))
            yield break;

        // Threaten all adjacent squares
        foreach (var cell in grid.GetAdjacentCells(position.Value))
        {
            yield return cell.Position;
        }
    }

    /// <inheritdoc />
    public IEnumerable<Guid> GetThreateningEntities(GridPosition position)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        // Check all adjacent cells for enemies with melee weapons
        foreach (var cell in grid.GetAdjacentCells(position))
        {
            if (cell.OccupantId.HasValue)
            {
                var occupant = _combatStateService.GetCombatant(cell.OccupantId.Value);
                if (occupant != null && HasMeleeWeapon(occupant))
                {
                    yield return cell.OccupantId.Value;
                }
            }
        }
    }

    /// <inheritdoc />
    public bool IsPositionThreatened(GridPosition position, Guid movingEntityId)
    {
        var movingCombatant = _combatStateService.GetCombatant(movingEntityId);
        if (movingCombatant == null)
            return false;

        foreach (var threateningId in GetThreateningEntities(position))
        {
            var threatening = _combatStateService.GetCombatant(threateningId);
            if (threatening != null && threatening.IsPlayer != movingCombatant.IsPlayer)
            {
                return true; // Threatened by enemy
            }
        }

        return false;
    }

    /// <inheritdoc />
    public OpportunityAttackCheckResult CheckOpportunityAttacks(
        Guid movingEntityId,
        GridPosition from,
        GridPosition to)
    {
        // Check if disengaging
        if (IsDisengaging(movingEntityId))
        {
            return new OpportunityAttackCheckResult
            {
                TriggersOpportunityAttacks = false,
                IsDisengaging = true,
                AttackingEntities = Array.Empty<Guid>(),
                Message = "You are disengaging - no opportunity attacks."
            };
        }

        var movingCombatant = _combatStateService.GetCombatant(movingEntityId);
        if (movingCombatant == null)
        {
            return new OpportunityAttackCheckResult
            {
                TriggersOpportunityAttacks = false,
                AttackingEntities = Array.Empty<Guid>(),
                Message = "Entity not found."
            };
        }

        var attackers = new List<Guid>();

        // Check which enemies were threatening the 'from' position
        foreach (var threateningId in GetThreateningEntities(from))
        {
            var threatening = _combatStateService.GetCombatant(threateningId);
            if (threatening == null)
                continue;

            // Must be enemy
            if (threatening.IsPlayer == movingCombatant.IsPlayer)
                continue;

            // Must not have used reaction
            if (HasUsedReaction(threateningId))
                continue;

            // Check if 'to' position is still adjacent to threatening entity
            var grid = _gridService.GetActiveGrid();
            var threatenerPos = grid?.GetEntityPosition(threateningId);
            if (threatenerPos.HasValue && to.DistanceTo(threatenerPos.Value) <= 1)
            {
                // Still adjacent, no opportunity attack
                continue;
            }

            // Moving out of threat range - opportunity attack!
            attackers.Add(threateningId);
        }

        if (attackers.Count == 0)
        {
            return new OpportunityAttackCheckResult
            {
                TriggersOpportunityAttacks = false,
                AttackingEntities = Array.Empty<Guid>(),
                Message = "No opportunity attacks triggered."
            };
        }

        var names = attackers
            .Select(id => _combatStateService.GetCombatant(id)?.Name ?? "Unknown")
            .ToList();

        return new OpportunityAttackCheckResult
        {
            TriggersOpportunityAttacks = true,
            AttackingEntities = attackers,
            Message = $"Warning: Moving will trigger opportunity attacks from {string.Join(", ", names)}!"
        };
    }

    /// <inheritdoc />
    public IEnumerable<OpportunityAttackResult> ExecuteOpportunityAttacks(
        Guid movingEntityId,
        GridPosition from,
        GridPosition to)
    {
        var check = CheckOpportunityAttacks(movingEntityId, from, to);

        if (!check.TriggersOpportunityAttacks)
            yield break;

        foreach (var attackerId in check.AttackingEntities)
        {
            // Use reaction
            UseReaction(attackerId);

            // Execute the attack
            var attacker = _combatStateService.GetCombatant(attackerId);
            if (attacker == null)
                continue;

            var attackResult = _combatService.ProcessOpportunityAttack(attackerId, movingEntityId);

            yield return new OpportunityAttackResult
            {
                AttackerId = attackerId,
                AttackerName = attacker.Name,
                Hit = attackResult.Success,
                Damage = attackResult.DamageDealt,
                AttackRoll = attackResult.AttackRollDetails,
                Message = attackResult.Message
            };

            _logger.LogInformation(
                "Opportunity attack: {Attacker} vs {Target} - {Result}",
                attacker.Name,
                movingEntityId,
                attackResult.Success ? "Hit" : "Miss");
        }
    }

    /// <inheritdoc />
    public bool HasUsedReaction(Guid entityId) => _usedReactions.Contains(entityId);

    /// <inheritdoc />
    public void UseReaction(Guid entityId) => _usedReactions.Add(entityId);

    /// <inheritdoc />
    public void ResetReactions() => _usedReactions.Clear();

    /// <inheritdoc />
    public bool IsDisengaging(Guid entityId) => _disengaging.Contains(entityId);

    /// <inheritdoc />
    public void SetDisengaging(Guid entityId) => _disengaging.Add(entityId);

    /// <inheritdoc />
    public void ClearDisengaging(Guid entityId) => _disengaging.Remove(entityId);

    private bool HasMeleeWeapon(CombatantInfo combatant)
    {
        // Check if equipped weapon is melee (range type == Melee)
        return combatant.EquippedWeapon?.RangeType == RangeType.Melee;
    }
}
```

### MovementService Opportunity Attack Integration

```csharp
// Update MovementService to check for opportunity attacks:

public MovementResult Move(Guid entityId, MovementDirection direction)
{
    // ... existing validation ...

    var newPosition = currentPosition.Move(direction);

    // Check for opportunity attacks
    var opportunityCheck = _threatService.CheckOpportunityAttacks(
        entityId, currentPosition, newPosition);

    if (opportunityCheck.TriggersOpportunityAttacks)
    {
        // Execute opportunity attacks before movement
        var opportunityResults = _threatService.ExecuteOpportunityAttacks(
            entityId, currentPosition, newPosition).ToList();

        // Check if entity died from opportunity attacks
        var entity = _combatStateService.GetCombatant(entityId);
        if (entity == null || entity.CurrentHp <= 0)
        {
            return new MovementResult
            {
                Success = false,
                FailureReason = MovementFailureReason.EntityDied,
                OpportunityAttacks = opportunityResults,
                Message = "You were killed while trying to move!"
            };
        }
    }

    // ... perform movement ...
    // ... terrain damage ...

    return new MovementResult
    {
        Success = true,
        OldPosition = currentPosition,
        NewPosition = newPosition,
        MovementPointsUsed = totalCost,
        MovementPointsRemaining = entity.MovementPointsRemaining - totalCost,
        OpportunityAttacks = opportunityResults,
        Message = BuildMovementMessage(/*...*/)
    };
}
```

### DisengageCommand

```csharp
namespace RuneAndRust.Application.Commands;

/// <summary>
/// Command to disengage, allowing movement without triggering opportunity attacks.
/// </summary>
public class DisengageCommand : ICommand
{
    public string Name => "disengage";
    public string Description => "Use your action to disengage, moving without triggering opportunity attacks this turn.";

    private readonly IThreatService _threatService;
    private readonly ICombatStateService _combatStateService;

    public DisengageCommand(
        IThreatService threatService,
        ICombatStateService combatStateService)
    {
        _threatService = threatService;
        _combatStateService = combatStateService;
    }

    public CommandResult Execute(CommandContext context)
    {
        var combat = _combatStateService.GetCurrentCombat();
        if (combat == null)
        {
            return new CommandResult
            {
                Success = false,
                Message = "You can only disengage during combat."
            };
        }

        var player = combat.GetPlayerCombatant();
        if (player == null)
        {
            return new CommandResult
            {
                Success = false,
                Message = "Player not in combat."
            };
        }

        // Check if already disengaging
        if (_threatService.IsDisengaging(player.Id))
        {
            return new CommandResult
            {
                Success = false,
                Message = "You are already disengaging this turn."
            };
        }

        // Mark as disengaging
        _threatService.SetDisengaging(player.Id);

        return new CommandResult
        {
            Success = true,
            Message = "You disengage, carefully stepping back. You can move without triggering opportunity attacks this turn."
        };
    }
}
```

### User-Facing Changes

**Movement with Threat Warning:**
```
> move north

WARNING: Moving will trigger opportunity attacks!
  - Skeleton (C3) threatens your current position

Do you want to move anyway? (yes/no/disengage)
> yes

The Skeleton swings at you as you try to escape!
[Opportunity Attack: Skeleton]
[Attack Roll: 2d6 + 2 = 11 vs AC 14]
Miss! The skeleton's sword misses you.

You move carefully...
[Movement: D3 → D2]
[Movement Points: 4 → 3 remaining]
```

**Opportunity Attack Hits:**
```
> move west

WARNING: Moving will trigger opportunity attacks!
  - Goblin (D4) threatens your current position

> yes

The Goblin stabs at you as you flee!
[Opportunity Attack: Goblin]
[Attack Roll: 2d6 + 3 = 16 vs AC 14]
Hit! 5 damage.
HP: 25/30 → 20/30

You move to C3...
[Movement: D3 → C3]
```

**Disengage Action:**
```
> disengage

You carefully disengage from combat.
You can now move without triggering opportunity attacks this turn.

> move north

You slip away from the Skeleton without provoking an attack.
[Movement: D3 → D2]
[Movement Points: 4 → 3 remaining]
```

**Grid with Threatened Squares:**
```
Combat Grid                              [Turn 3]
===============================================

  A B C D E F G H
1 . . . . . . . .
2 . . * * * . . .     @ = You (D4)
3 . . * M * . . .     M = Skeleton (C3)
4 . . * @←. . . .     * = Threatened squares
5 . . . . . . . .     ← = You are adjacent to threat

Threats:
  You are threatened by Skeleton at C3
  Moving away will trigger an opportunity attack

Options:
  - Use 'disengage' to move safely
  - Stay adjacent and attack
  - Move and risk opportunity attack

You (D4) | HP: 25/30 | Action: Available
```

### Configuration Example

```json
{
  "$schema": "../schemas/combat.schema.json",
  "opportunityAttacks": {
    "enabled": true,
    "requiresMeleeWeapon": true,
    "oneReactionPerRound": true,
    "disengageAction": {
      "enabled": true,
      "consumesAction": true
    },
    "description": "Moving out of an enemy's reach triggers an opportunity attack"
  }
}
```

### Acceptance Criteria

- [ ] Creatures with melee weapons threaten adjacent squares
- [ ] Moving out of threatened square triggers opportunity attack
- [ ] Opportunity attacks are executed before movement completes
- [ ] Each creature gets one reaction per round
- [ ] Reactions reset at start of round
- [ ] Disengage action prevents opportunity attacks
- [ ] Disengage consumes the action for the turn
- [ ] Grid displays threatened squares
- [ ] Movement warns about opportunity attacks
- [ ] Configuration enables/disables feature
- [ ] ~30 unit tests pass

---

## v0.5.3c: Area Effects

[v0.5.3c Design Specification](v0.5.3c-design-specification.md)

### Overview

Implement area effect targeting and resolution including multiple shape types (circle, cone, line, square). Abilities can define area effects that target multiple grid cells. The UI shows affected cells when targeting and damage is applied to all entities in the area.

### Scope

**In Scope:**
- `AreaEffectShape` enum (Circle, Cone, Line, Square)
- `AreaEffect` value object with shape and dimensions
- `IAreaEffectService` interface
- `AreaEffectService` for AoE calculations
- Circle shape (radius from center)
- Cone shape (direction and spread angle)
- Line shape (direction and length)
- Square shape (size centered on point)
- AoE targeting UI (select center point)
- AoE preview display on grid
- AbilityDefinition.AreaEffect property
- AoE damage resolution
- AoE ability configuration

**Out of Scope:**
- AoE with friendly fire options (future enhancement)
- Moving AoE effects (future enhancement)

### Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Domain Enums | 1 | `AreaEffectShape` |
| Domain Value Objects | 1 | `AreaEffect` |
| AbilityDefinition Updates | 1 | Add AreaEffect property |
| Application Interfaces | 1 | `IAreaEffectService` |
| Application Services | 1 | `AreaEffectService` |
| AbilityService Updates | 1 | AoE ability execution |
| Grid Renderer Updates | 1 | AoE preview display |
| Configuration | 1 | AoE abilities in JSON |
| Unit Tests | ~30 | Shape, targeting tests |

### AreaEffectShape Enum

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Shapes for area effect abilities.
/// </summary>
public enum AreaEffectShape
{
    /// <summary>
    /// No area effect - single target.
    /// </summary>
    None,

    /// <summary>
    /// Circle centered on target point.
    /// </summary>
    Circle,

    /// <summary>
    /// Cone spreading from caster in a direction.
    /// </summary>
    Cone,

    /// <summary>
    /// Line from caster to target point.
    /// </summary>
    Line,

    /// <summary>
    /// Square centered on target point.
    /// </summary>
    Square
}
```

### AreaEffect Value Object

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Defines an area effect for an ability.
/// </summary>
public readonly record struct AreaEffect
{
    /// <summary>
    /// Gets the shape of the area effect.
    /// </summary>
    public AreaEffectShape Shape { get; init; }

    /// <summary>
    /// Gets the radius (for Circle) or half-width (for Square).
    /// </summary>
    public int Radius { get; init; }

    /// <summary>
    /// Gets the length (for Line and Cone).
    /// </summary>
    public int Length { get; init; }

    /// <summary>
    /// Gets the width (for Line) or angle in degrees (for Cone).
    /// </summary>
    public int Width { get; init; }

    /// <summary>
    /// Gets whether the caster is included in the area.
    /// </summary>
    public bool IncludesCaster { get; init; }

    /// <summary>
    /// Gets whether allies are affected.
    /// </summary>
    public bool AffectsAllies { get; init; }

    /// <summary>
    /// Gets whether enemies are affected.
    /// </summary>
    public bool AffectsEnemies { get; init; }

    /// <summary>
    /// Creates a circle area effect.
    /// </summary>
    public static AreaEffect Circle(int radius, bool affectsAllies = false)
    {
        return new AreaEffect
        {
            Shape = AreaEffectShape.Circle,
            Radius = radius,
            AffectsAllies = affectsAllies,
            AffectsEnemies = true
        };
    }

    /// <summary>
    /// Creates a cone area effect.
    /// </summary>
    public static AreaEffect Cone(int length, int angleDegrees = 90, bool affectsAllies = false)
    {
        return new AreaEffect
        {
            Shape = AreaEffectShape.Cone,
            Length = length,
            Width = angleDegrees,
            AffectsAllies = affectsAllies,
            AffectsEnemies = true
        };
    }

    /// <summary>
    /// Creates a line area effect.
    /// </summary>
    public static AreaEffect Line(int length, int width = 1, bool affectsAllies = false)
    {
        return new AreaEffect
        {
            Shape = AreaEffectShape.Line,
            Length = length,
            Width = width,
            AffectsAllies = affectsAllies,
            AffectsEnemies = true
        };
    }

    /// <summary>
    /// Creates a square area effect.
    /// </summary>
    public static AreaEffect Square(int size, bool affectsAllies = false)
    {
        return new AreaEffect
        {
            Shape = AreaEffectShape.Square,
            Radius = size / 2,
            AffectsAllies = affectsAllies,
            AffectsEnemies = true
        };
    }
}
```

### AbilityDefinition Modifications

```
MODIFY: AbilityDefinition
├── ADD: AreaEffect: AreaEffect? (nullable for single-target)
├── ADD: IsAreaEffect: bool (getter, returns AreaEffect != null)
├── ADD: HasAreaEffect: bool (same as IsAreaEffect)
└── UPDATE: Create() to include areaEffect parameter
```

### IAreaEffectService Interface

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for area effect calculations and resolution.
/// </summary>
public interface IAreaEffectService
{
    /// <summary>
    /// Gets all cells affected by an area effect.
    /// </summary>
    IEnumerable<GridPosition> GetAffectedCells(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null);

    /// <summary>
    /// Gets all entities in an area effect.
    /// </summary>
    IEnumerable<Guid> GetAffectedEntities(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null,
        Guid? casterId = null);

    /// <summary>
    /// Gets a preview of cells that would be affected.
    /// </summary>
    AreaEffectPreview GetPreview(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null,
        Guid? casterId = null);

    /// <summary>
    /// Validates an area effect target point.
    /// </summary>
    AreaEffectValidation ValidateTarget(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition targetPoint,
        int range);

    /// <summary>
    /// Gets cells for a circle shape.
    /// </summary>
    IEnumerable<GridPosition> GetCircleCells(GridPosition center, int radius);

    /// <summary>
    /// Gets cells for a cone shape.
    /// </summary>
    IEnumerable<GridPosition> GetConeCells(
        GridPosition origin,
        FacingDirection direction,
        int length,
        int angleDegrees);

    /// <summary>
    /// Gets cells for a line shape.
    /// </summary>
    IEnumerable<GridPosition> GetLineCells(
        GridPosition origin,
        GridPosition target,
        int width);

    /// <summary>
    /// Gets cells for a square shape.
    /// </summary>
    IEnumerable<GridPosition> GetSquareCells(GridPosition center, int size);
}

/// <summary>
/// Preview of an area effect.
/// </summary>
public readonly record struct AreaEffectPreview
{
    /// <summary>
    /// Gets all affected cells.
    /// </summary>
    public IReadOnlyList<GridPosition> AffectedCells { get; init; }

    /// <summary>
    /// Gets affected enemies.
    /// </summary>
    public IReadOnlyList<AffectedEntityInfo> AffectedEnemies { get; init; }

    /// <summary>
    /// Gets affected allies (if any).
    /// </summary>
    public IReadOnlyList<AffectedEntityInfo> AffectedAllies { get; init; }

    /// <summary>
    /// Gets the total entity count.
    /// </summary>
    public int TotalAffected => AffectedEnemies.Count + AffectedAllies.Count;

    /// <summary>
    /// Gets a description of the effect.
    /// </summary>
    public string Description { get; init; }
}

public readonly record struct AffectedEntityInfo
{
    public Guid Id { get; init; }
    public string Name { get; init; }
    public GridPosition Position { get; init; }
    public bool IsAlly { get; init; }
}

/// <summary>
/// Result of validating an area effect target.
/// </summary>
public readonly record struct AreaEffectValidation
{
    public bool IsValid { get; init; }
    public string Message { get; init; }
    public bool InRange { get; init; }
    public bool HasLineOfSight { get; init; }
}
```

### AreaEffectService Implementation

```csharp
namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for area effect calculations.
/// </summary>
public class AreaEffectService : IAreaEffectService
{
    private readonly ICombatGridService _gridService;
    private readonly ICombatStateService _combatStateService;
    private readonly ILineOfSightService _losService;
    private readonly ILogger<AreaEffectService> _logger;

    public AreaEffectService(
        ICombatGridService gridService,
        ICombatStateService combatStateService,
        ILineOfSightService losService,
        ILogger<AreaEffectService> logger)
    {
        _gridService = gridService;
        _combatStateService = combatStateService;
        _losService = losService;
        _logger = logger;
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetAffectedCells(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        var cells = areaEffect.Shape switch
        {
            AreaEffectShape.Circle => GetCircleCells(
                targetPoint ?? origin,
                areaEffect.Radius),

            AreaEffectShape.Cone => GetConeCells(
                origin,
                direction ?? FacingDirection.North,
                areaEffect.Length,
                areaEffect.Width),

            AreaEffectShape.Line => GetLineCells(
                origin,
                targetPoint ?? origin,
                areaEffect.Width),

            AreaEffectShape.Square => GetSquareCells(
                targetPoint ?? origin,
                areaEffect.Radius * 2 + 1),

            _ => Enumerable.Empty<GridPosition>()
        };

        foreach (var cell in cells)
        {
            if (grid.IsValidPosition(cell))
            {
                yield return cell;
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetCircleCells(GridPosition center, int radius)
    {
        for (var x = center.X - radius; x <= center.X + radius; x++)
        {
            for (var y = center.Y - radius; y <= center.Y + radius; y++)
            {
                var pos = GridPosition.Create(x, y);
                if (pos.DistanceTo(center) <= radius)
                {
                    yield return pos;
                }
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetConeCells(
        GridPosition origin,
        FacingDirection direction,
        int length,
        int angleDegrees)
    {
        // Convert direction to vector
        var (dx, dy) = GetDirectionVector(direction);

        // For each distance from origin
        for (var dist = 1; dist <= length; dist++)
        {
            // Calculate cone width at this distance
            var halfAngleRad = (angleDegrees / 2.0) * Math.PI / 180.0;
            var spread = (int)Math.Ceiling(dist * Math.Tan(halfAngleRad));

            // Get center point at this distance
            var centerX = origin.X + dx * dist;
            var centerY = origin.Y + dy * dist;

            // Add cells in perpendicular spread
            for (var s = -spread; s <= spread; s++)
            {
                int px, py;
                if (dx == 0) // Vertical cone
                {
                    px = centerX + s;
                    py = centerY;
                }
                else if (dy == 0) // Horizontal cone
                {
                    px = centerX;
                    py = centerY + s;
                }
                else // Diagonal cone
                {
                    px = centerX + s * (dy == dx ? -1 : 1);
                    py = centerY + s;
                }

                yield return GridPosition.Create(px, py);
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetLineCells(
        GridPosition origin,
        GridPosition target,
        int width)
    {
        // Use Bresenham's line algorithm (from LOS service)
        var lineCells = _losService.GetLineCells(origin, target).ToList();

        if (width <= 1)
        {
            foreach (var cell in lineCells)
            {
                yield return cell;
            }
            yield break;
        }

        // Expand line to width
        var halfWidth = width / 2;

        // Calculate perpendicular direction
        var dx = target.X - origin.X;
        var dy = target.Y - origin.Y;
        var length = Math.Sqrt(dx * dx + dy * dy);

        if (length == 0)
            yield break;

        // Perpendicular unit vector
        var perpX = -dy / length;
        var perpY = dx / length;

        foreach (var cell in lineCells)
        {
            for (var w = -halfWidth; w <= halfWidth; w++)
            {
                var offsetX = (int)Math.Round(perpX * w);
                var offsetY = (int)Math.Round(perpY * w);
                yield return GridPosition.Create(cell.X + offsetX, cell.Y + offsetY);
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<GridPosition> GetSquareCells(GridPosition center, int size)
    {
        var halfSize = size / 2;

        for (var x = center.X - halfSize; x <= center.X + halfSize; x++)
        {
            for (var y = center.Y - halfSize; y <= center.Y + halfSize; y++)
            {
                yield return GridPosition.Create(x, y);
            }
        }
    }

    /// <inheritdoc />
    public IEnumerable<Guid> GetAffectedEntities(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null,
        Guid? casterId = null)
    {
        var grid = _gridService.GetActiveGrid();
        if (grid == null)
            yield break;

        var caster = casterId.HasValue
            ? _combatStateService.GetCombatant(casterId.Value)
            : null;

        var affectedCells = GetAffectedCells(areaEffect, origin, targetPoint, direction);

        foreach (var cell in affectedCells)
        {
            var gridCell = grid.GetCell(cell);
            if (gridCell.OccupantId.HasValue)
            {
                var occupant = _combatStateService.GetCombatant(gridCell.OccupantId.Value);
                if (occupant == null)
                    continue;

                // Skip caster if not included
                if (!areaEffect.IncludesCaster && gridCell.OccupantId == casterId)
                    continue;

                // Check ally/enemy filtering
                var isAlly = caster != null && occupant.IsPlayer == caster.IsPlayer;

                if (isAlly && !areaEffect.AffectsAllies)
                    continue;
                if (!isAlly && !areaEffect.AffectsEnemies)
                    continue;

                yield return gridCell.OccupantId.Value;
            }
        }
    }

    /// <inheritdoc />
    public AreaEffectPreview GetPreview(
        AreaEffect areaEffect,
        GridPosition origin,
        GridPosition? targetPoint = null,
        FacingDirection? direction = null,
        Guid? casterId = null)
    {
        var cells = GetAffectedCells(areaEffect, origin, targetPoint, direction).ToList();
        var enemies = new List<AffectedEntityInfo>();
        var allies = new List<AffectedEntityInfo>();

        var grid = _gridService.GetActiveGrid();
        var caster = casterId.HasValue
            ? _combatStateService.GetCombatant(casterId.Value)
            : null;

        foreach (var cell in cells)
        {
            var gridCell = grid?.GetCell(cell);
            if (gridCell?.OccupantId.HasValue == true)
            {
                var occupant = _combatStateService.GetCombatant(gridCell.OccupantId.Value);
                if (occupant == null)
                    continue;

                var isAlly = caster != null && occupant.IsPlayer == caster.IsPlayer;

                var info = new AffectedEntityInfo
                {
                    Id = gridCell.OccupantId.Value,
                    Name = occupant.Name,
                    Position = cell,
                    IsAlly = isAlly
                };

                if (isAlly)
                    allies.Add(info);
                else
                    enemies.Add(info);
            }
        }

        return new AreaEffectPreview
        {
            AffectedCells = cells,
            AffectedEnemies = enemies,
            AffectedAllies = allies,
            Description = $"{areaEffect.Shape} affects {cells.Count} cells, {enemies.Count} enemies"
        };
    }

    private (int dx, int dy) GetDirectionVector(FacingDirection direction) => direction switch
    {
        FacingDirection.North => (0, -1),
        FacingDirection.NorthEast => (1, -1),
        FacingDirection.East => (1, 0),
        FacingDirection.SouthEast => (1, 1),
        FacingDirection.South => (0, 1),
        FacingDirection.SouthWest => (-1, 1),
        FacingDirection.West => (-1, 0),
        FacingDirection.NorthWest => (-1, -1),
        _ => (0, -1)
    };

    // ... other methods ...
}
```

### User-Facing Changes

**AoE Targeting:**
```
> use fireball

Select target point for Fireball (3-cell radius):
Current grid position: D4

  A B C D E F G H
1 . . . . . . . .
2 . . M . . M . .
3 . . . . . . . .
4 . . . @ . . . .
5 . . . . . . . .

Enter target position (e.g., C2):
> D2

Fireball Preview:
  A B C D E F G H
1 . . ○ ○ ○ . . .
2 . ○ ○ M ○ ○ M .     ○ = Blast area
3 . . ○ ○ ○ . . .     M = Enemy in area
4 . . . @ . . . .

Targets: 1 enemy (Skeleton at D2)
Cast Fireball? (yes/no)
```

**Fireball Execution:**
```
> yes

You hurl a ball of fire at D2!

[FIREBALL - 3-cell radius]
[Affected cells: 13]
[Targets: Skeleton at D2]

Damage Roll: 3d6 = 12 fire damage

Results:
  Skeleton at D2: 12 damage → Defeated!

The flames engulf the area!
```

**Cone Attack (Breath Weapon):**
```
> use dragon-breath

Select direction for Dragon Breath (4-cell cone):
  N  NE  E  SE  S  SW  W  NW

> NE

Dragon Breath Preview:
  A B C D E F G H
1 . . . . ○ ○ . .
2 . . . ○ ○ M . .     ○ = Breath area
3 . . ○ ○ . . . .     M = Enemy in area
4 . . @ . . . . .

Targets: 1 enemy (Goblin at F2)
Use Dragon Breath? (yes/no)
```

**Line Attack (Lightning Bolt):**
```
> use lightning-bolt

Select end point for Lightning Bolt (6-cell line):

> H4

Lightning Bolt Preview:
  A B C D E F G H
1 . . . . . . . .
2 . . . . . . . .
3 . . . . . . . .
4 . . . @ ─ ─ M ─     ─ = Bolt path
5 . . . . . . . .     M = Enemy in path

Targets: 1 enemy (Skeleton at G4)
Cast Lightning Bolt? (yes/no)
```

**Grid with AoE Preview:**
```
Combat Grid - AoE Targeting                [Fireball]
=====================================================

  A B C D E F G H
1 . . ○ ○ ○ . . .
2 . ○ ○ M ○ ○ . .     @ = You (D4)
3 . . ○ ○ ○ . . .     M = Enemies
4 . . . @ . . . .     ○ = Fireball area
5 . . . . . . M .

Target: D2 (center)
Shape: Circle, Radius: 2
Enemies in area: 1 (Skeleton)
Allies in area: 0

[Enter] Cast  [Esc] Cancel  [Arrows] Move target
```

### Configuration Example

```json
{
  "$schema": "../schemas/abilities.schema.json",
  "abilities": [
    {
      "id": "fireball",
      "name": "Fireball",
      "description": "Hurl a ball of fire that explodes on impact",
      "resourceType": "Mana",
      "resourceCost": 15,
      "damage": "3d6",
      "damageType": "Fire",
      "range": 6,
      "areaEffect": {
        "shape": "Circle",
        "radius": 2,
        "affectsAllies": false,
        "affectsEnemies": true
      }
    },
    {
      "id": "cone-of-cold",
      "name": "Cone of Cold",
      "description": "Blast of freezing air in a cone",
      "resourceType": "Mana",
      "resourceCost": 12,
      "damage": "2d8",
      "damageType": "Cold",
      "areaEffect": {
        "shape": "Cone",
        "length": 4,
        "width": 90,
        "affectsAllies": false,
        "affectsEnemies": true
      }
    },
    {
      "id": "lightning-bolt",
      "name": "Lightning Bolt",
      "description": "A bolt of lightning streaks toward a target",
      "resourceType": "Mana",
      "resourceCost": 10,
      "damage": "4d6",
      "damageType": "Lightning",
      "range": 8,
      "areaEffect": {
        "shape": "Line",
        "length": 8,
        "width": 1,
        "affectsAllies": false,
        "affectsEnemies": true
      }
    },
    {
      "id": "earthquake",
      "name": "Earthquake",
      "description": "Shake the ground in an area",
      "resourceType": "Mana",
      "resourceCost": 20,
      "damage": "2d10",
      "damageType": "Bludgeoning",
      "range": 6,
      "areaEffect": {
        "shape": "Square",
        "radius": 2,
        "affectsAllies": true,
        "affectsEnemies": true,
        "includesCaster": false
      }
    }
  ]
}
```

### Acceptance Criteria

- [ ] AreaEffectShape enum has Circle, Cone, Line, Square
- [ ] AreaEffect value object stores shape and dimensions
- [ ] AbilityDefinition.AreaEffect stores AoE configuration
- [ ] Circle shape calculates cells within radius
- [ ] Cone shape spreads from origin in direction
- [ ] Line shape follows Bresenham's algorithm
- [ ] Square shape fills rectangular area
- [ ] AoE targeting UI shows preview
- [ ] Grid displays affected cells
- [ ] AoE abilities damage all targets in area
- [ ] Ally/enemy filtering works correctly
- [ ] AoE configuration loads from JSON
- [ ] ~30 unit tests pass

---

## Dependencies & Prerequisites

```
v0.5.2 (Terrain & Cover) - REQUIRED
    │
    ├── v0.5.2a: Terrain Core ─────────────────────┐
    │       TerrainType, TerrainService            │
    │                                               │
    ├── v0.5.2b: Cover System ─────────────────────┤
    │       CoverType, CoverObject, CoverService   │
    │                                               │
    └── v0.5.2c: Display & Integration ────────────┘
            Grid rendering, combat integration
                                                    │
v0.5.1 (Range & Melee Combat) - REQUIRED            │
    │                                               │
    ├── LineOfSightService ─────────────────────────┤
    ├── RangeService ───────────────────────────────┤
    └── GetLineCells (Bresenham's) ─────────────────┘
                                                    │
v0.5.0 (Combat Grid Foundation) - REQUIRED          │
    │                                               │
    ├── CombatGrid, GridPosition, GridCell ─────────┤
    ├── GetAdjacentCells ───────────────────────────┤
    ├── MovementService ────────────────────────────┤
    └── GridRenderer ───────────────────────────────┘
                                                    │
                                                    ▼
v0.5.3 (Tactical Positioning)
    │
    ├── v0.5.3a: Flanking System ───────────────────────────────┐
    │       Dependencies: v0.5.0 (GridPosition, adjacency)      │
    │       Provides: FacingDirection, FlankingService          │
    │                                                           │
    ├── v0.5.3b: Opportunity Attacks ───────────────────────────┤
    │       Dependencies: v0.5.0 (MovementService, adjacency)   │
    │       Dependencies: v0.5.1 (RangeType for melee check)    │
    │       Provides: ThreatService, DisengageCommand           │
    │                                                           │
    └── v0.5.3c: Area Effects ──────────────────────────────────┘
            Dependencies: v0.5.1 (LineOfSightService for line)
            Dependencies: v0.5.3a (FacingDirection for cone)
            Provides: AreaEffectService, AoE abilities
```

---

## Estimated Effort Summary

| Phase | New Files | Modified Files | Est. Tests | Complexity |
|-------|-----------|----------------|------------|------------|
| v0.5.3a | ~4 | ~5 | ~30 | High |
| v0.5.3b | ~3 | ~4 | ~30 | High |
| v0.5.3c | ~4 | ~4 | ~30 | High |
| **Total** | **~11** | **~13** | **~90** | |

---

## Risk Assessment

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Flanking calculation complexity | Medium | Medium | Clear opposite-side rules |
| Opportunity attack UX friction | High | Medium | Clear warnings, disengage option |
| AoE shape math complexity | Medium | Medium | Extensive unit tests |
| Cone direction calculation | Medium | High | Use discrete 8 directions |
| Friendly fire balance | Medium | Low | Configurable ally targeting |
| Performance with many threats | Low | Low | Efficient adjacency checks |
| UI complexity for AoE targeting | High | Medium | Clear preview system |

---

## Design Decisions (Confirmed)

### Flanking System

| Decision | Value | Notes |
|----------|-------|-------|
| **Flanking Bonus** | +2 attack | Standard tactical bonus |
| **Behind Bonus** | +2 attack, +2 damage | Stronger backstab |
| **Requires Ally** | Yes | Must have ally on opposite side |
| **Adjacent Only** | Yes | Only melee range qualifies |
| **Auto-Face** | Yes | Creatures face attack target |

### Opportunity Attacks

| Decision | Value | Notes |
|----------|-------|-------|
| **One Reaction** | Per round | Reset at round start |
| **Trigger** | Leaving threat | Moving out of adjacent |
| **Disengage Cost** | Full action | Use action to disengage |
| **Executes Before Move** | Yes | OA happens before movement |
| **Melee Only** | Yes | Must have melee weapon |

### Area Effects

| Decision | Value | Notes |
|----------|-------|-------|
| **Circle** | Radius from center | Target selects center |
| **Cone** | 90° default | Configurable angle |
| **Line** | Origin to target | Uses Bresenham's |
| **Square** | Size centered | Odd sizes only |
| **Friendly Fire** | Configurable | Per ability |

---

## Integration Points

### From v0.5.0
- GridPosition for all position calculations
- GetAdjacentCells for threat/flanking
- MovementService for OA integration
- GridRenderer for display updates

### From v0.5.1
- LineOfSightService for line AoE
- RangeType for melee weapon check
- Distance calculations for ranges

### From v0.5.2
- Terrain for AoE interaction
- Cover for tactical positioning
- Grid display patterns

### To Future Versions
- Status effects from AoE (debuffs)
- Persistent AoE zones
- Reaction abilities beyond OA
- Morale system using flanking

---

## Next Steps

1. **Review & Approve** - Confirm scope breakdown
2. **v0.5.3a Design Spec** - Flanking system details
3. **Implement v0.5.3a** - Build facing and flanking
4. **v0.5.3b Design Spec** - Opportunity attack details
5. **Implement v0.5.3b** - Build threat and reactions
6. **v0.5.3c Design Spec** - Area effect details
7. **Implement v0.5.3c** - Build AoE system

---

*This scope breakdown provides a structured approach to implementing v0.5.3 Tactical Positioning. Each sub-phase builds on the grid infrastructure to add depth to tactical combat, rewarding strategic positioning and coordinated attacks.*
