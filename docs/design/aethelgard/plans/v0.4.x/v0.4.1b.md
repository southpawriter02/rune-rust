# Data Capture Types — Codex Fragment Classification System

**Status:** Ready for Implementation
**Target File:** `/Volumes/GitHub/github/southpawriter02/rune-rust/docs/lore/dc-types.md`

---

## Overview

Data Captures are the evidentiary fragments that accompany Codex entries. Each fragment represents a discrete piece of recovered knowledge, classified by acquisition method and source type. These 20 canonical types provide the taxonomic framework for all Aethelgard Archival Material.

---

## The 20 Canonical Data Capture Types

### Category A: Written & Inscribed Records

| # | Type | Description | Example Source |
|---|------|-------------|----------------|
| 1 | **Text Fragment** | Recovered written documents—memoranda, reports, correspondence, administrative records. Typically scholarly or institutional in origin. | Scriptorium-Primus field reports, Guild circulars |
| 2 | **Runic Inscription** | Carved or etched runic markings recovered from stone, metal, or bone. May contain residual Aetheric signatures. | Waystone markers, tomb engravings, weapon inscriptions |
| 3 | **Cartographic Record** | Maps, charts, survey sketches, or territorial markings. Often fragmentary or outdated. | Ranger patrol maps, Pre-Glitch facility schematics |
| 4 | **Ledger Entry** | Transactional records—trade manifests, inventory logs, census fragments, taxation records. | Combine trade logs, Guild membership rolls |
| 5 | **Correspondence** | Personal or official letters, sealed messages, diplomatic communications. Often intercepted or recovered from ruins. | Noble house archives, courier satchels |

### Category B: Oral & Performance Traditions

| # | Type | Description | Example Source |
|---|------|-------------|----------------|
| 6 | **Oral History** | Transcribed survivor testimonies, elder recollections, eyewitness accounts. Preserves dialectal voice. | Hearth-Clan elders, settlement survivors |
| 7 | **Skaldic Saga** | Formal oral traditions—epic poems, mythic recitations, heroic cycles preserved by trained Skalds. | God-Sleeper tradition, Hearth-fire recitations |
| 8 | **Folk Wisdom** | Proverbs, sayings, survival aphorisms, children's rhymes encoding practical knowledge. | "When the sky screams, the ground listens" |
| 9 | **Liturgical Chant** | Religious or ritual recitations—prayers, invocations, ceremonial formulae. | Iron-Bane hymns, Blot-Priest rites |
| 10 | **Bardic Performance** | Songs, ballads, dramatic recitations documenting events or figures. Musical notation where recoverable. | Tavern songs, commemorative ballads |

### Category C: Physical Evidence & Specimens

| # | Type | Description | Example Source |
|---|------|-------------|----------------|
| 11 | **Physical Specimen** | Biological samples—tissue, feathers, scales, bone, organic material recovered for analysis. | Ash-Crow feathers, Blight-Hound claw |
| 12 | **Material Sample** | Non-biological physical evidence—metal fragments, mineral deposits, soil samples, residue analysis. | Forge slag, corrupted alloy samples |
| 13 | **Artifact Recovery** | Intact or fragmentary Pre-Glitch objects recovered from ruins. May retain residual function. | Data-Slates, Iron Hearts, control crystals |
| 14 | **Runic Trace** | Aetheric signature readings, Blight contamination measurements, H-Index documentation. | H-Index 1.8 readings, corruption gradient maps |
| 15 | **Forensic Analysis** | Post-mortem examinations, necropsy reports, wound pattern analysis, toxicological studies. | Alchemist Guild lab reports, battlefield assessments |

### Category D: Sensory & Recording Media

| # | Type | Description | Example Source |
|---|------|-------------|----------------|
| 16 | **Echo Recording** | Corrupted Pre-Glitch audio/data recordings. Often fragmentary with "echo-layer" contamination. | Environmental monitoring logs, security archives |
| 17 | **Visual Record** | Observation notes, survey documentation, behavioral studies, distance-lens descriptions. | Remote survey team reports, watch-post logs |
| 18 | **Acoustic Capture** | Sound recordings or descriptions—creature vocalizations, environmental audio, signal analysis. | Flock call patterns, sub-sonic communication logs |
| 19 | **Olfactory Profile** | Documented scent signatures, chemical trace descriptions, atmospheric composition notes. | Blight-zone atmospheric reports, creature tracking logs |
| 20 | **Tactile Assessment** | Documented texture, temperature, vibration, or physical sensation observations. | Artifact handling reports, tremor-sense documentation |

---

## Data Capture Property Schema

All Data Captures use the following property table structure:

| Property | Description | Example |
|----------|-------------|---------|
| **Capture ID** | Unique identifier | `cap-ash-crow-001` |
| **Type** | One of the 20 canonical types | Text Fragment |
| **Title** | Descriptive title in quotes | "Ash-Crow Taxonomic Assessment" |
| **Source** | Originating institution or individual | Scriptorium-Primus |
| **Quality** | Standard / Specialist / Enhanced | Standard |
| **Placement** | In-game discovery context | Readable object in ruins |
| **Date Window** | When the capture was made | Year 780 PG |

---

## Quality Tiers

| Tier | Description | Unlock Threshold |
|------|-------------|------------------|
| **Standard** | Common field observations, basic documentation | 25-50% |
| **Specialist** | Expert analysis requiring training or equipment | 50-75% |
| **Enhanced** | Rare finds with exceptional detail or significance | 75-100% |

---

## Voice Layer Mapping

| Type Category | Primary Voice Layer | Notes |
|---------------|---------------------|-------|
| Written Records (1-5) | L2 Scholarly | Clinical, diagnostic perspective |
| Oral Traditions (6-10) | L1 Mythic/Dialectal | Preserves folk voice, oral cadence |
| Physical Evidence (11-15) | L2/L3 Clinical | Technical analysis, measurement-adjacent |
| Sensory Media (16-20) | L1/L3 Hybrid | Often corrupted, echo-layer contamination |

---

## Implementation Notes

**Target File:** `docs/lore/dc-types.md`

The file should contain:
1. YAML frontmatter with standard lore document metadata
2. Overview section explaining Data Captures
3. The 20 types organized by category with descriptions
4. Property schema reference
5. Quality tier definitions
6. Voice layer mapping guidance

---

# Implementation Plan: v0.4.1b - The Unlock (Specialization Acquisition)

**Status:** Ready for Review
**Theme:** "The Unlock"
**Scope:** Service layer, business logic, PP spending, prerequisite validation, event publishing

---

## Executive Summary

v0.4.1b implements the **SpecializationService** business logic layer, enabling characters to unlock specializations and purchase nodes from ability trees using Progression Points (PP). This release builds on v0.4.1a's data foundation.

**Key Features:**
- **Specialization Unlock**: 10 PP cost with archetype/level validation
- **Node Unlock**: Variable tier-based costs (1/2/3/5 PP) with prerequisite validation
- **Capstone Logic**: Tier 4 nodes require ALL Tier 3 nodes unlocked
- **Event Publishing**: SpecializationUnlockedEvent and NodeUnlockedEvent for UI integration

**Layers Touched:** Core, Engine, Terminal, Test
**Patterns Used:** Service-Repository, Result Pattern, Event Bus Publishing
**Target Test Count:** 68 new unit tests

---

## Table of Contents

1. [Decision Trees](#1-decision-trees)
2. [Deliverable Checklist](#2-deliverable-checklist)
3. [Result Type Definitions](#3-result-type-definitions)
4. [Event Definitions](#4-event-definitions)
5. [Service Interface](#5-service-interface)
6. [Service Implementation](#6-service-implementation)
7. [Constants](#7-constants)
8. [Logging Matrix](#8-logging-matrix)
9. [Test Coverage Plan](#9-test-coverage-plan)
10. [DI Registration](#10-di-registration)
11. [Changelog Template](#11-changelog-template)
12. [Critical Files](#12-critical-files)
13. [Implementation Order](#13-implementation-order)

---

## 1. Decision Trees

### 1.1 Specialization Unlock Flow

```
UnlockSpecializationAsync(character, specId)
                │
                ▼
    ┌───────────────────────────────┐
    │ Fetch Specialization by ID    │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Specialization exists?        │──No──► Return Failure("Specialization not found")
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.HasSpecialization   │──Yes──► Return Failure("Already unlocked")
    │ (specId)?                     │
    └───────────────────────────────┘
                │ No
                ▼
    ┌───────────────────────────────┐
    │ Character.Archetype ==        │──No──► Return Failure("Requires {archetype}")
    │ Spec.RequiredArchetype?       │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.Level >=            │──No──► Return Failure("Requires level {level}")
    │ Spec.RequiredLevel?           │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.ProgressionPoints   │──No──► Return Failure("Insufficient PP")
    │ >= 10 (UNLOCK_COST)?          │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ EXECUTE TRANSACTION:          │
    │ 1. Deduct 10 PP               │
    │ 2. Add specId to UnlockedIds  │
    │ 3. Update LastModified        │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Publish SpecializationUnlocked│
    │ Event via IEventBus           │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Return Success(specId, name,  │
    │ costPP=10)                    │
    └───────────────────────────────┘
```

### 1.2 Node Unlock Flow

```
UnlockNodeAsync(character, nodeId)
                │
                ▼
    ┌───────────────────────────────┐
    │ Fetch Node by ID              │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Node exists?                  │──No──► Return Failure("Node not found")
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.HasNode(nodeId)?    │──Yes──► Return Failure("Already unlocked")
    └───────────────────────────────┘
                │ No
                ▼
    ┌───────────────────────────────┐
    │ Character.HasSpecialization   │──No──► Return Failure("Spec not unlocked")
    │ (node.SpecializationId)?      │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ ValidatePrerequisitesAsync(   │──No──► Return Failure(reason)
    │   character, node)?           │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ Character.ProgressionPoints   │──No──► Return Failure("Insufficient PP")
    │ >= node.CostPP?               │
    └───────────────────────────────┘
                │ Yes
                ▼
    ┌───────────────────────────────┐
    │ EXECUTE TRANSACTION:          │
    │ 1. Deduct node.CostPP         │
    │ 2. RecordNodeUnlockAsync()    │
    │ 3. SaveChangesAsync()         │
    │ 4. Update LastModified        │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Publish NodeUnlockedEvent     │
    │ via IEventBus                 │
    └───────────────────────────────┘
                │
                ▼
    ┌───────────────────────────────┐
    │ Return Success(nodeId, name,  │
    │ abilityId, tier, costPP)      │
    └───────────────────────────────┘
```

### 1.3 Prerequisite Validation Flow

```
ValidatePrerequisitesAsync(character, node)
                │
                ▼
    ┌───────────────────────────────┐
    │ Is node.IsCapstone (Tier 4)?  │
    └───────────────────────────────┘
                │
        ┌───────┴───────┐
       Yes              No
        │                │
        ▼                ▼
┌─────────────────┐  ┌─────────────────────────────┐
│ CAPSTONE LOGIC: │  │ STANDARD PREREQUISITE CHECK │
│ Get ALL Tier 3  │  │                             │
│ nodes in tree   │  │ ParentNodeIds empty?        │
└─────────────────┘  │   → Yes: Return (true, null)│
        │            │                             │
        ▼            │ For each parentId:          │
┌─────────────────┐  │   HasNode(parentId)?        │
│ ALL Tier 3      │  │   → No: Return (false,      │
│ unlocked?       │  │     "Requires: {parentName}")│
│ → No: Fail      │  │                             │
│ → Yes: Pass     │  │ All parents unlocked:       │
└─────────────────┘  │   → Return (true, null)     │
                     └─────────────────────────────┘
```

---

## 2. Deliverable Checklist

### New Files to Create

| Layer | File Path | Purpose |
|-------|-----------|---------|
| Core | `RuneAndRust.Core/Models/SpecializationUnlockResult.cs` | Result type for spec unlock |
| Core | `RuneAndRust.Core/Models/NodeUnlockResult.cs` | Result type for node unlock |
| Core | `RuneAndRust.Core/Events/SpecializationUnlockedEvent.cs` | Event for spec unlock |
| Core | `RuneAndRust.Core/Events/NodeUnlockedEvent.cs` | Event for node unlock |
| Core | `RuneAndRust.Core/Interfaces/ISpecializationService.cs` | Service interface |
| Engine | `RuneAndRust.Engine/Services/SpecializationService.cs` | Service implementation |
| Tests | `RuneAndRust.Tests/Engine/SpecializationServiceTests.cs` | 68 unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Terminal/Program.cs` | Register `ISpecializationService` as Scoped |

---

## 3. Result Type Definitions

### 3.1 SpecializationUnlockResult

**File:** `RuneAndRust.Core/Models/SpecializationUnlockResult.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of a specialization unlock operation.
/// </summary>
/// <remarks>See: v0.4.1b (The Unlock) for implementation.</remarks>
public record SpecializationUnlockResult(
    bool Success,
    string Message,
    Guid? SpecializationId = null,
    string? SpecializationName = null,
    int PpSpent = 0)
{
    public static SpecializationUnlockResult Ok(
        string message, Guid specId, string specName, int cost)
        => new(true, message, specId, specName, cost);

    public static SpecializationUnlockResult Failure(string reason)
        => new(false, reason);
}
```

### 3.2 NodeUnlockResult

**File:** `RuneAndRust.Core/Models/NodeUnlockResult.cs`

```csharp
namespace RuneAndRust.Core.Models;

/// <summary>
/// Result of a specialization node unlock operation.
/// </summary>
/// <remarks>See: v0.4.1b (The Unlock) for implementation.</remarks>
public record NodeUnlockResult(
    bool Success,
    string Message,
    Guid? NodeId = null,
    string? NodeName = null,
    Guid? AbilityId = null,
    int Tier = 0,
    int PpSpent = 0)
{
    public static NodeUnlockResult Ok(
        string message, Guid nodeId, string nodeName,
        Guid abilityId, int tier, int cost)
        => new(true, message, nodeId, nodeName, abilityId, tier, cost);

    public static NodeUnlockResult Failure(string reason)
        => new(false, reason);
}
```

---

## 4. Event Definitions

### 4.1 SpecializationUnlockedEvent

**File:** `RuneAndRust.Core/Events/SpecializationUnlockedEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a character unlocks a new specialization.
/// </summary>
/// <remarks>See: v0.4.1b (The Unlock) for implementation.</remarks>
public record SpecializationUnlockedEvent(
    Guid CharacterId,
    string CharacterName,
    Guid SpecializationId,
    string SpecializationName,
    int ProgressionPointsSpent);
```

### 4.2 NodeUnlockedEvent

**File:** `RuneAndRust.Core/Events/NodeUnlockedEvent.cs`

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>
/// Published when a character unlocks a specialization node.
/// </summary>
/// <remarks>See: v0.4.1b (The Unlock) for implementation.</remarks>
public record NodeUnlockedEvent(
    Guid CharacterId,
    string CharacterName,
    Guid NodeId,
    string NodeName,
    Guid AbilityId,
    int Tier,
    bool IsCapstone,
    int ProgressionPointsSpent);
```

---

## 5. Service Interface

**File:** `RuneAndRust.Core/Interfaces/ISpecializationService.cs`

```csharp
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Models;

namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing specialization unlocks and node purchases.
/// </summary>
/// <remarks>See: v0.4.1b (The Unlock) for implementation.</remarks>
public interface ISpecializationService
{
    // ═══════════════════════════════════════════════════════════════════════
    // Specialization Unlock Operations
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Attempts to unlock a specialization for a character (10 PP cost).
    /// </summary>
    Task<SpecializationUnlockResult> UnlockSpecializationAsync(Character character, Guid specId);

    /// <summary>
    /// Checks if a character can unlock a specific specialization.
    /// </summary>
    Task<bool> CanUnlockSpecializationAsync(Character character, Guid specId);

    /// <summary>
    /// Gets the PP cost to unlock a specialization (constant: 10).
    /// </summary>
    int GetSpecializationUnlockCost();

    // ═══════════════════════════════════════════════════════════════════════
    // Node Unlock Operations
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Attempts to unlock a specialization node by spending PP.
    /// </summary>
    Task<NodeUnlockResult> UnlockNodeAsync(Character character, Guid nodeId);

    /// <summary>
    /// Checks if a character can unlock a specific node.
    /// </summary>
    Task<bool> CanUnlockNodeAsync(Character character, Guid nodeId);

    /// <summary>
    /// Validates prerequisites for unlocking a node.
    /// Capstone (Tier 4) requires ALL Tier 3 nodes; others require parent nodes.
    /// </summary>
    Task<(bool IsValid, string? FailureReason)> ValidatePrerequisitesAsync(
        Character character, SpecializationNode node);

    // ═══════════════════════════════════════════════════════════════════════
    // Query Operations
    // ═══════════════════════════════════════════════════════════════════════

    /// <summary>
    /// Gets all specializations available to a character based on archetype.
    /// </summary>
    Task<IEnumerable<Specialization>> GetAvailableSpecializationsAsync(Character character);

    /// <summary>
    /// Gets all nodes for a specialization.
    /// </summary>
    Task<IEnumerable<SpecializationNode>> GetNodesWithStatusAsync(Character character, Guid specId);
}
```

---

## 6. Service Implementation

**File:** `RuneAndRust.Engine/Services/SpecializationService.cs`

Key implementation details:

```csharp
public class SpecializationService : ISpecializationService
{
    private readonly ISpecializationRepository _specRepo;
    private readonly IEventBus _eventBus;
    private readonly ILogger<SpecializationService> _logger;

    public const int SpecializationUnlockCost = 10;

    public SpecializationService(
        ISpecializationRepository specRepo,
        IEventBus eventBus,
        ILogger<SpecializationService> logger)
    {
        _specRepo = specRepo;
        _eventBus = eventBus;
        _logger = logger;
    }

    // UnlockSpecializationAsync:
    // 1. Fetch spec by ID
    // 2. Validate: exists, not already unlocked, archetype match, level req, PP >= 10
    // 3. Execute: deduct PP, add to UnlockedSpecializationIds, update LastModified
    // 4. Publish SpecializationUnlockedEvent
    // 5. Return SpecializationUnlockResult.Ok()

    // UnlockNodeAsync:
    // 1. Fetch node by ID
    // 2. Validate: exists, not already unlocked, spec owned, prerequisites met, PP >= cost
    // 3. Execute: deduct PP, RecordNodeUnlockAsync, SaveChangesAsync, update local collection
    // 4. Publish NodeUnlockedEvent
    // 5. Return NodeUnlockResult.Ok()

    // ValidatePrerequisitesAsync:
    // - Capstone (Tier 4): ALL Tier 3 nodes in tree must be unlocked
    // - Standard: ALL ParentNodeIds must be unlocked (empty = Tier 1 root = valid)
}
```

---

## 7. Constants

| Constant | Value | Location |
|----------|-------|----------|
| `SpecializationUnlockCost` | `10` | SpecializationService |

**Node Costs (from database):**
- Tier 1: 1 PP
- Tier 2: 2 PP
- Tier 3: 3 PP
- Tier 4 (Capstone): 5 PP

---

## 8. Logging Matrix

### SpecializationService Logging

| Event | Level | Template |
|-------|-------|----------|
| UnlockSpec entry | Trace | `[SpecService] UnlockSpecializationAsync called for {CharName}: SpecId={SpecId}` |
| Spec not found | Warning | `[SpecService] Unlock failed: Specialization {SpecId} not found` |
| Already unlocked | Warning | `[SpecService] Unlock failed: {CharName} already has {SpecName}` |
| Wrong archetype | Warning | `[SpecService] Unlock failed: {CharName} is {CharArch}, requires {ReqArch}` |
| Level too low | Warning | `[SpecService] Unlock failed: {CharName} is Level {CharLevel}, requires {ReqLevel}` |
| Insufficient PP (spec) | Warning | `[SpecService] Unlock failed: {CharName} has {Have} PP, needs {Need}` |
| Spec unlocked | Info | `[SpecService] {CharName} unlocked {SpecName}! Cost: {Cost} PP, Remaining: {Remaining} PP` |
| Spec event published | Debug | `[SpecService] SpecializationUnlockedEvent published for {CharName}: {SpecName}` |
| UnlockNode entry | Trace | `[SpecService] UnlockNodeAsync called for {CharName}: NodeId={NodeId}` |
| Node not found | Warning | `[SpecService] Node unlock failed: Node {NodeId} not found` |
| Node already unlocked | Warning | `[SpecService] Node unlock failed: {CharName} already has {NodeName}` |
| Spec not unlocked | Warning | `[SpecService] Node unlock failed: {CharName} has not unlocked specialization {SpecId}` |
| Prereq failed | Warning | `[SpecService] Node unlock failed: Prerequisite check failed for {NodeName}. Reason: {Reason}` |
| Insufficient PP (node) | Warning | `[SpecService] Node unlock failed: {CharName} has {Have} PP, needs {Need}` |
| Node unlocked | Info | `[SpecService] {CharName} unlocked node {NodeName} (Tier {Tier})! Cost: {Cost} PP, Remaining: {Remaining} PP` |
| Node event published | Debug | `[SpecService] NodeUnlockedEvent published for {CharName}: {NodeName} (Tier {Tier}, Capstone={IsCapstone})` |
| ValidatePrereq entry | Trace | `[SpecService] ValidatePrerequisitesAsync: Node={NodeId}, Tier={Tier}, IsCapstone={IsCapstone}` |
| Capstone prereq failed | Debug | `[SpecService] Capstone prereq failed: Missing Tier 3 node {NodeName}` |
| Capstone prereq passed | Debug | `[SpecService] Capstone prereq check passed: All {Count} Tier 3 nodes unlocked` |
| Tier 1 no prereq | Debug | `[SpecService] Tier 1 node has no prerequisites` |
| Parent prereq failed | Debug | `[SpecService] Prereq failed: Missing parent node {ParentName} ({ParentId})` |
| All prereqs satisfied | Debug | `[SpecService] All {Count} parent prerequisites satisfied` |
| GetAvailableSpecs | Debug | `[SpecService] GetAvailableSpecializationsAsync for {CharName} ({Archetype})` |
| GetNodesWithStatus | Debug | `[SpecService] GetNodesWithStatusAsync for {CharName}, SpecId={SpecId}` |

---

## 9. Test Coverage Plan

### Test Class Structure

**File:** `RuneAndRust.Tests/Engine/SpecializationServiceTests.cs`

**Dependencies (Mocks):**
- `Mock<ISpecializationRepository>`
- `Mock<IEventBus>`
- `Mock<ILogger<SpecializationService>>`

### Test Inventory (68 tests)

#### UnlockSpecializationAsync Tests (16 tests)

| Test Name | Description |
|-----------|-------------|
| `UnlockSpecializationAsync_DeductsPP_FromCharacter` | Verifies 10 PP deducted |
| `UnlockSpecializationAsync_AddsSpecIdToUnlockedList` | Verifies UnlockedSpecializationIds updated |
| `UnlockSpecializationAsync_UpdatesLastModified` | Verifies timestamp updated |
| `UnlockSpecializationAsync_ReturnsSuccess_WithCorrectDetails` | Validates result properties |
| `UnlockSpecializationAsync_PublishesEvent_OnSuccess` | Verifies event published |
| `UnlockSpecializationAsync_EventContainsCorrectData` | Validates event payload |
| `UnlockSpecializationAsync_Fails_WhenSpecNotFound` | 404 case |
| `UnlockSpecializationAsync_Fails_WhenAlreadyUnlocked` | Duplicate unlock |
| `UnlockSpecializationAsync_Fails_WhenWrongArchetype` | Archetype mismatch |
| `UnlockSpecializationAsync_Fails_WhenLevelTooLow` | Level requirement |
| `UnlockSpecializationAsync_Fails_WhenInsufficientPP` | PP < 10 |
| `UnlockSpecializationAsync_NoStateChange_OnFailure` | Rollback verification |
| `UnlockSpecializationAsync_NoEvent_OnFailure` | No event on fail |
| `UnlockSpecializationAsync_ExactlyTenPP_Succeeds` | Edge case: exactly 10 PP |
| `UnlockSpecializationAsync_HigherLevel_Succeeds` | Level > required |
| `UnlockSpecializationAsync_MultipleSpecs_CanUnlockSequentially` | Multiple unlocks |

#### CanUnlockSpecializationAsync Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `CanUnlockSpecializationAsync_ReturnsTrue_WhenAllRequirementsMet` | All conditions satisfied |
| `CanUnlockSpecializationAsync_ReturnsFalse_WhenSpecNotFound` | Non-existent spec |
| `CanUnlockSpecializationAsync_ReturnsFalse_WhenAlreadyUnlocked` | Already has spec |
| `CanUnlockSpecializationAsync_ReturnsFalse_WhenWrongArchetype` | Archetype mismatch |
| `CanUnlockSpecializationAsync_ReturnsFalse_WhenLevelTooLow` | Level too low |
| `CanUnlockSpecializationAsync_ReturnsFalse_WhenInsufficientPP` | Not enough PP |

#### UnlockNodeAsync Tests (18 tests)

| Test Name | Description |
|-----------|-------------|
| `UnlockNodeAsync_DeductsPP_FromCharacter` | Verifies node.CostPP deducted |
| `UnlockNodeAsync_RecordsUnlock_InRepository` | RecordNodeUnlockAsync called |
| `UnlockNodeAsync_CallsSaveChanges` | SaveChangesAsync called |
| `UnlockNodeAsync_AddsToSpecializationProgress` | Local collection updated |
| `UnlockNodeAsync_UpdatesLastModified` | Timestamp updated |
| `UnlockNodeAsync_ReturnsSuccess_WithCorrectDetails` | Validates result |
| `UnlockNodeAsync_PublishesEvent_OnSuccess` | Event published |
| `UnlockNodeAsync_EventContainsCorrectData` | Event payload validation |
| `UnlockNodeAsync_Fails_WhenNodeNotFound` | 404 case |
| `UnlockNodeAsync_Fails_WhenAlreadyUnlocked` | Duplicate unlock |
| `UnlockNodeAsync_Fails_WhenSpecNotUnlocked` | Spec not owned |
| `UnlockNodeAsync_Fails_WhenParentNotUnlocked` | Missing parent |
| `UnlockNodeAsync_Fails_WhenInsufficientPP` | Not enough PP |
| `UnlockNodeAsync_Tier1Node_NoPrerequisites` | Root nodes valid |
| `UnlockNodeAsync_Tier2Node_RequiresParent` | Tier 2 requires parent |
| `UnlockNodeAsync_NoStateChange_OnFailure` | Rollback verification |
| `UnlockNodeAsync_NoEvent_OnFailure` | No event on fail |
| `UnlockNodeAsync_VariableCosts_WorkCorrectly` | 1/2/3/5 PP costs |

#### ValidatePrerequisitesAsync Tests (12 tests)

| Test Name | Description |
|-----------|-------------|
| `ValidatePrerequisitesAsync_Tier1_ReturnsTrue_NoParents` | Root nodes always valid |
| `ValidatePrerequisitesAsync_Tier2_ReturnsTrue_WhenParentUnlocked` | Parent unlocked |
| `ValidatePrerequisitesAsync_Tier2_ReturnsFalse_WhenParentMissing` | Parent missing |
| `ValidatePrerequisitesAsync_Tier3_RequiresAllParents` | Multiple parents |
| `ValidatePrerequisitesAsync_Tier3_ReturnsFalse_WhenAnyParentMissing` | Partial parents |
| `ValidatePrerequisitesAsync_Capstone_RequiresAllTier3Nodes` | Capstone rule |
| `ValidatePrerequisitesAsync_Capstone_ReturnsFalse_WhenAnyTier3Missing` | Missing Tier 3 |
| `ValidatePrerequisitesAsync_Capstone_ReturnsTrue_WhenAllTier3Unlocked` | All Tier 3 present |
| `ValidatePrerequisitesAsync_Capstone_IgnoresOtherTiers` | Only checks Tier 3 |
| `ValidatePrerequisitesAsync_ReturnsCorrectFailureReason` | Message contains node name |
| `ValidatePrerequisitesAsync_EmptyParentList_ReturnsTrue` | Empty = no prereqs |
| `ValidatePrerequisitesAsync_MultipleParents_AllRequired` | All parents needed |

#### CanUnlockNodeAsync Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `CanUnlockNodeAsync_ReturnsTrue_WhenAllRequirementsMet` | All conditions met |
| `CanUnlockNodeAsync_ReturnsFalse_WhenNodeNotFound` | Non-existent node |
| `CanUnlockNodeAsync_ReturnsFalse_WhenAlreadyUnlocked` | Already has node |
| `CanUnlockNodeAsync_ReturnsFalse_WhenSpecNotUnlocked` | Spec not owned |
| `CanUnlockNodeAsync_ReturnsFalse_WhenPrereqsFail` | Prerequisites fail |
| `CanUnlockNodeAsync_ReturnsFalse_WhenInsufficientPP` | Not enough PP |

#### Query Operation Tests (4 tests)

| Test Name | Description |
|-----------|-------------|
| `GetAvailableSpecializationsAsync_ReturnsMatchingArchetype` | Filters by archetype |
| `GetAvailableSpecializationsAsync_ReturnsEmpty_WhenNoMatch` | No specs for archetype |
| `GetNodesWithStatusAsync_ReturnsAllNodes` | Returns complete tree |
| `GetSpecializationUnlockCost_Returns10` | Constant returns 10 |

#### Edge Case / Integration Tests (6 tests)

| Test Name | Description |
|-----------|-------------|
| `FullTree_CanUnlockFromTier1ToCapstone` | Complete unlock sequence |
| `FullTree_CannotSkipTiers` | Must unlock in order |
| `MultipleCharacters_IndependentProgress` | Characters don't share |
| `UnlockNode_AfterSpecUnlock_Works` | Correct sequence |
| `UnlockNode_BeforeSpecUnlock_Fails` | Wrong sequence fails |
| `Capstone_RequiresAllTier3_NotJustParents` | Capstone special rule |

---

## 10. DI Registration

**File:** `RuneAndRust.Terminal/Program.cs`

Add after line 111 (`services.AddScoped<IProgressionService, ProgressionService>();`):

```csharp
// Specialization Service (v0.4.1b)
services.AddScoped<ISpecializationService, SpecializationService>();
```

---

## 11. Changelog Template

```markdown
# Changelog: v0.4.1b - The Unlock (Specialization Acquisition)

**Release Date:** [DATE]
**Total Tests:** [N] (68 new tests added)

## Table of Contents

- [Summary](#summary)
- [New Files Created](#new-files-created)
- [Files Modified](#files-modified)
- [Code Implementation Details](#code-implementation-details)
- [Logging Matrix](#logging-matrix)
- [Test Coverage](#test-coverage)
- [DI Registration](#di-registration)
- [Verification Results](#verification-results)
- [Directory Structure After v0.4.1b](#directory-structure-after-v041b)
- [Running Tests](#running-tests)
- [Design Decisions](#design-decisions)
- [Next Steps](#next-steps)
- [Credits](#credits)

---

## Summary

Version 0.4.1b implements the **SpecializationService** business logic layer...

[Continue with CHANGELOG_GENERATION_RULES.md format]
```

---

## 12. Critical Files

### Files to Create (Priority Order)

| Priority | File | Purpose |
|----------|------|---------|
| 1 | `RuneAndRust.Core/Models/SpecializationUnlockResult.cs` | Result type |
| 2 | `RuneAndRust.Core/Models/NodeUnlockResult.cs` | Result type |
| 3 | `RuneAndRust.Core/Events/SpecializationUnlockedEvent.cs` | Event record |
| 4 | `RuneAndRust.Core/Events/NodeUnlockedEvent.cs` | Event record |
| 5 | `RuneAndRust.Core/Interfaces/ISpecializationService.cs` | Service interface |
| 6 | `RuneAndRust.Engine/Services/SpecializationService.cs` | Service implementation |
| 7 | `RuneAndRust.Tests/Engine/SpecializationServiceTests.cs` | Unit tests |

### Files to Modify

| File | Change |
|------|--------|
| `RuneAndRust.Terminal/Program.cs` | Register ISpecializationService |

### Reference Files (Read Only)

| File | Purpose |
|------|---------|
| `RuneAndRust.Engine/Services/ProgressionService.cs` | Pattern reference for Result/Validation |
| `RuneAndRust.Core/Events/LevelUpEvent.cs` | Pattern reference for events |
| `RuneAndRust.Core/Interfaces/ISpecializationRepository.cs` | Repository methods to use |
| `RuneAndRust.Core/Entities/Character.cs` | Entity to modify (HasSpecialization, HasNode) |

---

## 13. Implementation Order

1. **Create Result Types** (SpecializationUnlockResult, NodeUnlockResult)
2. **Create Event Records** (SpecializationUnlockedEvent, NodeUnlockedEvent)
3. **Create ISpecializationService Interface**
4. **Create SpecializationService Implementation**
5. **Register in Program.cs DI**
6. **Write Unit Tests** (68 tests)
7. **Run Build and Tests**
8. **Generate Changelog** following CHANGELOG_GENERATION_RULES.md

---

## Design Decisions

### Why 10 PP for Specialization Unlock?

**Problem:** Need a meaningful cost that gates specialization access without being prohibitive.

**Decision:** Fixed 10 PP cost for all specializations.

**Rationale:**
- By Level 4-5, players accumulate enough PP to afford one specialization
- Creates meaningful choice about when to unlock vs. upgrade attributes
- Consistent cost simplifies UI and player expectations
- Future specializations can adjust RequiredLevel for additional gating

### Why Capstone Requires ALL Tier 3 (Not Just Parents)?

**Problem:** Capstone abilities are ultimate transformations that should feel earned.

**Decision:** Tier 4 nodes require ALL Tier 3 nodes in the tree, not just their ParentNodeIds.

**Rationale:**
- Ensures full tree exploration before accessing ultimate ability
- Prevents "rushing" to capstone via shortest path
- Total investment: 1+1+1 + 2+2 + 3+3 + 5 = 18 PP minimum (plus 10 for unlock = 28 PP)
- Creates natural progression pacing aligned with character levels

