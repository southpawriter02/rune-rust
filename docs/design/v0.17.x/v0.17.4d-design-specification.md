# v0.17.4d Design Specification: Specialization Provider Service

**Version:** 0.17.4d
**Theme:** Specialization Provider Interface & Implementation
**Author:** Claude
**Created:** 2026-01-27
**Status:** Draft
**Prerequisites:** v0.17.4c Complete (Ability Tier Structures)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ISpecializationProvider Interface](#4-ispecializationprovider-interface)
5. [SpecializationProvider Implementation](#5-specializationprovider-implementation)
6. [Configuration Loading](#6-configuration-loading)
7. [Commands](#7-commands)
8. [User-Facing Changes](#8-user-facing-changes)
9. [Logging Specifications](#9-logging-specifications)
10. [Unit Testing Requirements](#10-unit-testing-requirements)
11. [Use Cases](#11-use-cases)
12. [Deliverable Checklist](#12-deliverable-checklist)
13. [Acceptance Criteria](#13-acceptance-criteria)
14. [Future Considerations](#14-future-considerations)
15. [Implementation Notes](#15-implementation-notes)
16. [Document Metadata](#16-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.17.4d, the Specialization Provider Service phase. This phase creates the infrastructure for loading, caching, and querying specialization definitions.

Key components:

1. **ISpecializationProvider Interface**: Defines the contract for accessing specialization definitions, supporting lookup by ID, archetype filtering, and path type queries.

2. **SpecializationProvider Implementation**: Loads specialization definitions from JSON configuration, caches them in memory, and provides efficient lookup methods.

This infrastructure enables the application layer to access specialization data without direct configuration file access, building on v0.17.4a-c and enabling the application service in v0.17.4e.

### 1.2 Current vs. Target Implementation

| Aspect                  | Current Implementation | Target Implementation                |
| ----------------------- | ---------------------- | ------------------------------------ |
| **Definition Access**   | Direct JSON parsing    | Provider service abstraction         |
| **Caching**             | None                   | In-memory dictionary cache           |
| **Lookup by ID**        | Manual parsing         | `GetBySpecializationId()` method     |
| **Archetype Filtering** | Not available          | `GetByArchetype()` method            |
| **Path Type Queries**   | Extension methods only | `GetHereticalSpecializations()` etc. |

### 1.3 Scope

**In Scope:**

- Define `ISpecializationProvider` interface with query methods
- Implement `SpecializationProvider` with JSON loading and caching
- Register provider in dependency injection
- Unit tests for provider methods (~3 tests)

**Out of Scope:**

- Application service - v0.17.4e
- Character creation workflow - v0.17.5
- Runtime specialization state tracking - Combat/Progression systems

### 1.4 Key Deliverables

| Type            | Count | Details                              |
| --------------- | ----- | ------------------------------------ |
| Interfaces      | 1     | `ISpecializationProvider`            |
| Services        | 1     | `SpecializationProvider`             |
| Configuration   | 0     | Uses existing `specializations.json` |
| DI Registration | 1     | Singleton registration               |
| Unit Tests      | ~3    | Provider loading, lookup, filtering  |

---

## 2. Dependencies

### 2.1 Required from v0.17.4a-c

| Component                   | Location                                           | Usage in v0.17.4d  |
| --------------------------- | -------------------------------------------------- | ------------------ |
| `SpecializationId`          | `Domain/Enums/SpecializationId.cs`                 | Lookup key         |
| `SpecializationPathType`    | `Domain/Enums/SpecializationPathType.cs`           | Filtering          |
| `SpecializationDefinition`  | `Domain/Entities/SpecializationDefinition.cs`      | Returned entity    |
| `SpecialResourceDefinition` | `Domain/ValueObjects/SpecialResourceDefinition.cs` | Part of definition |
| `SpecializationAbilityTier` | `Domain/ValueObjects/SpecializationAbilityTier.cs` | Part of definition |
| `SpecializationAbility`     | `Domain/ValueObjects/SpecializationAbility.cs`     | Part of definition |

### 2.2 Required from v0.17.3 (Archetype System)

| Component            | Location                                       | Usage in v0.17.4d          |
| -------------------- | ---------------------------------------------- | -------------------------- |
| `Archetype`          | `Domain/Enums/Archetype.cs`                    | Filter by parent archetype |
| `IArchetypeProvider` | `Application/Interfaces/IArchetypeProvider.cs` | Pattern reference          |

### 2.3 Required from Infrastructure

| Component              | Location                                         | Usage in v0.17.4d  |
| ---------------------- | ------------------------------------------------ | ------------------ |
| `IConfigurationLoader` | `Application/Interfaces/IConfigurationLoader.cs` | JSON loading       |
| `Serilog.ILogger`      | NuGet Package                                    | Structured logging |

### 2.4 Provides to Future Versions

| Version  | Component                 | Usage                                |
| -------- | ------------------------- | ------------------------------------ |
| v0.17.4e | `ISpecializationProvider` | Application service dependency       |
| v0.17.5  | `GetByArchetype()`        | Character creation available options |
| Combat   | `GetBySpecializationId()` | Ability lookups during combat        |

---

## 3. Architecture Diagrams

### 3.1 Provider Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      PROVIDER ARCHITECTURE                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      APPLICATION LAYER                               │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Interfaces/                                                        │    │
│  │  └── ISpecializationProvider.cs    ←── NEW                          │    │
│  │                                                                      │    │
│  │  Services/                                                          │    │
│  │  └── SpecializationProvider.cs     ←── NEW                          │    │
│  │                                                                      │    │
│  │  DTOs/                                                              │    │
│  │  └── SpecializationConfigDto.cs    ←── NEW (for JSON mapping)       │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ loads from                                │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                  INFRASTRUCTURE LAYER                                │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Configuration/                                                     │    │
│  │  └── specializations.json           (existing from v0.17.4b-c)      │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Entities/SpecializationDefinition.cs     (from v0.17.4b)           │    │
│  │  ValueObjects/SpecialResourceDefinition.cs (from v0.17.4b)          │    │
│  │  ValueObjects/SpecializationAbilityTier.cs (from v0.17.4c)          │    │
│  │  ValueObjects/SpecializationAbility.cs     (from v0.17.4c)          │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Provider Loading Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      PROVIDER LOADING FLOW                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  APPLICATION STARTUP                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              DI CONTAINER RESOLVES ISpecializationProvider           │    │
│  │                                                                      │    │
│  │  services.AddSingleton<ISpecializationProvider, SpecializationProvider>│  │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              CONSTRUCTOR: Load Configuration                         │    │
│  │                                                                      │    │
│  │  1. Read specializations.json                                        │    │
│  │  2. Deserialize to SpecializationConfigDto                           │    │
│  │  3. Map DTOs to domain entities                                      │    │
│  │  4. Build lookup dictionaries                                        │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              CACHE INITIALIZATION                                    │    │
│  │                                                                      │    │
│  │  _byId: Dictionary<SpecializationId, SpecializationDefinition>      │    │
│  │  _byArchetype: Dictionary<Archetype, List<SpecializationDefinition>>│    │
│  │  _heretical: List<SpecializationDefinition>                          │    │
│  │  _coherent: List<SpecializationDefinition>                           │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │              PROVIDER READY FOR QUERIES                              │    │
│  │                                                                      │    │
│  │  GetBySpecializationId(id) → O(1) dictionary lookup                 │    │
│  │  GetByArchetype(archetype) → O(1) dictionary lookup                 │    │
│  │  GetHereticalSpecializations() → cached list return                 │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Query Decision Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      QUERY DECISION FLOW                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CALLER NEEDS SPECIALIZATION DATA                                           │
│           │                                                                  │
│           ▼                                                                  │
│      ┌────────────────────────────────────────────────────────┐             │
│      │           WHAT TYPE OF QUERY?                          │             │
│      └────────────────────────────────────────────────────────┘             │
│           │              │              │              │                     │
│    [Single ID]   [By Archetype]  [By Path Type]   [All]                     │
│           │              │              │              │                     │
│           ▼              ▼              ▼              ▼                     │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │
│  │ GetBySpec-   │ │ GetByArche-  │ │ GetHeretical │ │ GetAll()     │        │
│  │ ializationId │ │ type()       │ │ /Coherent()  │ │              │        │
│  │ (id)         │ │              │ │              │ │              │        │
│  └──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘        │
│           │              │              │              │                     │
│           ▼              ▼              ▼              ▼                     │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐        │
│  │ Dictionary   │ │ Dictionary   │ │ Cached list  │ │ All values   │        │
│  │ lookup O(1)  │ │ lookup O(1)  │ │ return O(1)  │ │ enumeration  │        │
│  └──────────────┘ └──────────────┘ └──────────────┘ └──────────────┘        │
│           │              │              │              │                     │
│           ▼              ▼              ▼              ▼                     │
│      ┌────────────────────────────────────────────────────────┐             │
│      │           RETURN RESULT                                │             │
│      │                                                         │             │
│      │  Single: SpecializationDefinition?                      │             │
│      │  Multiple: IReadOnlyList<SpecializationDefinition>      │             │
│      └────────────────────────────────────────────────────────┘             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. ISpecializationProvider Interface

### 4.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/ISpecializationProvider.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;

/// <summary>
/// Provides access to specialization definitions loaded from configuration.
/// </summary>
/// <remarks>
/// <para>
/// ISpecializationProvider is the primary interface for accessing specialization
/// data throughout the application. It abstracts the loading and caching of
/// specialization definitions from JSON configuration.
/// </para>
/// <para>
/// Implementations should:
/// <list type="bullet">
/// <item><description>Load configuration once at startup</description></item>
/// <item><description>Cache definitions in memory for O(1) lookups</description></item>
/// <item><description>Return null or empty collections for missing data (not throw)</description></item>
/// </list>
/// </para>
/// </remarks>
public interface ISpecializationProvider
{
    /// <summary>
    /// Gets a specialization definition by its enum identifier.
    /// </summary>
    /// <param name="specializationId">The specialization identifier.</param>
    /// <returns>
    /// The <see cref="SpecializationDefinition"/> if found; otherwise, <c>null</c>.
    /// </returns>
    /// <example>
    /// <code>
    /// var berserkr = provider.GetBySpecializationId(SpecializationId.Berserkr);
    /// if (berserkr != null)
    /// {
    ///     Console.WriteLine($"Found: {berserkr.DisplayName}");
    /// }
    /// </code>
    /// </example>
    SpecializationDefinition? GetBySpecializationId(SpecializationId specializationId);

    /// <summary>
    /// Gets all specialization definitions for a specific archetype.
    /// </summary>
    /// <param name="archetype">The parent archetype.</param>
    /// <returns>
    /// A read-only list of specializations belonging to the archetype.
    /// Returns an empty list if no specializations found.
    /// </returns>
    /// <remarks>
    /// Used during character creation to show available specializations
    /// based on the player's chosen archetype.
    /// </remarks>
    /// <example>
    /// <code>
    /// var warriorSpecs = provider.GetByArchetype(Archetype.Warrior);
    /// // Returns: Berserkr, IronBane, Skjaldmaer, SkarHorde, AtgeirWielder, GorgeMaw
    /// </code>
    /// </example>
    IReadOnlyList<SpecializationDefinition> GetByArchetype(Archetype archetype);

    /// <summary>
    /// Gets all Heretical (Corruption-risk) specializations.
    /// </summary>
    /// <returns>
    /// A read-only list of all Heretical path specializations.
    /// </returns>
    /// <remarks>
    /// Heretical specializations interface with corrupted Aether and
    /// have abilities that may trigger Corruption gain.
    /// </remarks>
    IReadOnlyList<SpecializationDefinition> GetHereticalSpecializations();

    /// <summary>
    /// Gets all Coherent (no Corruption-risk) specializations.
    /// </summary>
    /// <returns>
    /// A read-only list of all Coherent path specializations.
    /// </returns>
    /// <remarks>
    /// Coherent specializations work within stable reality and
    /// do not risk Corruption from ability use.
    /// </remarks>
    IReadOnlyList<SpecializationDefinition> GetCoherentSpecializations();

    /// <summary>
    /// Gets all loaded specialization definitions.
    /// </summary>
    /// <returns>
    /// A read-only list of all 17 specialization definitions.
    /// </returns>
    IReadOnlyList<SpecializationDefinition> GetAll();

    /// <summary>
    /// Gets the total count of loaded specializations.
    /// </summary>
    /// <returns>The number of loaded definitions (expected: 17).</returns>
    int Count { get; }

    /// <summary>
    /// Checks if a specialization definition exists.
    /// </summary>
    /// <param name="specializationId">The specialization identifier.</param>
    /// <returns><c>true</c> if the definition is loaded; otherwise, <c>false</c>.</returns>
    bool Exists(SpecializationId specializationId);

    /// <summary>
    /// Gets specializations that have a special resource.
    /// </summary>
    /// <returns>
    /// A read-only list of specializations with special resource definitions.
    /// </returns>
    /// <remarks>
    /// Useful for combat systems that need to initialize special resource tracking.
    /// </remarks>
    IReadOnlyList<SpecializationDefinition> GetWithSpecialResource();

    /// <summary>
    /// Gets a specific ability by ID across all specializations.
    /// </summary>
    /// <param name="abilityId">The ability identifier.</param>
    /// <returns>
    /// A tuple containing the ability and its parent specialization,
    /// or <c>null</c> if not found.
    /// </returns>
    /// <remarks>
    /// Used by combat systems to look up ability details during execution.
    /// </remarks>
    (SpecializationDefinition Specialization, SpecializationAbility Ability)? GetAbility(string abilityId);
}
```

---

## 5. SpecializationProvider Implementation

### 5.1 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/SpecializationProvider.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.DTOs;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;
using System.Text.Json;

/// <summary>
/// Provides access to specialization definitions loaded from configuration.
/// </summary>
/// <remarks>
/// <para>
/// SpecializationProvider loads all specialization definitions at construction time
/// and caches them in memory for efficient O(1) lookups.
/// </para>
/// <para>
/// This service is registered as a singleton to ensure definitions are loaded
/// only once per application lifetime.
/// </para>
/// </remarks>
public class SpecializationProvider : ISpecializationProvider
{
    private readonly ILogger<SpecializationProvider> _logger;
    private readonly Dictionary<SpecializationId, SpecializationDefinition> _byId;
    private readonly Dictionary<Archetype, List<SpecializationDefinition>> _byArchetype;
    private readonly List<SpecializationDefinition> _heretical;
    private readonly List<SpecializationDefinition> _coherent;
    private readonly List<SpecializationDefinition> _withSpecialResource;
    private readonly List<SpecializationDefinition> _all;

    /// <summary>
    /// Initializes a new instance of the <see cref="SpecializationProvider"/> class.
    /// </summary>
    /// <param name="configurationLoader">Service for loading configuration files.</param>
    /// <param name="logger">Logger for diagnostic output.</param>
    public SpecializationProvider(
        IConfigurationLoader configurationLoader,
        ILogger<SpecializationProvider> logger)
    {
        _logger = logger;
        _byId = new Dictionary<SpecializationId, SpecializationDefinition>();
        _byArchetype = new Dictionary<Archetype, List<SpecializationDefinition>>();
        _heretical = new List<SpecializationDefinition>();
        _coherent = new List<SpecializationDefinition>();
        _withSpecialResource = new List<SpecializationDefinition>();
        _all = new List<SpecializationDefinition>();

        // Initialize archetype buckets
        foreach (var archetype in Enum.GetValues<Archetype>())
        {
            _byArchetype[archetype] = new List<SpecializationDefinition>();
        }

        LoadSpecializations(configurationLoader);
    }

    /// <inheritdoc />
    public int Count => _all.Count;

    /// <inheritdoc />
    public SpecializationDefinition? GetBySpecializationId(SpecializationId specializationId)
    {
        var found = _byId.TryGetValue(specializationId, out var definition);

        _logger.LogDebug(
            "Lookup for {SpecializationId}: {Result}",
            specializationId,
            found ? "Found" : "Not found");

        return definition;
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetByArchetype(Archetype archetype)
    {
        if (_byArchetype.TryGetValue(archetype, out var definitions))
        {
            _logger.LogDebug(
                "GetByArchetype({Archetype}): {Count} specializations",
                archetype,
                definitions.Count);

            return definitions.AsReadOnly();
        }

        _logger.LogWarning(
            "Unknown archetype requested: {Archetype}",
            archetype);

        return Array.Empty<SpecializationDefinition>();
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetHereticalSpecializations()
    {
        _logger.LogDebug(
            "GetHereticalSpecializations: {Count} specializations",
            _heretical.Count);

        return _heretical.AsReadOnly();
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetCoherentSpecializations()
    {
        _logger.LogDebug(
            "GetCoherentSpecializations: {Count} specializations",
            _coherent.Count);

        return _coherent.AsReadOnly();
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetAll()
    {
        return _all.AsReadOnly();
    }

    /// <inheritdoc />
    public bool Exists(SpecializationId specializationId)
    {
        return _byId.ContainsKey(specializationId);
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetWithSpecialResource()
    {
        _logger.LogDebug(
            "GetWithSpecialResource: {Count} specializations",
            _withSpecialResource.Count);

        return _withSpecialResource.AsReadOnly();
    }

    /// <inheritdoc />
    public (SpecializationDefinition Specialization, SpecializationAbility Ability)? GetAbility(
        string abilityId)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(abilityId);

        var normalizedId = abilityId.ToLowerInvariant();

        foreach (var specialization in _all)
        {
            var ability = specialization.GetAbility(normalizedId);
            if (ability.HasValue)
            {
                _logger.LogDebug(
                    "Found ability {AbilityId} in specialization {SpecializationId}",
                    abilityId,
                    specialization.SpecializationId);

                return (specialization, ability.Value);
            }
        }

        _logger.LogDebug(
            "Ability {AbilityId} not found in any specialization",
            abilityId);

        return null;
    }

    /// <summary>
    /// Loads specialization definitions from configuration.
    /// </summary>
    private void LoadSpecializations(IConfigurationLoader configurationLoader)
    {
        _logger.LogInformation("Loading specialization definitions...");

        try
        {
            var config = configurationLoader.Load<SpecializationsConfigDto>("specializations.json");

            if (config?.Definitions == null || config.Definitions.Count == 0)
            {
                _logger.LogWarning("No specialization definitions found in configuration");
                return;
            }

            foreach (var dto in config.Definitions)
            {
                try
                {
                    var definition = MapToDefinition(dto);
                    RegisterDefinition(definition);
                }
                catch (Exception ex)
                {
                    _logger.LogError(
                        ex,
                        "Failed to load specialization definition: {SpecializationId}",
                        dto.SpecializationId);
                }
            }

            _logger.LogInformation(
                "Loaded {Count} specialization definitions " +
                "({Heretical} Heretical, {Coherent} Coherent, {WithResource} with special resource)",
                _all.Count,
                _heretical.Count,
                _coherent.Count,
                _withSpecialResource.Count);

            ValidateLoadedDefinitions();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to load specializations configuration");
            throw;
        }
    }

    /// <summary>
    /// Maps a configuration DTO to a domain entity.
    /// </summary>
    private SpecializationDefinition MapToDefinition(SpecializationDefinitionDto dto)
    {
        // Parse enum values
        var specializationId = Enum.Parse<SpecializationId>(dto.SpecializationId, ignoreCase: true);
        var parentArchetype = Enum.Parse<Archetype>(dto.ParentArchetype, ignoreCase: true);
        var pathType = Enum.Parse<SpecializationPathType>(dto.PathType, ignoreCase: true);

        // Map special resource if present
        SpecialResourceDefinition? specialResource = null;
        if (dto.SpecialResource != null)
        {
            specialResource = SpecialResourceDefinition.Create(
                resourceId: dto.SpecialResource.ResourceId,
                displayName: dto.SpecialResource.DisplayName,
                minValue: dto.SpecialResource.MinValue,
                maxValue: dto.SpecialResource.MaxValue,
                startsAt: dto.SpecialResource.StartsAt,
                regenPerTurn: dto.SpecialResource.RegenPerTurn,
                decayPerTurn: dto.SpecialResource.DecayPerTurn,
                description: dto.SpecialResource.Description);
        }

        // Map ability tiers if present
        var abilityTiers = new List<SpecializationAbilityTier>();
        if (dto.AbilityTiers != null)
        {
            foreach (var tierDto in dto.AbilityTiers)
            {
                var abilities = tierDto.Abilities
                    .Select(a => SpecializationAbility.Create(
                        abilityId: a.AbilityId,
                        displayName: a.DisplayName,
                        description: a.Description,
                        isPassive: a.IsPassive,
                        resourceCost: a.ResourceCost,
                        resourceType: a.ResourceType,
                        cooldown: a.Cooldown,
                        corruptionRisk: a.CorruptionRisk))
                    .ToList();

                var tier = SpecializationAbilityTier.Create(
                    tier: tierDto.Tier,
                    displayName: tierDto.DisplayName,
                    unlockCost: tierDto.UnlockCost,
                    requiresPreviousTier: tierDto.RequiresPreviousTier,
                    requiredRank: tierDto.RequiredRank,
                    abilities: abilities);

                abilityTiers.Add(tier);
            }
        }

        return SpecializationDefinition.Create(
            specializationId: specializationId,
            displayName: dto.DisplayName,
            tagline: dto.Tagline,
            description: dto.Description,
            selectionText: dto.SelectionText,
            parentArchetype: parentArchetype,
            pathType: pathType,
            unlockCost: dto.UnlockCost,
            specialResource: specialResource,
            abilityTiers: abilityTiers);
    }

    /// <summary>
    /// Registers a definition in all lookup caches.
    /// </summary>
    private void RegisterDefinition(SpecializationDefinition definition)
    {
        _byId[definition.SpecializationId] = definition;
        _byArchetype[definition.ParentArchetype].Add(definition);
        _all.Add(definition);

        if (definition.IsHeretical)
        {
            _heretical.Add(definition);
        }
        else
        {
            _coherent.Add(definition);
        }

        if (definition.HasSpecialResource)
        {
            _withSpecialResource.Add(definition);
        }

        _logger.LogDebug(
            "Registered specialization {SpecializationId} ({PathType}, {Archetype})",
            definition.SpecializationId,
            definition.PathType,
            definition.ParentArchetype);
    }

    /// <summary>
    /// Validates that all expected specializations are loaded.
    /// </summary>
    private void ValidateLoadedDefinitions()
    {
        var expectedCount = Enum.GetValues<SpecializationId>().Length;

        if (_all.Count != expectedCount)
        {
            _logger.LogWarning(
                "Specialization count mismatch: expected {Expected}, loaded {Actual}",
                expectedCount,
                _all.Count);
        }

        // Check for missing definitions
        foreach (var id in Enum.GetValues<SpecializationId>())
        {
            if (!_byId.ContainsKey(id))
            {
                _logger.LogWarning(
                    "Missing specialization definition: {SpecializationId}",
                    id);
            }
        }
    }
}
```

---

## 6. Configuration Loading

### 6.1 Configuration DTOs

**File:** `src/Core/RuneAndRust.Application/DTOs/SpecializationConfigDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Root configuration DTO for specializations.json.
/// </summary>
public class SpecializationsConfigDto
{
    /// <summary>
    /// Gets or sets the list of specialization definitions.
    /// </summary>
    public List<SpecializationDefinitionDto> Definitions { get; set; } = new();
}

/// <summary>
/// Configuration DTO for a single specialization definition.
/// </summary>
public class SpecializationDefinitionDto
{
    public string SpecializationId { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Tagline { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string SelectionText { get; set; } = string.Empty;
    public string ParentArchetype { get; set; } = string.Empty;
    public string PathType { get; set; } = string.Empty;
    public int UnlockCost { get; set; }
    public SpecialResourceDto? SpecialResource { get; set; }
    public List<AbilityTierDto>? AbilityTiers { get; set; }
}

/// <summary>
/// Configuration DTO for special resource.
/// </summary>
public class SpecialResourceDto
{
    public string ResourceId { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public int MinValue { get; set; }
    public int MaxValue { get; set; }
    public int StartsAt { get; set; }
    public int RegenPerTurn { get; set; }
    public int DecayPerTurn { get; set; }
    public string Description { get; set; } = string.Empty;
}

/// <summary>
/// Configuration DTO for ability tier.
/// </summary>
public class AbilityTierDto
{
    public int Tier { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public int UnlockCost { get; set; }
    public bool RequiresPreviousTier { get; set; }
    public int RequiredRank { get; set; }
    public List<SpecializationAbilityDto> Abilities { get; set; } = new();
}

/// <summary>
/// Configuration DTO for specialization ability.
/// </summary>
public class SpecializationAbilityDto
{
    public string AbilityId { get; set; } = string.Empty;
    public string DisplayName { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public bool IsPassive { get; set; }
    public int ResourceCost { get; set; }
    public string ResourceType { get; set; } = string.Empty;
    public int Cooldown { get; set; }
    public int CorruptionRisk { get; set; }
}
```

### 6.2 Dependency Injection Registration

**File:** `src/Infrastructure/RuneAndRust.Infrastructure/DependencyInjection.cs`

```csharp
// Add to existing DI registration
services.AddSingleton<ISpecializationProvider, SpecializationProvider>();
```

---

## 7. Commands

No new commands introduced in v0.17.4d. The provider is a data access service.

---

## 8. User-Facing Changes

### 8.1 No Direct UI Changes

v0.17.4d introduces internal data access infrastructure. No direct user-facing changes.

### 8.2 Future UI Integration Points

The provider enables:

- Character creation specialization list (v0.17.5)
- Specialization detail screens (v0.17.5)
- Combat ability tooltips (Combat integration)

---

## 9. Logging Specifications

### 9.1 Log Levels by Component

| Component                            | Level       | Events                                        |
| ------------------------------------ | ----------- | --------------------------------------------- |
| `SpecializationProvider` constructor | Information | Loading started, loading complete with counts |
| `LoadSpecializations`                | Warning     | No definitions found, count mismatch          |
| `LoadSpecializations`                | Error       | Failed to load configuration                  |
| `MapToDefinition`                    | Error       | Failed to map individual definition           |
| Query methods                        | Debug       | Lookup results, found/not found               |

### 9.2 Log Message Templates

```csharp
// Information: Loading started
_logger.LogInformation("Loading specialization definitions...");

// Information: Loading complete
_logger.LogInformation(
    "Loaded {Count} specialization definitions " +
    "({Heretical} Heretical, {Coherent} Coherent, {WithResource} with special resource)",
    _all.Count,
    _heretical.Count,
    _coherent.Count,
    _withSpecialResource.Count);

// Warning: Count mismatch
_logger.LogWarning(
    "Specialization count mismatch: expected {Expected}, loaded {Actual}",
    expectedCount,
    _all.Count);

// Warning: Missing definition
_logger.LogWarning(
    "Missing specialization definition: {SpecializationId}",
    id);

// Debug: Lookup result
_logger.LogDebug(
    "Lookup for {SpecializationId}: {Result}",
    specializationId,
    found ? "Found" : "Not found");

// Debug: Registration
_logger.LogDebug(
    "Registered specialization {SpecializationId} ({PathType}, {Archetype})",
    definition.SpecializationId,
    definition.PathType,
    definition.ParentArchetype);

// Error: Load failure
_logger.LogError(
    ex,
    "Failed to load specialization definition: {SpecializationId}",
    dto.SpecializationId);
```

---

## 10. Unit Testing Requirements

### 10.1 Test Count by Feature

| Feature          | Test Count |
| ---------------- | ---------- |
| Provider loading | 1          |
| Lookup methods   | 1          |
| Filter methods   | 1          |
| **Total**        | **~3**     |

### 10.2 Test Specifications

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SpecializationProviderTests.cs`

```csharp
[TestFixture]
public class SpecializationProviderTests
{
    private Mock<IConfigurationLoader> _configLoaderMock;
    private Mock<ILogger<SpecializationProvider>> _loggerMock;

    [SetUp]
    public void SetUp()
    {
        _configLoaderMock = new Mock<IConfigurationLoader>();
        _loggerMock = new Mock<ILogger<SpecializationProvider>>();
    }

    [Test]
    public void Constructor_WithValidConfig_LoadsAllDefinitions()
    {
        // Arrange
        var config = CreateTestConfig();
        _configLoaderMock
            .Setup(x => x.Load<SpecializationsConfigDto>("specializations.json"))
            .Returns(config);

        // Act
        var provider = new SpecializationProvider(
            _configLoaderMock.Object,
            _loggerMock.Object);

        // Assert
        provider.Count.Should().Be(config.Definitions.Count);
        provider.GetAll().Should().HaveCount(config.Definitions.Count);
    }

    [Test]
    public void GetBySpecializationId_WithValidId_ReturnsDefinition()
    {
        // Arrange
        var config = CreateTestConfig();
        _configLoaderMock
            .Setup(x => x.Load<SpecializationsConfigDto>("specializations.json"))
            .Returns(config);

        var provider = new SpecializationProvider(
            _configLoaderMock.Object,
            _loggerMock.Object);

        // Act
        var result = provider.GetBySpecializationId(SpecializationId.Berserkr);

        // Assert
        result.Should().NotBeNull();
        result!.SpecializationId.Should().Be(SpecializationId.Berserkr);
        result.DisplayName.Should().Be("Berserkr");
    }

    [Test]
    public void GetByArchetype_ReturnsCorrectSpecializations()
    {
        // Arrange
        var config = CreateTestConfig();
        _configLoaderMock
            .Setup(x => x.Load<SpecializationsConfigDto>("specializations.json"))
            .Returns(config);

        var provider = new SpecializationProvider(
            _configLoaderMock.Object,
            _loggerMock.Object);

        // Act
        var warriors = provider.GetByArchetype(Archetype.Warrior);

        // Assert
        warriors.Should().NotBeEmpty();
        warriors.Should().OnlyContain(s => s.ParentArchetype == Archetype.Warrior);
    }

    [Test]
    public void GetHereticalSpecializations_ReturnsOnlyHeretical()
    {
        // Arrange
        var config = CreateTestConfig();
        _configLoaderMock
            .Setup(x => x.Load<SpecializationsConfigDto>("specializations.json"))
            .Returns(config);

        var provider = new SpecializationProvider(
            _configLoaderMock.Object,
            _loggerMock.Object);

        // Act
        var heretical = provider.GetHereticalSpecializations();

        // Assert
        heretical.Should().OnlyContain(s => s.IsHeretical);
    }

    private SpecializationsConfigDto CreateTestConfig()
    {
        return new SpecializationsConfigDto
        {
            Definitions = new List<SpecializationDefinitionDto>
            {
                new SpecializationDefinitionDto
                {
                    SpecializationId = "Berserkr",
                    DisplayName = "Berserkr",
                    Tagline = "Fury Unleashed",
                    Description = "Test description",
                    SelectionText = "Test selection",
                    ParentArchetype = "Warrior",
                    PathType = "Heretical",
                    UnlockCost = 0
                },
                new SpecializationDefinitionDto
                {
                    SpecializationId = "Skjaldmaer",
                    DisplayName = "Skjaldmaer",
                    Tagline = "The Living Shield",
                    Description = "Test description",
                    SelectionText = "Test selection",
                    ParentArchetype = "Warrior",
                    PathType = "Coherent",
                    UnlockCost = 0
                }
            }
        };
    }
}
```

---

## 11. Use Cases

### UC-001: Load Specializations at Startup

**Actor:** Application
**Precondition:** `specializations.json` exists
**Flow:**

1. DI container resolves `ISpecializationProvider`
2. Provider constructor invoked
3. Provider loads configuration via `IConfigurationLoader`
4. Provider maps DTOs to domain entities
5. Provider populates lookup caches
6. Provider validates all expected definitions loaded

**Postcondition:** Provider ready for queries

### UC-002: Get Specializations for Character Creation

**Actor:** Character Creation UI
**Precondition:** Player selected archetype
**Flow:**

1. UI calls `provider.GetByArchetype(selectedArchetype)`
2. Provider returns cached list for archetype
3. UI displays specialization options to player

**Postcondition:** Player sees available specializations

### UC-003: Lookup Ability During Combat

**Actor:** Combat System
**Precondition:** Player uses specialization ability
**Flow:**

1. Combat system calls `provider.GetAbility(abilityId)`
2. Provider searches all specializations for matching ability
3. Provider returns ability and parent specialization
4. Combat system uses ability properties for execution

**Postcondition:** Ability found and combat proceeds

---

## 12. Deliverable Checklist

### Interfaces

- [ ] `ISpecializationProvider.cs` with all query methods
- [ ] XML documentation with examples

### Implementation

- [ ] `SpecializationProvider.cs` with caching and loading
- [ ] `LoadSpecializations()` method
- [ ] `MapToDefinition()` method
- [ ] All query implementations

### DTOs

- [ ] `SpecializationsConfigDto.cs`
- [ ] `SpecializationDefinitionDto`
- [ ] `SpecialResourceDto`
- [ ] `AbilityTierDto`
- [ ] `SpecializationAbilityDto`

### Registration

- [ ] Singleton registration in `DependencyInjection.cs`

### Testing

- [ ] `SpecializationProviderTests.cs` with ~3 tests
- [ ] Mock configuration loader
- [ ] All tests passing

### Documentation

- [ ] XML documentation on all public types and members
- [ ] Examples in interface documentation

---

## 13. Acceptance Criteria

### Functional

- [ ] Provider loads all 17 specializations from configuration
- [ ] `GetBySpecializationId()` returns correct definition for each ID
- [ ] `GetByArchetype()` returns correct subset for each archetype
- [ ] `GetHereticalSpecializations()` returns exactly 5 definitions
- [ ] `GetCoherentSpecializations()` returns exactly 12 definitions
- [ ] `GetWithSpecialResource()` returns specializations with resources
- [ ] `GetAbility()` finds abilities by ID across all specializations
- [ ] `Exists()` correctly checks for loaded definitions
- [ ] `Count` property returns 17

### Quality

- [ ] Build succeeds with 0 errors/warnings
- [ ] All ~3 unit tests pass
- [ ] Provider registered as singleton
- [ ] XML documentation complete on all public members
- [ ] Logging covers all key operations

---

## 14. Future Considerations

### Deferred to v0.17.4e

- **ISpecializationApplicationService**: Uses provider to apply specializations

### Deferred to v0.17.5

- **Character Creation Integration**: UI consumes provider data

### Deferred to Future Versions

- **Hot Reload**: Reloading definitions without restart
- **Modding Support**: Loading from multiple configuration sources

---

## 15. Implementation Notes

### 15.1 Singleton Lifetime

Provider is registered as singleton because:

- Configuration is static (doesn't change at runtime)
- Loading is expensive (file I/O, parsing, validation)
- All consumers share the same data

### 15.2 O(1) Lookup Strategy

Multiple dictionaries provide O(1) access for common queries:

- `_byId`: Direct ID lookup
- `_byArchetype`: Pre-grouped by archetype
- `_heretical` / `_coherent`: Pre-filtered by path type

### 15.3 Error Handling

Provider uses defensive error handling:

- Individual definition failures don't fail entire load
- Missing definitions logged as warnings
- Empty configuration logged as warning, not error

### 15.4 GetAbility Performance

`GetAbility()` is O(n) where n = total abilities. For 17 specializations × 9 abilities = 153 abilities, this is acceptable. If performance becomes an issue, a separate ability ID dictionary can be added.

---

## 16. Document Metadata

---

_Document Version: 1.0_
_Last Updated: 2026-01-27_
_Author: Claude_
