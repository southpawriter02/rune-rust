# v0.39.1: 3D Vertical Layer System

Type: Technical
Description: 3D coordinate system with 7 vertical layers, 5 connection types, spatial layout algorithm
Priority: Must-Have
Status: In Design
Target Version: Alpha
Dependencies: v0.10, v0.39
Implementation Difficulty: Hard
Balance Validated: No
Parent item: v0.39: Advanced Dynamic Room Engine (v0%2039%20Advanced%20Dynamic%20Room%20Engine%20ea7030c7db18486d90330325a4e97005.md)
Proof-of-Concept Flag: No
Template Validated: No
Voice Validated: No

**Status:** Design Phase

**Prerequisites:** v0.10 (Dynamic Room Engine - Core), v0.39 (Parent Specification)

**Timeline:** 20-30 hours (3-4 weeks part-time)

**Goal:** Transform abstract graph-based room connectivity into spatially-aware 3D coordinate system

**Philosophy:** Rooms exist in real 3D space with vertical traversal mechanics

---

## I. Executive Summary

v0.39.1 implements the **foundational 3D spatial system** that enables vertical exploration and multi-level dungeon structures. This transforms the Dynamic Room Engine from abstract graph nodes into rooms with physical X, Y, Z coordinates.

**What v0.39.1 Delivers:**

- 3D coordinate system (X, Y, Z) with origin at Entry Hall
- 7 vertical layers spanning -300m to +300m
- 5 vertical connection types (stairs, shafts, elevators, ladders, collapsed)
- Spatial layout algorithm converting graphs to 3D coordinates
- Vertical pathfinding ensuring all layers are reachable
- Spatial validation preventing room overlaps

**Why This Matters:**

Current v0.10-v0.12 system has **no spatial awareness**:

- Rooms are nodes in an abstract graph
- "North" is just an edge label, not a coordinate
- Can't answer "what room is directly above/below?"
- Breaks immersion when descriptions mention depth

**v0.39.1 Solution:**

- Every room has (X, Y, Z) coordinates
- Vertical connections are explicit (stairs, shafts, etc.)
- Can query spatial relationships
- Foundation for vertical combat tactics

---

## II. 3D Coordinate System Design

### Coordinate Space Definition

```csharp
public struct RoomPosition
{
    public int X { get; set; }  // East (+) / West (-)
    public int Y { get; set; }  // North (+) / South (-)
    public int Z { get; set; }  // Up (+) / Down (-)
    
    public static readonly RoomPosition Origin = new RoomPosition(0, 0, 0);
}
```

**Axis Definitions:**

- **X-Axis (Horizontal):** East = positive, West = negative
- **Y-Axis (Horizontal):** North = positive, South = negative
- **Z-Axis (Vertical):** Up = positive, Down = negative
- **Origin Point:** Entry Hall always at (0, 0, 0)
- **Unit Size:** 1 coordinate unit = 1 room space (variable meters based on room size)

**Room Spatial Footprints:**

```jsx
Small Room:  1×1×1 units (10m × 10m × 3m typical)
Medium Room: 2×2×1 units (20m × 20m × 3m typical)
Large Room:  3×3×1 units (30m × 30m × 5m typical)
Vertical Shaft: 1×1×N units (spans multiple Z levels)
```

### Vertical Layer System

```csharp
public enum VerticalLayer
{
    DeepRoots = -3,      // Z=-3: -300 meters (ancient deep infrastructure)
    LowerRoots = -2,     // Z=-2: -200 meters (maintenance tunnels)
    UpperRoots = -1,     // Z=-1: -100 meters (lower facility levels)
    GroundLevel = 0,     // Z=0:  Entry level (origin)
    LowerTrunk = 1,      // Z=+1: +100 meters (mid-facility)
    UpperTrunk = 2,      // Z=+2: +200 meters (upper facility)
    Canopy = 3           // Z=+3: +300 meters (surface exposure)
}

public static class VerticalLayerExtensions
{
    public static int GetApproximateDepth(this VerticalLayer layer)
    {
        return layer switch
        {
            VerticalLayer.DeepRoots => -300,
            VerticalLayer.LowerRoots => -200,
            VerticalLayer.UpperRoots => -100,
            VerticalLayer.GroundLevel => 0,
            VerticalLayer.LowerTrunk => 100,
            VerticalLayer.UpperTrunk => 200,
            VerticalLayer.Canopy => 300,
            _ => 0
        };
    }
    
    public static string GetLayerDescription(this VerticalLayer layer)
    {
        return layer switch
        {
            VerticalLayer.DeepRoots => "Deep infrastructure levels, oldest sections",
            VerticalLayer.LowerRoots => "Lower maintenance tunnels and service passages",
            VerticalLayer.UpperRoots => "Upper maintenance levels, geothermal systems",
            VerticalLayer.GroundLevel => "Primary access level, main chambers",
            VerticalLayer.LowerTrunk => "Mid-facility, administrative and processing",
            VerticalLayer.UpperTrunk => "Upper facility, observation and control",
            VerticalLayer.Canopy => "Surface exposure, environmental interface",
            _ => "Unknown layer"
        };
    }
}
```

**Layer Characteristics:**

| Layer | Z | Depth | Typical Biomes | Characteristics |
| --- | --- | --- | --- | --- |
| Deep Roots | -3 | -300m | The Roots, Jötunheim | Ancient, heavily decayed, rare |
| Lower Roots | -2 | -200m | The Roots, Muspelheim | Geothermal, steam vents, hot |
| Upper Roots | -1 | -100m | The Roots, Niflheim | Cooling systems, frozen zones |
| Ground Level | 0 | 0m | Any | Entry point, most common |
| Lower Trunk | +1 | +100m | Jötunheim, Alfheim | Industrial, Aetheric resonance |
| Upper Trunk | +2 | +200m | Alfheim | High Aetheric energy |
| Canopy | +3 | +300m | Alfheim | Exposed to ash-filled sky |

---

## III. Vertical Connection Types

### Connection Type Definitions

```csharp
public enum VerticalConnectionType
{
    Stairs,      // Gradual ascent/descent, no checks required
    Shaft,       // Open vertical drop, requires climbing
    Elevator,    // Mechanical lift, may be powered or broken
    Ladder,      // Fixed climbing route, check required
    Collapsed    // Blocked passage, requires clearing
}

public class VerticalConnection
{
    public string ConnectionId { get; set; }
    public string FromRoomId { get; set; }
    public string ToRoomId { get; set; }
    public VerticalConnectionType Type { get; set; }
    public int TraversalDC { get; set; }  // Skill check difficulty
    public bool IsBlocked { get; set; }
    public string BlockageDescription { get; set; }
    
    // Z-level span
    public int LevelsSpanned { get; set; }
    
    // Descriptive elements
    public string Description { get; set; }
    public List<string> Hazards { get; set; }  // Hazards during traversal
}
```

### Traversal Mechanics by Type

**1. Stairs**

- **Use Case:** Standard vertical movement between 1-2 levels
- **Traversal:** Free action, no check required
- **Levels Spanned:** 1-2 Z levels
- **Description Examples:**
    - "Corroded metal stairs descend into darkness"
    - "Stone steps worn smooth by 800 years of neglect"
    - "Spiral staircase, rusted railing barely intact"

**2. Shaft**

- **Use Case:** Vertical drops requiring climbing or rappelling
- **Traversal:** MIGHT check (Athletics) DC 12
    - **Success:** Descend/ascend safely
    - **Failure (1-5):** 1d6 Physical damage from slipping
    - **Failure (6+):** 2d6 Physical damage + fall to bottom
- **Levels Spanned:** 2-4 Z levels
- **Description Examples:**
    - "Maintenance shaft plunges into the depths, handholds corroded"
    - "Vertical tunnel with exposed cable conduits for climbing"
    - "Broken elevator shaft, cables dangling uselessly"

**3. Elevator**

- **Use Case:** Mechanical transport, possibly functional
- **Traversal:**
    - **Powered:** Automatic, no check
    - **Unpowered:** WITS check (Repair) DC 15 to restore
    - **Alternative:** Climb shaft (treat as Shaft type)
- **Levels Spanned:** Any Z distance
- **Description Examples:**
    - "Cargo elevator, controls flickering weakly"
    - "Personnel lift, mechanism groaning ominously"
    - "Heavy freight platform suspended by fraying cables"

**4. Ladder**

- **Use Case:** Fixed climbing route, safer than open shaft
- **Traversal:** MIGHT check (Athletics) DC 10
    - **Success:** Ascend/descend safely
    - **Failure:** 1d4 Physical damage from slipping
- **Levels Spanned:** 1-3 Z levels
- **Description Examples:**
    - "Iron ladder bolted to wall, some rungs missing"
    - "Maintenance ladder with rust-eaten rungs"
    - "Emergency access ladder, structural integrity questionable"

**5. Collapsed**

- **Use Case:** Blocked passage requiring clearing
- **Traversal:** Requires obstacle removal
    - **MIGHT check (Athletics) DC 15:** Clear rubble (10 minutes)
    - **Explosive/Ability:** Blast through (instant, may cause damage)
    - **Alternative route:** Find another vertical connection
- **Levels Spanned:** N/A (blocked)
- **Description Examples:**
    - "Stairwell choked with debris from ceiling collapse"
    - "Shaft filled with twisted metal and rubble"
    - "Elevator crushed by structural failure"

### Vertical Connection Generation Rules

```csharp
public class VerticalConnectionGenerator
{
    public VerticalConnection GenerateConnection(
        Room fromRoom, 
        Room toRoom, 
        Random rng)
    {
        var zDifference = Math.Abs(toRoom.Position.Z - fromRoom.Position.Z);
        
        // Determine connection type based on Z distance
        var connectionType = SelectConnectionType(zDifference, rng);
        
        // Generate traversal difficulty
        var traversalDC = CalculateTraversalDC(connectionType, zDifference);
        
        // Check if connection is blocked (10% chance)
        var isBlocked = rng.NextDouble() < 0.10;
        
        return new VerticalConnection
        {
            FromRoomId = [fromRoom.Id](http://fromRoom.Id),
            ToRoomId = [toRoom.Id](http://toRoom.Id),
            Type = connectionType,
            TraversalDC = traversalDC,
            IsBlocked = isBlocked,
            LevelsSpanned = zDifference,
            Description = GenerateDescription(connectionType, isBlocked)
        };
    }
    
    private VerticalConnectionType SelectConnectionType(int zDifference, Random rng)
    {
        return zDifference switch
        {
            1 => rng.NextDouble() < 0.7 ? 
                VerticalConnectionType.Stairs : 
                VerticalConnectionType.Ladder,
            2 => rng.NextDouble() < 0.5 ? 
                VerticalConnectionType.Stairs : 
                VerticalConnectionType.Shaft,
            3 => rng.NextDouble() < 0.3 ? 
                VerticalConnectionType.Elevator : 
                VerticalConnectionType.Shaft,
            _ => VerticalConnectionType.Elevator  // 4+ levels requires elevator
        };
    }
}
```

---

## IV. Spatial Layout Algorithm

### Graph to 3D Conversion

**Problem:** v0.10 generates abstract graphs with no spatial coordinates.

**Solution:** Convert graph nodes to 3D positions using breadth-first traversal.

```csharp
public class SpatialLayoutService
{
    private readonly ILogger<SpatialLayoutService> _logger;
    
    public Sector ConvertGraphTo3DLayout(DungeonGraph graph, int seed)
    {
        var rng = new Random(seed);
        var positionedRooms = new Dictionary<string, RoomPosition>();
        
        // Step 1: Place Entry Hall at origin
        var startNode = graph.GetStartNode();
        positionedRooms[[startNode.Id](http://startNode.Id)] = RoomPosition.Origin;
        
        _logger.Information("Starting 3D layout: Origin={Origin}, Seed={Seed}",
            RoomPosition.Origin, seed);
        
        // Step 2: Breadth-first traversal to assign positions
        var queue = new Queue<DungeonNode>();
        queue.Enqueue(startNode);
        var visited = new HashSet<string> { [startNode.Id](http://startNode.Id) };
        
        while (queue.Count > 0)
        {
            var currentNode = queue.Dequeue();
            var currentPosition = positionedRooms[[currentNode.Id](http://currentNode.Id)];
            
            foreach (var edge in graph.GetEdgesFrom(currentNode))
            {
                if (visited.Contains([edge.To.Id](http://edge.To.Id))) continue;
                
                // Calculate new position based on direction
                var newPosition = CalculateNewPosition(
                    currentPosition, 
                    edge.Direction,
                    currentNode,
                    [edge.To](http://edge.To),
                    rng);
                
                // Validate no overlap
                if (IsPositionOccupied(positionedRooms.Values, newPosition))
                {
                    newPosition = FindNearbyUnoccupiedPosition(
                        newPosition, 
                        positionedRooms.Values);
                }
                
                positionedRooms[[edge.To.Id](http://edge.To.Id)] = newPosition;
                visited.Add([edge.To.Id](http://edge.To.Id));
                queue.Enqueue([edge.To](http://edge.To));
                
                _logger.Debug("Positioned room: {RoomId} at {Position}",
                    [edge.To.Id](http://edge.To.Id), newPosition);
            }
        }
        
        // Step 3: Add vertical connections
        AddVerticalConnections(graph, positionedRooms, rng);
        
        // Step 4: Convert to Sector with positioned rooms
        return CreateSectorFromPositions(graph, positionedRooms);
    }
    
    private RoomPosition CalculateNewPosition(
        RoomPosition current,
        Direction direction,
        DungeonNode fromNode,
        DungeonNode toNode,
        Random rng)
    {
        // Horizontal movement
        var newPosition = direction switch
        {
            Direction.North => new RoomPosition(current.X, current.Y + 1, current.Z),
            Direction.South => new RoomPosition(current.X, current.Y - 1, current.Z),
            Direction.East => new RoomPosition(current.X + 1, current.Y, current.Z),
            Direction.West => new RoomPosition(current.X - 1, current.Y, current.Z),
            _ => current
        };
        
        // Vertical movement: 30% chance to change Z level
        if (rng.NextDouble() < 0.30)
        {
            var zDelta = DetermineVerticalChange(fromNode, toNode, rng);
            newPosition = new RoomPosition(
                newPosition.X, 
                newPosition.Y, 
                newPosition.Z + zDelta);
        }
        
        return newPosition;
    }
    
    private int DetermineVerticalChange(
        DungeonNode fromNode, 
        DungeonNode toNode, 
        Random rng)
    {
        // Boss rooms tend to be deeper (negative Z)
        if (toNode.Type == NodeType.Boss)
        {
            return [rng.Next](http://rng.Next)(-2, 0);  // -2, -1, or 0
        }
        
        // Secret rooms can be anywhere
        if (toNode.Type == NodeType.Secret)
        {
            return [rng.Next](http://rng.Next)(-2, 2);  // -2 to +1
        }
        
        // Main path: gradual descent
        return [rng.Next](http://rng.Next)(-1, 1);  // -1, 0, or 0 (bias toward same level or down)
    }
    
    private void AddVerticalConnections(
        DungeonGraph graph,
        Dictionary<string, RoomPosition> positions,
        Random rng)
    {
        var verticalConnections = new List<VerticalConnection>();
        
        // Find room pairs with same X,Y but different Z
        foreach (var room1 in positions)
        {
            foreach (var room2 in positions)
            {
                if (room1.Key == room2.Key) continue;
                
                var pos1 = room1.Value;
                var pos2 = room2.Value;
                
                // Check if directly above/below
                if (pos1.X == pos2.X && pos1.Y == pos2.Y && pos1.Z != pos2.Z)
                {
                    var zDifference = Math.Abs(pos1.Z - pos2.Z);
                    
                    // Only connect adjacent or near-adjacent levels
                    if (zDifference <= 3)
                    {
                        var connection = GenerateVerticalConnection(
                            room1.Key,
                            room2.Key,
                            zDifference,
                            rng);
                        
                        verticalConnections.Add(connection);
                    }
                }
            }
        }
        
        _logger.Information("Generated {Count} vertical connections",
            verticalConnections.Count);
    }
}
```

---

## V. Database Schema

### Table Modifications

```sql
-- =====================================================
-- ALTER EXISTING ROOMS TABLE
-- =====================================================

ALTER TABLE Rooms ADD COLUMN coord_x INTEGER DEFAULT 0;
ALTER TABLE Rooms ADD COLUMN coord_y INTEGER DEFAULT 0;
ALTER TABLE Rooms ADD COLUMN coord_z INTEGER DEFAULT 0;
ALTER TABLE Rooms ADD COLUMN vertical_layer TEXT; -- DeepRoots, LowerRoots, etc.

CREATE INDEX idx_rooms_position ON Rooms(coord_x, coord_y, coord_z);
CREATE INDEX idx_rooms_layer ON Rooms(vertical_layer);

-- =====================================================
-- NEW: VERTICAL CONNECTIONS TABLE
-- =====================================================

CREATE TABLE Vertical_Connections (
    connection_id INTEGER PRIMARY KEY AUTOINCREMENT,
    from_room_id INTEGER NOT NULL,
    to_room_id INTEGER NOT NULL,
    connection_type TEXT NOT NULL, -- Stairs, Shaft, Elevator, Ladder, Collapsed
    traversal_dc INTEGER DEFAULT 0,
    is_blocked BOOLEAN DEFAULT 0,
    blockage_description TEXT,
    levels_spanned INTEGER DEFAULT 1,
    description TEXT,
    hazards TEXT, -- JSON array of hazards during traversal
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (from_room_id) REFERENCES Rooms(room_id) ON DELETE CASCADE,
    FOREIGN KEY (to_room_id) REFERENCES Rooms(room_id) ON DELETE CASCADE,
    
    CHECK (connection_type IN ('Stairs', 'Shaft', 'Elevator', 'Ladder', 'Collapsed')),
    CHECK (traversal_dc >= 0 AND traversal_dc <= 25),
    CHECK (levels_spanned >= 1 AND levels_spanned <= 6)
);

CREATE INDEX idx_vertical_from ON Vertical_Connections(from_room_id);
CREATE INDEX idx_vertical_to ON Vertical_Connections(to_room_id);
CREATE INDEX idx_vertical_type ON Vertical_Connections(connection_type);

-- =====================================================
-- NEW: SPATIAL VALIDATION TABLE (for debugging)
-- =====================================================

CREATE TABLE Spatial_Validation_Log (
    validation_id INTEGER PRIMARY KEY AUTOINCREMENT,
    sector_id INTEGER,
    validation_type TEXT, -- Overlap, Unreachable, MissingConnection
    severity TEXT, -- Warning, Error, Critical
    room_id_1 INTEGER,
    room_id_2 INTEGER,
    description TEXT,
    validated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (sector_id) REFERENCES Sectors(sector_id) ON DELETE CASCADE
);
```

### Example Data

```sql
-- Example: Entry Hall at origin
INSERT INTO Rooms (room_id, name, coord_x, coord_y, coord_z, vertical_layer)
VALUES (1, 'Collapsed Entry Hall', 0, 0, 0, 'GroundLevel');

-- Example: Corridor to the north
INSERT INTO Rooms (room_id, name, coord_x, coord_y, coord_z, vertical_layer)
VALUES (2, 'Rust-Choked Corridor', 0, 1, 0, 'GroundLevel');

-- Example: Chamber below entry hall
INSERT INTO Rooms (room_id, name, coord_x, coord_y, coord_z, vertical_layer)
VALUES (3, 'Geothermal Chamber', 0, 0, -1, 'UpperRoots');

-- Example: Stairs connecting entry hall to chamber
INSERT INTO Vertical_Connections (
    from_room_id, to_room_id, connection_type, 
    traversal_dc, levels_spanned, description
)
VALUES (
    1, 3, 'Stairs', 0, 1,
    'Corroded metal stairs descend into the geothermal levels. The steps are slick with condensation.'
);

-- Example: Blocked shaft
INSERT INTO Vertical_Connections (
    from_room_id, to_room_id, connection_type,
    traversal_dc, is_blocked, blockage_description, levels_spanned
)
VALUES (
    3, 5, 'Shaft', 12, 1,
    'The maintenance shaft is choked with debris from a ceiling collapse. Clearing it would take significant effort.',
    2
);
```

---

## VI. Service Implementation

### SpatialLayoutService

```csharp
public interface ISpatialLayoutService
{
    Sector ConvertGraphTo3DLayout(DungeonGraph graph, int seed);
    bool ValidateNoOverlaps(Sector sector);
    RoomPosition GetRoomPosition(string roomId);
    List<Room> GetRoomsAtLayer(VerticalLayer layer);
    List<Room> GetRoomsInRange(RoomPosition center, int radius);
}

public class SpatialLayoutService : ISpatialLayoutService
{
    private readonly ILogger<SpatialLayoutService> _logger;
    private readonly IVerticalConnectionGenerator _connectionGenerator;
    
    public Sector ConvertGraphTo3DLayout(DungeonGraph graph, int seed)
    {
        // Implementation shown in Section IV
    }
    
    public bool ValidateNoOverlaps(Sector sector)
    {
        var positions = new HashSet<RoomPosition>();
        
        foreach (var room in sector.Rooms)
        {
            var footprint = CalculateRoomFootprint(room);
            
            foreach (var position in footprint)
            {
                if (positions.Contains(position))
                {
                    _logger.Error("Room overlap detected: {RoomId} at {Position}",
                        [room.Id](http://room.Id), position);
                    return false;
                }
                positions.Add(position);
            }
        }
        
        return true;
    }
    
    private List<RoomPosition> CalculateRoomFootprint(Room room)
    {
        var footprint = new List<RoomPosition>();
        var size = GetRoomSizeUnits(room.Size);
        
        for (int x = 0; x < size; x++)
        {
            for (int y = 0; y < size; y++)
            {
                footprint.Add(new RoomPosition(
                    room.Position.X + x,
                    room.Position.Y + y,
                    room.Position.Z
                ));
            }
        }
        
        return footprint;
    }
    
    private int GetRoomSizeUnits(RoomSize size)
    {
        return size switch
        {
            RoomSize.Small => 1,
            RoomSize.Medium => 2,
            RoomSize.Large => 3,
            _ => 1
        };
    }
}
```

### VerticalTraversalService

```csharp
public interface IVerticalTraversalService
{
    VerticalConnection GetConnectionBetween(string fromRoomId, string toRoomId);
    bool CanTraverse(Character character, VerticalConnection connection);
    TraversalResult AttemptTraversal(Character character, VerticalConnection connection);
    List<string> GetReachableLayers(string startRoomId);
}

public class VerticalTraversalService : IVerticalTraversalService
{
    private readonly ILogger<VerticalTraversalService> _logger;
    private readonly ISkillCheckService _skillCheckService;
    
    public bool CanTraverse(Character character, VerticalConnection connection)
    {
        // Blocked connections require clearing first
        if (connection.IsBlocked)
        {
            return false;
        }
        
        // Stairs are always traversable
        if (connection.Type == VerticalConnectionType.Stairs)
        {
            return true;
        }
        
        // Other types require skill checks (evaluated during traversal)
        return true;
    }
    
    public TraversalResult AttemptTraversal(
        Character character, 
        VerticalConnection connection)
    {
        _logger.Information(
            "Character {CharId} attempting {ConnectionType} traversal, DC={DC}",
            [character.Id](http://character.Id), connection.Type, connection.TraversalDC);
        
        // Stairs: automatic success
        if (connection.Type == VerticalConnectionType.Stairs)
        {
            return TraversalResult.Success();
        }
        
        // Blocked: cannot traverse
        if (connection.IsBlocked)
        {
            return TraversalResult.Failure(
                "The passage is blocked. You must clear the obstruction first.");
        }
        
        // Shaft/Ladder: Athletics check
        if (connection.Type == VerticalConnectionType.Shaft ||
            connection.Type == VerticalConnectionType.Ladder)
        {
            var checkResult = _skillCheckService.ResolveCheck(
                character,
                Attribute.MIGHT,
                connection.TraversalDC,
                "Athletics");
            
            if (checkResult.Success)
            {
                _logger.Information(
                    "Traversal successful: {CharId} climbed {ConnectionType}",
                    [character.Id](http://character.Id), connection.Type);
                return TraversalResult.Success();
            }
            else
            {
                var damage = CalculateFallDamage(connection, checkResult.Margin);
                _logger.Warning(
                    "Traversal failed: {CharId} fell, Damage={Damage}",
                    [character.Id](http://character.Id), damage);
                return TraversalResult.Failure(
                    $"You slip and fall, taking {damage} Physical damage!",
                    damage);
            }
        }
        
        // Elevator: check if powered
        if (connection.Type == VerticalConnectionType.Elevator)
        {
            // TODO: Check power status
            return TraversalResult.Success();
        }
        
        return TraversalResult.Failure("Unknown connection type.");
    }
    
    private int CalculateFallDamage(
        VerticalConnection connection, 
        int checkMargin)
    {
        var baseDamage = connection.Type == VerticalConnectionType.Shaft ? 2 : 1;
        var marginDamage = Math.Abs(checkMargin) / 2;
        return (baseDamage + marginDamage) * 6;  // d6 per point
    }
}

public class TraversalResult
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public int Damage { get; set; }
    
    public static TraversalResult Success()
    {
        return new TraversalResult 
        { 
            Success = true, 
            Message = "You traverse the connection safely." 
        };
    }
    
    public static TraversalResult Failure(string message, int damage = 0)
    {
        return new TraversalResult
        {
            Success = false,
            Message = message,
            Damage = damage
        };
    }
}
```

### SpatialValidationService

```csharp
public interface ISpatialValidationService
{
    List<ValidationIssue> ValidateSector(Sector sector);
    bool IsReachableFromOrigin(Room room, Sector sector);
    void LogValidationIssues(int sectorId, List<ValidationIssue> issues);
}

public class ValidationIssue
{
    public string Type { get; set; }  // Overlap, Unreachable, MissingConnection
    public string Severity { get; set; }  // Warning, Error, Critical
    public string Description { get; set; }
    public List<string> AffectedRoomIds { get; set; }
}

public class SpatialValidationService : ISpatialValidationService
{
    private readonly ILogger<SpatialValidationService> _logger;
    
    public List<ValidationIssue> ValidateSector(Sector sector)
    {
        var issues = new List<ValidationIssue>();
        
        // Check 1: No room overlaps
        issues.AddRange(CheckForOverlaps(sector));
        
        // Check 2: All rooms reachable from origin
        issues.AddRange(CheckReachability(sector));
        
        // Check 3: Vertical connections have valid targets
        issues.AddRange(CheckVerticalConnections(sector));
        
        // Check 4: No rooms exceed layer bounds (-3 to +3)
        issues.AddRange(CheckLayerBounds(sector));
        
        _logger.Information(
            "Spatial validation complete: {IssueCount} issues found",
            issues.Count);
        
        return issues;
    }
    
    private List<ValidationIssue> CheckForOverlaps(Sector sector)
    {
        var issues = new List<ValidationIssue>();
        var occupiedPositions = new Dictionary<RoomPosition, string>();
        
        foreach (var room in sector.Rooms)
        {
            var footprint = CalculateRoomFootprint(room);
            
            foreach (var position in footprint)
            {
                if (occupiedPositions.ContainsKey(position))
                {
                    issues.Add(new ValidationIssue
                    {
                        Type = "Overlap",
                        Severity = "Critical",
                        Description = $"Room {[room.Id](http://room.Id)} overlaps with {occupiedPositions[position]} at {position}",
                        AffectedRoomIds = new List<string> { [room.Id](http://room.Id), occupiedPositions[position] }
                    });
                }
                else
                {
                    occupiedPositions[position] = [room.Id](http://room.Id);
                }
            }
        }
        
        return issues;
    }
    
    private List<ValidationIssue> CheckReachability(Sector sector)
    {
        var issues = new List<ValidationIssue>();
        var reachable = new HashSet<string>();
        
        // BFS from entry hall
        var queue = new Queue<Room>();
        var entryHall = sector.Rooms.First(r => r.Archetype == RoomArchetype.EntryHall);
        queue.Enqueue(entryHall);
        reachable.Add([entryHall.Id](http://entryHall.Id));
        
        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            
            // Check horizontal connections
            foreach (var exit in current.Exits)
            {
                var nextRoomId = exit.Value;
                if (!reachable.Contains(nextRoomId))
                {
                    var nextRoom = sector.Rooms.First(r => [r.Id](http://r.Id) == nextRoomId);
                    reachable.Add(nextRoomId);
                    queue.Enqueue(nextRoom);
                }
            }
            
            // Check vertical connections
            foreach (var connection in sector.VerticalConnections
                .Where(c => c.FromRoomId == [current.Id](http://current.Id) && !c.IsBlocked))
            {
                if (!reachable.Contains(connection.ToRoomId))
                {
                    var nextRoom = sector.Rooms.First(r => [r.Id](http://r.Id) == connection.ToRoomId);
                    reachable.Add(connection.ToRoomId);
                    queue.Enqueue(nextRoom);
                }
            }
        }
        
        // Find unreachable rooms
        var unreachableRooms = sector.Rooms
            .Where(r => !reachable.Contains([r.Id](http://r.Id)))
            .ToList();
        
        foreach (var room in unreachableRooms)
        {
            issues.Add(new ValidationIssue
            {
                Type = "Unreachable",
                Severity = "Error",
                Description = $"Room {[room.Id](http://room.Id)} ({[room.Name](http://room.Name)}) is not reachable from Entry Hall",
                AffectedRoomIds = new List<string> { [room.Id](http://room.Id) }
            });
        }
        
        return issues;
    }
}
```

---

## VII. Integration with v0.10 Graph Generation

### Modified Generation Pipeline

```csharp
public class DungeonGenerator
{
    private readonly ISpatialLayoutService _spatialLayoutService;
    private readonly IVerticalConnectionGenerator _verticalConnectionGenerator;
    private readonly ISpatialValidationService _validationService;
    
    public Sector Generate(int seed, SectorBlueprint blueprint)
    {
        var rng = new Random(seed);
        
        // STEP 1: Generate abstract graph (v0.10 UNCHANGED)
        var graph = GenerateGraph(blueprint, rng);
        
        _logger.Information(
            "Graph generated: {NodeCount} nodes, {EdgeCount} edges",
            graph.NodeCount, graph.EdgeCount);
        
        // STEP 2: Convert graph to 3D spatial layout (NEW - v0.39.1)
        var sector = _spatialLayoutService.ConvertGraphTo3DLayout(graph, seed);
        
        _logger.Information(
            "3D layout complete: {RoomCount} rooms positioned",
            sector.Rooms.Count);
        
        // STEP 3: Validate spatial coherence (NEW - v0.39.1)
        var validationIssues = _validationService.ValidateSector(sector);
        
        if (validationIssues.Any(i => i.Severity == "Critical"))
        {
            _logger.Error(
                "Critical spatial validation errors: {ErrorCount}",
                validationIssues.Count(i => i.Severity == "Critical"));
            throw new InvalidOperationException(
                "Sector generation failed spatial validation.");
        }
        
        // STEP 4: Continue with population (v0.11)
        // ...
        
        return sector;
    }
}
```

### Updated Room Model

```csharp
public class Room
{
    // Existing properties (v0.10)
    public string Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public RoomArchetype Archetype { get; set; }
    public Dictionary<Direction, string> Exits { get; set; }
    
    // NEW: 3D spatial properties (v0.39.1)
    public RoomPosition Position { get; set; }
    public VerticalLayer Layer { get; set; }
    public List<VerticalConnection> VerticalConnections { get; set; }
    
    // Helper methods
    public bool IsAtLayer(VerticalLayer layer) => Layer == layer;
    
    public bool HasVerticalConnectionTo(string roomId)
    {
        return VerticalConnections.Any(c => 
            c.ToRoomId == roomId && !c.IsBlocked);
    }
    
    public int GetDepthInMeters()
    {
        return Layer.GetApproximateDepth();
    }
}
```

---

## VIII. Testing Requirements

### Unit Tests (Target: 85%+ Coverage)

```csharp
[TestClass]
public class SpatialLayoutServiceTests
{
    [TestMethod]
    public void ConvertGraphTo3DLayout_EntryHallAtOrigin_Success()
    {
        // Arrange
        var graph = CreateTestGraph();
        var service = new SpatialLayoutService(Mock.Of<ILogger>(), null);
        
        // Act
        var sector = service.ConvertGraphTo3DLayout(graph, seed: 12345);
        
        // Assert
        var entryHall = sector.Rooms.First(r => r.Archetype == RoomArchetype.EntryHall);
        Assert.AreEqual(RoomPosition.Origin, entryHall.Position);
    }
    
    [TestMethod]
    public void ValidateNoOverlaps_OverlappingRooms_ReturnsFalse()
    {
        // Arrange
        var sector = new Sector
        {
            Rooms = new List<Room>
            {
                new Room { Id = "1", Position = new RoomPosition(0, 0, 0), Size = RoomSize.Medium },
                new Room { Id = "2", Position = new RoomPosition(1, 0, 0), Size = RoomSize.Medium }
            }
        };
        var service = new SpatialLayoutService(Mock.Of<ILogger>(), null);
        
        // Act
        var result = service.ValidateNoOverlaps(sector);
        
        // Assert
        Assert.IsFalse(result);
    }
    
    [TestMethod]
    public void GetRoomsAtLayer_DeepRootsLayer_ReturnsCorrectRooms()
    {
        // Arrange
        var sector = CreateTestSectorWithLayers();
        var service = new SpatialLayoutService(Mock.Of<ILogger>(), null);
        
        // Act
        var rooms = service.GetRoomsAtLayer(VerticalLayer.DeepRoots);
        
        // Assert
        Assert.AreEqual(2, rooms.Count);
        Assert.IsTrue(rooms.All(r => r.Layer == VerticalLayer.DeepRoots));
    }
}

[TestClass]
public class VerticalTraversalServiceTests
{
    [TestMethod]
    public void CanTraverse_BlockedConnection_ReturnsFalse()
    {
        // Arrange
        var connection = new VerticalConnection
        {
            Type = VerticalConnectionType.Stairs,
            IsBlocked = true
        };
        var service = new VerticalTraversalService(Mock.Of<ILogger>(), null);
        
        // Act
        var result = service.CanTraverse(CreateTestCharacter(), connection);
        
        // Assert
        Assert.IsFalse(result);
    }
    
    [TestMethod]
    public void AttemptTraversal_StairsConnection_AutoSuccess()
    {
        // Arrange
        var connection = new VerticalConnection
        {
            Type = VerticalConnectionType.Stairs,
            IsBlocked = false
        };
        var service = new VerticalTraversalService(Mock.Of<ILogger>(), null);
        
        // Act
        var result = service.AttemptTraversal(CreateTestCharacter(), connection);
        
        // Assert
        Assert.IsTrue(result.Success);
        Assert.AreEqual(0, result.Damage);
    }
    
    [TestMethod]
    public void AttemptTraversal_ShaftFailedCheck_TakesFallDamage()
    {
        // Arrange
        var connection = new VerticalConnection
        {
            Type = VerticalConnectionType.Shaft,
            TraversalDC = 12,
            LevelsSpanned = 2
        };
        
        var mockSkillCheck = new Mock<ISkillCheckService>();
        mockSkillCheck.Setup(s => s.ResolveCheck(
            It.IsAny<Character>(),
            Attribute.MIGHT,
            12,
            "Athletics"))
            .Returns(new SkillCheckResult { Success = false, Margin = -5 });
        
        var service = new VerticalTraversalService(
            Mock.Of<ILogger>(), 
            mockSkillCheck.Object);
        
        // Act
        var result = service.AttemptTraversal(CreateTestCharacter(), connection);
        
        // Assert
        Assert.IsFalse(result.Success);
        Assert.IsTrue(result.Damage > 0);
    }
}
```

### Integration Tests

```csharp
[TestClass]
public class SpatialLayoutIntegrationTests
{
    [TestMethod]
    public void FullPipeline_GenerateSectorWith3DLayout_Success()
    {
        // Arrange
        var generator = CreateDungeonGeneratorWithSpatialLayout();
        var blueprint = new SectorBlueprint
        {
            BiomeId = "the_roots",
            TargetRoomCount = 7,
            DifficultyTier = DifficultyTier.Normal
        };
        
        // Act
        var sector = generator.Generate(seed: 12345, blueprint);
        
        // Assert - Structural validity
        Assert.IsNotNull(sector);
        Assert.IsTrue(sector.Rooms.Count >= 5 && sector.Rooms.Count <= 7);
        
        // Assert - 3D coordinates assigned
        Assert.IsTrue(sector.Rooms.All(r => r.Position != null));
        
        // Assert - Entry hall at origin
        var entryHall = sector.Rooms.First(r => r.Archetype == RoomArchetype.EntryHall);
        Assert.AreEqual(RoomPosition.Origin, entryHall.Position);
        
        // Assert - Vertical connections exist
        var roomsWithVertical = sector.Rooms
            .Count(r => r.VerticalConnections.Any());
        Assert.IsTrue(roomsWithVertical >= 1);
        
        // Assert - No overlaps
        var validationService = new SpatialValidationService(Mock.Of<ILogger>());
        var issues = validationService.ValidateSector(sector);
        var criticalIssues = issues.Where(i => i.Severity == "Critical").ToList();
        Assert.AreEqual(0, criticalIssues.Count);
    }
}
```

---

## IX. Success Criteria

**v0.39.1 is DONE when:**

- [ ]  **3D Coordinate System:**
    - [ ]  RoomPosition struct implemented (X, Y, Z)
    - [ ]  All rooms have 3D coordinates after generation
    - [ ]  Entry Hall always at (0, 0, 0)
    - [ ]  Coordinate system documented
- [ ]  **Vertical Layer System:**
    - [ ]  7 vertical layers defined (-3 to +3)
    - [ ]  VerticalLayer enum implemented
    - [ ]  Rooms assigned to correct layers
    - [ ]  Layer descriptions available
- [ ]  **Vertical Connection Types:**
    - [ ]  5 connection types implemented
    - [ ]  Traversal mechanics functional
    - [ ]  Skill checks applied correctly
    - [ ]  Fall damage calculated
    - [ ]  Blocked passages preventable
- [ ]  **Spatial Layout Algorithm:**
    - [ ]  Graph-to-3D conversion works
    - [ ]  BFS traversal assigns positions
    - [ ]  Vertical connections generated
    - [ ]  No infinite loops
- [ ]  **Database Schema:**
    - [ ]  coord_x, coord_y, coord_z columns added
    - [ ]  Vertical_Connections table created
    - [ ]  Indexes created for performance
    - [ ]  Migration scripts tested
- [ ]  **Service Layer:**
    - [ ]  SpatialLayoutService operational
    - [ ]  VerticalTraversalService operational
    - [ ]  SpatialValidationService operational
    - [ ]  All interfaces documented
- [ ]  **Integration:**
    - [ ]  v0.10 graph generation unaffected
    - [ ]  3D layout generated after graph
    - [ ]  Room model updated with Position
    - [ ]  Navigation commands support up/down
- [ ]  **Validation:**
    - [ ]  No room overlaps
    - [ ]  All rooms reachable from origin
    - [ ]  Vertical connections valid
    - [ ]  Layer bounds respected
- [ ]  **Testing:**
    - [ ]  85%+ unit test coverage
    - [ ]  15+ unit tests passing
    - [ ]  3+ integration tests passing
    - [ ]  Performance < 500ms for 3D conversion
- [ ]  **Documentation:**
    - [ ]  Complete architecture documentation
    - [ ]  Database schema documented
    - [ ]  Service API documented
    - [ ]  Traversal mechanics documented
- [ ]  **Logging:**
    - [ ]  Serilog structured logging throughout
    - [ ]  Position assignments logged
    - [ ]  Validation issues logged
    - [ ]  Traversal attempts logged

---

## X. Timeline

**Week 1: Core 3D System (8-10 hours)**

- RoomPosition struct
- Coordinate system implementation
- Database schema migration
- VerticalLayer enum

**Week 2: Spatial Layout Algorithm (8-10 hours)**

- Graph-to-3D conversion
- BFS position assignment
- Overlap detection
- SpatialLayoutService

**Week 3: Vertical Connections (6-8 hours)**

- VerticalConnection model
- Connection type generation
- VerticalTraversalService
- Traversal mechanics

**Week 4: Validation & Testing (6-8 hours)**

- SpatialValidationService
- Unit tests (15+)
- Integration tests (3+)
- Performance optimization

**Total: 20-30 hours (3-4 weeks part-time)**

---

**Ready to build vertical exploration into Aethelgard.**