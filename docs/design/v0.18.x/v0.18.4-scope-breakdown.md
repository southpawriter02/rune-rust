# v0.18.4 Scope Breakdown: Specialization Resources

## Overview

v0.18.4 implements **Specialization Resources** — unique secondary resources that power specialized playstyles. These include Rage (Berserker), Momentum (Skirmisher), and Coherence (Skald/Thul). Each resource has distinct generation, decay, and threshold mechanics.

---

## Feature Tree

```
v0.18.4 — Specialization Resources
├── Domain Layer
│   ├── Rage System
│   │   ├── RageState (entity)
│   │   ├── RageThreshold (enum)
│   │   ├── RageSource (enum)
│   │   └── ControlCheckResult (record)
│   │
│   ├── Momentum System
│   │   ├── MomentumState (entity)
│   │   ├── MomentumThreshold (enum)
│   │   ├── MomentumSource (enum)
│   │   └── CascadeState (record)
│   │
│   └── Coherence System
│       ├── CoherenceState (entity)
│       ├── CoherenceThreshold (enum)
│       ├── CoherenceSource (enum)
│       └── ApotheosisState (record)
│
├── Application Layer
│   ├── IRageService (interface)
│   ├── RageService (implementation)
│   ├── IMomentumService (interface)
│   ├── MomentumService (implementation)
│   ├── ICoherenceService (interface)
│   └── CoherenceService (implementation)
│
├── Infrastructure Layer
│   └── Database schema extensions
│
├── Configuration
│   ├── rage_config.json
│   ├── momentum_config.json
│   └── coherence_config.json
│
└── Tests (~20 unit tests)
```

---

## In Scope

### Rage System (Berserker)

#### RageThreshold Enum

```csharp
/// <summary>
/// Defines the Rage level tiers for Berserker scaling.
/// Higher Rage grants damage and speed bonuses but risks control loss.
/// </summary>
public enum RageThreshold
{
    /// <summary>0-24 Rage: No bonus.</summary>
    Calm = 0,

    /// <summary>25-49 Rage: +15% damage, +1 Initiative.</summary>
    Simmering = 1,

    /// <summary>50-74 Rage: +30% damage, +2 Initiative.</summary>
    Angry = 2,

    /// <summary>75-99 Rage: +50% damage, +3 Initiative, attack-only lock.</summary>
    Furious = 3,

    /// <summary>100 Rage: +75% damage, +4 Initiative, Control Check required.</summary>
    Rampage = 4
}
```

#### RageSource Enum

```csharp
/// <summary>
/// Sources of Rage generation for Berserkers.
/// </summary>
public enum RageSource
{
    /// <summary>Dealing damage to enemies (+5 per 10 damage).</summary>
    DamageDealt,

    /// <summary>Receiving damage (+10 per 10 damage).</summary>
    DamageTaken,

    /// <summary>Killing an enemy (+15).</summary>
    EnemyKill,

    /// <summary>Ally dropping to 0 HP (+20).</summary>
    AllyDown,

    /// <summary>Rage ability usage (variable).</summary>
    AbilityUse
}
```

#### RageState Entity

```csharp
/// <summary>
/// Tracks Rage state for a Berserker character.
/// Rage builds in combat and decays outside combat.
/// </summary>
public sealed class RageState
{
    /// <summary>Character this state belongs to.</summary>
    public Guid CharacterId { get; init; }

    /// <summary>Current Rage value (0-100).</summary>
    public int CurrentRage { get; private set; }

    /// <summary>Maximum Rage cap.</summary>
    public const int MaxRage = 100;

    /// <summary>Rounds since combat ended (for decay timing).</summary>
    public int RoundsSinceCombat { get; private set; }

    /// <summary>Rounds before decay begins after combat.</summary>
    public const int DecayGracePeriod = 3;

    /// <summary>Decay amount per round outside combat.</summary>
    public const int DecayPerRound = 10;

    /// <summary>Gets the current Rage threshold.</summary>
    public RageThreshold Threshold => CurrentRage switch
    {
        < 25 => RageThreshold.Calm,
        < 50 => RageThreshold.Simmering,
        < 75 => RageThreshold.Angry,
        < 100 => RageThreshold.Furious,
        _ => RageThreshold.Rampage
    };

    /// <summary>Gets the damage bonus percentage.</summary>
    public int DamageBonusPercent => Threshold switch
    {
        RageThreshold.Calm => 0,
        RageThreshold.Simmering => 15,
        RageThreshold.Angry => 30,
        RageThreshold.Furious => 50,
        RageThreshold.Rampage => 75,
        _ => 0
    };

    /// <summary>Gets the Initiative bonus.</summary>
    public int InitiativeBonus => (int)Threshold;

    /// <summary>Whether only attack actions are allowed.</summary>
    public bool AttackOnlyLock => CurrentRage >= 75;

    /// <summary>Whether a Control Check is required.</summary>
    public bool RequiresControlCheck => CurrentRage >= 100;

    /// <summary>Adds Rage from a source.</summary>
    public RageChangeResult AddRage(int amount, RageSource source)
    {
        var oldValue = CurrentRage;
        var oldThreshold = Threshold;
        CurrentRage = Math.Min(CurrentRage + amount, MaxRage);
        RoundsSinceCombat = 0; // Reset decay timer

        return new RageChangeResult
        {
            PreviousRage = oldValue,
            NewRage = CurrentRage,
            AmountChanged = CurrentRage - oldValue,
            Source = source,
            PreviousThreshold = oldThreshold,
            NewThreshold = Threshold,
            RequiresControlCheck = RequiresControlCheck
        };
    }

    /// <summary>Spends Rage for an ability.</summary>
    public bool SpendRage(int cost)
    {
        if (CurrentRage < cost) return false;
        CurrentRage -= cost;
        return true;
    }

    /// <summary>Applies decay outside combat.</summary>
    public int ApplyDecay()
    {
        RoundsSinceCombat++;
        if (RoundsSinceCombat <= DecayGracePeriod) return 0;

        var decayAmount = Math.Min(CurrentRage, DecayPerRound);
        CurrentRage -= decayAmount;
        return decayAmount;
    }

    /// <summary>Dumps all Rage for a massive attack.</summary>
    public int DumpRage()
    {
        var dumped = CurrentRage;
        CurrentRage = 0;
        return dumped;
    }
}
```

#### ControlCheckResult Record

```csharp
/// <summary>
/// Result of a Rage Control Check at 100 Rage.
/// </summary>
public sealed record ControlCheckResult
{
    /// <summary>Whether control was retained.</summary>
    public bool RetainedControl { get; init; }

    /// <summary>WILL dice rolled.</summary>
    public int DiceRolled { get; init; }

    /// <summary>Successes achieved.</summary>
    public int Successes { get; init; }

    /// <summary>DC required (default 3).</summary>
    public int Dc { get; init; }

    /// <summary>Forced target (if control lost).</summary>
    public Guid? ForcedTargetId { get; init; }

    /// <summary>Whether forced target is ally.</summary>
    public bool? TargetIsAlly { get; init; }
}
```

### Momentum System (Skirmisher)

#### MomentumThreshold Enum

```csharp
/// <summary>
/// Defines the Momentum level tiers for Skirmisher bonuses.
/// Momentum rewards aggressive, mobile combat.
/// </summary>
public enum MomentumThreshold
{
    /// <summary>0-24 Momentum: No bonus.</summary>
    Static = 0,

    /// <summary>25-49 Momentum: +1 Defense.</summary>
    Moving = 1,

    /// <summary>50-74 Momentum: +2 Defense.</summary>
    Flowing = 2,

    /// <summary>75-99 Momentum: +3 Defense, Bonus Move action.</summary>
    Swift = 3,

    /// <summary>100 Momentum: +4 Defense, Cascade State (+25% damage).</summary>
    Cascade = 4
}
```

#### MomentumSource Enum

```csharp
/// <summary>
/// Sources of Momentum generation for Skirmishers.
/// </summary>
public enum MomentumSource
{
    /// <summary>Move + Attack in same turn (+15).</summary>
    MoveAndAttack,

    /// <summary>Successful hit (+10).</summary>
    Hit,

    /// <summary>Successfully dodging an attack (+15).</summary>
    Dodge,

    /// <summary>Killing an enemy (+20).</summary>
    Kill,

    /// <summary>Chaining 3+ abilities (+25).</summary>
    AbilityChain
}
```

#### MomentumDecayReason Enum

```csharp
/// <summary>
/// Reasons for Momentum decay.
/// </summary>
public enum MomentumDecayReason
{
    /// <summary>Ended turn without attacking (-20).</summary>
    NoAttack,

    /// <summary>Used Defend action (-15).</summary>
    Defend,

    /// <summary>Took a hit (-10).</summary>
    TookHit,

    /// <summary>Got stunned or disabled (-30).</summary>
    Disabled
}
```

#### MomentumState Entity

```csharp
/// <summary>
/// Tracks Momentum state for a Skirmisher character.
/// Momentum rewards continuous aggressive action.
/// </summary>
public sealed class MomentumState
{
    /// <summary>Character this state belongs to.</summary>
    public Guid CharacterId { get; init; }

    /// <summary>Current Momentum value (0-100).</summary>
    public int CurrentMomentum { get; private set; }

    /// <summary>Maximum Momentum cap.</summary>
    public const int MaxMomentum = 100;

    /// <summary>Threshold where Cascade ends.</summary>
    public const int CascadeExitThreshold = 75;

    /// <summary>Gets the current Momentum threshold.</summary>
    public MomentumThreshold Threshold => CurrentMomentum switch
    {
        < 25 => MomentumThreshold.Static,
        < 50 => MomentumThreshold.Moving,
        < 75 => MomentumThreshold.Flowing,
        < 100 => MomentumThreshold.Swift,
        _ => MomentumThreshold.Cascade
    };

    /// <summary>Gets the Defense bonus.</summary>
    public int DefenseBonus => (int)Threshold;

    /// <summary>Whether a Bonus Move action is granted.</summary>
    public bool HasBonusMove => CurrentMomentum >= 75;

    /// <summary>Whether in Cascade State (+25% damage).</summary>
    public bool InCascade { get; private set; }

    /// <summary>Cascade damage bonus percentage.</summary>
    public int CascadeDamageBonus => InCascade ? 25 : 0;

    /// <summary>Adds Momentum from a source.</summary>
    public MomentumChangeResult AddMomentum(int amount, MomentumSource source)
    {
        var oldValue = CurrentMomentum;
        var oldThreshold = Threshold;
        CurrentMomentum = Math.Min(CurrentMomentum + amount, MaxMomentum);

        // Enter Cascade at 100
        if (CurrentMomentum >= 100 && !InCascade)
        {
            InCascade = true;
        }

        return new MomentumChangeResult
        {
            PreviousMomentum = oldValue,
            NewMomentum = CurrentMomentum,
            AmountChanged = CurrentMomentum - oldValue,
            Source = source,
            PreviousThreshold = oldThreshold,
            NewThreshold = Threshold,
            EnteredCascade = InCascade && !oldThreshold.Equals(MomentumThreshold.Cascade)
        };
    }

    /// <summary>Reduces Momentum from decay.</summary>
    public MomentumChangeResult ReduceMomentum(int amount, MomentumDecayReason reason)
    {
        var oldValue = CurrentMomentum;
        var oldThreshold = Threshold;
        var wasInCascade = InCascade;

        CurrentMomentum = Math.Max(CurrentMomentum - amount, 0);

        // Exit Cascade below threshold
        if (InCascade && CurrentMomentum < CascadeExitThreshold)
        {
            InCascade = false;
        }

        return new MomentumChangeResult
        {
            PreviousMomentum = oldValue,
            NewMomentum = CurrentMomentum,
            AmountChanged = oldValue - CurrentMomentum,
            DecayReason = reason,
            PreviousThreshold = oldThreshold,
            NewThreshold = Threshold,
            ExitedCascade = wasInCascade && !InCascade
        };
    }

    /// <summary>Spends Momentum for an ability.</summary>
    public bool SpendMomentum(int cost)
    {
        if (CurrentMomentum < cost) return false;
        var oldInCascade = InCascade;
        CurrentMomentum -= cost;

        if (InCascade && CurrentMomentum < CascadeExitThreshold)
        {
            InCascade = false;
        }
        return true;
    }
}
```

#### MomentumChangeResult Record

```csharp
/// <summary>
/// Result of a Momentum change.
/// </summary>
public sealed record MomentumChangeResult
{
    public int PreviousMomentum { get; init; }
    public int NewMomentum { get; init; }
    public int AmountChanged { get; init; }
    public MomentumSource? Source { get; init; }
    public MomentumDecayReason? DecayReason { get; init; }
    public MomentumThreshold PreviousThreshold { get; init; }
    public MomentumThreshold NewThreshold { get; init; }
    public bool EnteredCascade { get; init; }
    public bool ExitedCascade { get; init; }
}
```

### Coherence System (Skald/Thul)

#### CoherenceThreshold Enum

```csharp
/// <summary>
/// Defines the Coherence level tiers for Skald/Thul narrative power.
/// Coherence represents the power of story to impose order on reality.
/// </summary>
public enum CoherenceThreshold
{
    /// <summary>0 Coherence: No narrative power.</summary>
    Silent = 0,

    /// <summary>1-24 Coherence: Minor buffs available.</summary>
    Whispering = 1,

    /// <summary>25-49 Coherence: Standard saga powers, +1 party Stress resist.</summary>
    Speaking = 2,

    /// <summary>50-74 Coherence: Powerful declarations, +2 party Stress resist.</summary>
    Declaiming = 3,

    /// <summary>75-99 Coherence: Reality-bending speech, Fear Immunity.</summary>
    Proclaiming = 4,

    /// <summary>100 Coherence: Ultimate narrative control, Anti-Corruption aura.</summary>
    Apotheosis = 5
}
```

#### CoherenceSource Enum

```csharp
/// <summary>
/// Sources of Coherence generation for Skalds/Thuls.
/// </summary>
public enum CoherenceSource
{
    /// <summary>Successful Rhetoric skill check (+10).</summary>
    RhetoricCheck,

    /// <summary>Tell inspiring tale ability (+15).</summary>
    InspiringTale,

    /// <summary>Ally succeeds dramatically (+10).</summary>
    AllyDramaticSuccess,

    /// <summary>Identify enemy weakness (+5).</summary>
    EnemyAnalysis,

    /// <summary>Party survives dire situation (+20).</summary>
    DireSurvival
}
```

#### CoherenceDecayReason Enum

```csharp
/// <summary>
/// Reasons for Coherence decay.
/// </summary>
public enum CoherenceDecayReason
{
    /// <summary>Passive decay in combat (-5 per turn).</summary>
    PassiveCombat,

    /// <summary>Ally falls unconscious (-15).</summary>
    AllyDown,

    /// <summary>Failed Rhetoric check (-10).</summary>
    FailedRhetoric,

    /// <summary>Witness corruption event (-20).</summary>
    CorruptionEvent
}
```

#### CoherenceState Entity

```csharp
/// <summary>
/// Tracks Coherence state for a Skald or Thul character.
/// Coherence provides party-wide narrative buffs.
/// </summary>
public sealed class CoherenceState
{
    /// <summary>Character this state belongs to.</summary>
    public Guid CharacterId { get; init; }

    /// <summary>Current Coherence value (0-100).</summary>
    public int CurrentCoherence { get; private set; }

    /// <summary>Maximum Coherence cap.</summary>
    public const int MaxCoherence = 100;

    /// <summary>Passive decay per combat turn.</summary>
    public const int PassiveDecayPerTurn = 5;

    /// <summary>Gets the current Coherence threshold.</summary>
    public CoherenceThreshold Threshold => CurrentCoherence switch
    {
        0 => CoherenceThreshold.Silent,
        < 25 => CoherenceThreshold.Whispering,
        < 50 => CoherenceThreshold.Speaking,
        < 75 => CoherenceThreshold.Declaiming,
        < 100 => CoherenceThreshold.Proclaiming,
        _ => CoherenceThreshold.Apotheosis
    };

    /// <summary>Party Stress Resistance bonus.</summary>
    public int PartyStressResistBonus => Threshold switch
    {
        CoherenceThreshold.Speaking => 1,
        CoherenceThreshold.Declaiming => 2,
        CoherenceThreshold.Proclaiming => 2,
        CoherenceThreshold.Apotheosis => 3,
        _ => 0
    };

    /// <summary>Whether party has Fear Immunity.</summary>
    public bool PartyFearImmunity => CurrentCoherence >= 75;

    /// <summary>Whether in Apotheosis state.</summary>
    public bool InApotheosis => CurrentCoherence >= 100;

    /// <summary>Whether Anti-Corruption aura is active.</summary>
    public bool AntiCorruptionAura => InApotheosis;

    /// <summary>Adds Coherence from a source.</summary>
    public CoherenceChangeResult AddCoherence(int amount, CoherenceSource source)
    {
        var oldValue = CurrentCoherence;
        var oldThreshold = Threshold;
        CurrentCoherence = Math.Min(CurrentCoherence + amount, MaxCoherence);

        return new CoherenceChangeResult
        {
            PreviousCoherence = oldValue,
            NewCoherence = CurrentCoherence,
            AmountChanged = CurrentCoherence - oldValue,
            Source = source,
            PreviousThreshold = oldThreshold,
            NewThreshold = Threshold,
            EnteredApotheosis = InApotheosis && oldValue < 100
        };
    }

    /// <summary>Reduces Coherence from decay.</summary>
    public CoherenceChangeResult ReduceCoherence(int amount, CoherenceDecayReason reason)
    {
        var oldValue = CurrentCoherence;
        var oldThreshold = Threshold;
        var wasInApotheosis = InApotheosis;

        CurrentCoherence = Math.Max(CurrentCoherence - amount, 0);

        return new CoherenceChangeResult
        {
            PreviousCoherence = oldValue,
            NewCoherence = CurrentCoherence,
            AmountChanged = oldValue - CurrentCoherence,
            DecayReason = reason,
            PreviousThreshold = oldThreshold,
            NewThreshold = Threshold,
            ExitedApotheosis = wasInApotheosis && !InApotheosis
        };
    }

    /// <summary>Spends Coherence for an ability.</summary>
    public bool SpendCoherence(int cost)
    {
        if (CurrentCoherence < cost) return false;
        CurrentCoherence -= cost;
        return true;
    }

    /// <summary>Applies passive combat decay.</summary>
    public int ApplyPassiveDecay()
    {
        var decayAmount = Math.Min(CurrentCoherence, PassiveDecayPerTurn);
        CurrentCoherence -= decayAmount;
        return decayAmount;
    }
}
```

#### CoherenceChangeResult Record

```csharp
/// <summary>
/// Result of a Coherence change.
/// </summary>
public sealed record CoherenceChangeResult
{
    public int PreviousCoherence { get; init; }
    public int NewCoherence { get; init; }
    public int AmountChanged { get; init; }
    public CoherenceSource? Source { get; init; }
    public CoherenceDecayReason? DecayReason { get; init; }
    public CoherenceThreshold PreviousThreshold { get; init; }
    public CoherenceThreshold NewThreshold { get; init; }
    public bool EnteredApotheosis { get; init; }
    public bool ExitedApotheosis { get; init; }
}
```

### Application Layer Interfaces

#### IRageService

```csharp
public interface IRageService
{
    RageState GetRageState(Guid characterId);
    RageChangeResult AddRage(Guid characterId, int amount, RageSource source);
    bool SpendRage(Guid characterId, int cost);
    int ApplyDecay(Guid characterId);
    int DumpRage(Guid characterId);
    ControlCheckResult PerformControlCheck(Guid characterId);
    int GetDamageBonusPercent(Guid characterId);
    int GetInitiativeBonus(Guid characterId);
}
```

#### IMomentumService

```csharp
public interface IMomentumService
{
    MomentumState GetMomentumState(Guid characterId);
    MomentumChangeResult AddMomentum(Guid characterId, int amount, MomentumSource source);
    MomentumChangeResult ReduceMomentum(Guid characterId, int amount, MomentumDecayReason reason);
    bool SpendMomentum(Guid characterId, int cost);
    bool IsInCascade(Guid characterId);
    int GetDefenseBonus(Guid characterId);
    int GetCascadeDamageBonus(Guid characterId);
}
```

#### ICoherenceService

```csharp
public interface ICoherenceService
{
    CoherenceState GetCoherenceState(Guid characterId);
    CoherenceChangeResult AddCoherence(Guid characterId, int amount, CoherenceSource source);
    CoherenceChangeResult ReduceCoherence(Guid characterId, int amount, CoherenceDecayReason reason);
    bool SpendCoherence(Guid characterId, int cost);
    int ApplyPassiveDecay(Guid characterId);
    int GetPartyStressResistBonus(Guid characterId);
    bool HasPartyFearImmunity(Guid characterId);
    bool IsInApotheosis(Guid characterId);
    void ApplyPartyBuffs(Guid narratorId, IEnumerable<Guid> partyMemberIds);
}
```

### Database Schema

```sql
-- Specialization resources table
CREATE TABLE IF NOT EXISTS character_spec_resources (
    character_id UUID PRIMARY KEY REFERENCES characters(id) ON DELETE CASCADE,

    -- Rage (Berserker)
    current_rage INT NOT NULL DEFAULT 0
        CONSTRAINT chk_rage_range CHECK (current_rage >= 0 AND current_rage <= 100),
    rounds_since_combat INT NOT NULL DEFAULT 0,

    -- Momentum (Skirmisher)
    current_momentum INT NOT NULL DEFAULT 0
        CONSTRAINT chk_momentum_range CHECK (current_momentum >= 0 AND current_momentum <= 100),
    in_cascade BOOLEAN NOT NULL DEFAULT false,

    -- Coherence (Skald/Thul)
    current_coherence INT NOT NULL DEFAULT 0
        CONSTRAINT chk_coherence_range CHECK (current_coherence >= 0 AND current_coherence <= 100),

    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_spec_resources_char ON character_spec_resources(character_id);
```

---

## Out of Scope

| Feature | Deferred To | Reason |
|---------|-------------|--------|
| Rage ability definitions | v0.20.x | Ability system |
| Momentum ability definitions | v0.20.x | Ability system |
| Coherence ability definitions | v0.20.x | Ability system |
| UI gauges/visuals | v0.19.x | UI version |
| Sound effects | v0.19.x | Audio version |
| Party buff distribution | v0.18.5 | Integration version |

---

## Unit Tests (~20 tests)

### Rage Tests

| Test | Description |
|------|-------------|
| `RageState_Threshold_CalculatesCorrectly` | Verify threshold breakpoints |
| `RageState_DamageBonus_ScalesWithThreshold` | Verify damage scaling |
| `RageState_AddRage_ClampsTo100` | Cannot exceed 100 |
| `RageState_SpendRage_DeductsCorrectly` | Spending works |
| `RageState_Decay_RespectsGracePeriod` | No decay for 3 rounds |
| `RageState_DumpRage_ResetsToZero` | Dump mechanic works |
| `RageService_ControlCheck_RequiredAt100` | Control check triggers |

### Momentum Tests

| Test | Description |
|------|-------------|
| `MomentumState_Threshold_CalculatesCorrectly` | Verify threshold breakpoints |
| `MomentumState_DefenseBonus_ScalesWithThreshold` | Verify defense scaling |
| `MomentumState_AddMomentum_EntersCascadeAt100` | Cascade entry |
| `MomentumState_ReduceMomentum_ExitsCascadeBelow75` | Cascade exit |
| `MomentumState_Decay_AppliesCorrectAmounts` | Decay amounts match |
| `MomentumService_IsInCascade_ReturnsCorrectly` | Cascade detection |

### Coherence Tests

| Test | Description |
|------|-------------|
| `CoherenceState_Threshold_CalculatesCorrectly` | Verify threshold breakpoints |
| `CoherenceState_PartyStressBonus_ScalesCorrectly` | Verify buff scaling |
| `CoherenceState_FearImmunity_At75Plus` | Fear immunity check |
| `CoherenceState_Apotheosis_At100` | Apotheosis state |
| `CoherenceState_PassiveDecay_DeductsCorrectly` | Combat decay |
| `CoherenceService_ApplyPartyBuffs_AffectsAllMembers` | Party buff application |

---

## Acceptance Criteria

### Functional Requirements

- [ ] All resources clamped to 0-100 range
- [ ] Threshold calculations match specifications
- [ ] Bonuses scale correctly with thresholds
- [ ] Decay mechanics work correctly
- [ ] Special states (Cascade, Apotheosis, Rampage) trigger at 100
- [ ] Control Check required for Berserker at 100 Rage
- [ ] Party buffs apply from Coherence correctly

### Quality Requirements

- [ ] All public methods have XML documentation
- [ ] Configuration externalized to JSON
- [ ] Unit test coverage ≥ 90%
- [ ] Resource values persisted correctly

---

## Dependencies

### Requires

| Dependency | Purpose |
|------------|---------|
| Dice System (v0.6.x) | Control checks |
| Attribute System (v0.17.2) | WILL, MIGHT, FINESSE |
| Specialization System (v0.17.4) | Specialization detection |

### Provides

| Feature | Consumer |
|---------|----------|
| Damage bonuses | Combat system |
| Defense bonuses | Combat system |
| Party stress resistance | Stress system |
| Fear immunity | Status effect system |

---

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-17 | Initial scope breakdown |
