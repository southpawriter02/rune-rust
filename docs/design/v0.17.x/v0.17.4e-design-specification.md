# v0.17.4e Design Specification: Specialization Application Service

**Version:** 0.17.4e
**Theme:** Specialization Application Service
**Author:** Claude
**Created:** 2026-01-27
**Status:** Draft
**Prerequisites:** v0.17.4d Complete (Specialization Provider)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [ISpecializationApplicationService Interface](#4-ispecializationapplicationservice-interface)
5. [SpecializationApplicationService Implementation](#5-specializationapplicationservice-implementation)
6. [Result Types](#6-result-types)
7. [Logging Specifications](#7-logging-specifications)
8. [Unit Testing Requirements](#8-unit-testing-requirements)
9. [Use Cases](#9-use-cases)
10. [Deliverable Checklist](#10-deliverable-checklist)
11. [Acceptance Criteria](#11-acceptance-criteria)
12. [Future Considerations](#12-future-considerations)

---

## 1. Overview

### 1.1 Purpose

This document specifies v0.17.4e, the Specialization Application Service. This phase creates the service that applies specializations to players and manages tier unlocks.

Key components:

1. **ISpecializationApplicationService Interface**: Contract for applying specializations and unlocking tiers.
2. **SpecializationApplicationService Implementation**: Core business logic for specialization management.
3. **Result Types**: `SpecializationApplicationResult` and `TierUnlockResult` for operation outcomes.

### 1.2 Scope

**In Scope:**

- `ISpecializationApplicationService` interface
- `SpecializationApplicationService` implementation
- `SpecializationApplicationResult` value object
- `TierUnlockResult` value object
- Validation logic for prerequisites
- Unit tests (~4 tests)

**Out of Scope:**

- Character creation workflow - v0.17.5
- Combat ability execution - Combat integration
- UI components - v0.17.5

### 1.3 Key Deliverables

| Type          | Count | Details                                               |
| ------------- | ----- | ----------------------------------------------------- |
| Interfaces    | 1     | `ISpecializationApplicationService`                   |
| Services      | 1     | `SpecializationApplicationService`                    |
| Value Objects | 2     | `SpecializationApplicationResult`, `TierUnlockResult` |
| Unit Tests    | ~4    | Apply, unlock, validation tests                       |

---

## 2. Dependencies

### 2.1 Required from v0.17.4a-d

| Component                   | Usage                     |
| --------------------------- | ------------------------- |
| `SpecializationId`          | Specialization identifier |
| `SpecializationPathType`    | Corruption risk checks    |
| `SpecializationDefinition`  | Definition data           |
| `SpecializationAbilityTier` | Tier unlock logic         |
| `ISpecializationProvider`   | Definition lookups        |

### 2.2 Required from v0.17.3

| Component   | Usage                         |
| ----------- | ----------------------------- |
| `Archetype` | Archetype matching validation |

### 2.3 Required from Player System

| Component     | Usage                          |
| ------------- | ------------------------------ |
| `Player`      | Apply specialization to player |
| `PlayerStats` | Check PP availability          |

### 2.4 Provides to Future Versions

| Version | Usage                                      |
| ------- | ------------------------------------------ |
| v0.17.5 | Character creation applies specializations |
| Combat  | Ability tier checks during combat          |

---

## 3. Architecture Diagrams

### 3.1 Service Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      APPLICATION SERVICE LAYER                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │              ISpecializationApplicationService                         │  │
│  ├───────────────────────────────────────────────────────────────────────┤  │
│  │  + ApplySpecialization(player, specializationId)                      │  │
│  │  + UnlockTier(player, specializationId, tier)                         │  │
│  │  + CanApplySpecialization(player, specializationId)                   │  │
│  │  + CanUnlockTier(player, specializationId, tier)                      │  │
│  │  + GetAvailableSpecializations(player)                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                      │                                                       │
│                      │ uses                                                  │
│                      ▼                                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │              ISpecializationProvider (from v0.17.4d)                   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Apply Specialization Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      APPLY SPECIALIZATION FLOW                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ApplySpecialization(player, specializationId)                              │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  1. Validate specialization exists         │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [exists]                                                         │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  2. Validate archetype matches             │                             │
│  │     (player.Archetype == spec.Parent)      │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [matches]                                                        │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  3. Check if first specialization          │                             │
│  │     (cost = 0) or additional (cost = 3 PP) │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [has sufficient PP]                                              │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  4. Apply specialization to player         │                             │
│  │     - Deduct PP cost                        │                             │
│  │     - Add to player.Specializations        │                             │
│  │     - Grant Tier 1 abilities               │                             │
│  │     - Initialize special resource          │                             │
│  └────────────────────────────────────────────┘                             │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  5. Return SpecializationApplicationResult │                             │
│  └────────────────────────────────────────────┘                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Tier Unlock Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      TIER UNLOCK FLOW                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  UnlockTier(player, specializationId, tier)                                 │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  1. Validate player has specialization     │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [has spec]                                                       │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  2. Check tier.RequiresPreviousTier        │                             │
│  │     - Tier 2 requires Tier 1 unlocked      │                             │
│  │     - Tier 3 requires Tier 2 unlocked      │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [previous unlocked]                                              │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  3. Check player rank >= RequiredRank      │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [rank sufficient]                                                │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  4. Check PP >= UnlockCost                 │                             │
│  │     - Tier 2: 2 PP                          │                             │
│  │     - Tier 3: 3 PP                          │                             │
│  └────────────────────────────────────────────┘                             │
│           │ [has PP]                                                         │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  5. Unlock tier                            │                             │
│  │     - Deduct PP                             │                             │
│  │     - Mark tier as unlocked                 │                             │
│  │     - Grant tier abilities                  │                             │
│  └────────────────────────────────────────────┘                             │
│           │                                                                  │
│           ▼                                                                  │
│  ┌────────────────────────────────────────────┐                             │
│  │  6. Return TierUnlockResult                │                             │
│  └────────────────────────────────────────────┘                             │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. ISpecializationApplicationService Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ISpecializationApplicationService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for applying specializations to players and managing tier unlocks.
/// </summary>
public interface ISpecializationApplicationService
{
    /// <summary>
    /// Applies a specialization to a player.
    /// </summary>
    /// <param name="player">The player receiving the specialization.</param>
    /// <param name="specializationId">The specialization to apply.</param>
    /// <returns>Result indicating success or failure with reason.</returns>
    SpecializationApplicationResult ApplySpecialization(
        Player player,
        SpecializationId specializationId);

    /// <summary>
    /// Unlocks a tier of abilities for a player's specialization.
    /// </summary>
    /// <param name="player">The player unlocking the tier.</param>
    /// <param name="specializationId">The specialization containing the tier.</param>
    /// <param name="tierNumber">The tier to unlock (2 or 3).</param>
    /// <returns>Result indicating success or failure with reason.</returns>
    TierUnlockResult UnlockTier(
        Player player,
        SpecializationId specializationId,
        int tierNumber);

    /// <summary>
    /// Checks if a player can apply a specialization.
    /// </summary>
    (bool CanApply, string? Reason) CanApplySpecialization(
        Player player,
        SpecializationId specializationId);

    /// <summary>
    /// Checks if a player can unlock a specific tier.
    /// </summary>
    (bool CanUnlock, string? Reason) CanUnlockTier(
        Player player,
        SpecializationId specializationId,
        int tierNumber);

    /// <summary>
    /// Gets specializations available to a player based on archetype.
    /// </summary>
    IReadOnlyList<SpecializationDefinition> GetAvailableSpecializations(Player player);

    /// <summary>
    /// Gets the PP cost for a player's next specialization.
    /// </summary>
    /// <param name="player">The player to check.</param>
    /// <returns>0 for first specialization, 3 for additional.</returns>
    int GetNextSpecializationCost(Player player);
}
```

---

## 5. SpecializationApplicationService Implementation

**File:** `src/Core/RuneAndRust.Application/Services/SpecializationApplicationService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Implements specialization application and tier unlock logic.
/// </summary>
public class SpecializationApplicationService : ISpecializationApplicationService
{
    private readonly ISpecializationProvider _provider;
    private readonly ILogger<SpecializationApplicationService> _logger;

    private const int AdditionalSpecializationCost = 3;

    public SpecializationApplicationService(
        ISpecializationProvider provider,
        ILogger<SpecializationApplicationService> logger)
    {
        _provider = provider;
        _logger = logger;
    }

    /// <inheritdoc />
    public SpecializationApplicationResult ApplySpecialization(
        Player player,
        SpecializationId specializationId)
    {
        ArgumentNullException.ThrowIfNull(player);

        _logger.LogInformation(
            "Attempting to apply specialization {SpecializationId} to player {PlayerName}",
            specializationId, player.Name);

        var (canApply, reason) = CanApplySpecialization(player, specializationId);
        if (!canApply)
        {
            _logger.LogWarning(
                "Cannot apply specialization {SpecializationId}: {Reason}",
                specializationId, reason);

            return SpecializationApplicationResult.Failure(reason!);
        }

        var definition = _provider.GetBySpecializationId(specializationId)!;
        var cost = GetNextSpecializationCost(player);

        // Deduct PP cost
        player.SpendProgressionPoints(cost);

        // Add specialization to player
        player.AddSpecialization(specializationId);

        // Initialize special resource if present
        if (definition.HasSpecialResource)
        {
            player.InitializeSpecialResource(definition.SpecialResource!.Value);
        }

        // Grant Tier 1 abilities
        var tier1 = definition.GetTier(1);
        if (tier1.HasValue)
        {
            foreach (var ability in tier1.Value.Abilities)
            {
                player.GrantAbility(ability.AbilityId);
            }
        }

        _logger.LogInformation(
            "Applied specialization {SpecializationId} to player {PlayerName} (cost: {Cost} PP)",
            specializationId, player.Name, cost);

        return SpecializationApplicationResult.Success(
            definition,
            tier1?.Abilities.ToList() ?? new List<SpecializationAbility>());
    }

    /// <inheritdoc />
    public TierUnlockResult UnlockTier(
        Player player,
        SpecializationId specializationId,
        int tierNumber)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentOutOfRangeException.ThrowIfLessThan(tierNumber, 2);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(tierNumber, 3);

        _logger.LogInformation(
            "Attempting to unlock tier {Tier} of {SpecializationId} for {PlayerName}",
            tierNumber, specializationId, player.Name);

        var (canUnlock, reason) = CanUnlockTier(player, specializationId, tierNumber);
        if (!canUnlock)
        {
            _logger.LogWarning(
                "Cannot unlock tier {Tier}: {Reason}",
                tierNumber, reason);

            return TierUnlockResult.Failure(reason!);
        }

        var definition = _provider.GetBySpecializationId(specializationId)!;
        var tier = definition.GetTier(tierNumber)!.Value;

        // Deduct PP cost
        player.SpendProgressionPoints(tier.UnlockCost);

        // Mark tier as unlocked
        player.UnlockSpecializationTier(specializationId, tierNumber);

        // Grant tier abilities
        foreach (var ability in tier.Abilities)
        {
            player.GrantAbility(ability.AbilityId);
        }

        _logger.LogInformation(
            "Unlocked tier {Tier} of {SpecializationId} for {PlayerName} (cost: {Cost} PP, {AbilityCount} abilities)",
            tierNumber, specializationId, player.Name, tier.UnlockCost, tier.AbilityCount);

        return TierUnlockResult.Success(tier);
    }

    /// <inheritdoc />
    public (bool CanApply, string? Reason) CanApplySpecialization(
        Player player,
        SpecializationId specializationId)
    {
        var definition = _provider.GetBySpecializationId(specializationId);
        if (definition == null)
        {
            return (false, "Specialization not found");
        }

        if (player.Archetype != definition.ParentArchetype)
        {
            return (false, $"Requires {definition.ParentArchetype} archetype");
        }

        if (player.HasSpecialization(specializationId))
        {
            return (false, "Already has this specialization");
        }

        var cost = GetNextSpecializationCost(player);
        if (player.ProgressionPoints < cost)
        {
            return (false, $"Requires {cost} PP ({player.ProgressionPoints} available)");
        }

        return (true, null);
    }

    /// <inheritdoc />
    public (bool CanUnlock, string? Reason) CanUnlockTier(
        Player player,
        SpecializationId specializationId,
        int tierNumber)
    {
        if (!player.HasSpecialization(specializationId))
        {
            return (false, "Does not have this specialization");
        }

        var definition = _provider.GetBySpecializationId(specializationId);
        if (definition == null)
        {
            return (false, "Specialization not found");
        }

        var tier = definition.GetTier(tierNumber);
        if (!tier.HasValue)
        {
            return (false, $"Tier {tierNumber} not found");
        }

        if (player.HasUnlockedTier(specializationId, tierNumber))
        {
            return (false, "Tier already unlocked");
        }

        return tier.Value.CanUnlock(
            player.ProgressionRank,
            player.HasUnlockedTier(specializationId, tierNumber - 1),
            player.ProgressionPoints);
    }

    /// <inheritdoc />
    public IReadOnlyList<SpecializationDefinition> GetAvailableSpecializations(Player player)
    {
        return _provider.GetByArchetype(player.Archetype);
    }

    /// <inheritdoc />
    public int GetNextSpecializationCost(Player player)
    {
        return player.SpecializationCount == 0 ? 0 : AdditionalSpecializationCost;
    }
}
```

---

## 6. Result Types

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SpecializationApplicationResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

using RuneAndRust.Domain.Entities;

/// <summary>
/// Result of applying a specialization to a player.
/// </summary>
public readonly record struct SpecializationApplicationResult
{
    public bool IsSuccess { get; init; }
    public string? FailureReason { get; init; }
    public SpecializationDefinition? AppliedDefinition { get; init; }
    public IReadOnlyList<SpecializationAbility> GrantedAbilities { get; init; }

    public static SpecializationApplicationResult Success(
        SpecializationDefinition definition,
        IReadOnlyList<SpecializationAbility> abilities)
    {
        return new SpecializationApplicationResult
        {
            IsSuccess = true,
            AppliedDefinition = definition,
            GrantedAbilities = abilities
        };
    }

    public static SpecializationApplicationResult Failure(string reason)
    {
        return new SpecializationApplicationResult
        {
            IsSuccess = false,
            FailureReason = reason,
            GrantedAbilities = Array.Empty<SpecializationAbility>()
        };
    }
}
```

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/TierUnlockResult.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Result of unlocking a specialization tier.
/// </summary>
public readonly record struct TierUnlockResult
{
    public bool IsSuccess { get; init; }
    public string? FailureReason { get; init; }
    public SpecializationAbilityTier? UnlockedTier { get; init; }

    public static TierUnlockResult Success(SpecializationAbilityTier tier)
    {
        return new TierUnlockResult
        {
            IsSuccess = true,
            UnlockedTier = tier
        };
    }

    public static TierUnlockResult Failure(string reason)
    {
        return new TierUnlockResult
        {
            IsSuccess = false,
            FailureReason = reason
        };
    }
}
```

---

## 7. Logging Specifications

| Component             | Level       | Events             |
| --------------------- | ----------- | ------------------ |
| `ApplySpecialization` | Information | Attempt, success   |
| `ApplySpecialization` | Warning     | Validation failure |
| `UnlockTier`          | Information | Attempt, success   |
| `UnlockTier`          | Warning     | Validation failure |

### Log Templates

```csharp
// Information: Apply attempt
_logger.LogInformation(
    "Attempting to apply specialization {SpecializationId} to player {PlayerName}",
    specializationId, player.Name);

// Information: Apply success
_logger.LogInformation(
    "Applied specialization {SpecializationId} to player {PlayerName} (cost: {Cost} PP)",
    specializationId, player.Name, cost);

// Warning: Validation failure
_logger.LogWarning(
    "Cannot apply specialization {SpecializationId}: {Reason}",
    specializationId, reason);
```

---

## 8. Unit Testing Requirements

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SpecializationApplicationServiceTests.cs`

```csharp
[TestFixture]
public class SpecializationApplicationServiceTests
{
    [Test]
    public void ApplySpecialization_FirstSpecialization_AppliesForFree()
    {
        // Arrange
        var player = CreateWarriorPlayer(pp: 0);
        var service = CreateService();

        // Act
        var result = service.ApplySpecialization(player, SpecializationId.Berserkr);

        // Assert
        result.IsSuccess.Should().BeTrue();
        player.HasSpecialization(SpecializationId.Berserkr).Should().BeTrue();
    }

    [Test]
    public void ApplySpecialization_WrongArchetype_Fails()
    {
        // Arrange
        var player = CreateMysticPlayer();
        var service = CreateService();

        // Act
        var result = service.ApplySpecialization(player, SpecializationId.Berserkr);

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.FailureReason.Should().Contain("Warrior archetype");
    }

    [Test]
    public void UnlockTier_WithPrerequisites_Succeeds()
    {
        // Arrange
        var player = CreatePlayerWithSpec(SpecializationId.Berserkr, tier1Unlocked: true, pp: 5, rank: 2);
        var service = CreateService();

        // Act
        var result = service.UnlockTier(player, SpecializationId.Berserkr, 2);

        // Assert
        result.IsSuccess.Should().BeTrue();
        player.HasUnlockedTier(SpecializationId.Berserkr, 2).Should().BeTrue();
    }

    [Test]
    public void UnlockTier_MissingPreviousTier_Fails()
    {
        // Arrange
        var player = CreatePlayerWithSpec(SpecializationId.Berserkr, tier1Unlocked: true, pp: 5, rank: 3);
        var service = CreateService();

        // Act
        var result = service.UnlockTier(player, SpecializationId.Berserkr, 3); // Skip tier 2

        // Assert
        result.IsSuccess.Should().BeFalse();
        result.FailureReason.Should().Contain("Tier 2 must be unlocked");
    }
}
```

---

## 9. Use Cases

### UC-001: Apply First Specialization

**Actor:** Player (via Character Creation)
**Flow:**

1. Player selects archetype (Warrior)
2. Player views available specializations (Berserkr, Skjaldmaer, etc.)
3. Player selects Berserkr
4. Service validates archetype matches
5. Service applies specialization (0 PP cost for first)
6. Player receives Tier 1 abilities

### UC-002: Unlock Tier 2 Abilities

**Actor:** Player (via Progression)
**Flow:**

1. Player reaches Rank 2 with 2+ PP
2. Player requests to unlock Tier 2 of their specialization
3. Service validates Tier 1 is unlocked
4. Service validates rank and PP
5. Service unlocks Tier 2, grants abilities

---

## 10. Deliverable Checklist

### Interfaces

- [ ] `ISpecializationApplicationService.cs`

### Implementation

- [ ] `SpecializationApplicationService.cs`

### Value Objects

- [ ] `SpecializationApplicationResult.cs`
- [ ] `TierUnlockResult.cs`

### Testing

- [ ] `SpecializationApplicationServiceTests.cs` (~4 tests)

### Documentation

- [ ] XML documentation on all public members

---

## 11. Acceptance Criteria

### Functional

- [ ] First specialization applies for 0 PP
- [ ] Additional specializations cost 3 PP
- [ ] Archetype validation prevents wrong specializations
- [ ] Tier 1 abilities granted on apply
- [ ] Tier 2 requires Tier 1 + Rank 2 + 2 PP
- [ ] Tier 3 requires Tier 2 + Rank 3 + 3 PP
- [ ] Special resource initialized on apply

### Quality

- [ ] Build succeeds with 0 errors
- [ ] All ~4 unit tests pass
- [ ] XML documentation complete

---

## 12. Future Considerations

### Deferred to v0.17.5

- Character creation workflow integration
- UI for specialization selection

### Deferred to Combat

- Ability execution from granted abilities
- Special resource tracking in combat

---

_Document Version: 1.0_
_Last Updated: 2026-01-27_
