Here is the comprehensive implementation plan for v0.3.23: The Gatekeeper (Input Refactoring).
This milestone fundamentally changes how the game interacts with the player. By abstracting raw input (Key Presses) into semantic GameActions, we decouple the engine from the console, enabling advanced features like key rebinding (already configured in v0.3.9c), macro support, and future GUI integration.
To manage the architectural shift, this version is split into three sub-versions:
	•	v0.3.23a: The Abstraction (Input Mapping) – Converting raw keys to semantic GameActions.
	•	v0.3.23b: The Loop (Event-Driven Architecture) – Refactoring the main loop for non-blocking input.
	•	v0.3.23c: The Mouse (TUI Pointing) – Implementing mouse support for Spectre.Console.

v0.3.23a: The Abstraction (Input Mapping)
Goal: Replace all direct calls to Console.ReadKey() with a centralized InputService that returns standardized InputEventobjects mapped to the GameAction enum (defined in v0.3.9c).
1. Architecture & Data Flow
	•	Input Pipeline:
	1	Hardware Layer: TerminalInputProvider reads System.ConsoleKeyInfo.
	2	Mapping Layer: InputConfigurationService (v0.3.9c) translates Key → GameAction.
	3	Semantic Layer: InputService broadcasts an InputEvent containing the Action.
	4	Consumer Layer: GameLoop or Controllers consume the Action.
Data Flow: Key Press to Action
	1	User Input: User presses 'W'.
	2	Lookup: InputConfigurationService.GetCommandForKey('W') returns "north".
	3	Translation: Mapper converts string "north" → GameAction.MoveNorth.
	4	Broadcast: Event ActionTriggered(GameAction.MoveNorth) is fired.
2. Logic Decision Trees
A. Input Resolution Logic Input: ConsoleKeyInfo
	1	Is Key Mapped? (Check InputConfigurationService)
	◦	Yes: Get Command String (e.g., "attack"). Convert to GameAction.Attack. Return ActionEvent.
	◦	No: Return RawKeyEvent (for text entry fields like Name or Seed).
	2	Is Global Hotkey? (e.g., '~' for Debug Console v0.3.17)
	◦	Yes: Intercept and fire SystemEvent.
B. Context Handling Input: GameAction.MoveNorth
	1	Current Phase:
	◦	Exploration: Execute GoCommand(North).
	◦	Combat: Move Cursor Up (Menu Navigation).
	◦	Inventory: Move Selection Up.
3. Code Implementation
A. Input Event Model File: RuneAndRust.Core/Models/Input/InputEvent.cs
public abstract record InputEvent;
public record ActionEvent(GameAction Action) : InputEvent;
public record RawKeyEvent(ConsoleKeyInfo KeyInfo) : InputEvent;
public record MouseEvent(int X, int Y, bool IsLeftClick) : InputEvent;
B. Input Service Wrapper File: RuneAndRust.Engine/Services/InputService.cs
public class InputService : IInputService
{
    private readonly IInputConfigurationService _config;

    public InputEvent ReadNext()
    {
        var keyInfo = Console.ReadKey(intercept: true);

        // 1. Check for Bindings (v0.3.9c integration)
        var command = _config.GetCommandForKey(keyInfo.Key);

        if (command != null)
        {
            if (Enum.TryParse<GameAction>(command, true, out var action))
            {
                return new ActionEvent(action);
            }
        }

        // 2. Fallback to Raw
        return new RawKeyEvent(keyInfo);
    }
}
4. Deliverable Checklist (v0.3.23a)
	•	Core:
	◦	[ ] Define InputEvent records.
	◦	[ ] Create IInputService interface.
	•	Engine:
	◦	[ ] Implement InputService.
	◦	[ ] Update GameAction enum to ensure 100% coverage of existing commands.
	•	Terminal:
	◦	[ ] Refactor TerminalInputHandler to use InputService.
	◦	[ ] Update OptionsController and CreationWizard to accept InputEvent.

v0.3.23b: The Loop (Event-Driven Architecture)
Goal: Refactor the Game Loop from a blocking while(true) { ReadKey } model to an async event loop. This allows background tasks (Animations v0.3.14b, Audio v0.3.19) to run while waiting for user input.
1. Architecture & Data Flow
	•	Polling Loop: Instead of blocking indefinitely, the loop waits with a timeout (e.g., 16ms for ~60 FPS).
	•	Update Cycle:
	1	Process Input: If input available, process.
	2	Update World: Tick animations, ambience, or real-time elements.
	3	Render: Draw changes.
2. Logic Decision Trees
A. Async Input Logic Input: Cancellation Token
	1	Check KeyAvailable: Is a key in the buffer?
	◦	Yes: Read immediately. Return Event.
	◦	No: Task.Delay(16). Return Null (Tick).
3. Code Implementation
A. Non-Blocking Loop File: RuneAndRust.Terminal/Services/TerminalGameLoop.cs
public async Task RunAsync(CancellationToken ct)
{
    while (!ct.IsCancellationRequested)
    {
        if (Console.KeyAvailable)
        {
            var inputEvent = _inputService.ReadNext();
            await HandleInputAsync(inputEvent);
        }

        // Allow background services to tick (Audio/VFX)
        await _ambienceService.UpdateAsync();
        await _visualEffectService.UpdateAsync();

        await Task.Delay(20, ct); // ~50 ticks/sec
    }
}
4. Deliverable Checklist (v0.3.23b)
	•	Engine:
	◦	[ ] Refactor GameService to support async ticks.
	•	Terminal:
	◦	[ ] Implement TerminalGameLoop with non-blocking logic.
	◦	[ ] Ensure AmbienceService (v0.3.19c) is ticked.

v0.3.23c: The Mouse (TUI Mouse Support)
Goal: Enable basic mouse interaction within the Terminal for players using compatible emulators (Windows Terminal, iTerm2).
1. Architecture & Data Flow
	•	Spectre Integration: Use Spectre.Console's capability to capture mouse events.
	•	Grid Mapping: Map X/Y console coordinates to UI Elements (Inventory Slots, Combat Grid Tiles).
2. Code Implementation
A. Mouse Handling Logic File: RuneAndRust.Terminal/Services/TerminalInputProvider.cs
// Requires enabling mouse mode in terminal
AnsiConsole.Write(new SystemControlInstruction(SystemControlInstruction.EnableMouse));

// In Loop
var input = await Console.In.ReadAsync(); // Pseudo-code for VT sequence parsing
if (IsMouseSequence(input))
{
    var (x, y) = ParseMouseCoordinates(input);
    return new MouseEvent(x, y, isLeftClick: true);
}
3. Deliverable Checklist (v0.3.23c)
	•	Terminal:
	◦	[ ] Enable VT Mouse Reporting code.
	◦	[ ] Map Mouse Clicks to GameAction.Confirm (Selection).
	◦	[ ] Update CombatGridRenderer to handle "Click to Target".

5. Logging Requirements
Reference: logging.md
System
Event
Level
Message Template
Properties
Input
Map Success
Trace
"[Input] Mapped Key {Key} -> Action {Action}"
Key, Action
Input
Raw
Trace
"[Input] Raw Key: {Key}"
Key
Input
Mouse
Verbose
"[Input] Mouse Click at ({X}, {Y})"
X, Y

6. Testing Strategy
Unit Tests (InputServiceTests.cs):
	•	Mapping_RespectsConfig:
	◦	Mock IInputConfigurationService to map 'Z' to MoveNorth.
	◦	Simulate 'Z' press.
	◦	Assert InputService.ReadNext() returns ActionEvent(MoveNorth).
	•	Fallback_ToRaw:
	◦	Simulate Unbound Key.
	◦	Assert returns RawKeyEvent.
Integration Tests:
	•	Scripted_Input_Compatibility:
	◦	Ensure ScriptedInputHandler (v0.3.12a) still functions by injecting ActionEvents directly into the loop, bypassing the raw key read.

7. Draft Changelog (v0.3.23)
# Changelog: v0.3.23 - The Gatekeeper

**Release Date:** 2026-03-XX

## Summary
"The Gatekeeper" modernizes the input handling of Rune & Rust. It decouples the game engine from the physical keyboard, allowing for an event-driven architecture that supports remapping, non-blocking animations, and experimental mouse support.

## Changes
- **Input Abstraction:** Raw key presses are now converted to semantic `GameAction` events before reaching the game logic.
- **Event Loop:** The game loop is now non-blocking, allowing ambient audio and visual effects to play smoothly while waiting for player input.
- **Mouse Support:** Added experimental support for mouse clicking in compatible terminals (Windows Terminal, iTerm2).