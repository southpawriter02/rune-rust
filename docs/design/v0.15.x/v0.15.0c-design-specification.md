# v0.15.0c Design Specification: Skill Check Refactor

**Version:** 0.15.0c
**Theme:** Skill Check Refactor
**Author:** Claude
**Created:** 2026-01-17
**Status:** Draft
**Prerequisites:** v0.15.0a Complete (Core Dice Mechanics Refactor), v0.15.0b Complete (Seeded Random Provider)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Dependencies](#2-dependencies)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [SkillOutcome Enum](#4-skilloutcome-enum)
5. [SkillCheckResult Refactor](#5-skillcheckresult-refactor)
6. [Outcome Classification Logic](#6-outcome-classification-logic)
7. [SkillCheckService Refactor](#7-skillcheckservice-refactor)
8. [Data Model Changes](#8-data-model-changes)
9. [Configuration](#9-configuration)
10. [Commands](#10-commands)
11. [User-Facing Changes](#11-user-facing-changes)
12. [Logging Specifications](#12-logging-specifications)
13. [Unit Testing Requirements](#13-unit-testing-requirements)
14. [Use Cases](#14-use-cases)
15. [Deliverable Checklist](#15-deliverable-checklist)
16. [Acceptance Criteria](#16-acceptance-criteria)
17. [Future Considerations](#17-future-considerations)
18. [Implementation Notes](#18-implementation-notes)
19. [Document Metadata](#19-document-metadata)

---

## 1. Overview

### 1.1 Purpose

This document provides a comprehensive design specification for v0.15.0c, the Skill Check Refactor. This part transitions the skill check system from a **total-based mechanic** (sum dice + bonuses, compare to DC) to a **success-counting mechanic** (use net successes from v0.15.0a, compare to DC threshold). The refactor expands the outcome classification from 4 levels to 6 tiers, enabling more nuanced success/failure gradations that better support narrative-driven gameplay.

### 1.2 Current vs. Target Implementation

| Aspect | Current Implementation | Target Implementation |
|--------|------------------------|----------------------|
| **Success Model** | `TotalResult >= DC` (sum-based) | `NetSuccesses >= DC` (success-counting) |
| **Margin Calculation** | `TotalResult - DifficultyClass` | `NetSuccesses - DifficultyClass` |
| **Outcome Levels** | 4 (`SuccessLevel` enum) | 6 (`SkillOutcome` enum) |
| **Critical Success** | `IsNaturalMax` (first die = max) | `IsCriticalSuccess` (net ≥ 5) OR margin ≥ 5 |
| **Critical Failure** | `IsNaturalOne` (first die = 1) | `IsFumble` (0 successes + ≥1 botch) |
| **Degrees of Success** | Binary (pass/fail) + criticals | 6 tiers: CriticalFailure, Failure, MarginalSuccess, FullSuccess, ExceptionalSuccess, CriticalSuccess |
| **Contested Checks** | Compare `TotalResult` | Compare `NetSuccesses` |

### 1.3 Scope

**In Scope:**
- Define `SkillOutcome` enum with 6 outcome tiers
- Refactor `SkillCheckResult` to use `NetSuccesses` and `SkillOutcome`
- Implement `ClassifyOutcome()` static method for outcome determination
- Refactor `SkillCheckService` to use success-counting mechanics
- Update contested check logic to compare `NetSuccesses`
- Preserve backward compatibility where feasible
- Unit tests for outcome classification (~8 tests)

**Out of Scope:**
- Extended checks (accumulated successes) - v0.15.0d
- `ContestedCheckResult` value object - v0.15.0d
- Dice roll logging infrastructure - v0.15.0e
- Combat hit quality integration - v0.15.0f
- Fumble consequence system - v0.15.1+
- Skill context modifiers - v0.15.1+

### 1.4 Key Deliverables

| Type | Count | Details |
|------|-------|---------|
| Enums | 1 | `SkillOutcome` (6 values, replaces `SuccessLevel` for skill checks) |
| Value Objects | 1 | `SkillCheckResult` (refactored) |
| Services | 1 | `SkillCheckService` (refactored) |
| Static Methods | 1 | `ClassifyOutcome()` |
| Unit Tests | ~8 | Outcome classification, fumble/critical detection |

---

## 2. Dependencies

### 2.1 Required from v0.15.0a (Core Dice Mechanics)

| Component | Location | Usage in v0.15.0c |
|-----------|----------|-------------------|
| `DiceRollResult` | `Domain/ValueObjects/DiceRollResult.cs` | Provides `NetSuccesses`, `IsFumble`, `IsCriticalSuccess` |
| `DiceConstants` | `Domain/Constants/DiceConstants.cs` | `CriticalSuccessNet` threshold (5) |
| `DiceService` | `Application/Services/DiceService.cs` | Returns success-counting results |

### 2.2 Required from v0.15.0b (Seeded Random Provider)

| Component | Location | Usage in v0.15.0c |
|-----------|----------|-------------------|
| `IRandomProvider` | `Domain/Interfaces/IRandomProvider.cs` | Injected into `DiceService` |
| `SeededRandomProvider` | `Application/Services/SeededRandomProvider.cs` | Deterministic testing |

### 2.3 Current SkillCheckResult Properties (to be modified)

```csharp
// Current properties in SkillCheckResult
public string SkillId { get; init; }
public string SkillName { get; init; }
public DiceRollResult DiceResult { get; init; }
public int AttributeBonus { get; init; }
public int OtherBonus { get; init; }
public int TotalResult { get; init; }        // Sum-based - TO BE DEPRECATED
public int DifficultyClass { get; init; }
public string DifficultyName { get; init; }
public SuccessLevel SuccessLevel { get; init; }  // 4 levels - TO BE REPLACED
public int Margin => TotalResult - DifficultyClass;  // TO BE REFACTORED
public bool IsSuccess { get; }
public bool IsCritical { get; }
public bool IsCriticalSuccess { get; }
public bool IsCriticalFailure { get; }
```

### 2.4 Current SuccessLevel Enum (to be superseded)

```csharp
// Current SuccessLevel enum - preserved for backward compatibility
public enum SuccessLevel
{
    CriticalFailure,  // Natural 1 on first die
    Failure,          // Total < DC
    Success,          // Total >= DC
    CriticalSuccess   // Natural max on first die
}
```

### 2.5 Provides to Future Versions

| Version | Component | Usage |
|---------|-----------|-------|
| v0.15.0d | `ContestedCheckResult` | Uses `SkillOutcome` for both parties |
| v0.15.0d | `ExtendedCheckState` | Uses `NetSuccesses` for accumulation |
| v0.15.0f | `CombatService` | Maps `SkillOutcome` to combat effects |
| v0.15.1+ | Fumble consequences | Triggered by `SkillOutcome.CriticalFailure` |

---

## 3. Architecture Diagrams

### 3.1 Outcome Classification Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     SKILL OUTCOME CLASSIFICATION FLOW                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  INPUT: DiceRollResult + DifficultyClass                                    │
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. CHECK FOR FUMBLE                                                 │    │
│  │                                                                      │    │
│  │  if (diceResult.IsFumble)                                           │    │
│  │      return SkillOutcome.CriticalFailure                            │    │
│  │                                                                      │    │
│  │  IsFumble = (0 successes AND ≥1 botch)                             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │ not fumble                                                       │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  2. CALCULATE MARGIN                                                 │    │
│  │                                                                      │    │
│  │  margin = netSuccesses - difficultyClass                            │    │
│  │                                                                      │    │
│  │  Example: 3 net successes, DC 2 → margin = 1                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  3. CLASSIFY BY MARGIN                                               │    │
│  │                                                                      │    │
│  │  margin < 0   → Failure           (did not meet DC)                 │    │
│  │  margin == 0  → MarginalSuccess   (exactly met DC)                  │    │
│  │  margin 1-2   → FullSuccess       (exceeded DC slightly)            │    │
│  │  margin 3-4   → ExceptionalSuccess (exceeded DC significantly)      │    │
│  │  margin >= 5  → CriticalSuccess   (greatly exceeded DC)             │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  OUTPUT: SkillOutcome                                                       │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Outcome Tier Examples

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         OUTCOME TIER EXAMPLES                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  CRITICAL FAILURE (Fumble):                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 4d10 → [1, 4, 2, 3]                                          │    │
│  │  Successes: 0, Botches: 1, Net: 0                                   │    │
│  │  IsFumble: true                                                     │    │
│  │  Outcome: CriticalFailure (regardless of DC)                        │    │
│  │                                                                      │    │
│  │  Narrative: "The lock pick snaps off inside the mechanism."        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  FAILURE (margin < 0):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 4d10 → [5, 6, 8, 3]                                          │    │
│  │  Successes: 1, Botches: 0, Net: 1                                   │    │
│  │  DC: 2, Margin: 1 - 2 = -1                                          │    │
│  │  Outcome: Failure                                                   │    │
│  │                                                                      │    │
│  │  Narrative: "You almost picked the lock, but a tumbler clicks back."│    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  MARGINAL SUCCESS (margin == 0):                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 4d10 → [5, 8, 9, 3]                                          │    │
│  │  Successes: 2, Botches: 0, Net: 2                                   │    │
│  │  DC: 2, Margin: 2 - 2 = 0                                           │    │
│  │  Outcome: MarginalSuccess                                           │    │
│  │                                                                      │    │
│  │  Narrative: "You pick the lock, but it takes longer than expected." │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  FULL SUCCESS (margin 1-2):                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 5d10 → [5, 8, 9, 10, 3]                                      │    │
│  │  Successes: 3, Botches: 0, Net: 3                                   │    │
│  │  DC: 2, Margin: 3 - 2 = 1                                           │    │
│  │  Outcome: FullSuccess                                               │    │
│  │                                                                      │    │
│  │  Narrative: "You pick the lock smoothly and quietly."               │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  EXCEPTIONAL SUCCESS (margin 3-4):                                          │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 6d10 → [8, 8, 9, 10, 10, 4]                                  │    │
│  │  Successes: 5, Botches: 0, Net: 5                                   │    │
│  │  DC: 2, Margin: 5 - 2 = 3                                           │    │
│  │  Outcome: ExceptionalSuccess                                        │    │
│  │                                                                      │    │
│  │  Narrative: "You pick the lock with ease and notice a hidden latch."│    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  CRITICAL SUCCESS (margin >= 5):                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  Roll: 8d10 → [8, 8, 9, 9, 10, 10, 10, 4]                           │    │
│  │  Successes: 7, Botches: 0, Net: 7                                   │    │
│  │  DC: 2, Margin: 7 - 2 = 5                                           │    │
│  │  Outcome: CriticalSuccess                                           │    │
│  │                                                                      │    │
│  │  Narrative: "You pick the lock instantly, disable the alarm,        │    │
│  │   and discover a secret compartment inside."                        │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.3 Comparison: Old vs. New Skill Check Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                   OLD VS. NEW SKILL CHECK FLOW                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────┐    ┌─────────────────────────────────┐    │
│  │     OLD (Sum-Based)         │    │    NEW (Success-Counting)        │    │
│  ├─────────────────────────────┤    ├─────────────────────────────────┤    │
│  │                             │    │                                  │    │
│  │  Roll: 3d10 → [4, 8, 6]    │    │  Roll: 3d10 → [4, 8, 6]         │    │
│  │  Total: 4 + 8 + 6 = 18     │    │  Successes: 1 (the 8)           │    │
│  │  Bonus: +3                  │    │  Botches: 0                      │    │
│  │  TotalResult: 21           │    │  NetSuccesses: 1                 │    │
│  │                             │    │                                  │    │
│  │  DC: 15                     │    │  DC: 2                           │    │
│  │                             │    │                                  │    │
│  │  21 >= 15 → Success        │    │  Margin: 1 - 2 = -1              │    │
│  │                             │    │  margin < 0 → Failure            │    │
│  │                             │    │                                  │    │
│  │  Outcomes:                  │    │  Outcomes:                       │    │
│  │  - CriticalFailure (nat 1) │    │  - CriticalFailure (fumble)      │    │
│  │  - Failure (total < DC)    │    │  - Failure (margin < 0)          │    │
│  │  - Success (total >= DC)   │    │  - MarginalSuccess (margin = 0)  │    │
│  │  - CriticalSuccess (nat max)│    │  - FullSuccess (margin 1-2)      │    │
│  │                             │    │  - ExceptionalSuccess (margin 3-4)│   │
│  │                             │    │  - CriticalSuccess (margin >= 5) │    │
│  │                             │    │                                  │    │
│  └─────────────────────────────┘    └─────────────────────────────────┘    │
│                                                                              │
│  KEY DIFFERENCES:                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  1. Dice evaluation: Sum → Count successes (8+) and botches (1)    │    │
│  │  2. DC meaning: Sum threshold → Success count threshold            │    │
│  │  3. Outcome tiers: 4 → 6 (more granular success degrees)           │    │
│  │  4. Critical success: Natural max → Net ≥ 5 or margin ≥ 5          │    │
│  │  5. Critical failure: Natural 1 → Fumble (0 successes + botch)     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.4 Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           LAYER ARCHITECTURE                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                      DOMAIN LAYER                                    │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  ValueObjects/                                                       │    │
│  │  └── SkillCheckResult.cs  ←── REFACTORED (NetSuccesses, SkillOutcome)│   │
│  │                                                                      │    │
│  │  Enums/                                                              │    │
│  │  ├── SuccessLevel.cs      ←── PRESERVED (backward compatibility)   │    │
│  │  └── SkillOutcome.cs      ←── NEW (6-tier outcome classification)  │    │
│  │                                                                      │    │
│  │  Extensions/                                                         │    │
│  │  └── SkillOutcomeExtensions.cs ←── NEW (helper methods)            │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                  │                                           │
│                                  │ uses                                      │
│                                  ▼                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    APPLICATION LAYER                                 │    │
│  ├─────────────────────────────────────────────────────────────────────┤    │
│  │                                                                      │    │
│  │  Services/                                                           │    │
│  │  └── SkillCheckService.cs ←── REFACTORED (uses NetSuccesses)       │    │
│  │                                                                      │    │
│  │  DTOs/                                                               │    │
│  │  └── SkillCheckDtos.cs    ←── UPDATED (SkillOutcome in response)   │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 4. SkillOutcome Enum

### 4.1 Enum Definition

**File:** `src/Core/RuneAndRust.Domain/Enums/SkillOutcome.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the degree of success or failure for a skill check using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Provides 6 tiers of outcomes for nuanced narrative and mechanical effects:
/// <list type="bullet">
///   <item><description>CriticalFailure: Fumble - catastrophic failure with consequences</description></item>
///   <item><description>Failure: Did not meet the difficulty class</description></item>
///   <item><description>MarginalSuccess: Barely succeeded - met DC exactly</description></item>
///   <item><description>FullSuccess: Clear success - exceeded DC by 1-2</description></item>
///   <item><description>ExceptionalSuccess: Outstanding - exceeded DC by 3-4</description></item>
///   <item><description>CriticalSuccess: Masterful - exceeded DC by 5+</description></item>
/// </list>
/// </para>
/// <para>
/// Outcome is determined by:
/// <list type="bullet">
///   <item><description>Fumble detection (0 successes AND ≥1 botch) → CriticalFailure</description></item>
///   <item><description>Margin calculation (NetSuccesses - DC) → other outcomes</description></item>
/// </list>
/// </para>
/// </remarks>
public enum SkillOutcome
{
    /// <summary>
    /// Fumble - catastrophic failure with additional consequences.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Triggered when the dice roll is a fumble (0 successes AND ≥1 botch).
    /// This outcome occurs regardless of difficulty class.
    /// </para>
    /// <para>
    /// Examples of consequences:
    /// <list type="bullet">
    ///   <item><description>Lockpicking: Pick breaks, alerting guards</description></item>
    ///   <item><description>Climbing: Fall and take damage</description></item>
    ///   <item><description>Persuasion: Target becomes hostile</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    CriticalFailure = 0,

    /// <summary>
    /// Failure - did not meet the difficulty class.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Net successes were less than the difficulty class (margin < 0).
    /// The attempt fails but without additional negative consequences.
    /// </para>
    /// <para>
    /// May allow retry in some circumstances.
    /// </para>
    /// </remarks>
    Failure = 1,

    /// <summary>
    /// Marginal Success - barely succeeded.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Net successes exactly matched the difficulty class (margin = 0).
    /// The task is accomplished but with complications or delays.
    /// </para>
    /// <para>
    /// Examples of complications:
    /// <list type="bullet">
    ///   <item><description>Lockpicking: Success but took extra time</description></item>
    ///   <item><description>Climbing: Made it but exhausted</description></item>
    ///   <item><description>Persuasion: Agreed but reluctantly</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    MarginalSuccess = 2,

    /// <summary>
    /// Full Success - clear success.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Net successes exceeded the difficulty class by 1-2 (margin 1-2).
    /// The task is accomplished cleanly as expected.
    /// </para>
    /// <para>
    /// This is the "normal" successful outcome.
    /// </para>
    /// </remarks>
    FullSuccess = 3,

    /// <summary>
    /// Exceptional Success - outstanding performance.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Net successes exceeded the difficulty class by 3-4 (margin 3-4).
    /// The task is accomplished with notable excellence.
    /// </para>
    /// <para>
    /// May provide minor bonus effects:
    /// <list type="bullet">
    ///   <item><description>Lockpicking: Discovered hidden compartment</description></item>
    ///   <item><description>Climbing: Found faster route for others</description></item>
    ///   <item><description>Persuasion: Gained additional favor</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    ExceptionalSuccess = 4,

    /// <summary>
    /// Critical Success - masterful achievement.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Net successes exceeded the difficulty class by 5+ (margin ≥ 5).
    /// The task is accomplished with extraordinary skill.
    /// </para>
    /// <para>
    /// Provides significant bonus effects:
    /// <list type="bullet">
    ///   <item><description>Lockpicking: Disabled alarm, found secret</description></item>
    ///   <item><description>Climbing: Reached destination instantly</description></item>
    ///   <item><description>Persuasion: Target becomes loyal ally</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    CriticalSuccess = 5
}
```

### 4.2 Outcome Tier Summary

| Outcome | Margin Range | Description | Narrative Impact |
|---------|--------------|-------------|------------------|
| `CriticalFailure` | N/A (fumble) | Catastrophic failure | Negative consequences |
| `Failure` | margin < 0 | Did not meet DC | No success, no extra penalty |
| `MarginalSuccess` | margin = 0 | Barely succeeded | Success with complications |
| `FullSuccess` | margin 1-2 | Clean success | Normal successful outcome |
| `ExceptionalSuccess` | margin 3-4 | Outstanding | Minor bonus effects |
| `CriticalSuccess` | margin ≥ 5 | Masterful | Significant bonus effects |

### 4.3 SkillOutcome Extensions

**File:** `src/Core/RuneAndRust.Domain/Extensions/SkillOutcomeExtensions.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.Extensions;

/// <summary>
/// Extension methods for the SkillOutcome enum.
/// </summary>
public static class SkillOutcomeExtensions
{
    /// <summary>
    /// Determines if the outcome represents any form of success.
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>True if the outcome is MarginalSuccess or better.</returns>
    public static bool IsSuccess(this SkillOutcome outcome)
    {
        return outcome >= SkillOutcome.MarginalSuccess;
    }

    /// <summary>
    /// Determines if the outcome represents any form of failure.
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>True if the outcome is Failure or CriticalFailure.</returns>
    public static bool IsFailure(this SkillOutcome outcome)
    {
        return outcome <= SkillOutcome.Failure;
    }

    /// <summary>
    /// Determines if the outcome is a critical result (best or worst).
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>True if CriticalSuccess or CriticalFailure.</returns>
    public static bool IsCritical(this SkillOutcome outcome)
    {
        return outcome is SkillOutcome.CriticalSuccess or SkillOutcome.CriticalFailure;
    }

    /// <summary>
    /// Gets the margin range for the outcome tier.
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>A tuple of (minMargin, maxMargin) for the tier, or null for fumble.</returns>
    public static (int? Min, int? Max) GetMarginRange(this SkillOutcome outcome)
    {
        return outcome switch
        {
            SkillOutcome.CriticalFailure => (null, null),  // Fumble-based, not margin
            SkillOutcome.Failure => (null, -1),            // Any negative margin
            SkillOutcome.MarginalSuccess => (0, 0),        // Exactly 0
            SkillOutcome.FullSuccess => (1, 2),            // 1-2
            SkillOutcome.ExceptionalSuccess => (3, 4),     // 3-4
            SkillOutcome.CriticalSuccess => (5, null),     // 5+
            _ => throw new ArgumentOutOfRangeException(nameof(outcome))
        };
    }

    /// <summary>
    /// Converts to the legacy SuccessLevel enum for backward compatibility.
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>The equivalent SuccessLevel.</returns>
    public static SuccessLevel ToSuccessLevel(this SkillOutcome outcome)
    {
        return outcome switch
        {
            SkillOutcome.CriticalFailure => SuccessLevel.CriticalFailure,
            SkillOutcome.Failure => SuccessLevel.Failure,
            SkillOutcome.MarginalSuccess or
            SkillOutcome.FullSuccess or
            SkillOutcome.ExceptionalSuccess => SuccessLevel.Success,
            SkillOutcome.CriticalSuccess => SuccessLevel.CriticalSuccess,
            _ => throw new ArgumentOutOfRangeException(nameof(outcome))
        };
    }

    /// <summary>
    /// Gets a display-friendly name for the outcome.
    /// </summary>
    /// <param name="outcome">The skill outcome.</param>
    /// <returns>A human-readable outcome name.</returns>
    public static string GetDisplayName(this SkillOutcome outcome)
    {
        return outcome switch
        {
            SkillOutcome.CriticalFailure => "Critical Failure",
            SkillOutcome.Failure => "Failure",
            SkillOutcome.MarginalSuccess => "Marginal Success",
            SkillOutcome.FullSuccess => "Success",
            SkillOutcome.ExceptionalSuccess => "Exceptional Success",
            SkillOutcome.CriticalSuccess => "Critical Success",
            _ => outcome.ToString()
        };
    }
}
```

---

## 5. SkillCheckResult Refactor

### 5.1 Refactored SkillCheckResult Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/SkillCheckResult.cs`

```csharp
using RuneAndRust.Domain.Constants;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Extensions;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the complete result of a skill check using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Immutable value object containing all skill check details including:
/// dice roll breakdown, net successes, margin, and outcome classification.
/// </para>
/// <para>
/// Outcome Determination (v0.15.0c+):
/// <list type="bullet">
///   <item><description>CriticalFailure: Fumble (0 successes + ≥1 botch)</description></item>
///   <item><description>Failure: Margin &lt; 0</description></item>
///   <item><description>MarginalSuccess: Margin = 0</description></item>
///   <item><description>FullSuccess: Margin 1-2</description></item>
///   <item><description>ExceptionalSuccess: Margin 3-4</description></item>
///   <item><description>CriticalSuccess: Margin ≥ 5</description></item>
/// </list>
/// </para>
/// </remarks>
public readonly record struct SkillCheckResult
{
    /// <summary>
    /// Gets the ID of the skill that was checked.
    /// </summary>
    public string SkillId { get; init; }

    /// <summary>
    /// Gets the display name of the skill.
    /// </summary>
    public string SkillName { get; init; }

    /// <summary>
    /// Gets the underlying dice roll result.
    /// </summary>
    public DiceRollResult DiceResult { get; init; }

    /// <summary>
    /// Gets the bonus dice added from the player's primary attribute.
    /// </summary>
    /// <remarks>
    /// In success-counting mechanics, attribute bonuses typically add dice to the pool
    /// rather than adding to a sum. This value represents the number of bonus dice.
    /// </remarks>
    public int AttributeBonus { get; init; }

    /// <summary>
    /// Gets bonus dice from other sources (equipment, abilities, situational).
    /// </summary>
    public int OtherBonus { get; init; }

    /// <summary>
    /// Gets the net successes from the dice roll.
    /// </summary>
    /// <remarks>
    /// Net successes = total successes (8+) minus total botches (1).
    /// This is the primary value used for comparison against the DC.
    /// </remarks>
    public int NetSuccesses { get; init; }

    /// <summary>
    /// Gets the difficulty class that was checked against.
    /// </summary>
    /// <remarks>
    /// In success-counting mechanics, DC represents the number of net successes
    /// required to succeed, not a sum threshold.
    /// </remarks>
    public int DifficultyClass { get; init; }

    /// <summary>
    /// Gets the name of the difficulty level.
    /// </summary>
    public string DifficultyName { get; init; }

    /// <summary>
    /// Gets the margin by which the check succeeded or failed.
    /// </summary>
    /// <remarks>
    /// Margin = NetSuccesses - DifficultyClass.
    /// Positive margin indicates success, negative indicates failure.
    /// </remarks>
    public int Margin { get; init; }

    /// <summary>
    /// Gets the 6-tier skill outcome classification.
    /// </summary>
    public SkillOutcome Outcome { get; init; }

    /// <summary>
    /// Gets whether this roll was a fumble.
    /// </summary>
    /// <remarks>
    /// A fumble occurs when there are 0 successes AND at least 1 botch.
    /// Fumbles always result in CriticalFailure regardless of DC.
    /// </remarks>
    public bool IsFumble { get; init; }

    /// <summary>
    /// Gets whether the check succeeded (MarginalSuccess or better).
    /// </summary>
    public bool IsSuccess => Outcome.IsSuccess();

    /// <summary>
    /// Gets whether the check was a critical result (best or worst tier).
    /// </summary>
    public bool IsCritical => Outcome.IsCritical();

    /// <summary>
    /// Gets whether this was a critical success.
    /// </summary>
    public bool IsCriticalSuccess => Outcome == SkillOutcome.CriticalSuccess;

    /// <summary>
    /// Gets whether this was a critical failure.
    /// </summary>
    public bool IsCriticalFailure => Outcome == SkillOutcome.CriticalFailure;

    /// <summary>
    /// Gets the total bonus dice applied (attribute + other).
    /// </summary>
    public int TotalBonus => AttributeBonus + OtherBonus;

    /// <summary>
    /// Gets the legacy success level for backward compatibility.
    /// </summary>
    /// <remarks>
    /// Maps the 6-tier SkillOutcome to the 4-tier SuccessLevel:
    /// CriticalFailure → CriticalFailure,
    /// Failure → Failure,
    /// MarginalSuccess/FullSuccess/ExceptionalSuccess → Success,
    /// CriticalSuccess → CriticalSuccess
    /// </remarks>
    [Obsolete("Use Outcome property for 6-tier classification. SuccessLevel preserved for backward compatibility.")]
    public SuccessLevel SuccessLevel => Outcome.ToSuccessLevel();

    /// <summary>
    /// Gets the legacy total result for backward compatibility.
    /// </summary>
    /// <remarks>
    /// In success-counting mechanics, use NetSuccesses instead.
    /// This returns the raw dice sum + bonuses for legacy code.
    /// </remarks>
    [Obsolete("Use NetSuccesses for success-counting mechanics. TotalResult preserved for damage calculations.")]
    public int TotalResult => DiceResult.Total + AttributeBonus + OtherBonus;

    /// <summary>
    /// Creates a skill check result with automatic outcome classification.
    /// </summary>
    /// <param name="skillId">The skill identifier.</param>
    /// <param name="skillName">The skill display name.</param>
    /// <param name="diceResult">The dice roll result.</param>
    /// <param name="attributeBonus">Bonus dice from attributes.</param>
    /// <param name="otherBonus">Bonus dice from other sources.</param>
    /// <param name="difficultyClass">The difficulty class (success threshold).</param>
    /// <param name="difficultyName">The difficulty level name.</param>
    public SkillCheckResult(
        string skillId,
        string skillName,
        DiceRollResult diceResult,
        int attributeBonus,
        int otherBonus,
        int difficultyClass,
        string difficultyName)
    {
        SkillId = skillId;
        SkillName = skillName;
        DiceResult = diceResult;
        AttributeBonus = attributeBonus;
        OtherBonus = otherBonus;
        DifficultyClass = difficultyClass;
        DifficultyName = difficultyName;

        // Use net successes from dice result
        NetSuccesses = diceResult.NetSuccesses;
        IsFumble = diceResult.IsFumble;

        // Calculate margin and classify outcome
        Margin = NetSuccesses - difficultyClass;
        Outcome = ClassifyOutcome(NetSuccesses, difficultyClass, IsFumble);
    }

    /// <summary>
    /// Classifies the skill check outcome based on margin and fumble status.
    /// </summary>
    /// <param name="netSuccesses">The net successes from the roll.</param>
    /// <param name="difficultyClass">The difficulty class.</param>
    /// <param name="isFumble">Whether the roll was a fumble.</param>
    /// <returns>The appropriate SkillOutcome tier.</returns>
    public static SkillOutcome ClassifyOutcome(int netSuccesses, int difficultyClass, bool isFumble)
    {
        // Fumble always results in critical failure
        if (isFumble)
            return SkillOutcome.CriticalFailure;

        var margin = netSuccesses - difficultyClass;

        return margin switch
        {
            < 0 => SkillOutcome.Failure,
            0 => SkillOutcome.MarginalSuccess,
            1 or 2 => SkillOutcome.FullSuccess,
            3 or 4 => SkillOutcome.ExceptionalSuccess,
            _ => SkillOutcome.CriticalSuccess  // margin >= 5
        };
    }

    /// <summary>
    /// Returns a formatted string showing the check breakdown with success counts.
    /// </summary>
    /// <example>
    /// "Acrobatics: 3 net (5S - 2B) vs DC 2 (Moderate) → Full Success [margin: +1]"
    /// "Stealth: 0 net (0S - 1B) vs DC 1 (Easy) → Critical Failure [FUMBLE!]"
    /// </example>
    public override string ToString()
    {
        var successBreakdown = $"{DiceResult.TotalSuccesses}S - {DiceResult.TotalBotches}B";
        var marginStr = Margin >= 0 ? $"+{Margin}" : Margin.ToString();

        var result = $"{SkillName}: {NetSuccesses} net ({successBreakdown}) vs DC {DifficultyClass} ({DifficultyName}) → {Outcome.GetDisplayName()} [margin: {marginStr}]";

        if (IsFumble)
            result += " [FUMBLE!]";
        else if (IsCriticalSuccess)
            result += " [CRITICAL!]";

        return result;
    }

    /// <summary>
    /// Returns a formatted string in legacy sum-based format.
    /// </summary>
    /// <remarks>
    /// For backward compatibility with systems expecting sum-based output.
    /// </remarks>
    [Obsolete("Use ToString() for success-counting format.")]
    public string ToLegacyString()
    {
        var bonusStr = new List<string>();
        if (AttributeBonus != 0)
            bonusStr.Add($"{(AttributeBonus > 0 ? "+" : "")}{AttributeBonus} (attr)");
        if (OtherBonus != 0)
            bonusStr.Add($"{(OtherBonus > 0 ? "+" : "")}{OtherBonus} (bonus)");

        var bonusPart = bonusStr.Count > 0 ? " " + string.Join(" ", bonusStr) : "";

#pragma warning disable CS0618 // Suppress obsolete warning for legacy properties
        return $"{SkillName}: [{DiceResult.Total}]{bonusPart} = {TotalResult} vs DC {DifficultyClass} ({DifficultyName}) -> {SuccessLevel}";
#pragma warning restore CS0618
    }
}
```

### 5.2 Property Summary Table

| Property | Type | Description | New/Modified |
|----------|------|-------------|--------------|
| `SkillId` | `string` | Skill identifier | Unchanged |
| `SkillName` | `string` | Skill display name | Unchanged |
| `DiceResult` | `DiceRollResult` | Underlying dice roll | Unchanged |
| `AttributeBonus` | `int` | Bonus dice from attributes | Unchanged |
| `OtherBonus` | `int` | Bonus dice from other sources | Unchanged |
| `NetSuccesses` | `int` | Net successes from roll | **New** |
| `DifficultyClass` | `int` | DC (success threshold) | Unchanged |
| `DifficultyName` | `string` | Difficulty name | Unchanged |
| `Margin` | `int` | NetSuccesses - DC | **Modified** |
| `Outcome` | `SkillOutcome` | 6-tier outcome classification | **New** |
| `IsFumble` | `bool` | Fumble detection | **New** |
| `IsSuccess` | `bool` | Success check | Modified |
| `IsCritical` | `bool` | Critical check | Modified |
| `IsCriticalSuccess` | `bool` | Critical success check | Modified |
| `IsCriticalFailure` | `bool` | Critical failure check | Modified |
| `TotalBonus` | `int` | Total bonus dice | Unchanged |
| `SuccessLevel` | `SuccessLevel` | Legacy 4-tier enum | **Obsolete** |
| `TotalResult` | `int` | Legacy sum-based total | **Obsolete** |

---

## 6. Outcome Classification Logic

### 6.1 ClassifyOutcome Method Specification

The `ClassifyOutcome` method is the core logic for determining skill check outcomes.

```csharp
public static SkillOutcome ClassifyOutcome(int netSuccesses, int difficultyClass, bool isFumble)
{
    // Step 1: Check for fumble (always critical failure)
    if (isFumble)
        return SkillOutcome.CriticalFailure;

    // Step 2: Calculate margin
    var margin = netSuccesses - difficultyClass;

    // Step 3: Classify by margin
    return margin switch
    {
        < 0 => SkillOutcome.Failure,           // Did not meet DC
        0 => SkillOutcome.MarginalSuccess,     // Exactly met DC
        1 or 2 => SkillOutcome.FullSuccess,    // Exceeded DC by 1-2
        3 or 4 => SkillOutcome.ExceptionalSuccess, // Exceeded DC by 3-4
        _ => SkillOutcome.CriticalSuccess      // Exceeded DC by 5+
    };
}
```

### 6.2 Classification Truth Table

| Net Successes | DC | Margin | IsFumble | Outcome |
|---------------|-----|--------|----------|---------|
| 0 | 1 | -1 | true | CriticalFailure |
| 0 | 1 | -1 | false | Failure |
| 1 | 2 | -1 | false | Failure |
| 2 | 2 | 0 | false | MarginalSuccess |
| 3 | 2 | 1 | false | FullSuccess |
| 4 | 2 | 2 | false | FullSuccess |
| 5 | 2 | 3 | false | ExceptionalSuccess |
| 6 | 2 | 4 | false | ExceptionalSuccess |
| 7 | 2 | 5 | false | CriticalSuccess |
| 10 | 2 | 8 | false | CriticalSuccess |

### 6.3 Edge Cases

| Scenario | Input | Expected Output | Rationale |
|----------|-------|-----------------|-----------|
| Fumble with DC 0 | net=0, dc=0, fumble=true | CriticalFailure | Fumble overrides |
| High success with botches | net=5, dc=2, fumble=false | ExceptionalSuccess | Not fumble, margin=3 |
| Zero DC | net=0, dc=0, fumble=false | MarginalSuccess | margin=0 |
| Negative DC (invalid) | net=1, dc=-1, fumble=false | FullSuccess | margin=2 |

---

## 7. SkillCheckService Refactor

### 7.1 Updated SkillCheckService

**File:** `src/Core/RuneAndRust.Application/Services/SkillCheckService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Extensions;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for performing skill checks using success-counting mechanics.
/// </summary>
/// <remarks>
/// <para>
/// Integrates dice rolling with player attributes and configuration-driven
/// skill definitions and difficulty classes.
/// </para>
/// <para>
/// v0.15.0c changes:
/// <list type="bullet">
///   <item><description>Uses NetSuccesses instead of sum-based totals</description></item>
///   <item><description>Returns SkillOutcome (6 tiers) instead of SuccessLevel (4 tiers)</description></item>
///   <item><description>Contested checks compare NetSuccesses</description></item>
/// </list>
/// </para>
/// </remarks>
public class SkillCheckService
{
    private readonly DiceService _diceService;
    private readonly IGameConfigurationProvider _configProvider;
    private readonly ILogger<SkillCheckService> _logger;
    private readonly IGameEventLogger? _eventLogger;

    /// <summary>
    /// Initializes a new instance of the SkillCheckService.
    /// </summary>
    public SkillCheckService(
        DiceService diceService,
        IGameConfigurationProvider configProvider,
        ILogger<SkillCheckService> logger,
        IGameEventLogger? eventLogger = null)
    {
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _configProvider = configProvider ?? throw new ArgumentNullException(nameof(configProvider));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _eventLogger = eventLogger;
        _logger.LogInformation("SkillCheckService initialized (success-counting mode)");
    }

    /// <summary>
    /// Performs a skill check for a player against a named difficulty class.
    /// </summary>
    public SkillCheckResult PerformCheck(
        Player player,
        string skillId,
        string difficultyClassId,
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonusDice = 0)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));
        ArgumentException.ThrowIfNullOrWhiteSpace(difficultyClassId, nameof(difficultyClassId));

        _logger.LogDebug(
            "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
            player.Name, skillId, difficultyClassId, advantageType);

        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        var dc = _configProvider.GetDifficultyClassById(difficultyClassId)
            ?? throw new ArgumentException($"Unknown difficulty class: {difficultyClassId}", nameof(difficultyClassId));

        return PerformCheckInternal(player, skill, dc, advantageType, additionalBonusDice);
    }

    /// <summary>
    /// Performs a skill check for a player against a specific DC value.
    /// </summary>
    public SkillCheckResult PerformCheckWithDC(
        Player player,
        string skillId,
        int difficultyClass,
        string difficultyName = "Custom",
        AdvantageType advantageType = AdvantageType.Normal,
        int additionalBonusDice = 0)
    {
        ArgumentNullException.ThrowIfNull(player);
        ArgumentException.ThrowIfNullOrWhiteSpace(skillId, nameof(skillId));

        if (difficultyClass < 0)
            throw new ArgumentOutOfRangeException(nameof(difficultyClass), "Difficulty class must be non-negative");

        _logger.LogDebug(
            "Performing skill check: Player={Player}, Skill={Skill}, DC={DC}, Advantage={Advantage}",
            player.Name, skillId, difficultyClass, advantageType);

        var skill = _configProvider.GetSkillById(skillId)
            ?? throw new ArgumentException($"Unknown skill: {skillId}", nameof(skillId));

        var attributeBonus = CalculateAttributeBonus(player, skill);
        var otherBonus = CalculateOtherBonus(player, skill, additionalBonusDice);

        // Build dice pool: base pool + attribute bonus + other bonuses
        var baseDiceCount = GetBaseDiceCount(skill);
        var totalDice = baseDiceCount + attributeBonus + otherBonus;
        var dicePool = new DicePool(Math.Max(1, totalDice), DiceType.D10);

        var rollResult = _diceService.Roll(dicePool, advantageType);

        var result = new SkillCheckResult(
            skillId,
            skill.Name,
            rollResult,
            attributeBonus,
            otherBonus,
            difficultyClass,
            difficultyName);

        LogCheckResult(result);
        return result;
    }

    /// <summary>
    /// Performs a contested skill check between two players.
    /// </summary>
    /// <returns>
    /// A tuple containing both results and the winner's name.
    /// In success-counting, the player with higher NetSuccesses wins.
    /// Ties favor the active player.
    /// </returns>
    public (SkillCheckResult ActiveResult, SkillCheckResult PassiveResult, string Winner, int MarginOfVictory) PerformContestedCheck(
        Player activePlayer,
        Player passivePlayer,
        string activeSkillId,
        string passiveSkillId,
        AdvantageType activeAdvantage = AdvantageType.Normal,
        AdvantageType passiveAdvantage = AdvantageType.Normal)
    {
        ArgumentNullException.ThrowIfNull(activePlayer);
        ArgumentNullException.ThrowIfNull(passivePlayer);

        _logger.LogDebug(
            "Performing contested check: {Active} ({ActiveSkill}) vs {Passive} ({PassiveSkill})",
            activePlayer.Name, activeSkillId, passivePlayer.Name, passiveSkillId);

        // Both rolls use DC 0 for contested checks (comparing net successes directly)
        var activeResult = PerformCheckWithDC(activePlayer, activeSkillId, 0, "Contested", activeAdvantage);
        var passiveResult = PerformCheckWithDC(passivePlayer, passiveSkillId, 0, "Contested", passiveAdvantage);

        // Compare net successes
        string winner;
        int marginOfVictory;

        if (activeResult.NetSuccesses > passiveResult.NetSuccesses)
        {
            winner = activePlayer.Name;
            marginOfVictory = activeResult.NetSuccesses - passiveResult.NetSuccesses;
        }
        else if (passiveResult.NetSuccesses > activeResult.NetSuccesses)
        {
            winner = passivePlayer.Name;
            marginOfVictory = passiveResult.NetSuccesses - activeResult.NetSuccesses;
        }
        else
        {
            // Tie - active player wins with 0 margin
            winner = activePlayer.Name;
            marginOfVictory = 0;
        }

        // Handle fumble cases
        if (activeResult.IsFumble && !passiveResult.IsFumble)
        {
            winner = passivePlayer.Name;
            marginOfVictory = passiveResult.NetSuccesses + 1;  // Fumble penalty
            _logger.LogInformation("{Active} fumbled! {Passive} automatically wins.", activePlayer.Name, passivePlayer.Name);
        }
        else if (passiveResult.IsFumble && !activeResult.IsFumble)
        {
            winner = activePlayer.Name;
            marginOfVictory = activeResult.NetSuccesses + 1;  // Fumble penalty
            _logger.LogInformation("{Passive} fumbled! {Active} automatically wins.", passivePlayer.Name, activePlayer.Name);
        }
        else if (activeResult.IsFumble && passiveResult.IsFumble)
        {
            winner = "Neither";
            marginOfVictory = 0;
            _logger.LogInformation("Both players fumbled! Mutual failure.");
        }

        _logger.LogInformation(
            "Contested check: {Active} ({ActiveNet} net) vs {Passive} ({PassiveNet} net) → {Winner} wins by {Margin}",
            activePlayer.Name, activeResult.NetSuccesses,
            passivePlayer.Name, passiveResult.NetSuccesses,
            winner, marginOfVictory);

        return (activeResult, passiveResult, winner, marginOfVictory);
    }

    private SkillCheckResult PerformCheckInternal(
        Player player,
        SkillDefinition skill,
        DifficultyClassDefinition dc,
        AdvantageType advantageType,
        int additionalBonusDice)
    {
        var attributeBonus = CalculateAttributeBonus(player, skill);
        var otherBonus = CalculateOtherBonus(player, skill, additionalBonusDice);

        // Build dice pool with total dice
        var baseDiceCount = GetBaseDiceCount(skill);
        var totalDice = baseDiceCount + attributeBonus + otherBonus;
        var dicePool = new DicePool(Math.Max(1, totalDice), DiceType.D10);

        var rollResult = _diceService.Roll(dicePool, advantageType);

        var result = new SkillCheckResult(
            skill.Id,
            skill.Name,
            rollResult,
            attributeBonus,
            otherBonus,
            dc.TargetNumber,
            dc.Name);

        LogCheckResult(result);
        return result;
    }

    /// <summary>
    /// Gets the base dice count from a skill definition.
    /// </summary>
    private static int GetBaseDiceCount(SkillDefinition skill)
    {
        // Parse base dice pool to get count (e.g., "3d10" -> 3)
        var pool = DicePool.Parse(skill.BaseDicePool);
        return pool.Count;
    }

    /// <summary>
    /// Calculates attribute bonus dice for the skill.
    /// </summary>
    private int CalculateAttributeBonus(Player player, SkillDefinition skill)
    {
        var primaryBonus = GetAttributeValue(player, skill.PrimaryAttribute);

        if (skill.HasSecondaryAttribute)
        {
            var secondaryBonus = GetAttributeValue(player, skill.SecondaryAttribute!) / 2;
            return primaryBonus + secondaryBonus;
        }

        return primaryBonus;
    }

    /// <summary>
    /// Calculates other bonus dice for the skill.
    /// </summary>
    private int CalculateOtherBonus(Player player, SkillDefinition skill, int additionalBonusDice)
    {
        var otherBonus = additionalBonusDice;

        if (skill.RequiresTraining && !PlayerHasSkillTraining(player, skill.Id))
        {
            // In success-counting, untrained penalty reduces dice pool
            otherBonus -= skill.UntrainedPenalty;
            _logger.LogDebug(
                "Applied untrained penalty of -{Penalty} dice for {Skill}",
                skill.UntrainedPenalty, skill.Name);
        }

        return otherBonus;
    }

    private static int GetAttributeValue(Player player, string attributeId)
    {
        return attributeId.ToLowerInvariant() switch
        {
            "might" => player.Attributes.Might,
            "fortitude" => player.Attributes.Fortitude,
            "will" => player.Attributes.Will,
            "wits" => player.Attributes.Wits,
            "finesse" => player.Attributes.Finesse,
            _ => 0
        };
    }

    private static bool PlayerHasSkillTraining(Player player, string skillId)
    {
        // TODO: Implement skill training system in future version
        return true;
    }

    private void LogCheckResult(SkillCheckResult result)
    {
        var level = result.IsCritical ? LogLevel.Information : LogLevel.Debug;

        _logger.Log(level,
            "Skill check complete: Skill={Skill} Net={Net} ({Successes}S-{Botches}B) DC={DC} Outcome={Outcome} Margin={Margin}",
            result.SkillName,
            result.NetSuccesses,
            result.DiceResult.TotalSuccesses,
            result.DiceResult.TotalBotches,
            result.DifficultyClass,
            result.Outcome,
            result.Margin);

        _eventLogger?.LogDice("SkillCheck", $"{result.SkillName}: {result.Outcome.GetDisplayName()}",
            data: new Dictionary<string, object>
            {
                ["skillId"] = result.SkillId,
                ["skillName"] = result.SkillName,
                ["netSuccesses"] = result.NetSuccesses,
                ["totalSuccesses"] = result.DiceResult.TotalSuccesses,
                ["totalBotches"] = result.DiceResult.TotalBotches,
                ["dc"] = result.DifficultyClass,
                ["dcName"] = result.DifficultyName,
                ["margin"] = result.Margin,
                ["outcome"] = result.Outcome.ToString(),
                ["isFumble"] = result.IsFumble,
                ["isCritical"] = result.IsCritical
            });

        if (result.IsFumble)
            _logger.LogInformation("FUMBLE on {Skill}!", result.SkillName);
        else if (result.IsCriticalSuccess)
            _logger.LogInformation("CRITICAL SUCCESS on {Skill}!", result.SkillName);
    }

    /// <summary>
    /// Gets all available skill definitions.
    /// </summary>
    public IReadOnlyList<SkillDefinition> GetAllSkills() => _configProvider.GetSkills();

    /// <summary>
    /// Gets skills filtered by category.
    /// </summary>
    public IReadOnlyList<SkillDefinition> GetSkillsByCategory(string category)
    {
        return _configProvider.GetSkills()
            .Where(s => s.IsInCategory(category))
            .OrderBy(s => s.SortOrder)
            .ThenBy(s => s.Name)
            .ToList();
    }

    /// <summary>
    /// Gets all difficulty class definitions.
    /// </summary>
    public IReadOnlyList<DifficultyClassDefinition> GetDifficultyClasses()
    {
        return _configProvider.GetDifficultyClasses()
            .OrderBy(dc => dc.SortOrder)
            .ToList();
    }

    /// <summary>
    /// Gets a difficulty class by ID.
    /// </summary>
    public DifficultyClassDefinition? GetDifficultyClass(string id) =>
        _configProvider.GetDifficultyClassById(id);

    /// <summary>
    /// Finds the nearest difficulty class for a given DC value.
    /// </summary>
    public DifficultyClassDefinition? GetNearestDifficultyClass(int targetNumber)
    {
        var allDCs = _configProvider.GetDifficultyClasses();
        return allDCs
            .OrderBy(dc => Math.Abs(dc.TargetNumber - targetNumber))
            .FirstOrDefault();
    }
}
```

### 7.2 Key Changes Summary

| Method | Before | After |
|--------|--------|-------|
| `PerformCheck` | Sum-based total | Uses NetSuccesses from DiceRollResult |
| `PerformCheckWithDC` | Sum-based comparison | Success-counting comparison |
| `PerformContestedCheck` | Compare TotalResult | Compare NetSuccesses, handle fumbles |
| `CalculateAttributeBonus` | Adds to sum | Adds to dice pool |
| `CalculateOtherBonus` | Adds to sum | Adds to dice pool |
| `LogCheckResult` | Logs sum-based | Logs success counts |

### 7.3 Contested Check Return Type Change

The `PerformContestedCheck` method return type changes to include `MarginOfVictory`:

**Before:**
```csharp
(SkillCheckResult ActiveResult, SkillCheckResult PassiveResult, string Winner)
```

**After:**
```csharp
(SkillCheckResult ActiveResult, SkillCheckResult PassiveResult, string Winner, int MarginOfVictory)
```

---

## 8. Data Model Changes

### 8.1 New Types Summary

| Type | Layer | File | Description |
|------|-------|------|-------------|
| `SkillOutcome` | Domain | `Enums/SkillOutcome.cs` | 6-tier outcome enum |
| `SkillOutcomeExtensions` | Domain | `Extensions/SkillOutcomeExtensions.cs` | Helper methods |

### 8.2 Modified Types Summary

| Type | Layer | File | Changes |
|------|-------|------|---------|
| `SkillCheckResult` | Domain | `ValueObjects/SkillCheckResult.cs` | Added NetSuccesses, Outcome, IsFumble; deprecated TotalResult, SuccessLevel |
| `SkillCheckService` | Application | `Services/SkillCheckService.cs` | Uses success-counting mechanics |

### 8.3 Preserved Types (Backward Compatibility)

| Type | Layer | Notes |
|------|-------|-------|
| `SuccessLevel` | Domain | Preserved for backward compatibility |
| `DifficultyClassDefinition` | Domain | No changes required |
| `SkillDefinition` | Domain | No changes required |

---

## 9. Configuration

### 9.1 Difficulty Class Configuration Updates

**File:** `config/difficulty-classes.json`

The difficulty classes need updated descriptions to reflect success-counting:

```json
{
  "difficultyClasses": [
    {
      "id": "trivial",
      "name": "Trivial",
      "targetNumber": 0,
      "description": "Automatic success (unless fumble)",
      "sortOrder": 0
    },
    {
      "id": "easy",
      "name": "Easy",
      "targetNumber": 1,
      "description": "Requires 1 net success",
      "sortOrder": 1
    },
    {
      "id": "moderate",
      "name": "Moderate",
      "targetNumber": 2,
      "description": "Requires 2 net successes",
      "sortOrder": 2
    },
    {
      "id": "challenging",
      "name": "Challenging",
      "targetNumber": 3,
      "description": "Requires 3 net successes",
      "sortOrder": 3
    },
    {
      "id": "hard",
      "name": "Hard",
      "targetNumber": 4,
      "description": "Requires 4 net successes",
      "sortOrder": 4
    },
    {
      "id": "extreme",
      "name": "Extreme",
      "targetNumber": 5,
      "description": "Requires 5 net successes",
      "sortOrder": 5
    },
    {
      "id": "legendary",
      "name": "Legendary",
      "targetNumber": 6,
      "description": "Requires 6+ net successes",
      "sortOrder": 6
    }
  ]
}
```

### 9.2 No New Configuration Files

v0.15.0c does not introduce new configuration files. The existing difficulty class configuration is updated with new descriptions only.

---

## 10. Commands

### 10.1 No Command Changes

v0.15.0c does not modify command structure. The `check` command will continue to work but display success-counting output.

### 10.2 Command Output Changes

The skill check output will change to show success counts:

**Before (sum-based):**
```
> check acrobatics moderate
Acrobatics: [14] +3 (attr) = 17 vs DC 12 (Moderate) -> Success
```

**After (success-counting):**
```
> check acrobatics moderate
Acrobatics: 3 net (4S - 1B) vs DC 2 (Moderate) → Full Success [margin: +1]
```

---

## 11. User-Facing Changes

### 11.1 Skill Check Output Format

| Scenario | Old Format | New Format |
|----------|------------|------------|
| Normal success | `Acrobatics: [14] +3 = 17 vs DC 12 → Success` | `Acrobatics: 3 net (4S - 1B) vs DC 2 → Full Success [margin: +1]` |
| Marginal | N/A (was binary) | `Stealth: 2 net (2S - 0B) vs DC 2 → Marginal Success [margin: 0]` |
| Exceptional | N/A (was binary) | `Persuasion: 6 net (6S - 0B) vs DC 2 → Exceptional Success [margin: +4]` |
| Fumble | `Lockpicking: [1] +2 = 3 vs DC 12 → Critical Failure` | `Lockpicking: 0 net (0S - 1B) vs DC 2 → Critical Failure [FUMBLE!]` |
| Critical | `Athletics: [10] +4 = 14 vs DC 8 → Critical Success` | `Athletics: 7 net (7S - 0B) vs DC 2 → Critical Success [margin: +5] [CRITICAL!]` |

### 11.2 New Outcome Descriptions

Users will see more granular feedback:

| Outcome | User Message Example |
|---------|---------------------|
| CriticalFailure | "FUMBLE! Your lockpick snaps inside the lock." |
| Failure | "The lock resists your attempts." |
| MarginalSuccess | "You pick the lock, but it took longer than expected." |
| FullSuccess | "You pick the lock smoothly." |
| ExceptionalSuccess | "You pick the lock with ease and notice a hidden mechanism." |
| CriticalSuccess | "CRITICAL! You bypass the lock instantly and discover a secret compartment." |

---

## 12. Logging Specifications

### 12.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `SkillCheckService` | Information | Service initialization, critical results |
| `SkillCheckService` | Debug | Check details, outcome classification |
| `SkillCheckResult` | Debug | Construction with outcome |

### 12.2 Log Message Formats

```
[Information] SkillCheckService initialized (success-counting mode)
[Debug] Performing skill check: Player=Hero, Skill=acrobatics, DC=moderate, Advantage=Normal
[Debug] Skill check complete: Skill=Acrobatics Net=3 (4S-1B) DC=2 Outcome=FullSuccess Margin=1
[Information] FUMBLE on Lockpicking!
[Information] CRITICAL SUCCESS on Athletics!
[Information] Contested check: Hero (3 net) vs Villain (1 net) → Hero wins by 2
[Information] Hero fumbled! Villain automatically wins.
```

---

## 13. Unit Testing Requirements

### 13.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Outcome classification | 3 |
| Fumble detection | 2 |
| Marginal success | 1 |
| Critical success | 1 |
| Contested checks | 1 |
| **Total** | **~8** |

### 13.2 Test Specifications

**File:** `tests/RuneAndRust.Domain.UnitTests/ValueObjects/SkillCheckResultSuccessCountingTests.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Domain.UnitTests.ValueObjects;

[TestFixture]
public class SkillCheckResultSuccessCountingTests
{
    [Test]
    public void ClassifyOutcome_Fumble_ReturnsCriticalFailure()
    {
        // Arrange & Act
        var outcome = SkillCheckResult.ClassifyOutcome(
            netSuccesses: 0,
            difficultyClass: 2,
            isFumble: true);

        // Assert
        Assert.That(outcome, Is.EqualTo(SkillOutcome.CriticalFailure));
    }

    [Test]
    public void ClassifyOutcome_NegativeMargin_ReturnsFailure()
    {
        var outcome = SkillCheckResult.ClassifyOutcome(
            netSuccesses: 1,
            difficultyClass: 2,
            isFumble: false);

        Assert.That(outcome, Is.EqualTo(SkillOutcome.Failure));
    }

    [Test]
    public void ClassifyOutcome_ZeroMargin_ReturnsMarginalSuccess()
    {
        var outcome = SkillCheckResult.ClassifyOutcome(
            netSuccesses: 2,
            difficultyClass: 2,
            isFumble: false);

        Assert.That(outcome, Is.EqualTo(SkillOutcome.MarginalSuccess));
    }

    [Test]
    public void ClassifyOutcome_MarginOneToTwo_ReturnsFullSuccess()
    {
        var outcome1 = SkillCheckResult.ClassifyOutcome(3, 2, false);
        var outcome2 = SkillCheckResult.ClassifyOutcome(4, 2, false);

        Assert.That(outcome1, Is.EqualTo(SkillOutcome.FullSuccess));
        Assert.That(outcome2, Is.EqualTo(SkillOutcome.FullSuccess));
    }

    [Test]
    public void ClassifyOutcome_MarginThreeToFour_ReturnsExceptionalSuccess()
    {
        var outcome1 = SkillCheckResult.ClassifyOutcome(5, 2, false);
        var outcome2 = SkillCheckResult.ClassifyOutcome(6, 2, false);

        Assert.That(outcome1, Is.EqualTo(SkillOutcome.ExceptionalSuccess));
        Assert.That(outcome2, Is.EqualTo(SkillOutcome.ExceptionalSuccess));
    }

    [Test]
    public void ClassifyOutcome_MarginFiveOrMore_ReturnsCriticalSuccess()
    {
        var outcome1 = SkillCheckResult.ClassifyOutcome(7, 2, false);
        var outcome2 = SkillCheckResult.ClassifyOutcome(10, 2, false);

        Assert.That(outcome1, Is.EqualTo(SkillOutcome.CriticalSuccess));
        Assert.That(outcome2, Is.EqualTo(SkillOutcome.CriticalSuccess));
    }

    [Test]
    public void ClassifyOutcome_FumbleOverridesMargin()
    {
        // Even with high net successes, fumble wins
        var outcome = SkillCheckResult.ClassifyOutcome(
            netSuccesses: 5,
            difficultyClass: 0,
            isFumble: true);

        // Note: This scenario shouldn't occur in practice (fumble implies 0 successes)
        // but tests that fumble flag takes precedence
        Assert.That(outcome, Is.EqualTo(SkillOutcome.CriticalFailure));
    }

    [Test]
    public void Constructor_SetsNetSuccessesFromDiceResult()
    {
        // Arrange: Create a mock DiceRollResult with known values
        var pool = new DicePool(4, DiceType.D10);
        var rolls = new[] { 8, 9, 1, 5 };  // 2 successes, 1 botch
        var diceResult = new DiceRollResult(pool, rolls);

        // Act
        var result = new SkillCheckResult(
            "test", "Test Skill", diceResult,
            attributeBonus: 0, otherBonus: 0,
            difficultyClass: 2, difficultyName: "Moderate");

        // Assert
        Assert.That(result.NetSuccesses, Is.EqualTo(1));  // 2 - 1
        Assert.That(result.Margin, Is.EqualTo(-1));       // 1 - 2
        Assert.That(result.Outcome, Is.EqualTo(SkillOutcome.Failure));
    }
}
```

**File:** `tests/RuneAndRust.Application.UnitTests/Services/SkillCheckServiceSuccessCountingTests.cs`

```csharp
using Microsoft.Extensions.Logging;
using Moq;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Application.Services;
using RuneAndRust.Domain.Definitions;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.Interfaces;

namespace RuneAndRust.Application.UnitTests.Services;

[TestFixture]
public class SkillCheckServiceSuccessCountingTests
{
    private Mock<ILogger<DiceService>> _mockDiceLogger = null!;
    private Mock<ILogger<SkillCheckService>> _mockSkillLogger = null!;
    private Mock<IGameConfigurationProvider> _mockConfigProvider = null!;
    private DiceService _diceService = null!;
    private SkillCheckService _skillCheckService = null!;

    [SetUp]
    public void SetUp()
    {
        _mockDiceLogger = new Mock<ILogger<DiceService>>();
        _mockSkillLogger = new Mock<ILogger<SkillCheckService>>();
        _mockConfigProvider = new Mock<IGameConfigurationProvider>();

        // Use seeded random for deterministic tests
        var seededRandom = new Random(42);
        var randomProvider = new SeededRandomProvider(42);
        _diceService = new DiceService(randomProvider, _mockDiceLogger.Object);
        _skillCheckService = new SkillCheckService(
            _diceService, _mockConfigProvider.Object, _mockSkillLogger.Object);

        // Setup mock skill
        var testSkill = new SkillDefinition
        {
            Id = "acrobatics",
            Name = "Acrobatics",
            BaseDicePool = "3d10",
            PrimaryAttribute = "finesse"
        };
        _mockConfigProvider.Setup(p => p.GetSkillById("acrobatics")).Returns(testSkill);
    }

    [Test]
    public void PerformCheckWithDC_UsesSuccessCounting()
    {
        // Arrange
        var player = CreateTestPlayer();

        // Act
        var result = _skillCheckService.PerformCheckWithDC(
            player, "acrobatics", difficultyClass: 2);

        // Assert
        Assert.That(result.NetSuccesses, Is.GreaterThanOrEqualTo(0));
        Assert.That(result.Outcome, Is.TypeOf<SkillOutcome>());
    }

    [Test]
    public void PerformCheckWithDC_FumbleDetected()
    {
        // This test may need multiple runs or specific seed to get a fumble
        // Using a mock to guarantee fumble conditions
        var player = CreateTestPlayer();

        // Run multiple checks to increase chance of fumble
        var results = Enumerable.Range(0, 100)
            .Select(_ => _skillCheckService.PerformCheckWithDC(player, "acrobatics", 1))
            .ToList();

        // With 100 rolls, we should see at least one fumble
        // (or this demonstrates the probability is very low with this pool size)
        // For guaranteed testing, use a mocked DiceService
    }

    [Test]
    public void PerformContestedCheck_ComparesNetSuccesses()
    {
        // Arrange
        var activePlayer = CreateTestPlayer("Hero");
        var passivePlayer = CreateTestPlayer("Villain");

        // Act
        var (activeResult, passiveResult, winner, margin) =
            _skillCheckService.PerformContestedCheck(
                activePlayer, passivePlayer,
                "acrobatics", "acrobatics");

        // Assert
        Assert.That(winner, Is.Not.Null.And.Not.Empty);
        Assert.That(margin, Is.GreaterThanOrEqualTo(0));

        // Winner should have equal or more net successes (ties favor active)
        if (winner == "Hero")
            Assert.That(activeResult.NetSuccesses, Is.GreaterThanOrEqualTo(passiveResult.NetSuccesses));
        else if (winner == "Villain")
            Assert.That(passiveResult.NetSuccesses, Is.GreaterThan(activeResult.NetSuccesses));
    }

    private static Player CreateTestPlayer(string name = "TestPlayer")
    {
        return new Player
        {
            Id = Guid.NewGuid(),
            Name = name,
            Attributes = new PlayerAttributes
            {
                Might = 2,
                Fortitude = 2,
                Will = 2,
                Wits = 2,
                Finesse = 3
            }
        };
    }
}
```

---

## 14. Use Cases

### 14.1 UC-150c-001: Standard Skill Check

**Actor:** Player
**Flow:** Player requests skill check → System rolls dice → System counts successes → System classifies outcome

**Details:**
1. Player initiates skill check (e.g., `check acrobatics moderate`)
2. SkillCheckService calculates dice pool (base + attribute + modifiers)
3. DiceService.Roll() returns result with NetSuccesses, IsFumble
4. SkillCheckResult.ClassifyOutcome() determines tier
5. Result displayed with outcome and margin

### 14.2 UC-150c-002: Fumble Detection

**Actor:** System
**Flow:** Player rolls → System detects fumble → CriticalFailure outcome

**Details:**
1. Player rolls dice pool
2. DiceRollResult.IsFumble is true (0 successes + ≥1 botch)
3. ClassifyOutcome returns CriticalFailure regardless of DC
4. System logs fumble event
5. Game may apply fumble consequences (v0.15.1+)

### 14.3 UC-150c-003: Contested Check

**Actor:** Two Players
**Flow:** Both roll → Compare NetSuccesses → Determine winner

**Details:**
1. Active and passive players both roll skill checks (DC 0)
2. Compare NetSuccesses directly
3. Higher net successes wins; ties favor active player
4. Fumble by either gives automatic win to opponent
5. Both fumble = mutual failure

### 14.4 UC-150c-004: Marginal Success

**Actor:** Player
**Flow:** Player rolls exactly enough → MarginalSuccess with complications

**Details:**
1. Player rolls and gets NetSuccesses = DC (margin 0)
2. ClassifyOutcome returns MarginalSuccess
3. Game describes success with complications
4. Example: "You pick the lock, but it took extra time."

---

## 15. Deliverable Checklist

### 15.1 Domain Layer

- [ ] `SkillOutcome.cs` created in `Domain/Enums/`
- [ ] `SkillOutcomeExtensions.cs` created in `Domain/Extensions/`
- [ ] `SkillCheckResult.cs` refactored with success-counting
- [ ] `ClassifyOutcome()` static method implemented
- [ ] Backward compatibility properties marked `[Obsolete]`

### 15.2 Application Layer

- [ ] `SkillCheckService.cs` refactored for success-counting
- [ ] Contested check returns `MarginOfVictory`
- [ ] Fumble handling in contested checks
- [ ] Logging updated for success-counting

### 15.3 Unit Tests

- [ ] `SkillCheckResultSuccessCountingTests.cs` created (~8 tests)
- [ ] `SkillCheckServiceSuccessCountingTests.cs` updated
- [ ] All outcome tiers tested
- [ ] Fumble detection tested
- [ ] Marginal success tested
- [ ] Contested check tested

### 15.4 Documentation

- [ ] This design specification complete
- [ ] Code XML documentation complete

---

## 16. Acceptance Criteria

### 16.1 Functional

- [ ] Skill checks use NetSuccesses instead of sum totals
- [ ] Fumble (0 successes + ≥1 botch) results in CriticalFailure
- [ ] Margin calculated as NetSuccesses - DC
- [ ] MarginalSuccess returned when margin = 0
- [ ] FullSuccess returned when margin 1-2
- [ ] ExceptionalSuccess returned when margin 3-4
- [ ] CriticalSuccess returned when margin ≥ 5
- [ ] Contested checks compare NetSuccesses
- [ ] Ties in contested checks favor active player
- [ ] Fumble in contested check gives automatic win to opponent
- [ ] Both fumble in contested check = mutual failure

### 16.2 Quality

- [ ] Build succeeds with 0 errors
- [ ] Build succeeds with 0 warnings
- [ ] All ~8 new unit tests pass
- [ ] All existing skill check tests updated and passing
- [ ] Backward compatibility maintained via `[Obsolete]` properties
- [ ] XML documentation complete on all public members

---

## 17. Future Considerations

### 17.1 Deferred to v0.15.0d (Contested & Extended Checks)

- `ContestedCheckResult` value object
- `ContestedOutcome` enum
- `ExtendedCheckState` entity
- Accumulated successes over rounds
- Catastrophic failure on 3 consecutive fumbles

### 17.2 Deferred to v0.15.0e (Dice Roll Logging)

- `IDiceRollLogger` interface
- `DiceRollLog` record with outcome data
- Outcome filtering in roll history

### 17.3 Deferred to v0.15.0f (Combat Integration)

- Map `SkillOutcome` to `HitQuality`
- Combat skill checks use success-counting
- Defense rolls use NetSuccesses

### 17.4 Deferred to v0.15.1+ (Fumble Consequences)

- `FumbleConsequence` entity
- Skill-specific fumble tables
- Fumble severity based on botch count

---

## 18. Implementation Notes

### 18.1 Backward Compatibility

The `SuccessLevel` property and `TotalResult` property are preserved with `[Obsolete]` attributes for code that hasn't been updated. The extension method `SkillOutcome.ToSuccessLevel()` provides mapping.

### 18.2 DC Value Interpretation Change

**Important:** Difficulty Class values now represent the number of net successes required, not a sum threshold. A "Moderate" check that was DC 12 (sum-based) becomes DC 2 (2 net successes required).

Existing DC configurations may need value adjustments:
- DC 1 = Very Easy (30% success per die)
- DC 2 = Moderate
- DC 3 = Challenging
- DC 4 = Hard
- DC 5+ = Extreme

### 18.3 Attribute Bonus Interpretation

In success-counting, attribute bonuses add dice to the pool rather than adding to a sum. Higher attributes mean more dice, increasing the probability of successes.

### 18.4 Testing Strategy

Use `SeededRandomProvider` from v0.15.0b for deterministic testing. With known seeds, exact dice values are predictable, allowing verification of outcome classification.

---

## 19. Document Metadata

---

*Document Version: 1.0*
*Last Updated: 2026-01-17*
*Author: Claude*

---

*This design specification provides the detailed blueprint for implementing v0.15.0c Skill Check Refactor. This transitions skill checks to success-counting mechanics with 6-tier outcomes, building on the dice system changes from v0.15.0a and the seeded RNG from v0.15.0b.*
