# Design Specification: v0.20.1c - Skjaldmær Tier 3 & Capstone Abilities

**Version:** v0.20.1c
**Status:** Design Phase
**Last Updated:** 2026-01-28
**Target Tests:** ~7 unit and integration tests
**Specialization:** Skjaldmær (Shield-Maiden)
**Focus:** Tier 3 Mastery & Ultimate Capstone

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Domain Layer Specifications](#5-domain-layer-specifications)
6. [Application Layer Specifications](#6-application-layer-specifications)
7. [Infrastructure Layer Configuration](#7-infrastructure-layer-configuration)
8. [Unbreakable Ability](#8-unbreakable-ability)
9. [Guardian's Sacrifice Ability](#9-guardians-sacrifice-ability)
10. [The Wall Lives Capstone](#10-the-wall-lives-capstone)
11. [Damage Pipeline Integration](#11-damage-pipeline-integration)
12. [Decision Trees and Flow Diagrams](#12-decision-trees-and-flow-diagrams)
13. [Code Examples with XML Documentation](#13-code-examples-with-xml-documentation)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Integration Testing Requirements](#16-integration-testing-requirements)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Dependencies](#19-dependencies)
20. [Deferrals and Future Considerations](#20-deferrals-and-future-considerations)

---

## 1. Executive Summary

Version 0.20.1c completes the Skjaldmær specialization implementation with two Tier 3 defensive mastery abilities and the signature Capstone ultimate. This phase represents the pinnacle of defensive tanking, introducing passive damage reduction and the iconic "cannot die" mechanics that define the ultimate protector.

### Phase Objectives

- Implement Tier 3 prerequisite validation (requires 16 PP invested)
- Implement Capstone prerequisite validation (requires 24 PP invested)
- Create two Tier 3 mastery abilities with advanced mechanics:
  - **Unbreakable:** Passive damage reduction scaling with defensive discipline
  - **Guardian's Sacrifice:** Reaction ability to completely absorb ally damage
- Create Capstone ultimate with game-changing mechanics:
  - **The Wall Lives:** 3-turn invulnerability (cannot drop below 1 HP)
- Establish damage pipeline integration
- Provide complete infrastructure configuration
- Establish unit test coverage (~7 tests)

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Domain Value Objects** | 1 | `TheWallLivesState` |
| **Application Services** | 1 | Enhanced `ISkjaldmaerAbilityService` |
| **Ability Implementations** | 3 | Unbreakable, Guardian's Sacrifice, The Wall Lives |
| **Integration Points** | 2 | Damage pipeline, cooldown system |
| **Configuration Updates** | 2 | specializations.json, abilities.json |
| **Unit Tests** | ~7 | Comprehensive Tier 3/Capstone coverage |

### Tier 3 & Capstone Abilities Overview

| Ability | Type | Cost | Key Mechanic | Purpose |
|---------|------|------|--------------|---------|
| **Unbreakable** | Passive | N/A | -3 damage (min 1) | Consistent reduction |
| **Guardian's Sacrifice** | Reaction | 2 Charges | Absorb 100% ally damage | Absolute protection |
| **The Wall Lives** | Ultimate | 4 AP | Cannot drop below 1 HP (3 turns) | Signature defense |

---

## 2. Feature Overview

### 2.1 Unbreakable (Tier 3 Passive)

**Conceptual Role:** The culmination of defensive discipline, where the Skjaldmær's body becomes progressively harder to injure through sheer tactical mastery and conditioning.

**Key Features:**
- **Type:** Passive ability (always active)
- **Effect:** Reduce all damage taken by 3
- **Minimum Damage:** 1 (prevents immunity)
- **Application:** All damage types (physical, magical, Aetheric)
- **Stacking:** Additive with armor/resistance
- **Precedence:** Applied before other damage reduction

**Damage Calculation:**
```
Effective Damage = max(1, IncomingDamage - 3)

Examples:
- 10 damage → 7 damage (10 - 3)
- 3 damage → 1 damage (max(1, 3 - 3))
- 1 damage → 1 damage (max(1, 1 - 3))
- 50 damage → 47 damage (50 - 3)
```

**Synergy:**
- Works with armor/shield to provide layered defense
- Enables Skjaldmær to survive burst damage scenarios
- Makes holding position more viable in prolonged fights

### 2.2 Guardian's Sacrifice (Tier 3 Reaction)

**Conceptual Role:** The ultimate expression of protective duty, where the Skjaldmær achieves the ability to completely intercept and absorb damage meant for an ally.

**Key Features:**
- **Type:** Reaction ability (triggered, no AP cost)
- **Trigger:** Ally within 2 spaces hit by attack
- **Resource Cost:** 2 Block Charges (high cost, high reward)
- **Effect:** Absorb 100% of attack damage for ally
- **Timing:** After attack hits, before damage applied
- **Synergy:** Unbreakable still applies to absorbed damage

**Comparison to Intercept:**
| Aspect | Intercept (T1) | Guardian's Sacrifice (T3) |
|--------|---|---|
| **Trigger** | Attack targeting ally | Attack hitting ally |
| **Timing** | Pre-resolution | Post-hit, pre-damage |
| **Redirection** | Full attack redirect | Direct absorption |
| **Charges** | 1 | 2 |
| **Guarantee** | Redirected attack resolves | 100% absorption guaranteed |

### 2.3 The Wall Lives (Capstone Ultimate)

**Conceptual Role:** The ultimate expression of the Skjaldmær's philosophy — the assertion that they will not fall, that the wall will hold, that hope persists.

**Key Features:**
- **Type:** Ultimate ability with AP cost
- **Duration:** 3 turns (long enough to matter, short enough to not trivialize)
- **Effect:** Cannot be reduced below 1 HP (prevents lethal damage)
- **Cooldown:** Once per combat (unique per combat)
- **AP Cost:** 4 (significant resource commitment)
- **Visible:** Clear UI indicator showing effect active
- **Edge Cases:** Does not prevent instant death effects (if any exist)

**Core Mechanic:**
```
Original Damage Calculation:
NewHP = CurrentHP - Damage

With The Wall Lives Active:
if (NewHP < 1)
    NewHP = 1  // Prevent lethal damage
else
    NewHP = CurrentHP - Damage
```

---

## 3. Architecture Diagrams

### 3.1 Tier 3 & Capstone Integration

```
┌─────────────────────────────────────────────────────┐
│     v0.20.1c Tier 3 & Capstone Architecture        │
├─────────────────────────────────────────────────────┤
│                                                     │
│  v0.20.1a + v0.20.1b (Foundation) ──────────────┐  │
│  ├── BlockChargeResource                        │  │
│  ├── Tier 1-2 Abilities                         │  │
│  ├── Character Extensions                       │  │
│  └── Prerequisite System                        │  │
│                                            │    │  │
│  ▼──────────────────────────────────────────┘    │  │
│                                                   │  │
│  ┌────────────────────────────────────────────┐  │  │
│  │ Tier 3 Value Objects (NEW)                 │  │  │
│  ├────────────────────────────────────────────┤  │  │
│  │ • TheWallLivesState                        │  │  │
│  │   ├── IsActive: bool                       │  │  │
│  │   ├── TurnsRemaining: int                  │  │  │
│  │   ├── ActivatedAt: DateTime                │  │  │
│  │   ├── Tick(): void                         │  │  │
│  │   ├── IsExpired(): bool                    │  │  │
│  │   └── PreventLethalDamage(damage): int     │  │  │
│  └────────────────────────────────────────────┘  │  │
│                    │                             │  │
│  ┌────────────────▼──────────────────────────┐  │  │
│  │ Enhanced Services (NEW METHODS)           │  │  │
│  ├────────────────────────────────────────────┤  │  │
│  │ • ISkjaldmaerAbilityService                │  │  │
│  │   ├── ActivateUnbreakableAsync()           │  │  │
│  │   ├── TryGuardiansSacrificeAsync()         │  │  │
│  │   ├── ActivateTheWallLivesAsync()          │  │  │
│  │   ├── GetDamageReduction()                 │  │  │
│  │   └── CanUseCapstone()                     │  │  │
│  │                                             │  │  │
│  │ • IDamageService (NEW)                    │  │  │
│  │   ├── ApplyDamageWithReductions()          │  │  │
│  │   ├── CheckLethalDamageProtection()        │  │  │
│  │   └── LogDamageApplication()               │  │  │
│  └────────────────────────────────────────────┘  │  │
│                    │                             │  │
│  ┌────────────────▼──────────────────────────┐  │  │
│  │ Ability Handlers (NEW)                    │  │  │
│  ├────────────────────────────────────────────┤  │  │
│  │ • UnbreakableAbilityHandler                │  │  │
│  │ • GuardiansSacrificeAbilityHandler         │  │  │
│  │ • TheWallLivesAbilityHandler               │  │  │
│  └────────────────────────────────────────────┘  │  │
│                                                   │  │
└─────────────────────────────────────────────────────┘

Damage Pipeline Integration:
┌──────────────────┐
│ Incoming Damage  │
│ (Before Reduce)  │
└────────┬─────────┘
         │
    ┌────▼────────────────┐
    │ Unbreakable Active?  │
    └────┬─────────────────┘
         │
     ┌───┴────┐
  No │        │ Yes
     │        │
  │  ▼   ┌────▼──────────────┐
  │  │   │ Apply -3 Damage   │
  │  │   │ (min 1)           │
  │  │   └────┬──────────────┘
  │  │        │
  │  ├────────┤
  │  │        │
  │  │   ┌────▼──────────────┐
  │  │   │ TheWallLives      │
  │  │   │ Active?           │
  │  │   └────┬──────────────┘
  │  │        │
  │  │    ┌───┴────┐
  │  │ No │        │ Yes
  │  │    │        │
  │  │ ┌──▼──┐ ┌───▼──────────┐
  │  │ │Apply│ │ NewHP < 1?   │
  │  │ │Damage│ └────┬─────────┘
  │  │ └──────┘      │
  │  │           ┌───┴────┐
  │  │        No │        │ Yes
  │  │           │        │
  │  │        ┌──▼──┐ ┌──▼────┐
  │  │        │Apply│ │Set HP  │
  │  │        │Damage│ │to 1    │
  │  │        └──────┘ └────────┘
  │  │
  └──▼──────────────────────────────────┐
          ▼
    ┌─────────────────┐
    │ Final Damage    │
    │ Applied to HP   │
    └─────────────────┘
```

### 3.2 Guardian's Sacrifice Flow

```
┌──────────────────────────────────┐
│ Attack Resolves Against Ally     │
│ (Damage About to Be Applied)     │
└────────────┬─────────────────────┘
             │
      ┌──────▼─────────┐
      │ Find Skjaldmær │
      │ Within 2 sp    │
      └──────┬─────────┘
             │
      ┌──────▼──────────┐
      │ Can Sacrifice?  │
      │ • 2 charges?    │
      │ • LoS?          │
      │ • Range?        │
      └──────┬──────────┘
             │
        ┌────┴─────┐
     No │          │ Yes
        │          │
   ┌────▼──┐  ┌────▼──────────┐
   │Normal │  │ Spend Charges  │
   │Damage │  │ (2 required)   │
   │on Ally│  └────┬───────────┘
   └───────┘       │
              ┌────▼──────────────┐
              │ Apply All Damage  │
              │ to Skjaldmær      │
              │ (Unbreakable      │
              │  still applies)   │
              └────┬──────────────┘
                   │
              ┌────▼──────────────┐
              │ Ally Takes 0      │
              │ Damage            │
              └────┬──────────────┘
                   │
              ┌────▼──────────────┐
              │ Log Sacrifice     │
              │ Continue Combat   │
              └────────────────────┘
```

### 3.3 The Wall Lives Activation

```
┌───────────────────────────┐
│ The Wall Lives Activated  │
│ (4 AP, Capstone)          │
└───────────┬───────────────┘
            │
     ┌──────▼──────────┐
     │ >= 4 AP?        │
     └──────┬──────────┘
            │
        ┌───┴────┐
     No │        │ Yes
        │        │
   ┌────▼─┐ ┌───▼─────────────┐
   │ Fail │ │ Used this       │
   └──────┘ │ combat already? │
            └───┬─────────────┘
                │
            ┌───┴────┐
         No │        │ Yes
            │        │
        ┌───▼──┐ ┌──▼────┐
        │Start │ │ Fail  │
        │Timer │ │ (Once │
        │3T    │ │per    │
        └───┬──┘ │Combat)│
            │    └───────┘
        ┌───▼──────────────┐
        │ Create State     │
        │ IsActive = true  │
        │ TurnsRemaining=3 │
        └───┬──────────────┘
            │
        ┌───▼──────────────┐
        │ Spend 4 AP       │
        │ Mark As Used     │
        │ (Cooldown Active)│
        └───┬──────────────┘
            │
        ┌───▼──────────────┐
        │ Next 3 Turns:    │
        │ Lethal Protection│
        │ Active           │
        └────────────────────┘
```

---

## 4. User Stories

### 4.1 Unbreakable Passive Benefit

**As a** Skjaldmær with 16+ PP invested
**I want to** automatically reduce all damage I take by 3
**So that** I can be the resilient tank the party depends on

**Acceptance Criteria:**
- Passive applies to all damage types
- Minimum 1 damage rule prevents immunity exploits
- Bonus works immediately upon unlocking
- Applies before other damage reductions

### 4.2 Guardian's Sacrifice Ultimate Protection

**As a** Skjaldmær protecting my allies
**I want to** spend 2 Block Charges to completely absorb an attack meant for an ally
**So that** I can achieve absolute protection when it matters most

**Acceptance Criteria:**
- Triggers when ally within 2 spaces is hit by attack
- Requires exactly 2 Block Charges
- Absorbs 100% of attack damage (ally takes 0)
- Skjaldmær takes all damage (Unbreakable still applies)
- Reaction is automatic if conditions met

### 4.3 The Wall Lives Ultimate Stand

**As a** Skjaldmær in critical situation
**I want to** activate The Wall Lives to become invulnerable for 3 turns
**So that** I can make a final stand and turn the tide of battle

**Acceptance Criteria:**
- Costs 4 AP to activate
- Effect lasts exactly 3 turns
- Cannot drop below 1 HP during effect
- Only usable once per combat
- Visual indicator shows effect is active
- After 3 turns, normal damage rules apply

---

## 5. Domain Layer Specifications

### 5.1 TheWallLivesState Value Object

```csharp
/// <summary>
/// Represents the state of The Wall Lives capstone ability effect.
/// Manages invulnerability duration and lethal damage prevention.
/// </summary>
public sealed record TheWallLivesState
{
    /// <summary>
    /// Whether The Wall Lives is currently active.
    /// During this time, character cannot drop below 1 HP.
    /// </summary>
    public bool IsActive { get; private set; }

    /// <summary>
    /// Number of turns remaining for this effect (0-3).
    /// Decrements at end of each turn.
    /// </summary>
    public int TurnsRemaining { get; private set; } = 3;

    /// <summary>
    /// UTC timestamp when effect was activated.
    /// Used for duration verification and logging.
    /// </summary>
    public DateTime ActivatedAt { get; private set; }

    /// <summary>
    /// UTC timestamp when effect will expire.
    /// Calculated as ActivatedAt + 3 turns.
    /// </summary>
    public DateTime ExpiresAt { get; private set; }

    /// <summary>
    /// Activates The Wall Lives effect.
    /// </summary>
    /// <remarks>
    /// Sets TurnsRemaining to 3 and marks as active.
    /// Sets ExpiresAt for verification.
    /// Called when ability is executed.
    /// </remarks>
    public void Activate()
    {
        IsActive = true;
        TurnsRemaining = 3;
        ActivatedAt = DateTime.UtcNow;
        ExpiresAt = DateTime.UtcNow.AddMinutes(10); // Rough estimate; actual turntime matters
    }

    /// <summary>
    /// Decrements turns remaining and deactivates if expired.
    /// </summary>
    /// <remarks>
    /// Called at end of each turn during combat.
    /// </remarks>
    public void Tick()
    {
        if (!IsActive)
            return;

        TurnsRemaining--;
        if (TurnsRemaining <= 0)
            IsActive = false;
    }

    /// <summary>
    /// Determines if the effect has expired.
    /// </summary>
    public bool IsExpired() => !IsActive || TurnsRemaining <= 0;

    /// <summary>
    /// Prevents lethal damage while effect is active.
    /// </summary>
    /// <param name="currentHp">Character's current HP before damage</param>
    /// <param name="incomingDamage">Damage being applied</param>
    /// <returns>Actual damage that should be applied (capped at leaving 1 HP)</returns>
    /// <remarks>
    /// If incoming damage would reduce HP below 1, it's capped to leave HP at 1.
    /// This preserves the character's life for the duration of the effect.
    /// </remarks>
    public int PreventLethalDamage(int currentHp, int incomingDamage)
    {
        if (!IsActive)
            return incomingDamage;

        int resultingHp = currentHp - incomingDamage;

        // If damage would be lethal, cap damage to leave 1 HP
        if (resultingHp < 1)
        {
            int cappedDamage = currentHp - 1;
            return Math.Max(cappedDamage, 0);
        }

        return incomingDamage;
    }

    /// <summary>
    /// Deactivates the effect immediately.
    /// </summary>
    /// <remarks>
    /// Called when effect expires or is dispelled.
    /// </remarks>
    public void Deactivate()
    {
        IsActive = false;
        TurnsRemaining = 0;
    }

    /// <summary>
    /// Gets remaining duration in turns.
    /// </summary>
    /// <returns>Number of turns until effect expires</returns>
    public int GetRemainingDuration() => IsActive ? TurnsRemaining : 0;
}
```

### 5.2 Character Entity Final Extensions

```csharp
public partial class Character : Entity
{
    /// <summary>
    /// Active The Wall Lives effect (capstone).
    /// </summary>
    public TheWallLivesState? TheWallLivesState { get; set; }

    /// <summary>
    /// Whether The Wall Lives has been used this combat.
    /// Prevents multiple uses per combat.
    /// </summary>
    public bool HasUsedCapstoneThisCombat { get; set; }

    /// <summary>
    /// Gets damage reduction from Unbreakable passive.
    /// </summary>
    /// <returns>Damage reduction value (3) if Unbreakable unlocked, 0 otherwise</returns>
    public int GetUnbreakableReduction()
    {
        if (Specialization != SpecializationId.Skjaldmaer)
            return 0;

        if (!HasAbilityUnlocked(SkjaldmaerAbilityId.Unbreakable))
            return 0;

        return 3; // Standard reduction
    }

    /// <summary>
    /// Applies damage with all protective abilities active.
    /// </summary>
    /// <param name="incomingDamage">Raw incoming damage</param>
    /// <returns>Actual damage after all reductions/protections</returns>
    public int CalculateFinalDamage(int incomingDamage)
    {
        int finalDamage = incomingDamage;

        // Apply Unbreakable reduction
        int unbreakableReduction = GetUnbreakableReduction();
        finalDamage = Math.Max(1, finalDamage - unbreakableReduction);

        // Check The Wall Lives protection
        if (TheWallLivesState?.IsActive == true)
        {
            finalDamage = TheWallLivesState.PreventLethalDamage(CurrentHP, finalDamage);
        }

        return finalDamage;
    }

    /// <summary>
    /// Applies damage to character with all protections.
    /// </summary>
    /// <param name="incomingDamage">Raw incoming damage</param>
    public void TakeDamage(int incomingDamage)
    {
        int finalDamage = CalculateFinalDamage(incomingDamage);
        CurrentHP = Math.Max(0, CurrentHP - finalDamage);
    }
}
```

---

## 6. Application Layer Specifications

### 6.1 Enhanced ISkjaldmaerAbilityService Interface

```csharp
/// <summary>
/// Extended service interface for Tier 3 & Capstone Skjaldmær abilities.
/// </summary>
public interface ISkjaldmaerAbilityService
{
    // Tier 1 methods (from v0.20.1a)
    // Tier 2 methods (from v0.20.1b)

    // Tier 3 & Capstone methods (NEW)

    /// <summary>
    /// Gets damage reduction from Unbreakable passive.
    /// </summary>
    /// <param name="character">Character to check</param>
    /// <returns>Damage reduction value (3 if unlocked, 0 otherwise)</returns>
    int GetDamageReduction(Character character);

    /// <summary>
    /// Attempts to execute Guardian's Sacrifice reaction.
    /// </summary>
    /// <param name="character">Skjaldmær executing reaction</param>
    /// <param name="defendedAlly">Ally being protected</param>
    /// <param name="incomingDamage">Damage from the attack</param>
    /// <returns>True if sacrifice executed successfully</returns>
    Task<bool> TryGuardiansSacrificeAsync(Character character, Character defendedAlly, int incomingDamage);

    /// <summary>
    /// Attempts to activate The Wall Lives capstone ability.
    /// </summary>
    /// <param name="character">Skjaldmær activating ability</param>
    /// <returns>True if ability activated successfully</returns>
    Task<bool> ActivateTheWallLivesAsync(Character character);

    /// <summary>
    /// Checks if character can use The Wall Lives this combat.
    /// </summary>
    /// <param name="character">Character to check</param>
    /// <returns>True if capstone is available (not already used this combat)</returns>
    bool CanUseCapstone(Character character);

    /// <summary>
    /// Checks if character can unlock Tier 3 abilities.
    /// </summary>
    /// <param name="character">Character to check</param>
    /// <returns>True if character has 16+ PP invested</returns>
    bool CanUnlockTier3(Character character);

    /// <summary>
    /// Checks if character can unlock Capstone ability.
    /// </summary>
    /// <param name="character">Character to check</param>
    /// <returns>True if character has 24+ PP invested</returns>
    bool CanUnlockCapstone(Character character);
}
```

### 6.2 IDamageService Interface

**New service for damage pipeline integration:**

```csharp
/// <summary>
/// Service for applying damage with all protective abilities integrated.
/// Handles damage reduction, lethal protection, and logging.
/// </summary>
public interface IDamageService
{
    /// <summary>
    /// Applies damage to character with all reductions/protections.
    /// </summary>
    /// <param name="target">Character taking damage</param>
    /// <param name="incomingDamage">Raw damage before reductions</param>
    /// <returns>Actual damage applied to character</returns>
    Task<int> ApplyDamageAsync(Character target, int incomingDamage);

    /// <summary>
    /// Calculates final damage after all reductions.
    /// </summary>
    /// <param name="target">Target character</param>
    /// <param name="incomingDamage">Raw damage</param>
    /// <returns>Damage after Unbreakable/protections</returns>
    int CalculateFinalDamage(Character target, int incomingDamage);

    /// <summary>
    /// Checks if damage would be lethal and prevents if protected.
    /// </summary>
    /// <param name="character">Target character</param>
    /// <param name="damageAmount">Proposed damage</param>
    /// <returns>Modified damage (capped at safe level if protected)</returns>
    int CheckLethalDamageProtection(Character character, int damageAmount);
}
```

### 6.3 SkjaldmaerAbilityService Tier 3 Implementation

```csharp
/// <summary>
/// Tier 3 & Capstone method implementations.
/// </summary>
public class SkjaldmaerAbilityService : ISkjaldmaerAbilityService
{
    // Previous tier implementations...

    /// <summary>
    /// Gets damage reduction from Unbreakable passive.
    /// </summary>
    public int GetDamageReduction(Character character)
    {
        if (character?.Specialization != SpecializationId.Skjaldmaer)
            return 0;

        if (!character.HasAbilityUnlocked(SkjaldmaerAbilityId.Unbreakable))
            return 0;

        return 3;
    }

    /// <summary>
    /// Executes Guardian's Sacrifice reaction.
    /// </summary>
    public async Task<bool> TryGuardiansSacrificeAsync(
        Character character,
        Character defendedAlly,
        int incomingDamage)
    {
        // Validate Skjaldmær state
        if (character?.BlockCharges == null || character.IsIncapacitated)
            return false;

        // Validate ability unlock
        if (!character.HasAbilityUnlocked(SkjaldmaerAbilityId.GuardiansSacrifice))
            return false;

        // Validate range and LoS
        int distance = character.Position.DistanceTo(defendedAlly.Position);
        if (distance > 2)
            return false;

        if (!HasLineOfSight(character.Position, defendedAlly.Position))
            return false;

        // Validate charges
        if (!_blockChargeService.CanSpend(character, 2))
            return false;

        // Spend charges
        if (!await _blockChargeService.SpendChargesAsync(character, 2))
            return false;

        // Apply all damage to Skjaldmær
        character.TakeDamage(incomingDamage);
        defendedAlly.TakeDamage(0); // Ally takes no damage

        await _characterRepository.UpdateAsync(character);
        await _characterRepository.UpdateAsync(defendedAlly);

        _logger.LogInformation(
            "Guardian's Sacrifice executed: {Skjaldmaer} absorbed {Damage} damage " +
            "meant for {Ally}",
            character.Name, incomingDamage, defendedAlly.Name);

        return true;
    }

    /// <summary>
    /// Activates The Wall Lives capstone.
    /// </summary>
    public async Task<bool> ActivateTheWallLivesAsync(Character character)
    {
        // Validate specialization
        if (character?.Specialization != SpecializationId.Skjaldmaer)
            return false;

        // Validate ability unlock
        if (!character.HasAbilityUnlocked(SkjaldmaerAbilityId.TheWallLives))
            return false;

        // Validate not already used this combat
        if (character.HasUsedCapstoneThisCombat)
        {
            _logger.LogWarning(
                "The Wall Lives already used this combat for {CharacterId}",
                character.Id);
            return false;
        }

        // Validate AP
        if (character.CurrentAP < 4)
            return false;

        // Deduct AP
        character.CurrentAP -= 4;

        // Create effect
        character.TheWallLivesState = new TheWallLivesState();
        character.TheWallLivesState.Activate();
        character.HasUsedCapstoneThisCombat = true;

        // Persist
        await _characterRepository.UpdateAsync(character);

        _logger.LogInformation(
            "The Wall Lives activated: Character {CharacterId} ({Name}) " +
            "cannot drop below 1 HP for 3 turns",
            character.Id, character.Name);

        return true;
    }

    /// <summary>
    /// Checks if capstone is available.
    /// </summary>
    public bool CanUseCapstone(Character character)
    {
        if (character?.Specialization != SpecializationId.Skjaldmaer)
            return false;

        return !character.HasUsedCapstoneThisCombat;
    }

    /// <summary>
    /// Checks Tier 3 unlock requirements.
    /// </summary>
    public bool CanUnlockTier3(Character character)
    {
        if (character?.Specialization != SpecializationId.Skjaldmaer)
            return false;

        return GetPPInvested(character) >= 16;
    }

    /// <summary>
    /// Checks Capstone unlock requirements.
    /// </summary>
    public bool CanUnlockCapstone(Character character)
    {
        if (character?.Specialization != SpecializationId.Skjaldmaer)
            return false;

        return GetPPInvested(character) >= 24;
    }
}
```

### 6.4 DamageService Implementation

```csharp
/// <summary>
/// Service for applying damage with protective ability integration.
/// </summary>
public class DamageService : IDamageService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ISkjaldmaerAbilityService _abilityService;
    private readonly ILogger<DamageService> _logger;

    public DamageService(
        ICharacterRepository characterRepository,
        ISkjaldmaerAbilityService abilityService,
        ILogger<DamageService> logger)
    {
        _characterRepository = characterRepository;
        _abilityService = abilityService;
        _logger = logger;
    }

    /// <summary>
    /// Applies damage with all protections.
    /// </summary>
    public async Task<int> ApplyDamageAsync(Character target, int incomingDamage)
    {
        int finalDamage = CalculateFinalDamage(target, incomingDamage);

        target.CurrentHP = Math.Max(0, target.CurrentHP - finalDamage);

        await _characterRepository.UpdateAsync(target);

        _logger.LogInformation(
            "Damage applied: {Target} took {Damage} damage (incoming {Incoming}, " +
            "reductions applied). HP: {CurrentHP}/{MaxHP}",
            target.Name, finalDamage, incomingDamage,
            target.CurrentHP, target.GetMaxHealth());

        return finalDamage;
    }

    /// <summary>
    /// Calculates final damage after all reductions.
    /// </summary>
    public int CalculateFinalDamage(Character target, int incomingDamage)
    {
        int finalDamage = incomingDamage;

        // Apply Unbreakable reduction
        int unbreakableReduction = _abilityService.GetDamageReduction(target);
        finalDamage = Math.Max(1, finalDamage - unbreakableReduction);

        _logger.LogDebug(
            "Damage calculation: {Target} - Incoming {Incoming}, " +
            "Unbreakable {Reduction}, Final {Final}",
            target.Name, incomingDamage, unbreakableReduction, finalDamage);

        return finalDamage;
    }

    /// <summary>
    /// Checks lethal damage protection.
    /// </summary>
    public int CheckLethalDamageProtection(Character character, int damageAmount)
    {
        if (character?.TheWallLivesState?.IsActive != true)
            return damageAmount;

        return character.TheWallLivesState.PreventLethalDamage(character.CurrentHP, damageAmount);
    }
}
```

---

## 7. Infrastructure Layer Configuration

### 7.1 specializations.json - Tier 3 & Capstone

```json
{
    "specializations": [
        {
            "specializationId": "Skjaldmaer",
            "abilityTiers": [
                {
                    "tier": 1,
                    "displayName": "Foundation",
                    "ppRequirement": 0,
                    "abilityCost": 0,
                    "abilities": ["shield-wall", "intercept", "bulwark"]
                },
                {
                    "tier": 2,
                    "displayName": "Discipline",
                    "ppRequirement": 8,
                    "abilityCost": 4,
                    "abilities": ["hold-the-line", "counter-shield", "rally"]
                },
                {
                    "tier": 3,
                    "displayName": "Mastery",
                    "ppRequirement": 16,
                    "abilityCost": 5,
                    "abilities": ["unbreakable", "guardians-sacrifice"],
                    "unlockDescription": "Unlock advanced defensive abilities requiring 16+ PP invested"
                },
                {
                    "tier": "capstone",
                    "displayName": "The Wall",
                    "ppRequirement": 24,
                    "abilityCost": 6,
                    "abilities": ["the-wall-lives"],
                    "unlockDescription": "Ultimate signature ability representing the peak of defensive mastery"
                }
            ]
        }
    ]
}
```

### 7.2 abilities.json - Tier 3 & Capstone

```json
{
    "abilities": [
        {
            "abilityId": "unbreakable",
            "displayName": "Unbreakable",
            "specialization": "Skjaldmaer",
            "tier": 3,
            "type": "Passive",
            "description": "Reduce all damage taken by 3. Damage cannot be reduced below 1.",
            "flavorText": "Your body has become hardened through discipline and sacrifice.",
            "requirements": {
                "ppInvested": 16
            },
            "effects": [
                {
                    "effectId": "unbreakable-reduction",
                    "type": "DamageReduction",
                    "value": 3,
                    "minimumDamage": 1,
                    "appliesTo": "AllDamageTypes",
                    "stacking": "Additive"
                }
            ],
            "keywords": ["Passive", "Defensive", "Mastery", "Reduction"],
            "tags": ["v0.20.1c"]
        },
        {
            "abilityId": "guardians-sacrifice",
            "displayName": "Guardian's Sacrifice",
            "specialization": "Skjaldmaer",
            "tier": 3,
            "type": "Reaction",
            "resourceCost": {
                "resourceId": "block-charges",
                "amount": 2
            },
            "trigger": {
                "event": "AllyHitByAttack",
                "range": 2,
                "requiresLineOfSight": true,
                "timing": "AfterHitBeforeDamage"
            },
            "description": "When an ally within 2 spaces is hit by an attack, spend 2 Block Charges to absorb all damage from that attack.",
            "flavorText": "You step in front of the blade meant for your ally, taking the full force of the blow.",
            "requirements": {
                "ppInvested": 16,
                "blockChargesRequired": 2
            },
            "effects": [
                {
                    "effectId": "guardians-sacrifice-absorption",
                    "type": "AbsorbDamage",
                    "source": "TriggeredAttack",
                    "percentage": 100,
                    "transferTarget": "Self"
                }
            ],
            "keywords": ["Reaction", "Protective", "ResourceCost", "Sacrifice"],
            "tags": ["v0.20.1c"]
        },
        {
            "abilityId": "the-wall-lives",
            "displayName": "The Wall Lives",
            "specialization": "Skjaldmaer",
            "tier": "capstone",
            "type": "Ultimate",
            "apCost": 4,
            "duration": 3,
            "durationUnit": "Turns",
            "cooldown": "Once",
            "cooldownUnit": "Combat",
            "description": "For 3 turns, you cannot be reduced below 1 HP. Usable once per combat.",
            "flavorText": "The Wall stands eternal. You will not fall.",
            "requirements": {
                "ppInvested": 24
            },
            "effects": [
                {
                    "effectId": "the-wall-lives-protection",
                    "type": "PreventLethalDamage",
                    "minimumHp": 1,
                    "duration": 3,
                    "cooldown": "Combat",
                    "dispellable": true
                }
            ],
            "keywords": ["Ultimate", "Capstone", "Defensive", "Invulnerability"],
            "tags": ["v0.20.1c", "Signature"]
        }
    ]
}
```

---

## 8. Unbreakable Ability

### 8.1 Implementation Integration

**Applied in damage pipeline:**

```csharp
public async Task<int> ResolveDamageAsync(Character target, DamageEvent damageEvent)
{
    int effectiveDamage = damageEvent.Amount;

    // Apply Unbreakable reduction
    if (target.Specialization == SpecializationId.Skjaldmaer &&
        target.HasAbilityUnlocked(SkjaldmaerAbilityId.Unbreakable))
    {
        effectiveDamage = Math.Max(1, effectiveDamage - 3);
        _logger.LogDebug(
            "Unbreakable applied: {Target} reduced {Original} to {Effective}",
            target.Name, damageEvent.Amount, effectiveDamage);
    }

    // Continue with other damage calculations
    target.CurrentHP -= effectiveDamage;

    return effectiveDamage;
}
```

### 8.2 Damage Reduction Examples

| Incoming | Reduction | Result | Notes |
|----------|-----------|--------|-------|
| 10 | 3 | 7 | Standard reduction |
| 3 | 3 | 1 | Minimum 1 enforced |
| 2 | 3 | 1 | Minimum 1 enforced |
| 1 | 3 | 1 | Already minimum |
| 50 | 3 | 47 | Scales with large damage |

---

## 9. Guardian's Sacrifice Ability

### 9.1 Attack Absorption Mechanics

**When trigger fires:**

1. Ally is hit by attack
2. Damage is calculated
3. Skjaldmær can react before damage application
4. If reaction succeeds:
   - Skjaldmær spends 2 Block Charges
   - Ally takes 0 damage (100% absorption)
   - Skjaldmær takes all damage
   - Unbreakable still applies to absorbed damage

### 9.2 Comparison to Other Abilities

| Ability | Trigger | Timing | Effect | Charges |
|---------|---------|--------|--------|---------|
| **Intercept (T1)** | Attack targeting | Pre-roll | Redirect attack | 1 |
| **Guardian's Sacrifice (T3)** | Attack hitting | Post-hit, pre-damage | Absorb damage | 2 |

---

## 10. The Wall Lives Capstone

### 10.1 Activation Requirements

- Must be Skjaldmær specialization
- Must have The Wall Lives ability unlocked (24+ PP invested)
- Must have 4+ AP available
- Must not have already used this combat

### 10.2 Duration Management

```csharp
public void ManageTurnCycle()
{
    foreach (var character in activeCombatants)
    {
        if (character.Specialization == SpecializationId.Skjaldmaer)
        {
            // Tick down The Wall Lives
            character.TheWallLivesState?.Tick();

            // Log remaining turns
            if (character.TheWallLivesState?.IsActive == true)
            {
                _logger.LogInformation(
                    "The Wall Lives: {Character} - {Turns} turns remaining",
                    character.Name, character.TheWallLivesState.TurnsRemaining);
            }
        }
    }
}
```

### 10.3 Combat End Cleanup

```csharp
public void EndCombat()
{
    foreach (var character in participants)
    {
        // Clear capstone usage flag for next combat
        character.HasUsedCapstoneThisCombat = false;
        character.TheWallLivesState = null;

        _logger.LogInformation(
            "Combat ended: {Character} capstone flag reset",
            character.Name);
    }
}
```

---

## 11. Damage Pipeline Integration

### 11.1 Damage Application Order

```
1. Calculate base damage
2. Apply Unbreakable reduction (-3, min 1)
3. Apply armor/resistance
4. Check The Wall Lives protection
   • If active and would be lethal: cap damage
   • Otherwise: apply normally
5. Reduce character HP
6. Check character status (alive/dead)
7. Log final damage
```

### 11.2 Integration Points

| System | Integration | Method |
|--------|-------------|--------|
| Combat System | Damage resolution | DamageService.ApplyDamageAsync() |
| Character Management | HP calculation | Character.TakeDamage() |
| Logging | Audit trail | DamageService logging |
| Status Effects | Character state | TheWallLivesState ticking |

---

## 12. Decision Trees and Flow Diagrams

### 12.1 Unbreakable Damage Reduction

```
┌──────────────────────────────────┐
│ Damage Being Applied to Target   │
└───────────────┬──────────────────┘
                │
         ┌──────▼──────────────┐
         │ Is Skjaldmær?       │
         └──────┬──────────────┘
                │
            ┌───┴────┐
         No │        │ Yes
            │        │
        ┌───▼──┐ ┌───▼──────────────┐
        │Apply │ │ Has Unbreakable? │
        │Full  │ └───┬──────────────┘
        │Damage│     │
        └──────┘ ┌───┴────┐
               No│        │ Yes
                 │        │
             ┌───▼──┐ ┌───▼──────────────┐
             │Apply │ │ Reduce by 3      │
             │Full  │ │ (min 1)          │
             │Damage│ └───┬──────────────┘
             └──────┘     │
                     ┌────▼──────────────┐
                     │ Effective Damage  │
                     │ = Max(1, Incoming │
                     │        - 3)       │
                     └────┬──────────────┘
                          │
                     ┌────▼──────────────┐
                     │ Check The Wall    │
                     │ Lives Protection  │
                     └────┬──────────────┘
                          │
                      ┌───┴────┐
                   No │        │ Yes
                      │        │
                  ┌───▼──┐ ┌───▼──────┐
                  │Apply │ │ Would Be  │
                  │Damage│ │ Lethal?   │
                  │      │ └───┬──────┘
                  └──────┘     │
                            ┌──┴───┐
                         No │      │ Yes
                            │      │
                        ┌───▼─┐ ┌─▼────┐
                        │Apply│ │Cap at │
                        │Full │ │ 1 HP  │
                        │     │ └───────┘
                        └─────┘
```

---

## 13. Code Examples with XML Documentation

### 13.1 DamageService Full Implementation

```csharp
/// <summary>
/// Service for applying damage with protective ability integration.
/// Handles Unbreakable reduction and The Wall Lives protection.
/// </summary>
public class DamageService : IDamageService
{
    private readonly ICharacterRepository _characterRepository;
    private readonly ISkjaldmaerAbilityService _abilityService;
    private readonly ILogger<DamageService> _logger;

    public DamageService(
        ICharacterRepository characterRepository,
        ISkjaldmaerAbilityService abilityService,
        ILogger<DamageService> logger)
    {
        _characterRepository = characterRepository ?? throw new ArgumentNullException(nameof(characterRepository));
        _abilityService = abilityService ?? throw new ArgumentNullException(nameof(abilityService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Applies damage with all protective abilities integrated.
    /// </summary>
    /// <remarks>
    /// Damage flow:
    /// 1. Calculate final damage (Unbreakable reduction)
    /// 2. Check The Wall Lives protection
    /// 3. Apply to character HP
    /// 4. Persist character
    /// 5. Log action
    /// </remarks>
    public async Task<int> ApplyDamageAsync(Character target, int incomingDamage)
    {
        if (target == null)
            throw new ArgumentNullException(nameof(target));

        if (incomingDamage <= 0)
            return 0; // No damage

        // Calculate final damage after reductions
        int finalDamage = CalculateFinalDamage(target, incomingDamage);

        // Apply damage to character
        target.CurrentHP = Math.Max(0, target.CurrentHP - finalDamage);

        // Persist changes
        await _characterRepository.UpdateAsync(target);

        // Log damage application
        _logger.LogInformation(
            "Damage applied: {Target} ({TargetId}) took {FinalDamage} damage " +
            "(incoming {IncomingDamage}). HP now: {CurrentHP}/{MaxHP}",
            target.Name, target.Id, finalDamage, incomingDamage,
            target.CurrentHP, target.GetMaxHealth());

        return finalDamage;
    }

    /// <summary>
    /// Calculates final damage after all reductions and protections.
    /// </summary>
    /// <remarks>
    /// Reduction order:
    /// 1. Unbreakable (-3, minimum 1)
    /// 2. The Wall Lives (lethal prevention)
    /// </remarks>
    public int CalculateFinalDamage(Character target, int incomingDamage)
    {
        if (target == null)
            throw new ArgumentNullException(nameof(target));

        int effectiveDamage = incomingDamage;

        // Apply Unbreakable reduction
        int unbreakableReduction = _abilityService.GetDamageReduction(target);
        if (unbreakableReduction > 0)
        {
            effectiveDamage = Math.Max(1, effectiveDamage - unbreakableReduction);

            _logger.LogDebug(
                "Unbreakable damage reduction applied to {Target} ({TargetId}): " +
                "reduced {IncomingDamage} by {Reduction} to {EffectiveDamage}",
                target.Name, target.Id, incomingDamage, unbreakableReduction, effectiveDamage);
        }

        // Apply The Wall Lives protection
        effectiveDamage = CheckLethalDamageProtection(target, effectiveDamage);

        return effectiveDamage;
    }

    /// <summary>
    /// Checks and applies lethal damage protection from The Wall Lives.
    /// </summary>
    public int CheckLethalDamageProtection(Character character, int damageAmount)
    {
        if (character?.TheWallLivesState?.IsActive != true)
            return damageAmount;

        int protectedDamage = character.TheWallLivesState.PreventLethalDamage(
            character.CurrentHP,
            damageAmount);

        if (protectedDamage < damageAmount)
        {
            _logger.LogInformation(
                "The Wall Lives protection activated for {Character} ({CharacterId}): " +
                "prevented lethal damage",
                character.Name, character.Id);
        }

        return protectedDamage;
    }
}
```

### 13.2 TheWallLivesState Full Implementation

```csharp
/// <summary>
/// Complete implementation of The Wall Lives capstone ability state.
/// Manages invulnerability duration and lethal damage prevention.
/// </summary>
public sealed record TheWallLivesState
{
    /// <summary>
    /// Whether The Wall Lives effect is currently active.
    /// When active, character cannot be reduced below 1 HP.
    /// </summary>
    public bool IsActive { get; private set; }

    /// <summary>
    /// Turns remaining for this effect (0-3, decrements each turn).
    /// Once reaches 0, effect is disabled.
    /// </summary>
    public int TurnsRemaining { get; private set; } = 3;

    /// <summary>
    /// UTC timestamp when effect was activated.
    /// Used for audit trails and duration verification.
    /// </summary>
    public DateTime ActivatedAt { get; private set; }

    /// <summary>
    /// Activates the effect.
    /// </summary>
    /// <remarks>
    /// Called when The Wall Lives ability is executed.
    /// Sets initial duration and marks as active.
    /// </remarks>
    public void Activate()
    {
        IsActive = true;
        TurnsRemaining = 3;
        ActivatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Processes one turn of the effect.
    /// </summary>
    /// <remarks>
    /// Called at end of each combat turn.
    /// Decrements TurnsRemaining and disables if expired.
    /// </remarks>
    public void Tick()
    {
        if (!IsActive)
            return;

        TurnsRemaining--;

        if (TurnsRemaining <= 0)
        {
            IsActive = false;
        }
    }

    /// <summary>
    /// Checks if effect has expired.
    /// </summary>
    public bool IsExpired() => !IsActive || TurnsRemaining <= 0;

    /// <summary>
    /// Prevents lethal damage while effect is active.
    /// </summary>
    /// <param name="currentHp">Character's HP before damage</param>
    /// <param name="incomingDamage">Damage about to be applied</param>
    /// <returns>Actual damage to apply (capped to preserve 1 HP)</returns>
    /// <remarks>
    /// If incoming damage would reduce HP below 1, it's capped
    /// to leave exactly 1 HP, effectively preventing death.
    ///
    /// Example:
    /// CurrentHP = 5, IncomingDamage = 10
    /// Normal: NewHP = 5 - 10 = -5 → 0 (death)
    /// Protected: Damage capped to 4, NewHP = 5 - 4 = 1 (survives)
    /// </remarks>
    public int PreventLethalDamage(int currentHp, int incomingDamage)
    {
        if (!IsActive)
            return incomingDamage;

        // Calculate what HP would be after damage
        int resultingHp = currentHp - incomingDamage;

        // If damage would reduce below 1 HP, cap it
        if (resultingHp < 1)
        {
            // Damage is capped to leave exactly 1 HP
            int cappedDamage = currentHp - 1;
            return Math.Max(cappedDamage, 0); // Ensure non-negative
        }

        // Damage is not lethal, apply normally
        return incomingDamage;
    }

    /// <summary>
    /// Deactivates the effect immediately.
    /// </summary>
    /// <remarks>
    /// Called when effect expires or is dispelled.
    /// </remarks>
    public void Deactivate()
    {
        IsActive = false;
        TurnsRemaining = 0;
    }

    /// <summary>
    /// Gets remaining duration in turns.
    /// </summary>
    /// <returns>
    /// Number of turns remaining (0-3 if active, 0 if inactive)
    /// </returns>
    public int GetRemainingDuration() => IsActive ? TurnsRemaining : 0;
}
```

---

## 14. Logging Specifications

### 14.1 Unbreakable Logging

```
On Damage Application:
[DEBUG] DamageService: Unbreakable damage reduction applied to {Target}: reduced {Incoming} by 3 to {Effective}

Example:
[DEBUG] DamageService: Unbreakable damage reduction applied to Erikka (character-id-123): reduced 10 by 3 to 7
```

### 14.2 Guardian's Sacrifice Logging

```
On Sacrifice Execution:
[INFO] SkjaldmaerAbilityService: Guardian's Sacrifice executed: {Skjaldmaer} absorbed {Damage} damage meant for {Ally}

On Charge Spending:
[INFO] BlockChargeService: Block Charges spent: ... spent 2 charges

Example:
[INFO] SkjaldmaerAbilityService: Guardian's Sacrifice executed: Erikka absorbed 15 damage meant for Bjorn Stonekin
```

### 14.3 The Wall Lives Logging

```
On Activation:
[INFO] SkjaldmaerAbilityService: The Wall Lives activated: Character {CharacterId} ({Name}) cannot drop below 1 HP for 3 turns

Per Turn Tick:
[INFO] SkjaldmaerAbilityService: The Wall Lives: {Character} - {Turns} turns remaining

On Protection Trigger:
[INFO] DamageService: The Wall Lives protection activated for {Character} ({CharacterId}): prevented lethal damage

On Expiration:
[INFO] CombatSystem: The Wall Lives expired for {Character} ({CharacterId})

On Combat End:
[DEBUG] CombatSystem: Combat ended: {Character} capstone flag reset
```

---

## 15. Unit Testing Requirements

### 15.1 Tier 3 & Capstone Tests

**File:** `Tests/Application/Tier3AndCapstoneTests.cs`

**Test Count:** 7 tests

```csharp
[TestFixture]
public class Tier3AndCapstoneTests
{
    private ISkjaldmaerAbilityService _abilityService;
    private IDamageService _damageService;
    private IBlockChargeService _blockChargeService;
    private Mock<ICharacterRepository> _mockRepository;
    private Character _skjaldmaer;
    private Character _ally;

    [SetUp]
    public void Setup()
    {
        _mockRepository = new Mock<ICharacterRepository>();
        _blockChargeService = new BlockChargeService(_mockRepository.Object, Mock.Of<ILogger<BlockChargeService>>());
        _abilityService = new SkjaldmaerAbilityService(
            _mockRepository.Object,
            new PrerequisiteService(_mockRepository.Object, Mock.Of<ILogger<PrerequisiteService>>()),
            new DiceRoller(),
            Mock.Of<ILogger<SkjaldmaerAbilityService>>());

        _damageService = new DamageService(
            _mockRepository.Object,
            _abilityService,
            Mock.Of<ILogger<DamageService>>());

        _skjaldmaer = CreateSkjaldmaerWithAbility(SkjaldmaerAbilityId.Unbreakable);
        _ally = new Character { Id = Guid.NewGuid(), CurrentHP = 20 };
    }

    [Test]
    public void GetDamageReduction_WithUnbreakable_ReturnsThree()
    {
        // Act
        int reduction = _abilityService.GetDamageReduction(_skjaldmaer);

        // Assert
        Assert.That(reduction, Is.EqualTo(3));
    }

    [Test]
    public void CalculateFinalDamage_WithUnbreakable_ReducesByThree()
    {
        // Act
        int finalDamage = _damageService.CalculateFinalDamage(_skjaldmaer, 10);

        // Assert
        Assert.That(finalDamage, Is.EqualTo(7)); // 10 - 3
    }

    [Test]
    public void CalculateFinalDamage_WithUnbreakable_MinimumOneDamage()
    {
        // Act
        int finalDamage = _damageService.CalculateFinalDamage(_skjaldmaer, 2);

        // Assert
        Assert.That(finalDamage, Is.EqualTo(1)); // max(1, 2 - 3)
    }

    [Test]
    public async Task TryGuardiansSacrificeAsync_AbsorbsAllDamage()
    {
        // Arrange
        _skjaldmaer.UnlockAbility(SkjaldmaerAbilityId.GuardiansSacrifice);
        _skjaldmaer.BlockCharges = new BlockChargeResource { CurrentCharges = 2 };
        _skjaldmaer.CurrentHP = 20;
        _ally.CurrentHP = 10;
        _ally.Position = new Position(1, 1, 0);
        _skjaldmaer.Position = new Position(0, 0, 0);

        // Act
        bool result = await _abilityService.TryGuardiansSacrificeAsync(_skjaldmaer, _ally, 8);

        // Assert
        Assert.That(result, Is.True);
        Assert.That(_ally.CurrentHP, Is.EqualTo(10)); // Ally unchanged
        Assert.That(_skjaldmaer.CurrentHP, Is.LessThan(20)); // Skjaldmaer took damage
    }

    [Test]
    public async Task ActivateTheWallLivesAsync_CreatesProtection()
    {
        // Arrange
        _skjaldmaer.UnlockAbility(SkjaldmaerAbilityId.TheWallLives);
        _skjaldmaer.CurrentAP = 4;

        // Act
        bool result = await _abilityService.ActivateTheWallLivesAsync(_skjaldmaer);

        // Assert
        Assert.That(result, Is.True);
        Assert.That(_skjaldmaer.TheWallLivesState, Is.Not.Null);
        Assert.That(_skjaldmaer.TheWallLivesState.IsActive, Is.True);
        Assert.That(_skjaldmaer.TheWallLivesState.TurnsRemaining, Is.EqualTo(3));
    }

    [Test]
    public void TheWallLivesState_PreventLethalDamage_CapsDamage()
    {
        // Arrange
        var state = new TheWallLivesState();
        state.Activate();

        // Act
        int cappedDamage = state.PreventLethalDamage(currentHp: 5, incomingDamage: 10);

        // Assert
        Assert.That(cappedDamage, Is.EqualTo(4)); // Capped to leave 1 HP
    }

    [Test]
    public void TheWallLivesState_Tick_DecrementsAndExpires()
    {
        // Arrange
        var state = new TheWallLivesState();
        state.Activate();

        // Act & Assert
        Assert.That(state.IsActive, Is.True);
        Assert.That(state.TurnsRemaining, Is.EqualTo(3));

        state.Tick();
        Assert.That(state.TurnsRemaining, Is.EqualTo(2));
        Assert.That(state.IsActive, Is.True);

        state.Tick();
        state.Tick();
        Assert.That(state.TurnsRemaining, Is.EqualTo(0));
        Assert.That(state.IsActive, Is.False);
    }

    [Test]
    public void CanUseCapstone_NotYetUsed_ReturnsTrue()
    {
        // Arrange
        _skjaldmaer.HasUsedCapstoneThisCombat = false;

        // Act
        bool result = _abilityService.CanUseCapstone(_skjaldmaer);

        // Assert
        Assert.That(result, Is.True);
    }

    private Character CreateSkjaldmaerWithAbility(SkjaldmaerAbilityId abilityId)
    {
        var character = new Character
        {
            Id = Guid.NewGuid(),
            Name = "Test Skjaldmaer",
            Specialization = SpecializationId.Skjaldmaer,
            CurrentAP = 10,
            CurrentHP = 30
        };
        character.UnlockAbility(abilityId);
        return character;
    }
}
```

---

## 16. Integration Testing Requirements

### 16.1 Tier 3 & Capstone Integration Tests

**File:** `Tests/Integration/Tier3AndCapstoneIntegrationTests.cs`

```csharp
[TestFixture]
public class Tier3AndCapstoneIntegrationTests
{
    private IServiceProvider _serviceProvider;
    private DamageService _damageService;

    [SetUp]
    public void Setup()
    {
        _serviceProvider = new ServiceCollection()
            .AddScoped<ISkjaldmaerAbilityService, SkjaldmaerAbilityService>()
            .AddScoped<IDamageService, DamageService>()
            .AddScoped<IBlockChargeService, BlockChargeService>()
            .AddScoped<ICharacterRepository, InMemoryCharacterRepository>()
            .BuildServiceProvider();

        _damageService = _serviceProvider.GetRequiredService<IDamageService>();
    }

    [Test]
    public async Task UnbreakableDamageReduction_Integration()
    {
        // Arrange
        var character = CreateSkjaldmaerWithAbility(SkjaldmaerAbilityId.Unbreakable);
        character.CurrentHP = 30;

        // Act
        int appliedDamage = await _damageService.ApplyDamageAsync(character, 10);

        // Assert
        Assert.That(appliedDamage, Is.EqualTo(7)); // 10 - 3
        Assert.That(character.CurrentHP, Is.EqualTo(23)); // 30 - 7
    }

    [Test]
    public async Task TheWallLives_PreventsLethalDamage()
    {
        // Arrange
        var character = CreateSkjaldmaerWithAbility(SkjaldmaerAbilityId.TheWallLives);
        character.CurrentHP = 5;
        character.TheWallLivesState = new TheWallLivesState();
        character.TheWallLivesState.Activate();

        // Act
        int appliedDamage = await _damageService.ApplyDamageAsync(character, 10);

        // Assert
        Assert.That(character.CurrentHP, Is.GreaterThanOrEqualTo(1)); // At least 1 HP
    }

    [Test]
    public async Task GuardiansSacrifice_TransfersAllyDamage()
    {
        // Arrange
        var abilityService = _serviceProvider.GetRequiredService<ISkjaldmaerAbilityService>();
        var skjaldmaer = CreateSkjaldmaerWithAbility(SkjaldmaerAbilityId.GuardiansSacrifice);
        var ally = new Character { Id = Guid.NewGuid(), CurrentHP = 10 };

        skjaldmaer.BlockCharges = new BlockChargeResource { CurrentCharges = 3 };
        skjaldmaer.Position = new Position(0, 0, 0);
        ally.Position = new Position(1, 1, 0);
        skjaldmaer.CurrentHP = 30;

        // Act
        bool sacrificed = await abilityService.TryGuardiansSacrificeAsync(
            skjaldmaer, ally, damageAmount: 15);

        // Assert
        Assert.That(sacrificed, Is.True);
        Assert.That(ally.CurrentHP, Is.EqualTo(10)); // Ally unharmed
    }
}
```

---

## 17. Deliverable Checklist

### Domain Layer Deliverables

- [ ] `TheWallLivesState` value object (complete)
- [ ] Character entity final extensions
- [ ] Unbreakable ability constants defined

### Application Layer Deliverables

- [ ] Enhanced `ISkjaldmaerAbilityService` interface (Tier 3 methods)
- [ ] `IDamageService` interface
- [ ] `SkjaldmaerAbilityService` Tier 3 implementations
- [ ] `DamageService` implementation
- [ ] `UnbreakableAbilityHandler` (passive integration)
- [ ] `GuardiansSacrificeAbilityHandler` (reaction handler)
- [ ] `TheWallLivesAbilityHandler` (ultimate handler)

### Infrastructure Layer Deliverables

- [ ] `specializations.json` Tier 3 & Capstone updates
- [ ] `abilities.json` three entries (unbreakable, guardians-sacrifice, the-wall-lives)

### Testing Deliverables

- [ ] Tier 3 & Capstone unit tests (~7 tests)
- [ ] Integration tests for damage pipeline
- [ ] Integration tests for capstone
- [ ] All tests passing with 85%+ coverage

### Documentation Deliverables

- [ ] v0.20.1c Design Specification (this document)
- [ ] Logging specifications documented
- [ ] Architecture diagrams completed
- [ ] Damage pipeline documented

---

## 18. Acceptance Criteria

- [ ] **AC-T3-1:** Tier 3 abilities locked until 16 PP invested in tree
- [ ] **AC-T3-2:** Capstone locked until 24 PP invested in tree
- [ ] **AC-T3-3:** Tier 3 abilities cost exactly 5 PP each to unlock
- [ ] **AC-T3-4:** Capstone costs exactly 6 PP to unlock
- [ ] **AC-T3-5:** Unbreakable reduces all damage by 3 (minimum 1)
- [ ] **AC-T3-6:** Unbreakable applies to all damage types
- [ ] **AC-T3-7:** Guardian's Sacrifice absorbs 100% of attack damage for 2 charges
- [ ] **AC-T3-8:** Guardian's Sacrifice transfers all damage to Skjaldmær
- [ ] **AC-T3-9:** The Wall Lives prevents HP from dropping below 1 for 3 turns
- [ ] **AC-T3-10:** The Wall Lives usable once per combat only
- [ ] **AC-T3-11:** The Wall Lives costs 4 AP to activate

---

## 19. Dependencies

**Hard Dependencies:**
- v0.20.1a (Block Charges, Tier 1 framework)
- v0.20.1b (Tier 2 abilities, prerequisite system)
- v0.17.4 (Specialization framework, PP system)
- v0.20.0 (Character entity v2, ability system)

**Core System Dependencies:**
- Combat system (damage resolution hooks)
- Character management (HP calculation, status)
- Logging infrastructure
- Repository pattern (character persistence)

---

## 20. Deferrals and Future Considerations

**Complete at v0.20.1c:**
- All Skjaldmær specialization abilities (9 total)
- Tier 1-3 progression (27 PP total investment)
- Capstone ultimate with 3-turn duration

**Future Versions:**
- Alternative Warrior specializations (Berserkr, Rúnasmiðr, etc.)
- Additional abilty tree enhancements
- Scaling adjustments based on playtesting
- New defensive mechanics for other classes

**Potential Balance Adjustments:**
- The Wall Lives duration (currently 3 turns)
- Unbreakable reduction amount (currently -3)
- Guardian's Sacrifice charge cost (currently 2)
- Capstone AP cost (currently 4)

---

## Conclusion

v0.20.1c completes the Skjaldmær (Shield-Maiden) specialization with the pinnacle of defensive abilities. The combination of Unbreakable's consistent damage reduction and The Wall Lives' invulnerability creates a defender capable of standing against overwhelming odds. Guardian's Sacrifice bridges the gap, enabling absolute protection for allies at critical moments.

The specialization is now complete and ready for integration into the full game system, playtesting, and balance adjustments.

---

**Document Version:** 0.20.1c-v1.0
**Last Updated:** 2026-01-28
**Status:** Design Phase - Ready for Review
**Specialization Status:** Complete (9/9 abilities designed)
**Next Phase:** v0.20.2 - Rúnasmiðr Specialization
