# v0.0.6d Design Specification: Status Effect Integration & Polish

**Version:** 0.0.6d
**Parent:** v0.0.6 (Enhanced Combat System)
**Prerequisites:** v0.0.6a, v0.0.6b, v0.0.6c Complete
**Status:** Design Complete

---

## Table of Contents

1. [Overview](#overview)
2. [Scope](#scope)
3. [Combat Integration](#combat-integration)
4. [Effect Interactions](#effect-interactions)
5. [Cleanse Mechanics](#cleanse-mechanics)
6. [AI Integration](#ai-integration)
7. [UI Display](#ui-display)
8. [Command Changes](#command-changes)
9. [Rendering Changes](#rendering-changes)
10. [Configuration](#configuration)
11. [Acceptance Criteria](#acceptance-criteria)
12. [Test Specifications](#test-specifications)

---

## Overview

### Purpose

v0.0.6d integrates the status effect framework (v0.0.6c) with combat, adds effect interactions and cleanse mechanics, modifies monster AI behavior based on active effects, and implements UI display for status effects.

### Key Changes

| Area | Current State (v0.0.6c) | Target State (v0.0.6d) |
|------|-------------------------|------------------------|
| Effect application | Manual only | On-hit, on-damage triggers |
| Effect interactions | None | Wet+Lightning, etc. |
| Cleanse | None | Items and abilities |
| AI adaptation | Ignores effects | Modifies behavior |
| Effect display | None | Player/monster status |
| Turn processing | Basic | Effect-aware |

### Design Principles

1. **Tactically Meaningful**: Effects should influence combat decisions
2. **Clear Feedback**: Players understand why effects trigger
3. **Consistent Rules**: Interactions follow predictable patterns
4. **AI Intelligence**: Monsters react sensibly to their conditions

---

## Scope

### In Scope

- Combat integration (effects on hit, abilities apply effects)
- Effect tick processing during turn resolution
- Effect interaction system (Wet + Lightning, etc.)
- Cleanse mechanics (items, abilities, triggers)
- AI behavior modification by status effects
- Player and monster effect display
- Turn processing with effect checks
- Combat log integration for effects

### Out of Scope

- New status effects (use existing 28)
- Complex environmental spreading (simplified)
- Equipment with effect application
- Passive effect auras

---

## Combat Integration

### Combat Turn Flow with Effects

```
START OF COMBATANT'S TURN
│
├─► 1. Process START_OF_TURN effects
│   ├─► Tick DoT/HoT
│   ├─► Decrement durations
│   ├─► Remove expired effects
│   └─► Log effect results
│
├─► 2. Check action prevention
│   ├─► Stunned? → Skip turn, advance
│   ├─► Feared? → Force flee/cower
│   └─► Other preventions
│
├─► 3. Execute action
│   ├─► Player: Wait for command
│   └─► Monster: AI decision (modified by effects)
│
├─► 4. Process action results
│   ├─► Attack hits → Check for on-hit effects
│   ├─► Damage dealt → Check for on-damage effects
│   └─► Ability used → Apply ability effects
│
├─► 5. Process END_OF_TURN effects
│   └─► Effect-specific triggers
│
└─► 6. Advance turn
```

### Effect Application Triggers

```csharp
/// <summary>
/// Defines when an effect can be applied.
/// </summary>
public enum EffectTrigger
{
    /// <summary>Applied when an attack hits.</summary>
    OnHit,

    /// <summary>Applied when damage is dealt.</summary>
    OnDamage,

    /// <summary>Applied when taking damage.</summary>
    OnDamageTaken,

    /// <summary>Applied at the start of turn.</summary>
    OnTurnStart,

    /// <summary>Applied at the end of turn.</summary>
    OnTurnEnd,

    /// <summary>Applied when using an ability.</summary>
    OnAbilityUse,

    /// <summary>Applied when entering combat.</summary>
    OnCombatStart,

    /// <summary>Applied manually.</summary>
    Manual
}
```

### CombatEffectService

```csharp
/// <summary>
/// Integrates status effects with combat actions.
/// </summary>
public class CombatEffectService
{
    private readonly StatusEffectService _effectService;
    private readonly EffectInteractionService _interactionService;
    private readonly CombatLogService _logService;
    private readonly ILogger<CombatEffectService> _logger;

    public CombatEffectService(
        StatusEffectService effectService,
        EffectInteractionService interactionService,
        CombatLogService logService,
        ILogger<CombatEffectService> logger)
    {
        _effectService = effectService;
        _interactionService = interactionService;
        _logService = logService;
        _logger = logger;
    }

    /// <summary>
    /// Processes effects at the start of a combatant's turn.
    /// </summary>
    public TurnStartEffectResult ProcessTurnStart(
        Combatant combatant,
        CombatEncounter encounter)
    {
        var target = GetEffectTarget(combatant);
        var tickResults = _effectService.TickEffects(target);

        var totalDamage = tickResults.Sum(r => r.DamageDealt);
        var totalHealing = tickResults.Sum(r => r.HealingDone);
        var expiredEffects = tickResults.Where(r => r.Expired).ToList();

        // Log tick results
        foreach (var result in tickResults)
        {
            if (result.DamageDealt > 0)
            {
                _logService.LogDamage(
                    encounter,
                    combatant.DisplayName,
                    result.DamageDealt,
                    $"({result.EffectId})");
            }
            if (result.HealingDone > 0)
            {
                _logService.LogHeal(
                    encounter,
                    combatant.DisplayName,
                    combatant.DisplayName,
                    result.HealingDone);
            }
            if (result.Expired)
            {
                _logService.LogStatusExpired(
                    encounter,
                    combatant.DisplayName,
                    result.EffectId);
            }
        }

        // Check for action prevention
        var canAct = _effectService.CanTakeActions(target);
        var mustFlee = target.HasEffect("feared");
        var preventionReason = GetPreventionReason(target);

        return new TurnStartEffectResult(
            TotalDamage: totalDamage,
            TotalHealing: totalHealing,
            ExpiredEffects: expiredEffects.Select(e => e.EffectId).ToList(),
            CanAct: canAct,
            MustFlee: mustFlee,
            PreventionReason: preventionReason);
    }

    /// <summary>
    /// Processes effects triggered by an attack hitting.
    /// </summary>
    public AttackEffectResult ProcessAttackHit(
        Combatant attacker,
        Combatant target,
        int damage,
        bool isCritical,
        string? damageType,
        CombatEncounter encounter)
    {
        var appliedEffects = new List<EffectApplicationResult>();
        var interactionResults = new List<EffectInteractionResult>();

        // Get on-hit effects from attacker (e.g., weapon effects)
        var onHitEffects = GetOnHitEffects(attacker);
        foreach (var effectId in onHitEffects)
        {
            var result = _effectService.ApplyEffect(
                effectId,
                GetEffectTarget(target),
                attacker.IsPlayer ? attacker.Player?.Id : attacker.Monster?.Id,
                attacker.DisplayName);

            appliedEffects.Add(result);

            if (result.Applied)
            {
                _logService.LogStatusApplied(
                    encounter,
                    target.DisplayName,
                    effectId);
            }
        }

        // Check for damage type interactions
        if (damageType != null)
        {
            var targetEffects = GetEffectTarget(target);
            interactionResults = _interactionService
                .ProcessDamageInteractions(targetEffects, damageType, damage)
                .ToList();

            foreach (var interaction in interactionResults)
            {
                _logService.LogEffectInteraction(
                    encounter,
                    interaction.Message);
            }
        }

        // Critical hits may apply additional effects
        if (isCritical)
        {
            var critEffect = GetCriticalHitEffect(attacker);
            if (critEffect != null)
            {
                var result = _effectService.ApplyEffect(
                    critEffect,
                    GetEffectTarget(target),
                    attacker.IsPlayer ? attacker.Player?.Id : attacker.Monster?.Id,
                    attacker.DisplayName);

                appliedEffects.Add(result);
            }
        }

        return new AttackEffectResult(
            AppliedEffects: appliedEffects,
            Interactions: interactionResults,
            BonusDamage: interactionResults.Sum(i => i.BonusDamage));
    }

    /// <summary>
    /// Calculates modified damage considering effects.
    /// </summary>
    public int CalculateModifiedDamage(
        int baseDamage,
        Combatant attacker,
        Combatant target,
        string? damageType)
    {
        var damage = baseDamage;

        // Attacker's damage modifiers
        var attackerTarget = GetEffectTarget(attacker);
        var attackMod = _effectService.GetAllStatModifiers(attackerTarget)
            .Where(m => m.StatId == "attack")
            .ToList();

        foreach (var mod in attackMod)
        {
            damage = mod.Apply(damage);
        }

        // Target's defense/resistance modifiers
        var defenderTarget = GetEffectTarget(target);
        var defenseMod = _effectService.GetAllStatModifiers(defenderTarget)
            .Where(m => m.StatId == "defense")
            .ToList();

        foreach (var mod in defenseMod)
        {
            // Defense reduces damage
            damage = Math.Max(0, damage - mod.Apply(0));
        }

        // Damage type resistance/vulnerability
        if (damageType != null)
        {
            var activeEffects = defenderTarget.ActiveEffects;

            // Check resistance
            foreach (var effect in activeEffects.Where(e => e.IsActive))
            {
                if (effect.Definition.ResistsDamageTypes.Contains(damageType))
                {
                    damage = (int)(damage * 0.5f); // 50% reduction
                }
                if (effect.Definition.VulnerableToDamageTypes.Contains(damageType))
                {
                    damage = (int)(damage * 1.5f); // 50% increase
                }
            }
        }

        return Math.Max(0, damage);
    }

    private string? GetPreventionReason(IEffectTarget target)
    {
        if (target.HasEffect("stunned"))
            return "Stunned and cannot act!";
        if (target.HasEffect("frozen"))
            return "Frozen solid!";
        if (target.HasEffect("feared"))
            return "Overcome with fear!";
        return null;
    }

    private IEnumerable<string> GetOnHitEffects(Combatant attacker)
    {
        // TODO: Get from weapon/ability configuration
        // For now, return empty
        return Enumerable.Empty<string>();
    }

    private string? GetCriticalHitEffect(Combatant attacker)
    {
        // Critical hits have a chance to apply bleeding
        return Random.Shared.NextDouble() < 0.3 ? "bleeding" : null;
    }

    private IEffectTarget GetEffectTarget(Combatant combatant)
    {
        return combatant.IsPlayer
            ? (IEffectTarget)combatant.Player!
            : (IEffectTarget)combatant.Monster!;
    }
}

/// <summary>
/// Result of processing turn-start effects.
/// </summary>
public record TurnStartEffectResult(
    int TotalDamage,
    int TotalHealing,
    IReadOnlyList<string> ExpiredEffects,
    bool CanAct,
    bool MustFlee,
    string? PreventionReason);

/// <summary>
/// Result of processing attack effects.
/// </summary>
public record AttackEffectResult(
    IReadOnlyList<EffectApplicationResult> AppliedEffects,
    IReadOnlyList<EffectInteractionResult> Interactions,
    int BonusDamage);
```

---

## Effect Interactions

### Effect Interaction System

```csharp
/// <summary>
/// Handles interactions between status effects and damage types.
/// </summary>
public class EffectInteractionService
{
    private readonly IEffectInteractionRepository _interactionRepo;
    private readonly StatusEffectService _effectService;
    private readonly ILogger<EffectInteractionService> _logger;

    public EffectInteractionService(
        IEffectInteractionRepository interactionRepo,
        StatusEffectService effectService,
        ILogger<EffectInteractionService> logger)
    {
        _interactionRepo = interactionRepo;
        _effectService = effectService;
        _logger = logger;
    }

    /// <summary>
    /// Processes interactions when damage is dealt to a target.
    /// </summary>
    public IEnumerable<EffectInteractionResult> ProcessDamageInteractions(
        IEffectTarget target,
        string damageType,
        int damage)
    {
        var results = new List<EffectInteractionResult>();

        foreach (var effect in target.ActiveEffects.Where(e => e.IsActive))
        {
            var interaction = _interactionRepo.GetInteraction(
                effect.Definition.Id,
                damageType);

            if (interaction != null)
            {
                var result = ExecuteInteraction(interaction, target, damage);
                results.Add(result);

                _logger.LogInformation(
                    "Effect interaction: {Effect} + {DamageType} on {Target}",
                    effect.Definition.Name, damageType, target.Name);
            }
        }

        return results;
    }

    /// <summary>
    /// Processes interactions when an effect is applied.
    /// </summary>
    public IEnumerable<EffectInteractionResult> ProcessEffectApplication(
        IEffectTarget target,
        string newEffectId)
    {
        var results = new List<EffectInteractionResult>();

        foreach (var existing in target.ActiveEffects.Where(e => e.IsActive))
        {
            var interaction = _interactionRepo.GetInteraction(
                existing.Definition.Id,
                newEffectId);

            if (interaction != null)
            {
                var result = ExecuteInteraction(interaction, target, 0);
                results.Add(result);
            }
        }

        return results;
    }

    private EffectInteractionResult ExecuteInteraction(
        EffectInteraction interaction,
        IEffectTarget target,
        int baseDamage)
    {
        var bonusDamage = 0;
        var appliedEffects = new List<string>();
        var removedEffects = new List<string>();

        // Process bonus damage
        if (interaction.BonusDamagePercent > 0)
        {
            bonusDamage = (int)(baseDamage * interaction.BonusDamagePercent / 100f);
            target.TakeDamage(bonusDamage, interaction.BonusDamageType);
        }

        // Apply new effect
        if (interaction.ApplyEffect != null)
        {
            var result = _effectService.ApplyEffect(
                interaction.ApplyEffect,
                target);

            if (result.Applied)
                appliedEffects.Add(interaction.ApplyEffect);
        }

        // Remove existing effect
        if (interaction.RemoveEffect != null)
        {
            if (_effectService.RemoveEffect(target, interaction.RemoveEffect))
                removedEffects.Add(interaction.RemoveEffect);
        }

        return new EffectInteractionResult(
            InteractionId: interaction.Id,
            Message: interaction.Message,
            BonusDamage: bonusDamage,
            AppliedEffects: appliedEffects,
            RemovedEffects: removedEffects);
    }
}

/// <summary>
/// Defines an interaction between an effect and a trigger.
/// </summary>
public record EffectInteraction(
    string Id,
    string TriggerEffectId,
    string WithTrigger,
    int BonusDamagePercent,
    string? BonusDamageType,
    string? ApplyEffect,
    string? RemoveEffect,
    string Message);

/// <summary>
/// Result of an effect interaction.
/// </summary>
public record EffectInteractionResult(
    string InteractionId,
    string Message,
    int BonusDamage,
    IReadOnlyList<string> AppliedEffects,
    IReadOnlyList<string> RemovedEffects);
```

### Defined Interactions

Based on confirmed design:

| Trigger Effect | With | Result | Message |
|----------------|------|--------|---------|
| Wet | Lightning damage | +50% damage, apply Stunned | "Electricity arcs through the water!" |
| Wet | Ice damage | Apply Frozen, remove Wet | "The water freezes solid!" |
| Burning | Wet | Remove Burning | "The flames are extinguished!" |
| Chilled | Ice damage | Apply Frozen, remove Chilled | "The cold intensifies into ice!" |
| On Fire | Wet | Remove On Fire | "The fire is put out!" |

---

## Cleanse Mechanics

### Cleanse Types

```csharp
/// <summary>
/// Defines what types of effects a cleanse removes.
/// </summary>
public enum CleanseType
{
    /// <summary>Removes all negative effects.</summary>
    AllNegative,

    /// <summary>Removes all positive effects (dispel).</summary>
    AllPositive,

    /// <summary>Removes physical debuffs (Bleeding, Poisoned, Exhausted).</summary>
    Physical,

    /// <summary>Removes magical debuffs (Cursed, Silenced).</summary>
    Magical,

    /// <summary>Removes elemental effects (Burning, Frozen, Wet, etc.).</summary>
    Elemental,

    /// <summary>Removes a specific named effect.</summary>
    Specific
}
```

### CleanseService

```csharp
/// <summary>
/// Service for removing status effects through cleansing.
/// </summary>
public class CleanseService
{
    private readonly StatusEffectService _effectService;
    private readonly ILogger<CleanseService> _logger;

    // Effect categories for cleanse targeting
    private static readonly HashSet<string> PhysicalEffects = new()
    {
        "bleeding", "poisoned", "exhausted", "knocked_down"
    };

    private static readonly HashSet<string> MagicalEffects = new()
    {
        "cursed", "silenced", "feared", "weakened"
    };

    private static readonly HashSet<string> ElementalEffects = new()
    {
        "burning", "frozen", "wet", "chilled", "electrified", "on_fire"
    };

    public CleanseService(
        StatusEffectService effectService,
        ILogger<CleanseService> logger)
    {
        _effectService = effectService;
        _logger = logger;
    }

    /// <summary>
    /// Cleanses effects from a target.
    /// </summary>
    /// <param name="target">The target to cleanse.</param>
    /// <param name="cleanseType">The type of cleanse.</param>
    /// <param name="specificEffectId">Specific effect ID (if CleanseType.Specific).</param>
    /// <returns>The cleanse result.</returns>
    public CleanseResult Cleanse(
        IEffectTarget target,
        CleanseType cleanseType,
        string? specificEffectId = null)
    {
        var removedEffects = new List<string>();

        switch (cleanseType)
        {
            case CleanseType.AllNegative:
                removedEffects.AddRange(RemoveByPredicate(target, e =>
                    e.Definition.Category == EffectCategory.Debuff));
                break;

            case CleanseType.AllPositive:
                removedEffects.AddRange(RemoveByPredicate(target, e =>
                    e.Definition.Category == EffectCategory.Buff));
                break;

            case CleanseType.Physical:
                removedEffects.AddRange(RemoveByPredicate(target, e =>
                    PhysicalEffects.Contains(e.Definition.Id)));
                break;

            case CleanseType.Magical:
                removedEffects.AddRange(RemoveByPredicate(target, e =>
                    MagicalEffects.Contains(e.Definition.Id)));
                break;

            case CleanseType.Elemental:
                removedEffects.AddRange(RemoveByPredicate(target, e =>
                    ElementalEffects.Contains(e.Definition.Id)));
                break;

            case CleanseType.Specific when specificEffectId != null:
                if (_effectService.RemoveEffect(target, specificEffectId))
                    removedEffects.Add(specificEffectId);
                break;
        }

        _logger.LogInformation(
            "Cleansed {Count} effects from {Target}: {Effects}",
            removedEffects.Count, target.Name, string.Join(", ", removedEffects));

        return new CleanseResult(
            Success: removedEffects.Count > 0,
            RemovedEffects: removedEffects,
            Message: BuildCleanseMessage(removedEffects));
    }

    private IEnumerable<string> RemoveByPredicate(
        IEffectTarget target,
        Func<ActiveStatusEffect, bool> predicate)
    {
        var toRemove = target.ActiveEffects
            .Where(e => e.IsActive && predicate(e))
            .Select(e => e.Definition.Id)
            .ToList();

        foreach (var effectId in toRemove)
        {
            _effectService.RemoveEffect(target, effectId);
        }

        return toRemove;
    }

    private string BuildCleanseMessage(IReadOnlyList<string> removed)
    {
        if (removed.Count == 0)
            return "No effects to cleanse.";
        if (removed.Count == 1)
            return $"Cleansed {removed[0]}.";
        return $"Cleansed {removed.Count} effects.";
    }
}

/// <summary>
/// Result of a cleanse operation.
/// </summary>
public record CleanseResult(
    bool Success,
    IReadOnlyList<string> RemovedEffects,
    string Message);
```

### Cleanse Items

```csharp
/// <summary>
/// Defines a consumable item that cleanses effects.
/// </summary>
public record CleanseItem(
    string Id,
    string Name,
    string Description,
    CleanseType CleanseType,
    string? SpecificEffect)
{
    /// <summary>
    /// Antidote - removes Poisoned.
    /// </summary>
    public static CleanseItem Antidote => new(
        "antidote", "Antidote",
        "Cures poison.",
        CleanseType.Specific, "poisoned");

    /// <summary>
    /// Bandage - removes Bleeding.
    /// </summary>
    public static CleanseItem Bandage => new(
        "bandage", "Bandage",
        "Stops bleeding.",
        CleanseType.Specific, "bleeding");

    /// <summary>
    /// Panacea - removes all negative effects.
    /// </summary>
    public static CleanseItem Panacea => new(
        "panacea", "Panacea",
        "Cures all ailments.",
        CleanseType.AllNegative, null);

    /// <summary>
    /// Smelling Salts - removes Stunned.
    /// </summary>
    public static CleanseItem SmellingSalts => new(
        "smelling_salts", "Smelling Salts",
        "Clears the mind.",
        CleanseType.Specific, "stunned");

    /// <summary>
    /// Fire Resistance Potion - removes Burning and applies Protected(fire).
    /// </summary>
    public static CleanseItem FireResistancePotion => new(
        "fire_resistance_potion", "Fire Resistance Potion",
        "Quenches flames and grants fire resistance.",
        CleanseType.Specific, "burning");
}
```

---

## AI Integration

### AI Behavior Modification by Effects

Based on confirmed design decisions:

```csharp
/// <summary>
/// Modifies AI decisions based on active status effects.
/// </summary>
public class EffectAwareAIService
{
    private readonly MonsterAIService _baseAIService;
    private readonly StatusEffectService _effectService;
    private readonly ILogger<EffectAwareAIService> _logger;

    public EffectAwareAIService(
        MonsterAIService baseAIService,
        StatusEffectService effectService,
        ILogger<EffectAwareAIService> logger)
    {
        _baseAIService = baseAIService;
        _effectService = effectService;
        _logger = logger;
    }

    /// <summary>
    /// Gets an AI decision considering active effects.
    /// </summary>
    public AIDecision GetEffectAwareDecision(AIContext context)
    {
        var target = (IEffectTarget)context.Self.Monster!;

        // Check for effect-forced behaviors
        var forcedDecision = GetForcedDecision(context, target);
        if (forcedDecision != null)
        {
            _logger.LogDebug(
                "AI {Monster} forced to {Action} due to status effect",
                context.Self.DisplayName, forcedDecision.Value.Action);
            return forcedDecision.Value;
        }

        // Get modified behavior based on effects
        var modifiedContext = GetModifiedContext(context, target);

        // Get base AI decision
        var decision = _baseAIService.DecideAction(modifiedContext);

        // Potentially modify the decision based on effects
        return ModifyDecision(decision, context, target);
    }

    private AIDecision? GetForcedDecision(AIContext context, IEffectTarget target)
    {
        // Feared: Must attempt to flee
        if (target.HasEffect("feared"))
        {
            return AIDecision.Flee("Overcome with fear, must flee!");
        }

        // Stunned: Cannot act (handled by turn processing, but as fallback)
        if (target.HasEffect("stunned"))
        {
            return AIDecision.Wait("Stunned and cannot act!");
        }

        return null;
    }

    private AIContext GetModifiedContext(AIContext context, IEffectTarget target)
    {
        // For now, return unmodified context
        // Future: could modify perceived health, etc.
        return context;
    }

    private AIDecision ModifyDecision(
        AIDecision decision,
        AIContext context,
        IEffectTarget target)
    {
        // Cursed: Won't try to heal unless HP is really low
        if (target.HasEffect("cursed"))
        {
            if (decision.Action == AIAction.Heal && context.HealthPercentage > 0.2f)
            {
                // Don't heal unless critically low
                var fallbackTarget = context.WeakestEnemy;
                if (fallbackTarget != null)
                {
                    return AIDecision.Attack(fallbackTarget,
                        "Cursed, healing ineffective - attacking instead");
                }
                return AIDecision.Wait("Cursed, avoiding ineffective healing");
            }
        }

        // Blinded: Prefer melee/close range
        if (target.HasEffect("blinded"))
        {
            // AI should prefer attacking (melee) over abilities (ranged)
            // This is a simplification; full implementation would check ranges
            _logger.LogDebug("{Monster} is blinded, preferring close combat",
                context.Self.DisplayName);
        }

        // Silenced: Cannot use abilities
        if (target.HasEffect("silenced"))
        {
            if (decision.Action == AIAction.Heal || decision.AbilityId != null)
            {
                // Fall back to attack
                var fallbackTarget = context.WeakestEnemy;
                if (fallbackTarget != null)
                {
                    return AIDecision.Attack(fallbackTarget,
                        "Silenced, cannot use abilities - attacking instead");
                }
                return AIDecision.Defend("Silenced, defending");
            }
        }

        // Poisoned/Bleeding: May prioritize cleansing if available
        if ((target.HasEffect("poisoned") || target.HasEffect("bleeding")) &&
            context.Self.CanHeal && context.IsCriticalHealth)
        {
            // Prioritize healing to counteract DoT
            return AIDecision.Heal(context.Self, null,
                "Suffering from DoT, prioritizing healing");
        }

        // Disarmed: Cannot make weapon attacks
        if (target.HasEffect("disarmed"))
        {
            if (decision.Action == AIAction.Attack)
            {
                return AIDecision.Defend("Disarmed, cannot attack - defending");
            }
        }

        return decision;
    }
}
```

### AI Behavior Summary by Effect

| Effect | AI Modification |
|--------|-----------------|
| **Feared** | Forces flee attempt (overrides all) |
| **Stunned** | Skips turn (overrides all) |
| **Cursed** | Won't heal unless HP < 20% |
| **Blinded** | Prefers melee attacks |
| **Silenced** | Cannot use abilities, falls back to attack/defend |
| **Poisoned/Bleeding** | Prioritizes healing if critically hurt |
| **Disarmed** | Cannot attack, defends instead |

---

## UI Display

### Effect Display on Status

```
┌─────────────────────────────────────────────────────────┐
│ YOU                                        Round 3      │
│ HP: 45/60 [████████░░░] 75%                             │
│                                                         │
│ Active Effects:                                         │
│   [+] Strengthened (2) - +30% ATK                       │
│   [-] Poisoned (3) - 2 dmg/turn, -1 ATK                 │
│                                                         │
├─────────────────────────────────────────────────────────┤
│ ENEMIES                                                 │
│                                                         │
│ [1] Goblin Warrior (30/30 HP)                           │
│     [-] Bleeding (2)                                    │
│                                                         │
│ [2] Goblin Shaman (25/25 HP)                            │
│     (no effects)                                        │
└─────────────────────────────────────────────────────────┘
```

### DTOs for Effect Display

```csharp
/// <summary>
/// Active effect display information.
/// </summary>
public record ActiveEffectDto(
    string Id,
    string Name,
    string Description,
    bool IsBeneficial,
    int? RemainingDuration,
    int? RemainingResource,
    int Stacks,
    string? ShortDescription)
{
    /// <summary>
    /// Gets the effect indicator (+/-).
    /// </summary>
    public string Indicator => IsBeneficial ? "[+]" : "[-]";

    /// <summary>
    /// Gets the duration display text.
    /// </summary>
    public string DurationText => RemainingDuration.HasValue
        ? $"({RemainingDuration})"
        : RemainingResource.HasValue
            ? $"({RemainingResource} HP)"
            : "";

    /// <summary>
    /// Creates from an active effect.
    /// </summary>
    public static ActiveEffectDto FromActiveEffect(ActiveStatusEffect effect)
    {
        return new ActiveEffectDto(
            effect.Definition.Id,
            effect.Definition.Name,
            effect.Definition.Description,
            effect.Definition.IsBeneficial,
            effect.RemainingDuration,
            effect.RemainingResource,
            effect.Stacks,
            BuildShortDescription(effect));
    }

    private static string? BuildShortDescription(ActiveStatusEffect effect)
    {
        var parts = new List<string>();

        if (effect.CalculateDamagePerTurn() > 0)
            parts.Add($"{effect.CalculateDamagePerTurn()} dmg/turn");

        if (effect.CalculateHealingPerTurn() > 0)
            parts.Add($"{effect.CalculateHealingPerTurn()} heal/turn");

        foreach (var mod in effect.Definition.StatModifiers.Take(2))
        {
            var sign = mod.Value >= 0 ? "+" : "";
            var valueStr = mod.ModifierType == StatModifierType.Percentage
                ? $"{sign}{mod.Value * 100}%"
                : $"{sign}{mod.Value}";
            parts.Add($"{valueStr} {mod.StatId.ToUpper()}");
        }

        return parts.Count > 0 ? string.Join(", ", parts) : null;
    }
}

/// <summary>
/// Combatant status with effects for display.
/// </summary>
public record CombatantStatusDto(
    string Name,
    int CurrentHealth,
    int MaxHealth,
    bool IsPlayer,
    int? Number,
    IReadOnlyList<ActiveEffectDto> ActiveEffects);
```

---

## Command Changes

### UseItemCommand Enhancement

```csharp
/// <summary>
/// Command to use an item from inventory.
/// </summary>
public record UseItemCommand(string ItemId, string? TargetSpec = null) : GameCommand;
```

### Command Handling

```csharp
// In GameSessionService:

/// <summary>
/// Uses a cleanse item.
/// </summary>
public UseItemResult UseCleanseItem(string itemId, string? targetSpec = null)
{
    if (_currentSession == null)
        return UseItemResult.Failure("No active game session.");

    // Get item
    var item = _inventoryService.GetItem(_currentSession.Player, itemId);
    if (item == null)
        return UseItemResult.Failure("You don't have that item.");

    if (item is not CleanseItem cleanseItem)
        return UseItemResult.Failure("That item can't be used that way.");

    // Determine target
    IEffectTarget target;
    if (targetSpec == null || targetSpec.ToLower() == "self")
    {
        target = _currentSession.Player;
    }
    else if (_currentSession.IsInCombat)
    {
        var encounter = _currentSession.ActiveEncounter!;
        var combatant = _targetResolver.ResolveMonsterTarget(encounter, targetSpec);
        if (combatant?.Monster == null)
            return UseItemResult.Failure("Invalid target.");
        target = combatant.Monster;
    }
    else
    {
        return UseItemResult.Failure("Can only target others in combat.");
    }

    // Apply cleanse
    var result = _cleanseService.Cleanse(
        target,
        cleanseItem.CleanseType,
        cleanseItem.SpecificEffect);

    // Remove item from inventory
    if (result.Success)
    {
        _inventoryService.RemoveItem(_currentSession.Player, itemId, 1);
    }

    return new UseItemResult(
        Success: result.Success,
        Message: result.Message,
        RemovedEffects: result.RemovedEffects);
}
```

---

## Rendering Changes

### IGameRenderer Additions

```csharp
/// <summary>
/// Renders combatant status with effects.
/// </summary>
Task RenderCombatantStatusAsync(
    CombatantStatusDto status,
    CancellationToken ct = default);

/// <summary>
/// Renders an effect being applied.
/// </summary>
Task RenderEffectAppliedAsync(
    string targetName,
    string effectName,
    bool isBeneficial,
    CancellationToken ct = default);

/// <summary>
/// Renders an effect expiring.
/// </summary>
Task RenderEffectExpiredAsync(
    string targetName,
    string effectName,
    CancellationToken ct = default);

/// <summary>
/// Renders an effect interaction.
/// </summary>
Task RenderEffectInteractionAsync(
    string message,
    CancellationToken ct = default);

/// <summary>
/// Renders DoT/HoT damage/healing.
/// </summary>
Task RenderEffectTickAsync(
    string targetName,
    string effectName,
    int damage,
    int healing,
    CancellationToken ct = default);
```

### SpectreGameRenderer Implementation

```csharp
public Task RenderCombatantStatusAsync(
    CombatantStatusDto status,
    CancellationToken ct = default)
{
    var healthPct = (float)status.CurrentHealth / status.MaxHealth;
    var healthColor = healthPct > 0.5 ? "green" : healthPct > 0.25 ? "yellow" : "red";
    var healthBar = BuildHealthBar(healthPct, 10);

    var numberPrefix = status.Number.HasValue ? $"[{status.Number}] " : "";
    var nameColor = status.IsPlayer ? "green" : "red";

    AnsiConsole.MarkupLine(
        $"{numberPrefix}[{nameColor}]{status.Name}[/] " +
        $"([{healthColor}]{status.CurrentHealth}/{status.MaxHealth} HP[/]) {healthBar}");

    if (status.ActiveEffects.Count > 0)
    {
        foreach (var effect in status.ActiveEffects)
        {
            var effectColor = effect.IsBeneficial ? "cyan" : "yellow";
            var shortDesc = effect.ShortDescription != null
                ? $" - {effect.ShortDescription}"
                : "";

            AnsiConsole.MarkupLine(
                $"    [{effectColor}]{effect.Indicator} {effect.Name} {effect.DurationText}[/]{shortDesc}");
        }
    }
    else if (!status.IsPlayer)
    {
        AnsiConsole.MarkupLine("    [grey](no effects)[/]");
    }

    return Task.CompletedTask;
}

public Task RenderEffectAppliedAsync(
    string targetName,
    string effectName,
    bool isBeneficial,
    CancellationToken ct = default)
{
    var color = isBeneficial ? "cyan" : "yellow";
    var verb = isBeneficial ? "gains" : "is afflicted with";

    AnsiConsole.MarkupLine(
        $"[{color}]{targetName} {verb} {effectName}![/]");

    return Task.CompletedTask;
}

public Task RenderEffectExpiredAsync(
    string targetName,
    string effectName,
    CancellationToken ct = default)
{
    AnsiConsole.MarkupLine(
        $"[grey]{effectName} has worn off from {targetName}.[/]");

    return Task.CompletedTask;
}

public Task RenderEffectInteractionAsync(
    string message,
    CancellationToken ct = default)
{
    AnsiConsole.MarkupLine($"[yellow bold]{message}[/]");
    return Task.CompletedTask;
}

public Task RenderEffectTickAsync(
    string targetName,
    string effectName,
    int damage,
    int healing,
    CancellationToken ct = default)
{
    if (damage > 0)
    {
        AnsiConsole.MarkupLine(
            $"[red]{targetName} takes {damage} damage from {effectName}![/]");
    }
    if (healing > 0)
    {
        AnsiConsole.MarkupLine(
            $"[green]{targetName} heals {healing} from {effectName}.[/]");
    }
    return Task.CompletedTask;
}

private string BuildHealthBar(float percentage, int width)
{
    var filled = (int)(percentage * width);
    var empty = width - filled;
    var color = percentage > 0.5 ? "green" : percentage > 0.25 ? "yellow" : "red";

    return $"[{color}]{"█".PadRight(filled, '█')}[/][grey]{"░".PadRight(empty, '░')}[/]";
}
```

---

## Configuration

### effect-interactions.json

```json
{
  "$schema": "./effect-interactions.schema.json",
  "version": "1.0",
  "interactions": [
    {
      "id": "wet_lightning",
      "triggerEffect": "wet",
      "withTrigger": "lightning_damage",
      "bonusDamagePercent": 50,
      "bonusDamageType": "lightning",
      "applyEffect": "stunned",
      "removeEffect": null,
      "message": "Electricity arcs through the water!"
    },
    {
      "id": "wet_ice",
      "triggerEffect": "wet",
      "withTrigger": "ice_damage",
      "bonusDamagePercent": 0,
      "bonusDamageType": null,
      "applyEffect": "frozen",
      "removeEffect": "wet",
      "message": "The water freezes solid!"
    },
    {
      "id": "burning_wet",
      "triggerEffect": "burning",
      "withTrigger": "wet",
      "bonusDamagePercent": 0,
      "bonusDamageType": null,
      "applyEffect": null,
      "removeEffect": "burning",
      "message": "The flames are extinguished!"
    },
    {
      "id": "chilled_ice",
      "triggerEffect": "chilled",
      "withTrigger": "ice_damage",
      "bonusDamagePercent": 0,
      "bonusDamageType": null,
      "applyEffect": "frozen",
      "removeEffect": "chilled",
      "message": "The cold intensifies into ice!"
    },
    {
      "id": "on_fire_wet",
      "triggerEffect": "on_fire",
      "withTrigger": "wet",
      "bonusDamagePercent": 0,
      "bonusDamageType": null,
      "applyEffect": null,
      "removeEffect": "on_fire",
      "message": "The fire is put out!"
    }
  ]
}
```

### cleanse-items.json

```json
{
  "$schema": "./cleanse-items.schema.json",
  "version": "1.0",
  "items": [
    {
      "id": "antidote",
      "name": "Antidote",
      "description": "A small vial of bitter liquid that neutralizes poison.",
      "cleanseType": "specific",
      "specificEffect": "poisoned",
      "value": 15
    },
    {
      "id": "bandage",
      "name": "Bandage",
      "description": "Clean cloth strips to stop bleeding.",
      "cleanseType": "specific",
      "specificEffect": "bleeding",
      "value": 10
    },
    {
      "id": "panacea",
      "name": "Panacea",
      "description": "A miraculous cure-all that removes all ailments.",
      "cleanseType": "allNegative",
      "specificEffect": null,
      "value": 100
    },
    {
      "id": "smelling_salts",
      "name": "Smelling Salts",
      "description": "Strong salts to revive the dazed.",
      "cleanseType": "specific",
      "specificEffect": "stunned",
      "value": 25
    },
    {
      "id": "fire_resistance_potion",
      "name": "Fire Resistance Potion",
      "description": "Quenches flames and protects against fire.",
      "cleanseType": "specific",
      "specificEffect": "burning",
      "grantsEffect": "protected",
      "grantsDamageTypeResistance": "fire",
      "value": 50
    },
    {
      "id": "ice_resistance_potion",
      "name": "Ice Resistance Potion",
      "description": "Warms the body and protects against cold.",
      "cleanseType": "elemental",
      "specificEffect": null,
      "grantsEffect": "protected",
      "grantsDamageTypeResistance": "ice",
      "value": 50
    }
  ]
}
```

---

## Acceptance Criteria

### Combat Integration
- [ ] Effects tick at start of combatant's turn
- [ ] DoT damage applied during tick
- [ ] HoT healing applied during tick
- [ ] Expired effects removed after tick
- [ ] Action prevention checked after tick
- [ ] Stunned combatants skip their turn
- [ ] Feared combatants must flee

### Effect Interactions
- [ ] Wet + Lightning = +50% damage + Stunned
- [ ] Wet + Ice = Frozen, removes Wet
- [ ] Burning + Wet = removes Burning
- [ ] Chilled + Ice = Frozen, removes Chilled
- [ ] On Fire + Wet = removes On Fire
- [ ] Interaction messages displayed

### Cleanse Mechanics
- [ ] Antidote removes Poisoned
- [ ] Bandage removes Bleeding
- [ ] Panacea removes all negative effects
- [ ] Smelling Salts removes Stunned
- [ ] Cleanse items consumed on use
- [ ] Cleanse reports removed effects

### AI Integration
- [ ] Feared monsters attempt to flee
- [ ] Stunned monsters skip turn
- [ ] Cursed monsters avoid healing unless critical
- [ ] Silenced monsters use physical attacks
- [ ] Disarmed monsters defend instead of attack
- [ ] Bleeding/Poisoned monsters prioritize healing

### UI Display
- [ ] Player status shows active effects
- [ ] Monster status shows active effects
- [ ] Effect duration displayed
- [ ] Effect short description shown
- [ ] Beneficial effects marked with [+]
- [ ] Harmful effects marked with [-]
- [ ] Effect application announced
- [ ] Effect expiration announced
- [ ] Effect tick damage/healing displayed

---

## Test Specifications

### Unit Tests (~20 tests)

#### CombatEffectServiceTests.cs

```csharp
[TestFixture]
public class CombatEffectServiceTests
{
    [Test]
    public void ProcessTurnStart_TicksAllEffects();

    [Test]
    public void ProcessTurnStart_AppliesDoTDamage();

    [Test]
    public void ProcessTurnStart_AppliesHoTHealing();

    [Test]
    public void ProcessTurnStart_RemovesExpiredEffects();

    [Test]
    public void ProcessTurnStart_ReturnsCantActIfStunned();

    [Test]
    public void ProcessTurnStart_ReturnsMustFleeIfFeared();

    [Test]
    public void ProcessAttackHit_AppliesOnHitEffects();

    [Test]
    public void ProcessAttackHit_TriggersInteractions();

    [Test]
    public void CalculateModifiedDamage_AppliesResistance();

    [Test]
    public void CalculateModifiedDamage_AppliesVulnerability();
}
```

#### EffectInteractionServiceTests.cs

```csharp
[TestFixture]
public class EffectInteractionServiceTests
{
    [Test]
    public void ProcessDamageInteractions_WetLightning_BonusDamageAndStun();

    [Test]
    public void ProcessDamageInteractions_WetIce_AppliesFrozenRemovesWet();

    [Test]
    public void ProcessDamageInteractions_ChilledIce_AppliesFrozen();

    [Test]
    public void ProcessEffectApplication_BurningWet_RemovesBurning();

    [Test]
    public void ProcessDamageInteractions_NoInteraction_ReturnsEmpty();
}
```

#### CleanseServiceTests.cs

```csharp
[TestFixture]
public class CleanseServiceTests
{
    [Test]
    public void Cleanse_AllNegative_RemovesAllDebuffs();

    [Test]
    public void Cleanse_Physical_RemovesOnlyPhysical();

    [Test]
    public void Cleanse_Specific_RemovesOnlyNamed();

    [Test]
    public void Cleanse_NoMatchingEffects_ReturnsFalse();
}
```

#### EffectAwareAIServiceTests.cs

```csharp
[TestFixture]
public class EffectAwareAIServiceTests
{
    [Test]
    public void GetDecision_Feared_ForcesFlee();

    [Test]
    public void GetDecision_Stunned_ForcesWait();

    [Test]
    public void GetDecision_Cursed_AvoidsHealingUnlessCritical();

    [Test]
    public void GetDecision_Silenced_FallsBackToAttack();

    [Test]
    public void GetDecision_Disarmed_FallsBackToDefend();

    [Test]
    public void GetDecision_NoEffects_ReturnsBaseDecision();
}
```

---

## Dependencies

### Required from Previous Phases

**v0.0.6a:**
- `CombatEncounter` - Combat context
- `Combatant` - Participant wrapper
- Turn management system

**v0.0.6b:**
- `MonsterAIService` - Base AI decisions
- `AIContext`, `AIDecision` - AI structures
- `CombatLogService` - Logging infrastructure

**v0.0.6c:**
- `StatusEffectDefinition` - Effect metadata
- `ActiveStatusEffect` - Effect instances
- `StatusEffectService` - Effect management
- `IEffectTarget` - Target interface

### Final v0.0.6 Deliverables

Upon completion of v0.0.6d, the following features are complete:

1. **Multi-Monster Combat** (v0.0.6a)
   - 1-5 monsters per room
   - Initiative-based turn order
   - Target selection

2. **Monster AI & Flee** (v0.0.6b)
   - 5 AI behavior types
   - Flee command with skill check
   - Combat log

3. **Status Effect Framework** (v0.0.6c)
   - 28 status effects (14 debuffs, 10 buffs, 4 environmental)
   - DoT/HoT processing
   - Stat modification

4. **Status Effect Integration** (v0.0.6d)
   - Combat integration
   - 5 effect interactions
   - Cleanse items
   - AI behavior modification
   - UI display

---

*This design specification completes the v0.0.6 Enhanced Combat System. All four phases together provide a rich, tactical combat experience with intelligent monsters, meaningful status effects, and clear player feedback.*
