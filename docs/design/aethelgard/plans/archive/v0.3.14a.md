> **Archived** - This plan has been consolidated. See the complete version at [v0.3.14](../v0.3.x/v0.3.14.md).

# v0.3.14a: The Palette (Theme Standardization)

This sub-version serves as a "technical debt downpayment," eliminating all remaining hardcoded ANSI colors in the Terminal UI. It enforces the Semantic Color System established in v0.3.9b, ensuring that every pixel of the interface respects the user's accessibility settings (High Contrast, Protanopia, etc.).

Goal: Conduct a comprehensive audit of all Terminal Renderers to replace hardcoded colors (e.g., Color.Red, [green]) with semantic lookups via IThemeService (e.g., GetColor("Danger")).

1. Architecture & Data Flow
The Semantic Rendering Pipeline Instead of Renderers deciding what color to use, they ask the ThemeService how to represent a concept.
	1	Trigger: GameLoop calls a Renderer (e.g., ExplorationScreenRenderer.Render()).
	2	Request: The Renderer encounters a UI element (e.g., the Biome Header).
	3	Lookup: The Renderer calls _themeService.GetColor("Biome_Industrial").
	4	Resolution:
	◦	ThemeService checks the active palette (e.g., High Contrast).
	◦	If the key exists, return the mapped color (e.g., Color.Yellow).
	◦	If missing, fallback to Standard palette.
	5	Output: The Renderer draws the element using the resolved color.

2. Logic Decision Trees
A. Hardcode Elimination Logic Input: Code review identifies a hardcoded color string (e.g., [orange1])
	1	Analyze Context: What does this color signify?
	◦	Danger/Hostile? -> Map to DangerColor or EnemyColor.
	◦	Success/Safe? -> Map to SuccessColor.
	◦	Biome Specific? -> Map to Biome_{Type} (New Role).
	◦	Rarity? -> Map to Quality_{Tier}.
	2	Update Palette:
	◦	Does IThemeService support this key?
	◦	No: Add key to ThemeService dictionary initialization for all 5 themes.
	3	Refactor: Replace string literal with interpolation: $"[{_theme.GetColor("Key")}]{Text}[/]".
B. Biome Color Mapping (New Scope) Input: BiomeType (Industrial)
	1	Standard: Orange1 (Rust).
	2	High Contrast: Yellow (Visibility).
	3	Protanopia: Blue (Distinct from organic/green).
	4	Deuteranopia: Blue (Distinct from organic/red).

3. Deliverable Checklist
	•	Core:
	◦	[ ] Expand ThemeType palettes with Biome-specific keys: Biome_Ruin, Biome_Industrial, Biome_Organic, Biome_Void.
	◦	[ ] Add UI structural keys: SeparatorColor, InputColor, DimColor.
	•	Terminal (Refactoring):
	◦	[ ] ExplorationScreenRenderer: Remove hardcoded biome headers.
	◦	[ ] RoomRenderer: Use Biome_{Type} keys for descriptions.
	◦	[ ] InventoryScreenRenderer: Use BorderActive / BorderInactive for focus highlighting.
	◦	[ ] CraftingScreenRenderer: Standardize "Can Craft" checks to SuccessColor / DimColor.
	◦	[ ] JournalScreenRenderer: Ensure all tab headers use Tab_{Name} keys.
	•	Tests:
	◦	[ ] ThemeServiceTests: Verify new Biome keys exist in all palettes.

4. Code Implementation
A. Renderer Refactor (ExplorationScreenRenderer.cs)
// BEFORE (v0.3.5c style)
private Panel CreateHeader(ExplorationViewModel vm)
{
    // Hardcoded color logic mixed with rendering
    var color = vm.BiomeType == BiomeType.Industrial ? "orange1" : "grey";
    return new Panel($"[{color}]{vm.RoomName}[/]");
}

// AFTER (v0.3.14a style)
private Panel CreateHeader(ExplorationViewModel vm)
{
    // Semantic lookup
    var colorRole = $"Biome_{vm.BiomeType}";
    var color = _themeService.GetColor(colorRole);

    return new Panel($"[{color}]{Markup.Escape(vm.RoomName)}[/]")
        .BorderColor(_themeService.GetColorObject("Border_Header"));
}
B. Theme Service Expansion (ThemeService.cs)
private void InitializePalettes()
{
    // ... existing initialization ...

    // Add Biome Keys to Standard Palette
    _palettes[ThemeType.Standard].Add("Biome_Ruin", "grey");
    _palettes[ThemeType.Standard].Add("Biome_Industrial", "orange1");
    _palettes[ThemeType.Standard].Add("Biome_Organic", "green");
    _palettes[ThemeType.Standard].Add("Biome_Void", "purple");

    // Add Biome Keys to High Contrast Palette
    _palettes[ThemeType.HighContrast].Add("Biome_Ruin", "white");
    _palettes[ThemeType.HighContrast].Add("Biome_Industrial", "bold yellow");
    _palettes[ThemeType.HighContrast].Add("Biome_Organic", "bold white"); // Distinct pattern needed
    _palettes[ThemeType.HighContrast].Add("Biome_Void", "grey");
}

5. Logging Requirements
System
Event
Level
Message Template
Properties
Theme
Missing Key
Warning
"[Theme] Missing color key '{Key}' in theme '{Theme}'. Fallback to Grey."
Key, Theme
Theme
Biome Resolve
Trace
"[Theme] Resolved Biome '{Biome}' to color '{Color}'."
Biome, Color

6. Testing Strategy
Unit Test (ThemeServiceTests.cs)
	•	Completeness_Biomes:
	◦	Action: Iterate through all ThemeType enums.
	◦	Assert: GetColor("Biome_Industrial") does not return "grey" (fallback) for any theme.
	•	Renderer_Mocking:
	◦	Action: Instantiate ExplorationScreenRenderer with a Mock IThemeService.
	◦	Setup: Mock returns "TEST_COLOR" for "Biome_Ruin".
	◦	Act: Render a Ruin room.
	◦	Assert: Output string contains [TEST_COLOR].

7. Draft Changelog (v0.3.14a)
# v0.3.14a Changelog: The Palette
**Release Date:** 2026-02-10

## Summary
This release standardizes the color system across the entire application. Hardcoded colors have been removed from the Exploration, Inventory, and Crafting screens, replaced by semantic lookups via the `ThemeService`. This ensures that High Contrast and Colorblind modes now apply to 100% of the game's UI, including biome atmosphere and room headers.

## Technical Changes
*   **Theme Expansion:** Added semantic keys for `Biome_Ruin`, `Biome_Industrial`, `Biome_Organic`, and `Biome_Void` to all 5 themes.
*   **Refactor:** Updated `ExplorationScreenRenderer`, `RoomRenderer`, and `CraftingScreenRenderer` to use `IThemeService`.
*   **Validation:** Added unit tests to ensure all semantic keys are defined in every theme palette.