# v0.1.1d Design Specification: Branch Generation & Infinite Mode

**Version:** 0.1.1d
**Phase Name:** Branch Generation & Infinite Mode
**Parent Version:** v0.1.1 (Template-Based Generation)
**Prerequisites:** v0.1.1c Complete (Difficulty & Content Scaling)
**Estimated Tests:** ~23 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [BranchGeneratorService](#4-branchgeneratorservice)
5. [BranchType and BranchDecision](#5-branchtype-and-branchdecision)
6. [Dead End Generation](#6-dead-end-generation)
7. [Loop Detection and Creation](#7-loop-detection-and-creation)
8. [InfiniteDungeonService](#8-infinitedungeonservice)
9. [Chunk-Based Generation](#9-chunk-based-generation)
10. [Memory Management](#10-memory-management)
11. [Infinite Mode Commands](#11-infinite-mode-commands)
12. [Data Model Changes](#12-data-model-changes)
13. [Configuration File Schemas](#13-configuration-file-schemas)
14. [Logging Specifications](#14-logging-specifications)
15. [Unit Testing Requirements](#15-unit-testing-requirements)
16. [Use Cases](#16-use-cases)
17. [Deliverable Checklist](#17-deliverable-checklist)
18. [Acceptance Criteria](#18-acceptance-criteria)
19. [Dependencies](#19-dependencies)
20. [Future Considerations](#20-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

Implement branching path generation for varied dungeon layouts with side paths, dead ends, and optional loops. Add infinite dungeon mode for endless procedural generation, enabling players to explore an ever-expanding dungeon that generates new content as they move through it.

### 1.2 Current State

| Area | Current State (v0.1.1c) | Target State (v0.1.1d) |
|------|-------------------------|------------------------|
| Path structure | Linear room connections | Branching paths (main, side, dead end, loop) |
| Dead ends | None (all paths continue) | Intentional dead ends with special content |
| Loops | None | Optional loop connections |
| Generation mode | Fixed size dungeons | Infinite mode option |
| Room generation | All at dungeon creation | Lazy generation around player |
| Memory | All rooms in memory | Cleanup of distant rooms |
| Mode commands | None | `infinite mode` toggle |

### 1.3 Key Deliverables

| Category | Items |
|----------|-------|
| **Services** | `BranchGeneratorService`, `InfiniteDungeonService` |
| **Enums** | `BranchType`, `DeadEndContent` |
| **Value Objects** | `BranchDecision`, `BranchRules`, `InfiniteRules` |
| **Configuration** | `branch-rules.json` |
| **Commands** | `infinite mode` toggle |
| **Tests** | ~23 new unit tests |

### 1.4 Architectural Significance

This version establishes the **procedural generation pattern** that enables:
- Varied dungeon layouts with meaningful exploration choices
- Dead ends that reward exploration with special content
- Loop connections for non-linear navigation
- Unlimited dungeon size through lazy generation
- Memory-efficient infinite exploration

---

## 2. Feature Overview

```
v0.1.1d Branch Generation & Infinite Mode
├── BranchGeneratorService
│   ├── DecideBranching()
│   ├── Branch probability rules
│   ├── Main path continuation
│   ├── Side path branching
│   └── SeededRandom integration
├── BranchType Enum
│   ├── None (no exit)
│   ├── MainPath (primary route)
│   ├── SidePath (optional exploration)
│   ├── DeadEnd (terminates after 1-3 rooms)
│   └── Loop (connects to existing room)
├── BranchDecision Value Object
│   ├── Position
│   ├── ExitDecisions dictionary
│   └── IsDeadEnd flag
├── Dead End Generation
│   ├── Dead end length limits
│   ├── Dead end content types
│   └── Special rewards for dead ends
├── Loop Detection
│   ├── Existing room detection
│   ├── Loop probability
│   └── Loop connection creation
├── InfiniteDungeonService
│   ├── IsInfiniteMode flag
│   ├── EnableInfiniteMode()
│   ├── DisableInfiniteMode()
│   ├── EnsureGeneratedAround()
│   └── GenerateRoomAt()
├── Chunk-Based Generation
│   ├── Generation radius
│   ├── Position-based generation
│   └── Adjacent room detection
├── Memory Management
│   ├── Cleanup radius
│   ├── CleanupDistantRooms()
│   └── Uncollected loot protection
├── Infinite Mode Commands
│   └── Toggle infinite mode
└── Branch Rules Configuration
    ├── mainPathProbability
    ├── sidePathProbability
    ├── deadEndProbability
    ├── loopProbability
    └── infiniteRules
```

---

## 3. Architecture Diagrams

### 3.1 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           PRESENTATION LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  GameSessionService (updated)         CommandHandler (existing)              │
│  └── HandleInfiniteModeCommand()      └── Routes "infinite mode" command     │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           APPLICATION LAYER                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  BranchGeneratorService               InfiniteDungeonService                 │
│  ├── DecideBranching()                ├── IsInfiniteMode                     │
│  ├── GenerateDeadEndContent()         ├── EnableInfiniteMode()               │
│  └── Uses SeededRandomService         ├── DisableInfiniteMode()              │
│                                       ├── EnsureGeneratedAround()            │
│  BranchRules (config)                 ├── GenerateRoomAt()                   │
│  ├── MainPathProbability              ├── CleanupDistantRooms()              │
│  ├── SidePathProbability              └── Uses BranchGeneratorService        │
│  ├── DeadEndProbability                                                      │
│  └── LoopProbability                  InfiniteRules (config)                 │
│                                       ├── GenerationRadius                   │
│  From v0.1.1c:                        ├── CleanupRadius                      │
│  ├── ContentPlacementService          ├── EnableCleanup                      │
│  └── DifficultyRating                 └── MaxGeneratedRooms                  │
│                                                                              │
│  From v0.1.1b:                        From v0.1.1a:                          │
│  └── SeededRandomService              └── RoomGeneratorService               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             DOMAIN LAYER                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  Enums (New):                        Value Objects (New):                    │
│  ┌────────────────────────────┐     ┌────────────────────────────────────┐  │
│  │ BranchType                 │     │ BranchDecision                     │  │
│  │ ├── None                   │     │ ├── Position: Position3D           │  │
│  │ ├── MainPath               │     │ ├── ExitDecisions: Dictionary      │  │
│  │ ├── SidePath               │     │ └── IsDeadEnd: bool                │  │
│  │ ├── DeadEnd                │     └────────────────────────────────────┘  │
│  │ └── Loop                   │                                             │
│  └────────────────────────────┘     Entities (Updated):                     │
│                                     ┌────────────────────────────────────┐  │
│  ┌────────────────────────────┐     │ Dungeon                            │  │
│  │ DeadEndContent             │     │ ├── HasRoomAt(Position3D)          │  │
│  │ ├── TreasureCache          │     │ ├── RemoveRoom(Guid)               │  │
│  │ ├── MonsterLair            │     │ └── GetGraph()                     │  │
│  │ ├── SecretShrine           │     └────────────────────────────────────┘  │
│  │ ├── TrapRoom               │                                             │
│  │ └── Empty                  │     Existing (from prior versions):         │
│  └────────────────────────────┘     ├── Position3D (v0.1.0a)                │
│                                     ├── Direction (v0.0.x)                  │
│                                     └── DifficultyRating (v0.1.1c)          │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         INFRASTRUCTURE LAYER                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  JsonConfigurationProvider                                                   │
│  └── GetBranchRulesConfiguration()                                           │
│      └── Loads config/branch-rules.json                                      │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Branch Decision Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Room at Position (X, Y, Z) with potential exits               │
│ PotentialExits: [North, East, South]                          │
└───────────────────────────────┬───────────────────────────────┘
                                │
                                ▼
┌───────────────────────────────────────────────────────────────┐
│ BranchGeneratorService.DecideBranching()                      │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│ For each direction in potentialExits:                         │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Step 1: Calculate target position                       │  │
│ │ targetPos = position.Move(direction)                    │  │
│ │ Example: North → (3, 5, 2)                             │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Step 2: Generate seeded roll                            │  │
│ │ roll = seededRandom.NextFloatForPosition(pos, "branch") │  │
│ │ Example: roll = 0.35                                    │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Step 3: Check for loop (existing room)                  │  │
│ │ wouldLoop = existingGraph.HasRoom(targetPos)            │  │
│ │ If wouldLoop && roll < loopProbability (0.08):          │  │
│ │   decisions[direction] = BranchType.Loop                │  │
│ │ Else if wouldLoop:                                      │  │
│ │   decisions[direction] = BranchType.None                │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Step 4: Decide branch type (if not loop)                │  │
│ │ if (!hasMainPath && roll < 0.70): MainPath              │  │
│ │ else if (roll < 0.40): SidePath                         │  │
│ │ else if (roll < 0.15): DeadEnd                          │  │
│ │ else: None                                              │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Step 5: Ensure at least one continuation                │  │
│ │ if no exits have MainPath/SidePath:                     │  │
│ │   Force first exit to MainPath                          │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
└───────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌───────────────────────────────────────────────────────────────┐
│ Result: BranchDecision                                        │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ Position: (3, 4, 2)                                     │  │
│ │ ExitDecisions:                                          │  │
│ │   North → MainPath                                      │  │
│ │   East  → SidePath                                      │  │
│ │   South → None                                          │  │
│ │ IsDeadEnd: false                                        │  │
│ └─────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────┘
```

### 3.3 Infinite Generation Flow

```
┌───────────────────────────────────────────────────────────────┐
│ Player moves to new position                                  │
│ PlayerPosition: (5, 3, 2)                                     │
└───────────────────────────────┬───────────────────────────────┘
                                │
                                ▼
┌───────────────────────────────────────────────────────────────┐
│ InfiniteDungeonService.EnsureGeneratedAround()                │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│ Step 1: Check if infinite mode active                         │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ if (!IsInfiniteMode) return;                            │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 2: Get positions in radius                               │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ for x in [-3..3], y in [-3..3], z in [0..3]:            │  │
│ │   if (|x| + |y| + z <= 3):                              │  │
│ │     yield (playerPos.X + x, playerPos.Y + y, playerPos.Z + z) │
│ │                                                         │  │
│ │ Generates ~80 candidate positions within Manhattan radius │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 3: Filter to ungenerated positions                       │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ toGenerate = candidates                                 │  │
│ │   .Where(p => !dungeon.HasRoomAt(p))                    │  │
│ │   .Where(p => ShouldGenerate(p, dungeon, playerPos))    │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 4: Generate each needed room                             │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ foreach (position in toGenerate):                       │  │
│ │   GenerateRoomAt(dungeon, position)                     │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
│ Step 5: Cleanup distant rooms (if enabled)                    │
│ ┌─────────────────────────────────────────────────────────┐  │
│ │ if (_rules.EnableCleanup):                              │  │
│ │   CleanupDistantRooms(dungeon, playerPosition)          │  │
│ └─────────────────────────────────────────────────────────┘  │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

### 3.4 Dead End Content Selection

```
┌─────────────────────────────────────────────────────────────┐
│ Dead End Room at Position (7, 2, 3)                         │
│ Difficulty: Level 45, Tier: elite                           │
└─────────────────────────────────┬───────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────┐
│ BranchGeneratorService.GenerateDeadEndContent()             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ Generate seeded roll:                                        │
│ roll = seededRandom.NextFloatForPosition(pos, "deadend")    │
│                                                             │
│ Content Selection:                                           │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ roll < 0.30 → TreasureCache   (good loot, no combat)    │ │
│ │ roll < 0.50 → MonsterLair     (tough fight, great loot) │ │
│ │ roll < 0.70 → SecretShrine    (special interaction)     │ │
│ │ roll < 0.85 → TrapRoom        (dangerous, some loot)    │ │
│ │ else        → Empty           (nothing special)         │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ Content Type Modifiers:                                      │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ TreasureCache: Loot × 2.0, No monsters                  │ │
│ │ MonsterLair:   Monster tier +1, Loot × 1.5              │ │
│ │ SecretShrine:  Special buff/effect                      │ │
│ │ TrapRoom:      Traps × 2.0, Loot × 1.2                  │ │
│ │ Empty:         Standard content                         │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. BranchGeneratorService

### 4.1 Purpose

Generate branching decisions for dungeon paths, determining which exits lead to main paths, side paths, dead ends, or loops.

### 4.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/BranchGeneratorService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for generating branching dungeon paths.
/// </summary>
/// <remarks>
/// Determines how rooms connect to create varied dungeon layouts with
/// main paths, side paths, dead ends, and optional loops.
/// </remarks>
public class BranchGeneratorService : IBranchGeneratorService
{
    private readonly ISeededRandomService _random;
    private readonly BranchRules _rules;
    private readonly ILogger<BranchGeneratorService> _logger;

    public BranchGeneratorService(
        ISeededRandomService random,
        BranchRules rules,
        ILogger<BranchGeneratorService> logger)
    {
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _rules = rules ?? throw new ArgumentNullException(nameof(rules));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _logger.LogDebug("BranchGeneratorService initialized with rules: " +
            "mainPath={MainPath}, sidePath={SidePath}, deadEnd={DeadEnd}, loop={Loop}",
            _rules.MainPathProbability,
            _rules.SidePathProbability,
            _rules.DeadEndProbability,
            _rules.LoopProbability);
    }

    /// <inheritdoc/>
    public BranchDecision DecideBranching(
        Position3D position,
        IEnumerable<Direction> potentialExits,
        IDungeonGraph existingGraph)
    {
        var decisions = new Dictionary<Direction, BranchType>();
        var exits = potentialExits.ToList();
        var hasMainPath = false;

        _logger.LogDebug(
            "Deciding branching at {Position} with {ExitCount} potential exits",
            position, exits.Count);

        foreach (var direction in exits)
        {
            var targetPos = position.Move(direction);
            var contextKey = $"branch_{direction}";
            var roll = _random.NextFloatForPosition(position, contextKey);

            // Check if this would create a loop
            var wouldLoop = existingGraph.HasRoom(targetPos);

            if (wouldLoop)
            {
                // Decide whether to allow the loop connection
                if (roll < _rules.LoopProbability)
                {
                    decisions[direction] = BranchType.Loop;
                    _logger.LogDebug(
                        "Loop connection at {Direction} (roll={Roll:F2} < {Prob:F2})",
                        direction, roll, _rules.LoopProbability);
                }
                else
                {
                    decisions[direction] = BranchType.None;
                    _logger.LogDebug(
                        "Blocked loop at {Direction} (roll={Roll:F2} >= {Prob:F2})",
                        direction, roll, _rules.LoopProbability);
                }
                continue;
            }

            // Main path vs side path vs dead end decision
            var branchType = DetermineBranchType(roll, ref hasMainPath);
            decisions[direction] = branchType;

            _logger.LogDebug(
                "Direction {Direction}: {BranchType} (roll={Roll:F2})",
                direction, branchType, roll);
        }

        // Ensure at least one continuation if not at a forced dead end
        if (!decisions.Values.Any(b => b == BranchType.MainPath || b == BranchType.SidePath))
        {
            var fallback = exits.FirstOrDefault();
            if (fallback != default)
            {
                decisions[fallback] = BranchType.MainPath;
                _logger.LogDebug(
                    "Forced MainPath at {Direction} to ensure continuation",
                    fallback);
            }
        }

        var isDeadEnd = decisions.Values.All(b =>
            b == BranchType.None || b == BranchType.DeadEnd);

        return new BranchDecision
        {
            Position = position,
            ExitDecisions = decisions,
            IsDeadEnd = isDeadEnd
        };
    }

    /// <inheritdoc/>
    public DeadEndContent GenerateDeadEndContent(
        Position3D position,
        DifficultyRating difficulty)
    {
        var roll = _random.NextFloatForPosition(position, "deadend_type");

        var content = SelectDeadEndContent(roll);

        _logger.LogDebug(
            "Dead end at {Position} contains {Content} (roll={Roll:F2})",
            position, content, roll);

        return content;
    }

    /// <summary>
    /// Determines the branch type based on roll and main path status.
    /// </summary>
    private BranchType DetermineBranchType(float roll, ref bool hasMainPath)
    {
        // Main path: Ensure at least one main continuation
        if (!hasMainPath && roll < _rules.MainPathProbability)
        {
            hasMainPath = true;
            return BranchType.MainPath;
        }

        // Side path: Optional exploration
        if (roll < _rules.SidePathProbability)
        {
            return BranchType.SidePath;
        }

        // Dead end: Terminates after 1-3 rooms
        if (roll < _rules.DeadEndProbability)
        {
            return BranchType.DeadEnd;
        }

        // No exit in this direction
        return BranchType.None;
    }

    /// <summary>
    /// Selects dead end content type based on roll.
    /// </summary>
    private DeadEndContent SelectDeadEndContent(float roll)
    {
        var chances = _rules.DeadEndContentChances;

        if (roll < chances.TreasureCache)
            return DeadEndContent.TreasureCache;

        if (roll < chances.TreasureCache + chances.MonsterLair)
            return DeadEndContent.MonsterLair;

        if (roll < chances.TreasureCache + chances.MonsterLair + chances.SecretShrine)
            return DeadEndContent.SecretShrine;

        if (roll < chances.TreasureCache + chances.MonsterLair +
                   chances.SecretShrine + chances.TrapRoom)
            return DeadEndContent.TrapRoom;

        return DeadEndContent.Empty;
    }
}
```

### 4.3 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IBranchGeneratorService.cs`

```csharp
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for generating branching dungeon paths.
/// </summary>
public interface IBranchGeneratorService
{
    /// <summary>
    /// Determines branching decisions for a room's exits.
    /// </summary>
    /// <param name="position">The current room position.</param>
    /// <param name="potentialExits">Available exit directions.</param>
    /// <param name="existingGraph">The current dungeon graph for loop detection.</param>
    /// <returns>A BranchDecision containing exit decisions for each direction.</returns>
    BranchDecision DecideBranching(
        Position3D position,
        IEnumerable<Direction> potentialExits,
        IDungeonGraph existingGraph);

    /// <summary>
    /// Generates content type for a dead end room.
    /// </summary>
    /// <param name="position">The dead end position.</param>
    /// <param name="difficulty">The room difficulty rating.</param>
    /// <returns>The type of content to place in the dead end.</returns>
    DeadEndContent GenerateDeadEndContent(
        Position3D position,
        DifficultyRating difficulty);
}
```

---

## 5. BranchType and BranchDecision

### 5.1 BranchType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/BranchType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of branch connections in the dungeon.
/// </summary>
/// <remarks>
/// Branch types determine how rooms connect and affect content generation.
/// Main paths always continue, side paths provide optional exploration,
/// dead ends terminate with special content, and loops connect to existing rooms.
/// </remarks>
public enum BranchType
{
    /// <summary>
    /// No exit in this direction.
    /// </summary>
    None,

    /// <summary>
    /// Primary progression route that always continues.
    /// </summary>
    /// <remarks>
    /// At least one MainPath is guaranteed per room (except dead ends).
    /// Main paths form the critical path through the dungeon.
    /// </remarks>
    MainPath,

    /// <summary>
    /// Optional exploration path that may lead to rewards.
    /// </summary>
    /// <remarks>
    /// Side paths branch off the main route and may contain
    /// treasure, secrets, or additional encounters.
    /// </remarks>
    SidePath,

    /// <summary>
    /// Terminal path that ends after 1-3 rooms.
    /// </summary>
    /// <remarks>
    /// Dead ends contain special content rewards:
    /// treasure caches, monster lairs, shrines, or traps.
    /// </remarks>
    DeadEnd,

    /// <summary>
    /// Connection to an already existing room.
    /// </summary>
    /// <remarks>
    /// Loops create shortcuts and alternative navigation paths.
    /// They add non-linearity to the dungeon layout.
    /// </remarks>
    Loop
}
```

### 5.2 DeadEndContent Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/DeadEndContent.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Types of special content found at dead ends.
/// </summary>
/// <remarks>
/// Dead ends reward exploration with varied content types,
/// each with different risk/reward profiles.
/// </remarks>
public enum DeadEndContent
{
    /// <summary>
    /// A cache of valuable loot without combat.
    /// </summary>
    /// <remarks>
    /// Loot multiplier: 2.0x, no monsters.
    /// The safest dead end type.
    /// </remarks>
    TreasureCache,

    /// <summary>
    /// A monster's lair with tough enemies and great rewards.
    /// </summary>
    /// <remarks>
    /// Monster tier +1, loot multiplier: 1.5x.
    /// High risk, high reward.
    /// </remarks>
    MonsterLair,

    /// <summary>
    /// A secret shrine with special interactions.
    /// </summary>
    /// <remarks>
    /// May provide buffs, blessings, or unique items.
    /// Moderate risk with unique rewards.
    /// </remarks>
    SecretShrine,

    /// <summary>
    /// A trapped room with danger and some loot.
    /// </summary>
    /// <remarks>
    /// Trap count: 2.0x, loot multiplier: 1.2x.
    /// Skill-based risk/reward.
    /// </remarks>
    TrapRoom,

    /// <summary>
    /// An empty dead end with no special content.
    /// </summary>
    /// <remarks>
    /// Standard room content only.
    /// </remarks>
    Empty
}
```

### 5.3 BranchDecision Value Object

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/BranchDecision.cs`

```csharp
using RuneAndRust.Domain.Enums;

namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents the branching decisions made for a room's exits.
/// </summary>
/// <remarks>
/// Contains the decided branch type for each potential exit direction,
/// determined by the BranchGeneratorService based on probability rules.
/// </remarks>
public readonly record struct BranchDecision
{
    /// <summary>
    /// Gets the position where branching was decided.
    /// </summary>
    public Position3D Position { get; init; }

    /// <summary>
    /// Gets the branch type decisions for each exit direction.
    /// </summary>
    /// <remarks>
    /// Maps each Direction to its decided BranchType.
    /// Directions with BranchType.None have no exit.
    /// </remarks>
    public IReadOnlyDictionary<Direction, BranchType> ExitDecisions { get; init; }

    /// <summary>
    /// Gets whether this room is a dead end (no continuing paths).
    /// </summary>
    /// <remarks>
    /// True when all exits are None or DeadEnd type.
    /// Dead end rooms receive special content rewards.
    /// </remarks>
    public bool IsDeadEnd { get; init; }

    /// <summary>
    /// Gets the directions that have actual exits.
    /// </summary>
    public IEnumerable<Direction> ActiveExits =>
        ExitDecisions
            .Where(kv => kv.Value != BranchType.None)
            .Select(kv => kv.Key);

    /// <summary>
    /// Gets the count of active exits.
    /// </summary>
    public int ExitCount => ActiveExits.Count();

    /// <summary>
    /// Gets whether this decision includes a main path continuation.
    /// </summary>
    public bool HasMainPath =>
        ExitDecisions.Values.Any(b => b == BranchType.MainPath);

    /// <summary>
    /// Gets whether this decision includes any loop connections.
    /// </summary>
    public bool HasLoop =>
        ExitDecisions.Values.Any(b => b == BranchType.Loop);

    /// <summary>
    /// Creates an empty branch decision with no exits.
    /// </summary>
    public static BranchDecision Empty(Position3D position) => new()
    {
        Position = position,
        ExitDecisions = new Dictionary<Direction, BranchType>(),
        IsDeadEnd = true
    };

    /// <inheritdoc/>
    public override string ToString() =>
        $"BranchDecision[{Position}, {ExitCount} exits, DeadEnd={IsDeadEnd}]";
}
```

---

## 6. Dead End Generation

### 6.1 Purpose

Generate meaningful content for dead end rooms that rewards exploration.

### 6.2 Dead End Length Rules

Dead ends terminate after a random length of 1-3 rooms:

```
Dead End Example:
┌─────────┐
│ Main    │──────┐
│ Path    │      │
└─────────┘      │
                 ▼
           ┌─────────┐
           │ Dead    │ Room 1 (may continue)
           │ End #1  │
           └────┬────┘
                │
                ▼
           ┌─────────┐
           │ Dead    │ Room 2 (may continue)
           │ End #2  │
           └────┬────┘
                │
                ▼
           ┌─────────┐
           │ Dead    │ Room 3 (always ends)
           │ End #3  │ Contains: TreasureCache
           └─────────┘
```

### 6.3 Content Type Distribution

| Content Type | Probability | Effect |
|--------------|-------------|--------|
| TreasureCache | 30% | Loot × 2.0, no monsters |
| MonsterLair | 20% | Tier +1, Loot × 1.5 |
| SecretShrine | 20% | Special buff/effect |
| TrapRoom | 15% | Traps × 2.0, Loot × 1.2 |
| Empty | 15% | Standard content |

---

## 7. Loop Detection and Creation

### 7.1 Purpose

Create optional connections to existing rooms for non-linear navigation.

### 7.2 Loop Detection

Loops are detected when a potential exit direction would lead to an already-generated room:

```csharp
var targetPos = position.Move(direction);
var wouldLoop = existingGraph.HasRoom(targetPos);
```

### 7.3 Loop Probability

Loops have a low probability (default 8%) to maintain dungeon coherence while allowing shortcuts:

```
Loop Example:
┌─────────┐     ┌─────────┐
│ Room A  │────▶│ Room B  │
└────┬────┘     └────┬────┘
     │               │
     ▼               ▼
┌─────────┐     ┌─────────┐
│ Room C  │     │ Room D  │
└────┬────┘     └────┬────┘
     │               │
     └───────┬───────┘
             │ (Loop connection)
             ▼
       ┌─────────┐
       │ Room E  │
       └─────────┘
```

### 7.4 IDungeonGraph Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IDungeonGraph.cs`

```csharp
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Interface for querying dungeon room structure.
/// </summary>
/// <remarks>
/// Provides read-only access to dungeon room information
/// for use in branch generation and loop detection.
/// </remarks>
public interface IDungeonGraph
{
    /// <summary>
    /// Checks if a room exists at the specified position.
    /// </summary>
    /// <param name="position">The 3D position to check.</param>
    /// <returns>True if a room exists at the position.</returns>
    bool HasRoom(Position3D position);

    /// <summary>
    /// Gets the count of rooms in the dungeon.
    /// </summary>
    int RoomCount { get; }

    /// <summary>
    /// Gets all room positions in the dungeon.
    /// </summary>
    IEnumerable<Position3D> RoomPositions { get; }
}
```

---

## 8. InfiniteDungeonService

### 8.1 Purpose

Manage infinite procedural dungeon generation, creating rooms as the player explores and cleaning up distant rooms for memory efficiency.

### 8.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/InfiniteDungeonService.cs`

```csharp
using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.Enums;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Services;

/// <summary>
/// Service for managing infinite procedural dungeon generation.
/// </summary>
/// <remarks>
/// Generates rooms lazily as the player explores, creating content
/// within a configurable radius around the player position.
/// Optionally cleans up distant rooms to manage memory usage.
/// </remarks>
public class InfiniteDungeonService : IInfiniteDungeonService
{
    private readonly IRoomGeneratorService _roomGenerator;
    private readonly IBranchGeneratorService _branchGenerator;
    private readonly IContentPlacementService _contentPlacer;
    private readonly ISeededRandomService _random;
    private readonly InfiniteRules _rules;
    private readonly ILogger<InfiniteDungeonService> _logger;

    /// <inheritdoc/>
    public bool IsInfiniteMode { get; private set; }

    /// <inheritdoc/>
    public int GenerationRadius => _rules.GenerationRadius;

    public InfiniteDungeonService(
        IRoomGeneratorService roomGenerator,
        IBranchGeneratorService branchGenerator,
        IContentPlacementService contentPlacer,
        ISeededRandomService random,
        InfiniteRules rules,
        ILogger<InfiniteDungeonService> logger)
    {
        _roomGenerator = roomGenerator ?? throw new ArgumentNullException(nameof(roomGenerator));
        _branchGenerator = branchGenerator ?? throw new ArgumentNullException(nameof(branchGenerator));
        _contentPlacer = contentPlacer ?? throw new ArgumentNullException(nameof(contentPlacer));
        _random = random ?? throw new ArgumentNullException(nameof(random));
        _rules = rules ?? throw new ArgumentNullException(nameof(rules));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));

        _logger.LogDebug(
            "InfiniteDungeonService initialized: radius={Radius}, cleanup={Cleanup}",
            _rules.GenerationRadius, _rules.EnableCleanup);
    }

    /// <inheritdoc/>
    public void EnableInfiniteMode(Dungeon dungeon)
    {
        IsInfiniteMode = true;
        _logger.LogInformation(
            "Infinite dungeon mode enabled for {DungeonName}",
            dungeon.Name);
    }

    /// <inheritdoc/>
    public void DisableInfiniteMode()
    {
        IsInfiniteMode = false;
        _logger.LogInformation("Infinite dungeon mode disabled");
    }

    /// <inheritdoc/>
    public void EnsureGeneratedAround(Dungeon dungeon, Position3D playerPosition)
    {
        if (!IsInfiniteMode)
        {
            return;
        }

        var positionsToGenerate = GetPositionsInRadius(playerPosition, GenerationRadius)
            .Where(p => !dungeon.HasRoomAt(p))
            .Where(p => ShouldGenerate(p, dungeon, playerPosition))
            .ToList();

        _logger.LogDebug(
            "Generating {Count} rooms around player at {Position}",
            positionsToGenerate.Count, playerPosition);

        foreach (var position in positionsToGenerate)
        {
            if (dungeon.RoomCount >= _rules.MaxGeneratedRooms)
            {
                _logger.LogWarning(
                    "Max generated rooms ({Max}) reached, stopping generation",
                    _rules.MaxGeneratedRooms);
                break;
            }

            GenerateRoomAt(dungeon, position);
        }

        // Cleanup distant rooms if memory management enabled
        if (_rules.EnableCleanup)
        {
            CleanupDistantRooms(dungeon, playerPosition);
        }
    }

    /// <inheritdoc/>
    public int GetGeneratedRoomCount(Dungeon dungeon) => dungeon.RoomCount;

    /// <summary>
    /// Generates a single room at the specified position.
    /// </summary>
    private void GenerateRoomAt(Dungeon dungeon, Position3D position)
    {
        var environment = DetermineEnvironment(position);
        var difficulty = _contentPlacer.CalculateDifficulty(
            position,
            dungeon.StartingRoomPosition,
            RoomType.Standard); // Will be updated by template

        var template = _roomGenerator.SelectTemplate(position, environment);
        var room = _roomGenerator.GenerateFromTemplate(template, position, environment);

        // Set difficulty rating
        room.SetDifficultyRating(difficulty);

        // Fill template slots with difficulty-scaled content
        _roomGenerator.FillRoomContent(room, template, difficulty, position, environment);

        // Determine branching for this room
        var branches = _branchGenerator.DecideBranching(
            position,
            template.PotentialExits,
            dungeon.GetGraph());

        // Add room to dungeon
        dungeon.AddRoom(room);

        // Connect to adjacent rooms based on branch decisions
        ConnectToBranches(dungeon, room, branches);

        _logger.LogDebug(
            "Generated room at {Position}: {Name} (difficulty={Difficulty})",
            position, room.Name, difficulty.EffectiveLevel);
    }

    /// <summary>
    /// Connects a room to its neighbors based on branch decisions.
    /// </summary>
    private void ConnectToBranches(Dungeon dungeon, Room room, BranchDecision branches)
    {
        foreach (var (direction, branchType) in branches.ExitDecisions)
        {
            if (branchType == BranchType.None)
            {
                continue;
            }

            var targetPos = room.Position3D.Move(direction);
            var targetRoom = dungeon.GetRoomByPosition(targetPos);

            if (targetRoom != null)
            {
                // Connect to existing room (including loops)
                dungeon.ConnectRooms(room.Id, direction, targetRoom.Id);

                if (branchType == BranchType.Loop)
                {
                    _logger.LogDebug(
                        "Created loop connection from {From} to {To}",
                        room.Position3D, targetPos);
                }
            }
            // If target room doesn't exist, it will be created on a future pass
        }
    }

    /// <summary>
    /// Removes rooms far from the player to manage memory.
    /// </summary>
    private void CleanupDistantRooms(Dungeon dungeon, Position3D playerPosition)
    {
        var cleanupRadius = _rules.CleanupRadius;
        var roomsToRemove = dungeon.Rooms.Values
            .Where(r => ManhattanDistance(r.Position3D, playerPosition) > cleanupRadius)
            .Where(r => !r.HasUncollectedLoot) // Don't remove rooms with uncollected loot
            .Where(r => r.Id != dungeon.StartingRoomId) // Never remove starting room
            .ToList();

        foreach (var room in roomsToRemove)
        {
            dungeon.RemoveRoom(room.Id);
            _logger.LogDebug(
                "Cleaned up distant room at {Position}: {Name}",
                room.Position3D, room.Name);
        }

        if (roomsToRemove.Count > 0)
        {
            _logger.LogInformation(
                "Cleaned up {Count} distant rooms",
                roomsToRemove.Count);
        }
    }

    /// <summary>
    /// Determines if a position should have a room generated.
    /// </summary>
    private bool ShouldGenerate(Position3D position, Dungeon dungeon, Position3D playerPosition)
    {
        // Don't generate below starting depth (going up from start)
        if (position.Z < dungeon.StartingRoomPosition.Z)
        {
            return false;
        }

        // Check if there's an adjacent room that would connect here
        var hasAdjacentRoom = Enum.GetValues<Direction>()
            .Any(d => {
                var adjacent = position.MoveOpposite(d);
                var room = dungeon.GetRoomByPosition(adjacent);
                return room?.HasExit(d) ?? false;
            });

        return hasAdjacentRoom;
    }

    /// <summary>
    /// Determines the environment for a position.
    /// </summary>
    private EnvironmentContext DetermineEnvironment(Position3D position)
    {
        // Environment transitions based on depth and distance
        var depthBiome = position.Z switch
        {
            <= 0 => "dungeon",
            1 or 2 => "cave",
            3 or 4 => "ruins",
            >= 5 => "volcanic"
        };

        return new EnvironmentContext
        {
            Biome = depthBiome,
            Depth = position.Z,
            Climate = position.Z >= 5 ? "hot" : "temperate"
        };
    }

    /// <summary>
    /// Gets all positions within a Manhattan distance radius.
    /// </summary>
    private IEnumerable<Position3D> GetPositionsInRadius(Position3D center, int radius)
    {
        for (int x = -radius; x <= radius; x++)
        {
            for (int y = -radius; y <= radius; y++)
            {
                // Only generate deeper, not upward from current depth
                for (int z = 0; z <= radius; z++)
                {
                    if (Math.Abs(x) + Math.Abs(y) + z <= radius)
                    {
                        yield return new Position3D(center.X + x, center.Y + y, center.Z + z);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Calculates Manhattan distance between two 3D positions.
    /// </summary>
    private static int ManhattanDistance(Position3D a, Position3D b) =>
        Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y) + Math.Abs(a.Z - b.Z);
}
```

### 8.3 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInfiniteDungeonService.cs`

```csharp
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing infinite procedural dungeon generation.
/// </summary>
public interface IInfiniteDungeonService
{
    /// <summary>
    /// Gets whether infinite mode is currently active.
    /// </summary>
    bool IsInfiniteMode { get; }

    /// <summary>
    /// Gets the generation radius around the player.
    /// </summary>
    int GenerationRadius { get; }

    /// <summary>
    /// Enables infinite dungeon mode.
    /// </summary>
    /// <param name="dungeon">The dungeon to enable infinite mode for.</param>
    void EnableInfiniteMode(Dungeon dungeon);

    /// <summary>
    /// Disables infinite dungeon mode.
    /// </summary>
    void DisableInfiniteMode();

    /// <summary>
    /// Ensures rooms are generated around the player position.
    /// </summary>
    /// <param name="dungeon">The dungeon to generate rooms in.</param>
    /// <param name="playerPosition">The current player position.</param>
    void EnsureGeneratedAround(Dungeon dungeon, Position3D playerPosition);

    /// <summary>
    /// Gets the count of generated rooms.
    /// </summary>
    /// <param name="dungeon">The dungeon to count rooms in.</param>
    /// <returns>The number of rooms in the dungeon.</returns>
    int GetGeneratedRoomCount(Dungeon dungeon);
}
```

---

## 9. Chunk-Based Generation

### 9.1 Purpose

Generate rooms lazily within a radius around the player, rather than generating the entire dungeon upfront.

### 9.2 Generation Radius

The generation radius determines how many rooms ahead the system generates:

| Radius | Total Positions | Typical Rooms Generated |
|--------|-----------------|-------------------------|
| 2 | ~25 | ~8-12 |
| 3 | ~80 | ~15-25 |
| 4 | ~150 | ~30-50 |

### 9.3 Generation Logic

```
Player at (5, 3, 2) with radius 3:

Check all positions within Manhattan distance 3:
├── (5, 3, 2) - Player's current room (exists)
├── (4, 3, 2) - West, check if adjacent room connects
├── (6, 3, 2) - East, check if adjacent room connects
├── (5, 4, 2) - North, check if adjacent room connects
├── (5, 2, 2) - South, check if adjacent room connects
├── (5, 3, 3) - Down, check if adjacent room connects
└── ... (all positions within radius)

For each candidate:
1. Skip if room already exists
2. Skip if no adjacent room would connect
3. Skip if above starting depth
4. Generate room using template system
5. Connect to adjacent rooms per branch decisions
```

---

## 10. Memory Management

### 10.1 Purpose

Clean up distant rooms to prevent unbounded memory growth during infinite exploration.

### 10.2 Cleanup Rules

| Rule | Value | Notes |
|------|-------|-------|
| Cleanup radius | 10 | Rooms beyond this distance are eligible |
| Uncollected loot | Protected | Rooms with items/currency not removed |
| Starting room | Protected | Never removed |
| Enable cleanup | Configurable | Can be disabled if memory allows |
| Max rooms | 500 | Hard limit before generation stops |

### 10.3 Cleanup Flow

```
CleanupDistantRooms(playerPosition):
1. Get all rooms beyond cleanup radius
2. Filter out rooms with uncollected loot
3. Filter out starting room
4. Remove each remaining room
5. Log cleanup count
```

---

## 11. Infinite Mode Commands

### 11.1 Command Specification

| Command | Syntax | Description |
|---------|--------|-------------|
| Toggle infinite mode | `infinite mode` | Toggles infinite dungeon mode on/off |
| Check status | `status` | Shows if infinite mode is active |

### 11.2 Command Handler Updates

**File:** `src/Presentation/RuneAndRust.Presentation/Commands/GameSessionService.cs` (partial update)

```csharp
/// <summary>
/// Handles the infinite mode toggle command.
/// </summary>
/// <param name="dungeon">The current dungeon.</param>
/// <returns>A message describing the mode change.</returns>
public string HandleInfiniteModeCommand(Dungeon dungeon)
{
    if (_infiniteDungeonService.IsInfiniteMode)
    {
        _infiniteDungeonService.DisableInfiniteMode();
        return "Infinite dungeon mode disabled. Dungeon will not expand further.";
    }
    else
    {
        _infiniteDungeonService.EnableInfiniteMode(dungeon);
        return "Infinite dungeon mode enabled! The dungeon will expand as you explore.";
    }
}
```

---

## 12. Data Model Changes

### 12.1 New Enums

| Enum | Layer | Description |
|------|-------|-------------|
| `BranchType` | Domain | Types of branch connections |
| `DeadEndContent` | Domain | Types of dead end content |

### 12.2 New Value Objects

| Value Object | Layer | Description |
|--------------|-------|-------------|
| `BranchDecision` | Domain | Branching decisions for room exits |
| `BranchRules` | Application | Branch probability configuration |
| `InfiniteRules` | Application | Infinite mode configuration |
| `DeadEndContentChances` | Application | Dead end content probabilities |

### 12.3 Entity Updates

| Entity | Method/Property | Description |
|--------|-----------------|-------------|
| `Dungeon` | `HasRoomAt(Position3D)` | Check if room exists at 3D position |
| `Dungeon` | `RemoveRoom(Guid)` | Remove a room by ID |
| `Dungeon` | `GetGraph()` | Get IDungeonGraph for loop detection |
| `Dungeon` | `StartingRoomPosition` | Get Position3D of starting room |
| `Room` | `Position3D` | Get 3D position of room |
| `Room` | `HasUncollectedLoot` | Check for remaining items/currency |

### 12.4 Dungeon Entity Updates

**File:** `src/Core/RuneAndRust.Domain/Entities/Dungeon.cs` (additions)

```csharp
/// <summary>
/// Checks if a room exists at the specified 3D position.
/// </summary>
/// <param name="position">The 3D position to check.</param>
/// <returns>True if a room exists at the position.</returns>
public bool HasRoomAt(Position3D position) =>
    _rooms.Values.Any(r => r.Position3D.Equals(position));

/// <summary>
/// Removes a room from the dungeon.
/// </summary>
/// <param name="roomId">The ID of the room to remove.</param>
/// <returns>True if the room was removed; false if not found.</returns>
/// <remarks>
/// Also removes all exit connections to/from this room.
/// Cannot remove the starting room.
/// </remarks>
public bool RemoveRoom(Guid roomId)
{
    if (roomId == StartingRoomId)
    {
        return false;
    }

    if (!_rooms.TryGetValue(roomId, out var room))
    {
        return false;
    }

    // Remove connections to this room from other rooms
    foreach (var otherRoom in _rooms.Values.Where(r => r.Id != roomId))
    {
        otherRoom.RemoveExitTo(roomId);
    }

    return _rooms.Remove(roomId);
}

/// <summary>
/// Gets a graph interface for querying room structure.
/// </summary>
/// <returns>An IDungeonGraph for the current dungeon state.</returns>
public IDungeonGraph GetGraph() => new DungeonGraphAdapter(this);

/// <summary>
/// Gets the 3D position of the starting room.
/// </summary>
public Position3D StartingRoomPosition =>
    GetStartingRoom()?.Position3D ?? Position3D.Origin;

/// <summary>
/// Adapter to expose Dungeon as IDungeonGraph.
/// </summary>
private class DungeonGraphAdapter : IDungeonGraph
{
    private readonly Dungeon _dungeon;

    public DungeonGraphAdapter(Dungeon dungeon) => _dungeon = dungeon;

    public bool HasRoom(Position3D position) => _dungeon.HasRoomAt(position);
    public int RoomCount => _dungeon.RoomCount;
    public IEnumerable<Position3D> RoomPositions =>
        _dungeon.Rooms.Values.Select(r => r.Position3D);
}
```

---

## 13. Configuration File Schemas

### 13.1 Branch Rules Configuration

**File:** `config/branch-rules.json`

```json
{
  "$schema": "schemas/branch-rules.schema.json",
  "version": "1.0",
  "branchRules": {
    "mainPathProbability": 0.70,
    "sidePathProbability": 0.40,
    "deadEndProbability": 0.15,
    "loopProbability": 0.08,
    "maxDeadEndLength": 3,
    "minMainPathContinuation": 1,
    "deadEndContentChances": {
      "treasureCache": 0.30,
      "monsterLair": 0.20,
      "secretShrine": 0.20,
      "trapRoom": 0.15,
      "empty": 0.15
    }
  },
  "infiniteRules": {
    "generationRadius": 3,
    "cleanupRadius": 10,
    "enableCleanup": true,
    "maxGeneratedRooms": 500,
    "depthLimit": null
  }
}
```

### 13.2 Configuration Classes

**File:** `src/Core/RuneAndRust.Application/Configuration/BranchRulesConfiguration.cs`

```csharp
namespace RuneAndRust.Application.Configuration;

/// <summary>
/// Configuration wrapper for branch generation rules.
/// </summary>
public class BranchRulesConfiguration
{
    /// <summary>
    /// Schema version for configuration validation.
    /// </summary>
    public string Version { get; init; } = "1.0";

    /// <summary>
    /// Branch probability rules.
    /// </summary>
    public BranchRules BranchRules { get; init; } = new();

    /// <summary>
    /// Infinite mode rules.
    /// </summary>
    public InfiniteRules InfiniteRules { get; init; } = new();
}

/// <summary>
/// Branch probability configuration.
/// </summary>
public class BranchRules
{
    /// <summary>
    /// Probability of creating a main path exit.
    /// </summary>
    /// <remarks>
    /// At least one main path is guaranteed per room.
    /// </remarks>
    public float MainPathProbability { get; init; } = 0.70f;

    /// <summary>
    /// Probability of creating a side path exit.
    /// </summary>
    public float SidePathProbability { get; init; } = 0.40f;

    /// <summary>
    /// Probability of creating a dead end exit.
    /// </summary>
    public float DeadEndProbability { get; init; } = 0.15f;

    /// <summary>
    /// Probability of creating a loop connection.
    /// </summary>
    public float LoopProbability { get; init; } = 0.08f;

    /// <summary>
    /// Maximum length of dead end paths (in rooms).
    /// </summary>
    public int MaxDeadEndLength { get; init; } = 3;

    /// <summary>
    /// Minimum main path continuations per room.
    /// </summary>
    public int MinMainPathContinuation { get; init; } = 1;

    /// <summary>
    /// Content type probabilities for dead ends.
    /// </summary>
    public DeadEndContentChances DeadEndContentChances { get; init; } = new();
}

/// <summary>
/// Dead end content probability configuration.
/// </summary>
public class DeadEndContentChances
{
    /// <summary>
    /// Chance of treasure cache (good loot, no combat).
    /// </summary>
    public float TreasureCache { get; init; } = 0.30f;

    /// <summary>
    /// Chance of monster lair (tough fight, great loot).
    /// </summary>
    public float MonsterLair { get; init; } = 0.20f;

    /// <summary>
    /// Chance of secret shrine (special interaction).
    /// </summary>
    public float SecretShrine { get; init; } = 0.20f;

    /// <summary>
    /// Chance of trap room (dangerous, some loot).
    /// </summary>
    public float TrapRoom { get; init; } = 0.15f;

    /// <summary>
    /// Chance of empty dead end.
    /// </summary>
    public float Empty { get; init; } = 0.15f;
}

/// <summary>
/// Infinite mode configuration.
/// </summary>
public class InfiniteRules
{
    /// <summary>
    /// Radius of room generation around player.
    /// </summary>
    public int GenerationRadius { get; init; } = 3;

    /// <summary>
    /// Distance beyond which rooms are eligible for cleanup.
    /// </summary>
    public int CleanupRadius { get; init; } = 10;

    /// <summary>
    /// Whether to clean up distant rooms for memory management.
    /// </summary>
    public bool EnableCleanup { get; init; } = true;

    /// <summary>
    /// Maximum number of rooms before generation stops.
    /// </summary>
    public int MaxGeneratedRooms { get; init; } = 500;

    /// <summary>
    /// Optional depth limit (null for truly infinite).
    /// </summary>
    public int? DepthLimit { get; init; } = null;
}
```

### 13.3 JSON Schema

**File:** `config/schemas/branch-rules.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "branch-rules.schema.json",
  "title": "Branch Rules Configuration",
  "description": "Schema for branch generation and infinite mode rules",
  "type": "object",
  "required": ["version", "branchRules", "infiniteRules"],
  "properties": {
    "$schema": {
      "type": "string"
    },
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+$"
    },
    "branchRules": {
      "type": "object",
      "required": ["mainPathProbability", "sidePathProbability"],
      "properties": {
        "mainPathProbability": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of creating main path exit"
        },
        "sidePathProbability": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of creating side path exit"
        },
        "deadEndProbability": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of creating dead end exit"
        },
        "loopProbability": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Probability of creating loop connection"
        },
        "maxDeadEndLength": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum rooms in a dead end path"
        },
        "minMainPathContinuation": {
          "type": "integer",
          "minimum": 1,
          "description": "Minimum main path exits per room"
        },
        "deadEndContentChances": {
          "type": "object",
          "properties": {
            "treasureCache": { "type": "number", "minimum": 0, "maximum": 1 },
            "monsterLair": { "type": "number", "minimum": 0, "maximum": 1 },
            "secretShrine": { "type": "number", "minimum": 0, "maximum": 1 },
            "trapRoom": { "type": "number", "minimum": 0, "maximum": 1 },
            "empty": { "type": "number", "minimum": 0, "maximum": 1 }
          }
        }
      }
    },
    "infiniteRules": {
      "type": "object",
      "required": ["generationRadius", "cleanupRadius"],
      "properties": {
        "generationRadius": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "description": "Room generation radius around player"
        },
        "cleanupRadius": {
          "type": "integer",
          "minimum": 5,
          "description": "Distance for room cleanup eligibility"
        },
        "enableCleanup": {
          "type": "boolean",
          "description": "Whether to clean up distant rooms"
        },
        "maxGeneratedRooms": {
          "type": "integer",
          "minimum": 50,
          "description": "Maximum rooms before generation stops"
        },
        "depthLimit": {
          "type": ["integer", "null"],
          "minimum": 1,
          "description": "Optional maximum depth limit"
        }
      }
    }
  }
}
```

---

## 14. Logging Specifications

### 14.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `BranchGeneratorService` | Information | Branch decision summary |
| `BranchGeneratorService` | Debug | Individual direction decisions |
| `BranchGeneratorService` | Debug | Loop detection results |
| `BranchGeneratorService` | Debug | Dead end content selection |
| `InfiniteDungeonService` | Information | Mode enabled/disabled |
| `InfiniteDungeonService` | Information | Cleanup summary |
| `InfiniteDungeonService` | Debug | Room generation details |
| `InfiniteDungeonService` | Warning | Max rooms reached |

### 14.2 Log Message Examples

```
// Information
[InfiniteDungeonService] Infinite dungeon mode enabled for The Forgotten Depths
[InfiniteDungeonService] Infinite dungeon mode disabled
[InfiniteDungeonService] Cleaned up 12 distant rooms

// Debug
[BranchGeneratorService] Deciding branching at (3, 4, 2) with 3 potential exits
[BranchGeneratorService] Direction North: MainPath (roll=0.35)
[BranchGeneratorService] Loop connection at East (roll=0.05 < 0.08)
[BranchGeneratorService] Dead end at (7, 2, 3) contains TreasureCache (roll=0.22)
[InfiniteDungeonService] Generating 5 rooms around player at (5, 3, 2)
[InfiniteDungeonService] Generated room at (6, 3, 2): Dark Corridor (difficulty=35)
[InfiniteDungeonService] Cleaned up distant room at (1, 1, 0): Entrance Hall

// Warning
[InfiniteDungeonService] Max generated rooms (500) reached, stopping generation
```

---

## 15. Unit Testing Requirements

### 15.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| BranchGeneratorService branching | 6 |
| Dead end content selection | 3 |
| Loop detection and creation | 3 |
| InfiniteDungeonService generation | 5 |
| Memory cleanup | 3 |
| Mode toggle | 2 |
| Configuration loading | 1 |
| **Total** | **~23** |

### 15.2 Test Categories

#### BranchGeneratorService Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/BranchGeneratorServiceTests.cs`

1. `DecideBranching_EnsuresAtLeastOneMainPath`
2. `DecideBranching_RespectsMainPathProbability`
3. `DecideBranching_CreatesSidePaths`
4. `DecideBranching_CreatesDeadEnds`
5. `DecideBranching_IsDeadEnd_WhenAllNoneOrDeadEnd`
6. `DecideBranching_SeededRandom_IsDeterministic`

#### Dead End Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/BranchGeneratorDeadEndTests.cs`

1. `GenerateDeadEndContent_TreasureCache_WithinProbability`
2. `GenerateDeadEndContent_MonsterLair_WithinProbability`
3. `GenerateDeadEndContent_SeededRandom_IsDeterministic`

#### Loop Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/BranchGeneratorLoopTests.cs`

1. `DecideBranching_DetectsExistingRoom_AsLoop`
2. `DecideBranching_RespectsLoopProbability`
3. `DecideBranching_BlocksLoop_WhenRollExceedsProbability`

#### InfiniteDungeonService Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/InfiniteDungeonServiceTests.cs`

1. `EnsureGeneratedAround_DoesNothing_WhenNotInfiniteMode`
2. `EnsureGeneratedAround_GeneratesWithinRadius`
3. `EnsureGeneratedAround_SkipsExistingRooms`
4. `EnsureGeneratedAround_RespectsMaxRooms`
5. `EnsureGeneratedAround_ConnectsToAdjacentRooms`

#### Memory Cleanup Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/InfiniteDungeonCleanupTests.cs`

1. `CleanupDistantRooms_RemovesRoomsBeyondRadius`
2. `CleanupDistantRooms_ProtectsRoomsWithLoot`
3. `CleanupDistantRooms_ProtectsStartingRoom`

#### Mode Toggle Tests

**File:** `tests/RuneAndRust.Application.UnitTests/Services/InfiniteDungeonModeTests.cs`

1. `EnableInfiniteMode_SetsIsInfiniteMode`
2. `DisableInfiniteMode_ClearsIsInfiniteMode`

#### Configuration Tests

**File:** `tests/RuneAndRust.Infrastructure.UnitTests/Configuration/BranchRulesConfigurationTests.cs`

1. `LoadFromJson_ValidFile_ReturnsConfiguration`

---

## 16. Use Cases

### UC-001: Decide Room Branching
**Actor:** RoomGeneratorService (System)
**Flow:** Get potential exits → Get dungeon graph → Call BranchGeneratorService.DecideBranching() → Return branch decisions

### UC-002: Generate Dead End Content
**Actor:** RoomGeneratorService (System)
**Flow:** Detect dead end room → Get difficulty → Call BranchGeneratorService.GenerateDeadEndContent() → Apply content modifiers

### UC-003: Detect Loop Opportunity
**Actor:** BranchGeneratorService (System)
**Flow:** Check target position → Query dungeon graph → If room exists → Roll for loop probability → Create loop if successful

### UC-004: Enable Infinite Mode
**Actor:** Player
**Flow:** Enter `infinite mode` command → GameSessionService routes → InfiniteDungeonService.EnableInfiniteMode() → Display confirmation

### UC-005: Generate Rooms on Move
**Actor:** InfiniteDungeonService (System)
**Flow:** Player moves → Get new position → Call EnsureGeneratedAround() → Generate needed rooms → Connect to dungeon

### UC-006: Cleanup Distant Rooms
**Actor:** InfiniteDungeonService (System)
**Flow:** After generation → Get rooms beyond cleanup radius → Filter protected rooms → Remove eligible rooms

---

## 17. Deliverable Checklist

### Domain Layer
- [ ] `BranchType` enum created
- [ ] `DeadEndContent` enum created
- [ ] `BranchDecision` value object created
- [ ] `Dungeon.HasRoomAt()` method added
- [ ] `Dungeon.RemoveRoom()` method added
- [ ] `Dungeon.GetGraph()` method added
- [ ] `Dungeon.StartingRoomPosition` property added
- [ ] `Room.Position3D` property accessible
- [ ] `Room.HasUncollectedLoot` property added

### Application Layer
- [ ] `IBranchGeneratorService` interface defined
- [ ] `BranchGeneratorService` implementation complete
- [ ] `IInfiniteDungeonService` interface defined
- [ ] `InfiniteDungeonService` implementation complete
- [ ] `IDungeonGraph` interface defined
- [ ] `BranchRules` configuration class created
- [ ] `InfiniteRules` configuration class created
- [ ] `DeadEndContentChances` configuration class created
- [ ] `BranchRulesConfiguration` wrapper class created

### Configuration
- [ ] `config/branch-rules.json` created
- [ ] `config/schemas/branch-rules.schema.json` created
- [ ] JSON validates against schema

### Infrastructure
- [ ] `JsonConfigurationProvider` loads branch rules
- [ ] DI registration for BranchGeneratorService
- [ ] DI registration for InfiniteDungeonService
- [ ] DI registration for BranchRules
- [ ] DI registration for InfiniteRules

### Presentation
- [ ] `infinite mode` command handler added
- [ ] GameSessionService updated for infinite mode

### Testing
- [ ] ~23 unit tests implemented
- [ ] All tests passing
- [ ] Test coverage for all branching scenarios

---

## 18. Acceptance Criteria

### Functional
- [ ] BranchGeneratorService creates varied path structures
- [ ] At least one main path continuation per room (except forced dead ends)
- [ ] Side paths branch off with configured probability
- [ ] Dead ends terminate after 1-3 rooms
- [ ] Dead ends contain special content based on type
- [ ] Loops can optionally form with low probability
- [ ] Loop connections work bidirectionally
- [ ] InfiniteDungeonService generates rooms around player
- [ ] Generation respects configured radius
- [ ] Infinite mode can be toggled with command
- [ ] Distant rooms are cleaned up when cleanup enabled
- [ ] Rooms with uncollected loot are protected from cleanup
- [ ] Starting room is never cleaned up
- [ ] Max generated rooms limit is respected
- [ ] Seeded random ensures deterministic branch decisions

### Quality
- [ ] Build succeeds with 0 errors and 0 warnings
- [ ] All ~23 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public APIs
- [ ] Logging follows specified patterns

---

## 19. Dependencies

### Requires (from prior versions)
- v0.1.1c: `ContentPlacementService`, `DifficultyRating`
- v0.1.1b: `SeededRandomService`, `ISeededRandomService`
- v0.1.1a: `RoomGeneratorService`, `RoomTemplate`, `TemplateSlot`
- v0.1.0c: `RoomType` enum
- v0.1.0a: `Position3D` value object
- v0.0.11a: `EnvironmentContext`
- v0.0.x: `Dungeon`, `Room`, `Direction`

### Provides (for future versions)
- `BranchGeneratorService` for varied dungeon layouts
- `InfiniteDungeonService` for endless exploration
- `BranchDecision` for procedural path planning
- Memory-efficient infinite generation pattern

---

## 20. Future Considerations

### Deferred to Future Versions
- **Save/Load for infinite mode** - Persistence of dynamically generated rooms
- **Multiplayer infinite dungeons** - Synchronized generation across clients
- **Branch difficulty variance** - Side paths easier, dead ends harder
- **Named dead ends** - Procedural naming for memorable locations
- **Achievement tracking** - Stats for exploration in infinite mode

### Out of Scope
- Multiple infinite dungeons simultaneously
- Cross-dungeon portals
- Player-placed waypoints in infinite mode
- Minimap for infinite dungeons
- Automatic backtracking in infinite mode

---

*Document Version: 1.0*
*Last Updated: 2026-01-08*
*Author: Claude*
