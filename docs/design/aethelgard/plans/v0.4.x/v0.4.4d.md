# v0.4.4d: The Paradox (Mystic-Specific Backlash)

> **Status:** Planned
> **Parent:** v0.4.4 - The Mystic (Archetype Specialization)
> **Theme:** When personal resonance and environmental flux collide, reality fractures—and the caster pays the price in pieces of their soul.

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Decision Trees](#decision-trees)
4. [Deliverables Checklist](#deliverables-checklist)
5. [Implementation Workflow](#implementation-workflow)
6. [Code Examples](#code-examples)
7. [Logging Specification](#logging-specification)
8. [Unit Testing](#unit-testing)
9. [Integration Points](#integration-points)
10. [Domain 4 Compliance](#domain-4-compliance)
11. [Changelog Template](#changelog-template)

---

## Overview

v0.4.4d introduces **Paradox**—the Mystic-specific enhanced backlash that occurs when personal Resonance and environmental Flux combine to dangerous levels. While standard Backlash (v0.4.3d) affects all casters, Paradox is a unique hazard faced only by those who push their attunement to the Weave beyond safe limits.

### Core Concept

> *"The Weave is patient, but it is not forgiving. When a Mystic's resonance harmonizes with the ambient chaos, something new is created—a discord that tears at the fabric of existence. The Old Ones called it Paradox, the moment when the caster becomes both the instrument and the wound."*
> — Jötun-Reader Field Notes, Codex Entry #734

### Paradox vs Standard Backlash

| Aspect | Backlash (v0.4.3d) | Paradox (v0.4.4d) |
|--------|--------------------|--------------------|
| **Who** | All spell casters | Mystics only |
| **Trigger** | Flux > 50 | Flux + Resonance > 100 |
| **Severity Factors** | Flux level only | Flux + Resonance + School mismatch |
| **Consequences** | Damage, Aether Sickness, Corruption | Same + Soul Fracture, Reality Tear |
| **Mitigation** | None | School Mastery reduces severity |
| **Special State** | None | Overflow grants power before damage |
| **Permanence** | Temporary effects | Soul Fracture is permanent |

### Paradox Severity System

Unlike standard Backlash which uses a linear risk calculation, Paradox uses **combined thresholds**:

| Combined Value | Risk Chance | Minimum Severity | Maximum Severity |
|----------------|-------------|------------------|------------------|
| 100-119 | 20% | Minor | Minor |
| 120-139 | 35% | Minor | Major |
| 140-159 | 50% | Major | Severe |
| 160-179 | 70% | Severe | Catastrophic |
| 180+ | 90% | Catastrophic | Catastrophic |

### Paradox Severity Effects

| Severity | Damage | Status Effect | Corruption | Soul Fracture | Special |
|----------|--------|---------------|------------|---------------|---------|
| **Minor** | 1d6 | None | None | None | Resonance drops by 10 |
| **Major** | 2d8 | Aether Sickness (2 turns) | None | None | Resonance drops by 25 |
| **Severe** | 3d10 | Aether Sickness (4 turns) | +5 | None | Resonance reset to 0, Reality Flicker |
| **Catastrophic** | 4d12 | Aether Sickness (6 turns) | +10 | +1 Fracture | Resonance reset, Reality Tear event |

### Aetheric Overflow

When Resonance reaches exactly 100, the Mystic enters **Overflow**—a dangerous state of maximum power:

| Phase | Duration | Effect |
|-------|----------|--------|
| **Entry** | Instant | Resonance locked at 100, Overflow state applied |
| **Power Surge** | 1 turn | +50% spell potency, -50% AP costs |
| **Forced Discharge** | End of turn | Automatic Catastrophic Paradox check |
| **Aftermath** | Persistent | Resonance reset to 0, +1 Soul Fracture |

### Soul Fracture

The permanent consequence of pushing too far:

| Fractures | Max Resonance | Additional Penalty |
|-----------|---------------|-------------------|
| 0 | 100 | None |
| 1 | 99 | None |
| 2 | 98 | None |
| 3 | 97 | -1 WILL |
| 4 | 96 | -1 WILL |
| 5 | 95 | -1 WILL, -1 WITS |
| 6+ | 94 - (n-5) | -2 WILL, -1 WITS, "Fractured Soul" trait |
| 10 | 90 | **Soul Death** - Character becomes Forlorn |

### School Mastery Mitigation

Mastery in the casting school reduces Paradox severity:

| Mastery Tier | Severity Reduction | Notes |
|--------------|-------------------|-------|
| Novice | None | Full severity |
| Apprentice | -1 tier (min Minor) | Major → Minor |
| Adept | -1 tier (min Minor) | + 10% chance to avoid |
| Master | -2 tiers (min Minor) | Severe → Minor |
| Archon | -2 tiers (min Minor) | + 25% chance to avoid entirely |

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        MagicService                              │
│   (Orchestrates casting, calls ParadoxService before execution) │
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
┌─────────────────────────┐     ┌─────────────────────────────────┐
│    IResonanceService    │     │         IParadoxService          │
│  (v0.4.4a - Resonance)  │     │  ┌─────────────────────────────┐│
└─────────────┬───────────┘     │  │ + CheckParadox(char, spell) ││
              │                 │  │ + CalculateSeverity(combo)  ││
              │                 │  │ + ApplyParadoxEffects(...)  ││
              │                 │  │ + EnterOverflow(character)  ││
              │                 │  │ + ProcessDischarge(char)    ││
              │                 │  │ + ApplySoulFracture(char)   ││
              │                 │  │ + GetSoulFractureCount(char)││
              │                 │  └─────────────────────────────┘│
              │                 └─────────────────┬───────────────┘
              │                                   │
              └───────────────┬───────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      ParadoxService                              │
│  ┌─────────────────────────────────────────────────────────────┐│
│  │ - _logger: ILogger<ParadoxService>                          ││
│  │ - _eventBus: IEventBus                                      ││
│  │ - _diceService: IDiceService                                ││
│  │ - _resonanceService: IResonanceService                      ││
│  │ - _masteryService: IMasteryService                          ││
│  │ - _backslashService: IBacklashService                       ││
│  │ - _statusEffectService: IStatusEffectService                ││
│  └─────────────────────────────────────────────────────────────┘│
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┬───────────────┐
              ▼               ▼               ▼               ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ ParadoxSeverity │ │  ParadoxResult  │ │  OverflowState  │ │  SoulFracture   │
│  ┌───────────┐  │ │  ┌───────────┐  │ │  ┌───────────┐  │ │  ┌───────────┐  │
│  │ None      │  │ │  │ Triggered │  │ │  │ IsActive  │  │ │  │ Count     │  │
│  │ Minor     │  │ │  │ Severity  │  │ │  │ TurnEnter │  │ │  │ MaxRes    │  │
│  │ Major     │  │ │  │ Damage    │  │ │  │ PotencyMod│  │ │  │ WillPen   │  │
│  │ Severe    │  │ │  │ StatusEff │  │ │  │ APCostMod │  │ │  │ WitsPen   │  │
│  │ Catastrph │  │ │  │ SoulFract │  │ │  │ Discharged│  │ │  │ Timestamp │  │
│  └───────────┘  │ │  │ ResTear   │  │ │  └───────────┘  │ │  └───────────┘  │
└─────────────────┘ │  └───────────┘  │ └─────────────────┘ └─────────────────┘
                    └─────────────────┘
```

### Data Flow

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           MagicService.CastSpell()                        │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 1. Get environmental Flux and personal Resonance                          │
│    Flux = _aetherService.GetCurrentFlux()                                │
│    Resonance = _resonanceService.GetResonance(character)                 │
│    Combined = Flux + Resonance                                           │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 2. Check if Paradox applies (Mystic archetype only)                      │
│    ├─ NOT Mystic? → Skip to standard Backlash check                      │
│    └─ IS Mystic?  → Continue to Paradox check                            │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 3. Check for Overflow (Resonance == 100)                                 │
│    ├─ YES → EnterOverflow() → Apply bonuses → Schedule discharge         │
│    └─ NO  → Continue to Paradox risk check                               │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 4. Paradox risk check (if Combined > 100)                                │
│    ├─ Combined <= 100? → No Paradox, proceed with cast                   │
│    └─ Combined > 100?  → Calculate risk and roll                         │
│         ├─ Risk = GetRiskChance(Combined)                                │
│         ├─ Roll d100                                                     │
│         ├─ Roll > Risk? → AVOIDED, proceed with cast                     │
│         └─ Roll <= Risk? → TRIGGERED, continue to severity               │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 5. Calculate Paradox severity                                            │
│    BaseSeverity = GetBaseSeverity(Combined)                              │
│    MasteryTier = _masteryService.GetMasteryTier(char, spell.School)      │
│    Reduction = GetSeverityReduction(MasteryTier)                         │
│    FinalSeverity = Max(Minor, BaseSeverity - Reduction)                  │
│    AvoidChance = GetAvoidChance(MasteryTier)                             │
│    IF Roll(d100) <= AvoidChance → Severity becomes None                  │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 6. Apply Paradox effects                                                 │
│    ├─ Calculate damage based on severity                                 │
│    ├─ Apply Aether Sickness status if severity >= Major                  │
│    ├─ Add Corruption if severity >= Severe                               │
│    ├─ Apply Soul Fracture if severity == Catastrophic                    │
│    ├─ Trigger Reality Tear event if severity == Catastrophic             │
│    ├─ Reduce/Reset Resonance based on severity                           │
│    └─ Publish ParadoxTriggeredEvent                                      │
└────────────────────────────────────┬─────────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────────┐
│ 7. Return ParadoxResult to MagicService                                  │
│    ├─ Triggered = true? → Spell fizzles, return failure                  │
│    └─ Triggered = false? → Continue with normal spell execution          │
└──────────────────────────────────────────────────────────────────────────┘
```

### Character State Extension

```
Character
  ├─ ResonanceState (from v0.4.4a)
  │    └─ CurrentResonance: int (0-100, reduced by Soul Fracture)
  ├─ OverflowState: OverflowState?
  │    ├─ IsActive: bool
  │    ├─ TurnEntered: int
  │    ├─ PotencyModifier: decimal (1.50)
  │    ├─ APCostModifier: decimal (0.50)
  │    └─ HasDischarged: bool
  └─ SoulFractures: List<SoulFracture>
       └─ Each: { Count, Timestamp, Source }

Computed Properties:
  ├─ TotalSoulFractures: int (sum of all fracture counts)
  ├─ MaxResonanceCapacity: int (100 - TotalSoulFractures)
  ├─ SoulFractureWillPenalty: int (0 at <3, -1 at 3-5, -2 at 6+)
  └─ SoulFractureWitsPenalty: int (0 at <5, -1 at 5+)
```

---

## Decision Trees

### 1. CheckParadox Decision Tree

```
CheckParadox(character, spell, currentFlux)
│
├─ Validate inputs
│   ├─ character is null? → throw ArgumentNullException
│   ├─ spell is null? → throw ArgumentNullException
│   └─ character is not Mystic? → return ParadoxResult.NotApplicable()
│
├─ Get current states
│   ├─ resonance = _resonanceService.GetResonance(character)
│   ├─ combined = currentFlux + resonance
│   └─ Log: "Paradox check: Flux={Flux}, Resonance={Res}, Combined={Comb}"
│
├─ Check Overflow state first
│   ├─ resonance == 100 AND NOT already in Overflow?
│   │   └─ EnterOverflow(character) → return ParadoxResult.OverflowEntered()
│   └─ Already in Overflow? → ProcessOverflowDischarge() is called at turn end
│
├─ Check if Paradox threshold exceeded
│   ├─ combined <= 100? → return ParadoxResult.Safe()
│   └─ combined > 100? → continue to risk calculation
│
├─ Calculate risk chance
│   └─ riskChance = GetRiskChance(combined)
│       ├─ 100-119 → 20%
│       ├─ 120-139 → 35%
│       ├─ 140-159 → 50%
│       ├─ 160-179 → 70%
│       └─ 180+    → 90%
│
├─ Roll for Paradox
│   ├─ roll = _diceService.RollD100()
│   ├─ roll > riskChance? → return ParadoxResult.Avoided(roll, riskChance)
│   └─ roll <= riskChance? → Paradox triggered, continue
│
├─ Calculate severity
│   └─ severity = CalculateParadoxSeverity(combined, character, spell.School)
│
├─ Apply effects
│   └─ return ApplyParadoxEffects(character, severity, spell.School)
│
└─ Log final result
```

### 2. CalculateParadoxSeverity Decision Tree

```
CalculateParadoxSeverity(combined, character, school)
│
├─ Determine base severity from combined value
│   ├─ 100-119 → baseSeverity = Minor
│   ├─ 120-139 → baseSeverity = Random(Minor, Major)
│   ├─ 140-159 → baseSeverity = Random(Major, Severe)
│   ├─ 160-179 → baseSeverity = Random(Severe, Catastrophic)
│   └─ 180+    → baseSeverity = Catastrophic
│
├─ Get mastery tier for reduction
│   └─ masteryTier = _masteryService.GetMasteryTier(character, school)
│
├─ Calculate tier reduction
│   ├─ Novice     → reduction = 0
│   ├─ Apprentice → reduction = 1
│   ├─ Adept      → reduction = 1
│   ├─ Master     → reduction = 2
│   └─ Archon    → reduction = 2
│
├─ Apply reduction
│   └─ finalSeverity = Max(Minor, baseSeverity - reduction)
│
├─ Check avoidance chance (Adept+)
│   ├─ Adept   → avoidChance = 10%
│   ├─ Archon → avoidChance = 25%
│   └─ Others  → avoidChance = 0%
│   │
│   └─ Roll d100, if roll <= avoidChance → finalSeverity = None
│
└─ Return finalSeverity with calculation details
```

### 3. EnterOverflow Decision Tree

```
EnterOverflow(character)
│
├─ Validate
│   ├─ Already in Overflow? → return OverflowResult.AlreadyActive()
│   └─ Resonance != 100? → return OverflowResult.NotAtCapacity()
│
├─ Create Overflow state
│   └─ overflowState = new OverflowState
│       ├─ IsActive = true
│       ├─ TurnEntered = _combatService.CurrentTurn
│       ├─ PotencyModifier = 1.50m
│       ├─ APCostModifier = 0.50m
│       └─ HasDischarged = false
│
├─ Apply to character
│   └─ character.OverflowState = overflowState
│
├─ Log entry
│   └─ "OVERFLOW ENTERED: Character={Id} enters Aetheric Overflow. Power surges!"
│
├─ Publish event
│   └─ _eventBus.Publish(new OverflowEnteredEvent { CharacterId, Turn })
│
└─ Return OverflowResult.Entered(overflowState)
```

### 4. ProcessOverflowDischarge Decision Tree

```
ProcessOverflowDischarge(character)
│
├─ Validate
│   ├─ Not in Overflow? → return DischargeResult.NotInOverflow()
│   └─ Already discharged this turn? → return DischargeResult.AlreadyDischarged()
│
├─ Mark as discharged
│   └─ character.OverflowState.HasDischarged = true
│
├─ Calculate discharge damage
│   └─ damage = _diceService.Roll(4, 12) // 4d12 catastrophic damage
│
├─ Apply damage
│   └─ character.TakeDamage(damage, "Aetheric Overflow Discharge")
│
├─ Apply Soul Fracture
│   └─ ApplySoulFracture(character, "Overflow Discharge")
│
├─ Reset Resonance
│   └─ _resonanceService.Reset(character)
│
├─ Apply Aether Sickness
│   └─ _statusEffectService.Apply(character, AetherSickness, duration: 6)
│
├─ Clear Overflow state
│   └─ character.OverflowState = null
│
├─ Check for Soul Death
│   ├─ TotalSoulFractures >= 10? → TriggerSoulDeath(character)
│   └─ Otherwise → continue
│
├─ Publish event
│   └─ _eventBus.Publish(new OverflowDischargeEvent { ... })
│
└─ Return DischargeResult.Completed(damage, newFractureCount)
```

### 5. ApplySoulFracture Decision Tree

```
ApplySoulFracture(character, source)
│
├─ Validate
│   └─ character is null? → throw ArgumentNullException
│
├─ Create fracture record
│   └─ fracture = new SoulFracture
│       ├─ Count = 1
│       ├─ Timestamp = DateTime.UtcNow
│       └─ Source = source
│
├─ Add to character
│   └─ character.SoulFractures.Add(fracture)
│
├─ Calculate new totals
│   ├─ totalFractures = character.SoulFractures.Sum(f => f.Count)
│   └─ newMaxResonance = 100 - totalFractures
│
├─ Apply attribute penalties (if thresholds crossed)
│   ├─ totalFractures >= 3 AND < 6? → WillPenalty = -1
│   ├─ totalFractures >= 6? → WillPenalty = -2, WitsPenalty = -1
│   └─ Log penalty changes
│
├─ Check for Soul Death
│   ├─ totalFractures >= 10?
│   │   ├─ Log: "SOUL DEATH: Character={Id} soul has shattered completely"
│   │   ├─ character.IsSoulDead = true
│   │   └─ Publish SoulDeathEvent
│   └─ Otherwise → continue
│
├─ Log fracture
│   └─ "SOUL FRACTURE: Character={Id} gained fracture. Total={Total}, MaxRes={Max}"
│
├─ Publish event
│   └─ _eventBus.Publish(new SoulFractureGainedEvent { ... })
│
└─ Return SoulFractureResult
    ├─ NewFractureCount = totalFractures
    ├─ NewMaxResonance = newMaxResonance
    └─ IsSoulDeath = totalFractures >= 10
```

---

## Deliverables Checklist

### Core Models (RuneAndRust.Core)

- [ ] **`ParadoxSeverity.cs`** (Enums)
  - Enum: `None`, `Minor`, `Major`, `Severe`, `Catastrophic`
  - Extension method: `GetDamageDice()` returning dice expression
  - Extension method: `GetAetherSicknessDuration()` returning int
  - Extension method: `GetCorruptionGain()` returning int
  - Extension method: `CausesSoulFracture()` returning bool

- [ ] **`SoulFracture.cs`** (Models/Magic)
  - Properties: `Count`, `Timestamp`, `Source`
  - Factory: `FromOverflow()`, `FromCatastrophicParadox()`

- [ ] **`OverflowState.cs`** (Models/Magic)
  - Properties: `IsActive`, `TurnEntered`, `PotencyModifier`, `APCostModifier`, `HasDischarged`
  - Method: `GetRemainingTurns(currentTurn)` → int
  - Static: `Default` property for creating new state

- [ ] **`ParadoxResult.cs`** (Models/Magic)
  - Properties: `Triggered`, `Severity`, `DamageDealt`, `StatusApplied`, `CorruptionGained`, `SoulFractureGained`, `ResonanceChange`, `RealityTearTriggered`
  - Factory methods: `Safe()`, `Avoided()`, `Triggered()`, `OverflowEntered()`, `NotApplicable()`

- [ ] **`DischargeResult.cs`** (Models/Magic)
  - Properties: `DamageDealt`, `FractureGained`, `NewMaxResonance`, `IsSoulDeath`
  - Factory methods: `Completed()`, `NotInOverflow()`, `AlreadyDischarged()`

- [ ] **`SoulFractureResult.cs`** (Models/Magic)
  - Properties: `NewFractureCount`, `NewMaxResonance`, `WillPenalty`, `WitsPenalty`, `IsSoulDeath`

### Events (RuneAndRust.Core/Events)

- [ ] **`ParadoxTriggeredEvent.cs`**
  - Properties: `CharacterId`, `Severity`, `DamageDealt`, `Combined`, `Roll`, `RiskChance`, `Timestamp`

- [ ] **`OverflowEnteredEvent.cs`**
  - Properties: `CharacterId`, `Turn`, `PotencyBonus`, `APCostReduction`, `Timestamp`

- [ ] **`OverflowDischargeEvent.cs`**
  - Properties: `CharacterId`, `DamageDealt`, `FractureGained`, `NewMaxResonance`, `Timestamp`

- [ ] **`SoulFractureGainedEvent.cs`**
  - Properties: `CharacterId`, `Source`, `NewTotal`, `NewMaxResonance`, `WillPenalty`, `WitsPenalty`, `Timestamp`

- [ ] **`SoulDeathEvent.cs`**
  - Properties: `CharacterId`, `FinalFractureCount`, `Source`, `Timestamp`

### Service Layer (RuneAndRust.Engine)

- [ ] **`IParadoxService.cs`** (Interfaces)
  - Full interface contract (8 methods)

- [ ] **`ParadoxService.cs`** (Services)
  - Full implementation with logging
  - Dependencies: `ILogger`, `IEventBus`, `IDiceService`, `IResonanceService`, `IMasteryService`, `IBacklashService`, `IStatusEffectService`

### Integration (RuneAndRust.Engine)

- [ ] **MagicService extension**
  - Call `CheckParadox` before spell execution (for Mystics)
  - Apply Overflow bonuses when active
  - Handle Paradox result (fizzle on triggered)

- [ ] **CombatService extension**
  - Call `ProcessOverflowDischarge` at end of Overflow character's turn
  - Track Overflow duration

- [ ] **Character entity extension**
  - Add `OverflowState` property
  - Add `SoulFractures` collection
  - Add computed properties for penalties

### Terminal UI (RuneAndRust.Terminal)

- [ ] **`ParadoxDisplay.cs`** (Rendering)
  - Paradox warning indicator when combined > 80
  - Overflow state display with countdown
  - Soul Fracture indicator

- [ ] **Combat log integration**
  - Paradox triggered messages
  - Overflow entry/discharge messages
  - Soul Fracture warnings

### Tests (RuneAndRust.Tests)

- [ ] **`ParadoxServiceTests.cs`**
  - 30 unit tests across 5 categories
  - 80%+ code coverage

---

## Implementation Workflow

### Phase 1: Core Models (Day 1)

```
1. Create ParadoxSeverity enum with extension methods
   ├─ Define 5 severity values
   ├─ Add GetDamageDice() extension
   ├─ Add GetAetherSicknessDuration() extension
   ├─ Add GetCorruptionGain() extension
   └─ Add CausesSoulFracture() extension

2. Create SoulFracture model
   ├─ Define properties
   └─ Add factory methods

3. Create OverflowState model
   ├─ Define properties
   ├─ Add GetRemainingTurns() method
   └─ Add Default static property

4. Create result records
   ├─ ParadoxResult with factory methods
   ├─ DischargeResult with factory methods
   └─ SoulFractureResult
```

### Phase 2: Events (Day 1)

```
1. Create all event records
   ├─ ParadoxTriggeredEvent
   ├─ OverflowEnteredEvent
   ├─ OverflowDischargeEvent
   ├─ SoulFractureGainedEvent
   └─ SoulDeathEvent
```

### Phase 3: Service Interface (Day 2)

```
1. Create IParadoxService interface
   ├─ CheckParadox method signature
   ├─ CalculateParadoxSeverity method signature
   ├─ ApplyParadoxEffects method signature
   ├─ EnterOverflow method signature
   ├─ ProcessOverflowDischarge method signature
   ├─ ApplySoulFracture method signature
   ├─ GetSoulFractureCount method signature
   └─ GetMaxResonanceCapacity method signature
```

### Phase 4: Service Implementation (Day 2-3)

```
1. Implement ParadoxService
   ├─ Constructor with all dependencies
   ├─ CheckParadox with full logic
   ├─ CalculateParadoxSeverity with mastery mitigation
   ├─ ApplyParadoxEffects with all consequences
   ├─ EnterOverflow with state management
   ├─ ProcessOverflowDischarge with damage/fracture
   ├─ ApplySoulFracture with penalty calculation
   └─ Getter methods

2. Write unit tests (30 tests)
   └─ Cover all decision paths
```

### Phase 5: Integration (Day 3-4)

```
1. Extend Character entity
   ├─ Add OverflowState property
   ├─ Add SoulFractures collection
   └─ Add computed penalty properties

2. Extend MagicService
   ├─ Inject IParadoxService
   ├─ Call CheckParadox for Mystics
   ├─ Apply Overflow bonuses
   └─ Handle Paradox results

3. Extend CombatService
   ├─ Track Overflow characters
   └─ Call ProcessOverflowDischarge at turn end

4. Integration tests
   └─ Full Paradox cycle with casting
```

### Phase 6: Terminal UI & Polish (Day 4-5)

```
1. Create ParadoxDisplay
   ├─ Warning indicators
   ├─ Overflow state display
   └─ Soul Fracture indicator

2. Combat log integration
   ├─ Subscribe to Paradox events
   └─ Format appropriate messages

3. Edge case testing
4. Performance validation
5. Changelog generation
```

---

## Code Examples

### ParadoxSeverity Enum

```csharp
namespace RuneAndRust.Core.Enums;

/// <summary>
/// Severity levels for Paradox events specific to Mystic characters.
/// Higher severity results in greater consequences.
/// </summary>
public enum ParadoxSeverity
{
    /// <summary>No Paradox occurred or was successfully avoided.</summary>
    None = 0,

    /// <summary>Minor Paradox: 1d6 damage, resonance drop.</summary>
    Minor = 1,

    /// <summary>Major Paradox: 2d8 damage, Aether Sickness (2 turns).</summary>
    Major = 2,

    /// <summary>Severe Paradox: 3d10 damage, Aether Sickness (4 turns), corruption.</summary>
    Severe = 3,

    /// <summary>Catastrophic Paradox: 4d12 damage, Aether Sickness (6 turns), corruption, Soul Fracture.</summary>
    Catastrophic = 4
}

public static class ParadoxSeverityExtensions
{
    /// <summary>
    /// Gets the damage dice expression for this severity.
    /// </summary>
    public static string GetDamageDice(this ParadoxSeverity severity) => severity switch
    {
        ParadoxSeverity.None => "0",
        ParadoxSeverity.Minor => "1d6",
        ParadoxSeverity.Major => "2d8",
        ParadoxSeverity.Severe => "3d10",
        ParadoxSeverity.Catastrophic => "4d12",
        _ => throw new ArgumentOutOfRangeException(nameof(severity))
    };

    /// <summary>
    /// Gets the dice count and die type for damage calculation.
    /// </summary>
    public static (int Count, int Sides) GetDamageRoll(this ParadoxSeverity severity) => severity switch
    {
        ParadoxSeverity.None => (0, 0),
        ParadoxSeverity.Minor => (1, 6),
        ParadoxSeverity.Major => (2, 8),
        ParadoxSeverity.Severe => (3, 10),
        ParadoxSeverity.Catastrophic => (4, 12),
        _ => throw new ArgumentOutOfRangeException(nameof(severity))
    };

    /// <summary>
    /// Gets the duration of Aether Sickness applied at this severity.
    /// Returns 0 if no sickness is applied.
    /// </summary>
    public static int GetAetherSicknessDuration(this ParadoxSeverity severity) => severity switch
    {
        ParadoxSeverity.None => 0,
        ParadoxSeverity.Minor => 0,
        ParadoxSeverity.Major => 2,
        ParadoxSeverity.Severe => 4,
        ParadoxSeverity.Catastrophic => 6,
        _ => throw new ArgumentOutOfRangeException(nameof(severity))
    };

    /// <summary>
    /// Gets the corruption gained at this severity.
    /// </summary>
    public static int GetCorruptionGain(this ParadoxSeverity severity) => severity switch
    {
        ParadoxSeverity.None => 0,
        ParadoxSeverity.Minor => 0,
        ParadoxSeverity.Major => 0,
        ParadoxSeverity.Severe => 5,
        ParadoxSeverity.Catastrophic => 10,
        _ => throw new ArgumentOutOfRangeException(nameof(severity))
    };

    /// <summary>
    /// Returns true if this severity causes Soul Fracture.
    /// </summary>
    public static bool CausesSoulFracture(this ParadoxSeverity severity) =>
        severity == ParadoxSeverity.Catastrophic;

    /// <summary>
    /// Returns true if this severity triggers a Reality Tear event.
    /// </summary>
    public static bool TriggersRealityTear(this ParadoxSeverity severity) =>
        severity == ParadoxSeverity.Catastrophic;

    /// <summary>
    /// Gets the resonance change (reduction) at this severity.
    /// </summary>
    public static int GetResonanceChange(this ParadoxSeverity severity) => severity switch
    {
        ParadoxSeverity.None => 0,
        ParadoxSeverity.Minor => -10,
        ParadoxSeverity.Major => -25,
        ParadoxSeverity.Severe => -100, // Reset to 0
        ParadoxSeverity.Catastrophic => -100, // Reset to 0
        _ => throw new ArgumentOutOfRangeException(nameof(severity))
    };
}
```

### SoulFracture Model

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Represents a permanent fracture in a Mystic's soul caused by Paradox.
/// Each fracture permanently reduces maximum Resonance capacity.
/// </summary>
public record SoulFracture
{
    /// <summary>Number of fracture points (usually 1).</summary>
    public int Count { get; init; } = 1;

    /// <summary>When this fracture was incurred.</summary>
    public DateTime Timestamp { get; init; } = DateTime.UtcNow;

    /// <summary>What caused this fracture.</summary>
    public required string Source { get; init; }

    /// <summary>
    /// Creates a Soul Fracture from an Overflow discharge.
    /// </summary>
    public static SoulFracture FromOverflow() => new()
    {
        Count = 1,
        Source = "Aetheric Overflow Discharge"
    };

    /// <summary>
    /// Creates a Soul Fracture from a Catastrophic Paradox.
    /// </summary>
    public static SoulFracture FromCatastrophicParadox() => new()
    {
        Count = 1,
        Source = "Catastrophic Paradox"
    };
}

/// <summary>
/// Computed penalties from accumulated Soul Fractures.
/// </summary>
public record SoulFracturePenalties
{
    /// <summary>Total number of fractures.</summary>
    public int TotalFractures { get; init; }

    /// <summary>Maximum Resonance capacity (100 - TotalFractures).</summary>
    public int MaxResonanceCapacity => Math.Max(0, 100 - TotalFractures);

    /// <summary>WILL attribute penalty from fractures.</summary>
    public int WillPenalty => TotalFractures switch
    {
        < 3 => 0,
        < 6 => -1,
        _ => -2
    };

    /// <summary>WITS attribute penalty from fractures.</summary>
    public int WitsPenalty => TotalFractures >= 5 ? -1 : 0;

    /// <summary>Whether the soul has completely shattered.</summary>
    public bool IsSoulDeath => TotalFractures >= 10;

    /// <summary>Whether the character has the "Fractured Soul" trait.</summary>
    public bool HasFracturedSoulTrait => TotalFractures >= 6;

    /// <summary>
    /// Creates penalties from a list of fractures.
    /// </summary>
    public static SoulFracturePenalties FromFractures(IEnumerable<SoulFracture> fractures) => new()
    {
        TotalFractures = fractures.Sum(f => f.Count)
    };
}
```

### OverflowState Model

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Tracks the temporary Aetheric Overflow state when Resonance reaches 100.
/// Grants powerful bonuses for one turn before forced discharge.
/// </summary>
public record OverflowState
{
    /// <summary>Whether Overflow is currently active.</summary>
    public bool IsActive { get; init; }

    /// <summary>The combat turn when Overflow was entered.</summary>
    public int TurnEntered { get; init; }

    /// <summary>Spell potency multiplier during Overflow (1.50 = +50%).</summary>
    public decimal PotencyModifier { get; init; } = 1.50m;

    /// <summary>AP cost multiplier during Overflow (0.50 = -50%).</summary>
    public decimal APCostModifier { get; init; } = 0.50m;

    /// <summary>Whether discharge has already occurred this turn.</summary>
    public bool HasDischarged { get; init; }

    /// <summary>
    /// Gets remaining turns before discharge (always 0 or 1).
    /// </summary>
    public int GetRemainingTurns(int currentTurn) =>
        IsActive && !HasDischarged && currentTurn == TurnEntered ? 1 : 0;

    /// <summary>
    /// Returns true if discharge should occur (end of entry turn).
    /// </summary>
    public bool ShouldDischarge(int currentTurn) =>
        IsActive && !HasDischarged && currentTurn > TurnEntered;

    /// <summary>
    /// Default Overflow state for new entry.
    /// </summary>
    public static OverflowState Create(int currentTurn) => new()
    {
        IsActive = true,
        TurnEntered = currentTurn,
        PotencyModifier = 1.50m,
        APCostModifier = 0.50m,
        HasDischarged = false
    };

    /// <summary>
    /// Inactive state (no Overflow).
    /// </summary>
    public static OverflowState Inactive => new()
    {
        IsActive = false,
        TurnEntered = 0,
        PotencyModifier = 1.00m,
        APCostModifier = 1.00m,
        HasDischarged = false
    };
}
```

### ParadoxResult Record

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>
/// Result of a Paradox check performed during Mystic spell casting.
/// </summary>
public record ParadoxResult
{
    /// <summary>Whether Paradox was triggered.</summary>
    public required bool Triggered { get; init; }

    /// <summary>The severity of the Paradox (if triggered).</summary>
    public ParadoxSeverity Severity { get; init; } = ParadoxSeverity.None;

    /// <summary>The combined Flux + Resonance value checked.</summary>
    public int CombinedValue { get; init; }

    /// <summary>The risk percentage that was rolled against.</summary>
    public int RiskChance { get; init; }

    /// <summary>The d100 roll result.</summary>
    public int Roll { get; init; }

    /// <summary>Damage dealt by the Paradox.</summary>
    public int DamageDealt { get; init; }

    /// <summary>Status effect applied (if any).</summary>
    public StatusEffectType? StatusApplied { get; init; }

    /// <summary>Duration of applied status effect.</summary>
    public int StatusDuration { get; init; }

    /// <summary>Corruption gained from the Paradox.</summary>
    public int CorruptionGained { get; init; }

    /// <summary>Whether a Soul Fracture was gained.</summary>
    public bool SoulFractureGained { get; init; }

    /// <summary>Resonance change (usually negative).</summary>
    public int ResonanceChange { get; init; }

    /// <summary>Whether a Reality Tear event was triggered.</summary>
    public bool RealityTearTriggered { get; init; }

    /// <summary>Whether Overflow state was entered.</summary>
    public bool OverflowEntered { get; init; }

    /// <summary>Reason for result (for logging/display).</summary>
    public required string Reason { get; init; }

    // Factory methods

    /// <summary>Paradox check not applicable (non-Mystic).</summary>
    public static ParadoxResult NotApplicable() => new()
    {
        Triggered = false,
        Reason = "Not a Mystic character"
    };

    /// <summary>Combined value below threshold, no risk.</summary>
    public static ParadoxResult Safe(int combined) => new()
    {
        Triggered = false,
        CombinedValue = combined,
        Reason = $"Combined value {combined} below Paradox threshold (100)"
    };

    /// <summary>Risk check succeeded, Paradox avoided.</summary>
    public static ParadoxResult Avoided(int combined, int riskChance, int roll) => new()
    {
        Triggered = false,
        CombinedValue = combined,
        RiskChance = riskChance,
        Roll = roll,
        Reason = $"Paradox avoided: rolled {roll} vs {riskChance}% risk"
    };

    /// <summary>Overflow state entered.</summary>
    public static ParadoxResult OverflowEnteredResult(int resonance) => new()
    {
        Triggered = false,
        OverflowEntered = true,
        CombinedValue = resonance,
        Reason = "Resonance at 100: Aetheric Overflow entered"
    };

    /// <summary>Full Paradox triggered with all effects.</summary>
    public static ParadoxResult TriggeredResult(
        ParadoxSeverity severity,
        int combined,
        int riskChance,
        int roll,
        int damage,
        StatusEffectType? status,
        int statusDuration,
        int corruption,
        bool soulFracture,
        int resonanceChange,
        bool realityTear) => new()
    {
        Triggered = true,
        Severity = severity,
        CombinedValue = combined,
        RiskChance = riskChance,
        Roll = roll,
        DamageDealt = damage,
        StatusApplied = status,
        StatusDuration = statusDuration,
        CorruptionGained = corruption,
        SoulFractureGained = soulFracture,
        ResonanceChange = resonanceChange,
        RealityTearTriggered = realityTear,
        Reason = $"{severity} Paradox triggered: rolled {roll} vs {riskChance}% risk"
    };
}
```

### IParadoxService Interface

```csharp
namespace RuneAndRust.Core.Interfaces;

/// <summary>
/// Service for managing Mystic-specific Paradox mechanics.
/// Paradox occurs when combined Flux + Resonance exceeds safe thresholds.
/// </summary>
public interface IParadoxService
{
    /// <summary>
    /// Performs a Paradox check before spell casting.
    /// Only applicable to Mystic characters.
    /// </summary>
    /// <param name="character">The casting character.</param>
    /// <param name="spell">The spell being cast.</param>
    /// <param name="currentFlux">Current environmental Flux.</param>
    /// <returns>Result of the Paradox check.</returns>
    ParadoxResult CheckParadox(Character character, Spell spell, int currentFlux);

    /// <summary>
    /// Calculates Paradox severity from combined Flux + Resonance.
    /// Applies mastery-based mitigation.
    /// </summary>
    /// <param name="combined">Combined Flux + Resonance value.</param>
    /// <param name="character">The character (for mastery lookup).</param>
    /// <param name="school">The spell school (for mastery mitigation).</param>
    /// <returns>Final severity after mitigation.</returns>
    ParadoxSeverity CalculateParadoxSeverity(int combined, Character character, SpellSchool school);

    /// <summary>
    /// Applies all effects of a triggered Paradox.
    /// </summary>
    /// <param name="character">The affected character.</param>
    /// <param name="severity">The Paradox severity.</param>
    /// <param name="school">The spell school (for effect flavor).</param>
    /// <returns>Result with all applied effects.</returns>
    ParadoxResult ApplyParadoxEffects(Character character, ParadoxSeverity severity, SpellSchool school);

    /// <summary>
    /// Enters the Aetheric Overflow state when Resonance reaches 100.
    /// </summary>
    /// <param name="character">The character entering Overflow.</param>
    /// <param name="currentTurn">The current combat turn.</param>
    /// <returns>Result of Overflow entry.</returns>
    OverflowResult EnterOverflow(Character character, int currentTurn);

    /// <summary>
    /// Processes the forced discharge at the end of Overflow.
    /// </summary>
    /// <param name="character">The character in Overflow.</param>
    /// <returns>Result of the discharge.</returns>
    DischargeResult ProcessOverflowDischarge(Character character);

    /// <summary>
    /// Applies a Soul Fracture to a character.
    /// </summary>
    /// <param name="character">The affected character.</param>
    /// <param name="source">What caused the fracture.</param>
    /// <returns>Result with new fracture totals and penalties.</returns>
    SoulFractureResult ApplySoulFracture(Character character, string source);

    /// <summary>
    /// Gets the total Soul Fracture count for a character.
    /// </summary>
    int GetSoulFractureCount(Character character);

    /// <summary>
    /// Gets the maximum Resonance capacity (reduced by Soul Fractures).
    /// </summary>
    int GetMaxResonanceCapacity(Character character);

    /// <summary>
    /// Gets the current Soul Fracture penalties.
    /// </summary>
    SoulFracturePenalties GetSoulFracturePenalties(Character character);
}
```

### ParadoxService Implementation

```csharp
namespace RuneAndRust.Engine.Services;

/// <summary>
/// Manages Mystic-specific Paradox mechanics, Overflow state, and Soul Fractures.
/// </summary>
public class ParadoxService : IParadoxService
{
    private readonly ILogger<ParadoxService> _logger;
    private readonly IEventBus _eventBus;
    private readonly IDiceService _diceService;
    private readonly IResonanceService _resonanceService;
    private readonly IMasteryService _masteryService;
    private readonly IStatusEffectService _statusEffectService;

    // Risk chance thresholds
    private static readonly (int MinCombined, int RiskChance)[] RiskThresholds =
    {
        (180, 90),
        (160, 70),
        (140, 50),
        (120, 35),
        (100, 20)
    };

    public ParadoxService(
        ILogger<ParadoxService> logger,
        IEventBus eventBus,
        IDiceService diceService,
        IResonanceService resonanceService,
        IMasteryService masteryService,
        IStatusEffectService statusEffectService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _eventBus = eventBus ?? throw new ArgumentNullException(nameof(eventBus));
        _diceService = diceService ?? throw new ArgumentNullException(nameof(diceService));
        _resonanceService = resonanceService ?? throw new ArgumentNullException(nameof(resonanceService));
        _masteryService = masteryService ?? throw new ArgumentNullException(nameof(masteryService));
        _statusEffectService = statusEffectService ?? throw new ArgumentNullException(nameof(statusEffectService));

        _logger.LogInformation("ParadoxService initialized");
    }

    /// <inheritdoc />
    public ParadoxResult CheckParadox(Character character, Spell spell, int currentFlux)
    {
        _logger.LogDebug(
            "CheckParadox called: Character={CharacterId}, Spell={SpellName}, Flux={Flux}",
            character.Id, spell.Name, currentFlux);

        // Only Mystics experience Paradox
        if (!character.IsMystic)
        {
            _logger.LogDebug("Character is not a Mystic, Paradox check skipped");
            return ParadoxResult.NotApplicable();
        }

        var resonance = _resonanceService.GetResonance(character);
        var combined = currentFlux + resonance;

        _logger.LogDebug(
            "Paradox values: Flux={Flux}, Resonance={Resonance}, Combined={Combined}",
            currentFlux, resonance, combined);

        // Check for Overflow entry (Resonance == 100)
        if (resonance >= 100 && character.OverflowState?.IsActive != true)
        {
            _logger.LogInformation(
                "Resonance at maximum ({Resonance}), entering Overflow state",
                resonance);
            return ParadoxResult.OverflowEnteredResult(resonance);
        }

        // Check if below Paradox threshold
        if (combined <= 100)
        {
            _logger.LogDebug("Combined {Combined} <= 100, no Paradox risk", combined);
            return ParadoxResult.Safe(combined);
        }

        // Calculate risk chance
        var riskChance = GetRiskChance(combined);

        // Roll for Paradox
        var roll = _diceService.RollD100();
        _logger.LogDebug(
            "Paradox roll: {Roll} vs {RiskChance}% risk",
            roll, riskChance);

        if (roll > riskChance)
        {
            _logger.LogInformation(
                "Paradox AVOIDED: Character={CharacterId}, Roll={Roll} > Risk={Risk}%",
                character.Id, roll, riskChance);
            return ParadoxResult.Avoided(combined, riskChance, roll);
        }

        // Paradox triggered
        _logger.LogWarning(
            "PARADOX TRIGGERED: Character={CharacterId}, Roll={Roll} <= Risk={Risk}%",
            character.Id, roll, riskChance);

        var severity = CalculateParadoxSeverity(combined, character, spell.School);
        return ApplyParadoxEffects(character, severity, spell.School);
    }

    /// <inheritdoc />
    public ParadoxSeverity CalculateParadoxSeverity(int combined, Character character, SpellSchool school)
    {
        _logger.LogDebug(
            "CalculateParadoxSeverity: Combined={Combined}, School={School}",
            combined, school);

        // Determine base severity
        var baseSeverity = GetBaseSeverity(combined);
        _logger.LogDebug("Base severity: {BaseSeverity}", baseSeverity);

        // Get mastery tier for mitigation
        var masteryTier = _masteryService.GetMasteryTier(character, school);
        var reduction = GetSeverityReduction(masteryTier);
        var avoidChance = GetAvoidChance(masteryTier);

        _logger.LogDebug(
            "Mastery mitigation: Tier={Tier}, Reduction={Reduction}, AvoidChance={Avoid}%",
            masteryTier, reduction, avoidChance);

        // Check for avoidance (Adept+)
        if (avoidChance > 0)
        {
            var avoidRoll = _diceService.RollD100();
            if (avoidRoll <= avoidChance)
            {
                _logger.LogInformation(
                    "Paradox AVOIDED by mastery: Roll={Roll} <= {Chance}%",
                    avoidRoll, avoidChance);
                return ParadoxSeverity.None;
            }
        }

        // Apply reduction
        var finalSeverity = (ParadoxSeverity)Math.Max(
            (int)ParadoxSeverity.Minor,
            (int)baseSeverity - reduction);

        _logger.LogDebug(
            "Final severity: {Final} (base {Base} - {Reduction} reduction)",
            finalSeverity, baseSeverity, reduction);

        return finalSeverity;
    }

    /// <inheritdoc />
    public ParadoxResult ApplyParadoxEffects(Character character, ParadoxSeverity severity, SpellSchool school)
    {
        if (severity == ParadoxSeverity.None)
        {
            return ParadoxResult.Safe(0);
        }

        _logger.LogInformation(
            "Applying {Severity} Paradox effects to Character={CharacterId}",
            severity, character.Id);

        // Calculate damage
        var (diceCount, diceSides) = severity.GetDamageRoll();
        var damage = _diceService.Roll(diceCount, diceSides);
        character.TakeDamage(damage, $"{severity} Paradox");

        _logger.LogInformation(
            "Paradox damage: {Dice}d{Sides} = {Damage}",
            diceCount, diceSides, damage);

        // Apply Aether Sickness
        StatusEffectType? statusApplied = null;
        var statusDuration = severity.GetAetherSicknessDuration();
        if (statusDuration > 0)
        {
            statusApplied = StatusEffectType.AetherSickness;
            _statusEffectService.Apply(character, StatusEffectType.AetherSickness, statusDuration);
            _logger.LogInformation(
                "Applied Aether Sickness for {Duration} turns",
                statusDuration);
        }

        // Apply Corruption
        var corruptionGain = severity.GetCorruptionGain();
        if (corruptionGain > 0)
        {
            character.CurrentCorruption = Math.Min(100, character.CurrentCorruption + corruptionGain);
            _logger.LogInformation(
                "Added {Corruption} Corruption, new total: {Total}",
                corruptionGain, character.CurrentCorruption);
        }

        // Apply Soul Fracture
        var soulFractureGained = false;
        if (severity.CausesSoulFracture())
        {
            ApplySoulFracture(character, $"{severity} Paradox");
            soulFractureGained = true;
        }

        // Reduce/Reset Resonance
        var resonanceChange = severity.GetResonanceChange();
        _resonanceService.ModifyResonance(character, resonanceChange, $"{severity} Paradox");

        // Reality Tear event
        var realityTear = severity.TriggersRealityTear();
        if (realityTear)
        {
            _eventBus.Publish(new RealityTearEvent
            {
                CharacterId = character.Id,
                Severity = severity,
                Timestamp = DateTime.UtcNow
            });
            _logger.LogWarning("REALITY TEAR triggered by {Severity} Paradox!", severity);
        }

        // Publish main event
        var paradoxEvent = new ParadoxTriggeredEvent
        {
            CharacterId = character.Id,
            Severity = severity,
            DamageDealt = damage,
            Combined = 0, // Set by caller
            Roll = 0, // Set by caller
            RiskChance = 0, // Set by caller
            Timestamp = DateTime.UtcNow
        };
        _eventBus.Publish(paradoxEvent);

        return ParadoxResult.TriggeredResult(
            severity,
            combined: 0, // Caller provides
            riskChance: 0,
            roll: 0,
            damage: damage,
            status: statusApplied,
            statusDuration: statusDuration,
            corruption: corruptionGain,
            soulFracture: soulFractureGained,
            resonanceChange: resonanceChange,
            realityTear: realityTear);
    }

    /// <inheritdoc />
    public OverflowResult EnterOverflow(Character character, int currentTurn)
    {
        _logger.LogDebug(
            "EnterOverflow called: Character={CharacterId}, Turn={Turn}",
            character.Id, currentTurn);

        if (character.OverflowState?.IsActive == true)
        {
            _logger.LogWarning("Character already in Overflow state");
            return OverflowResult.AlreadyActive();
        }

        var resonance = _resonanceService.GetResonance(character);
        if (resonance < 100)
        {
            _logger.LogWarning(
                "Cannot enter Overflow: Resonance {Resonance} < 100",
                resonance);
            return OverflowResult.NotAtCapacity(resonance);
        }

        // Create and apply Overflow state
        var overflowState = OverflowState.Create(currentTurn);
        character.OverflowState = overflowState;

        _logger.LogWarning(
            "OVERFLOW ENTERED: Character={CharacterId}, Turn={Turn}, " +
            "PotencyMod={Potency}, APCostMod={APCost}",
            character.Id, currentTurn,
            overflowState.PotencyModifier, overflowState.APCostModifier);

        _eventBus.Publish(new OverflowEnteredEvent
        {
            CharacterId = character.Id,
            Turn = currentTurn,
            PotencyBonus = overflowState.PotencyModifier,
            APCostReduction = overflowState.APCostModifier,
            Timestamp = DateTime.UtcNow
        });

        return OverflowResult.Entered(overflowState);
    }

    /// <inheritdoc />
    public DischargeResult ProcessOverflowDischarge(Character character)
    {
        _logger.LogDebug(
            "ProcessOverflowDischarge called: Character={CharacterId}",
            character.Id);

        if (character.OverflowState?.IsActive != true)
        {
            _logger.LogDebug("Character not in Overflow state");
            return DischargeResult.NotInOverflow();
        }

        if (character.OverflowState.HasDischarged)
        {
            _logger.LogDebug("Discharge already processed this turn");
            return DischargeResult.AlreadyDischarged();
        }

        _logger.LogWarning(
            "OVERFLOW DISCHARGE: Character={CharacterId}",
            character.Id);

        // Calculate catastrophic damage (4d12)
        var damage = _diceService.Roll(4, 12);
        character.TakeDamage(damage, "Aetheric Overflow Discharge");

        _logger.LogInformation(
            "Overflow discharge damage: 4d12 = {Damage}",
            damage);

        // Apply Soul Fracture
        var fractureResult = ApplySoulFracture(character, "Overflow Discharge");

        // Apply Aether Sickness (6 turns)
        _statusEffectService.Apply(character, StatusEffectType.AetherSickness, 6);

        // Reset Resonance
        _resonanceService.Reset(character);

        // Clear Overflow state
        character.OverflowState = null;

        // Publish event
        _eventBus.Publish(new OverflowDischargeEvent
        {
            CharacterId = character.Id,
            DamageDealt = damage,
            FractureGained = true,
            NewMaxResonance = fractureResult.NewMaxResonance,
            Timestamp = DateTime.UtcNow
        });

        return DischargeResult.Completed(
            damage,
            fractureResult.NewFractureCount,
            fractureResult.NewMaxResonance,
            fractureResult.IsSoulDeath);
    }

    /// <inheritdoc />
    public SoulFractureResult ApplySoulFracture(Character character, string source)
    {
        _logger.LogWarning(
            "SOUL FRACTURE: Character={CharacterId}, Source={Source}",
            character.Id, source);

        var fracture = new SoulFracture
        {
            Count = 1,
            Timestamp = DateTime.UtcNow,
            Source = source
        };

        character.SoulFractures.Add(fracture);

        var penalties = SoulFracturePenalties.FromFractures(character.SoulFractures);

        _logger.LogInformation(
            "Soul Fracture applied: Total={Total}, MaxResonance={MaxRes}, " +
            "WillPen={Will}, WitsPen={Wits}, IsSoulDeath={Death}",
            penalties.TotalFractures, penalties.MaxResonanceCapacity,
            penalties.WillPenalty, penalties.WitsPenalty, penalties.IsSoulDeath);

        if (penalties.IsSoulDeath)
        {
            _logger.LogError(
                "SOUL DEATH: Character={CharacterId} soul has shattered completely!",
                character.Id);

            character.IsSoulDead = true;

            _eventBus.Publish(new SoulDeathEvent
            {
                CharacterId = character.Id,
                FinalFractureCount = penalties.TotalFractures,
                Source = source,
                Timestamp = DateTime.UtcNow
            });
        }

        _eventBus.Publish(new SoulFractureGainedEvent
        {
            CharacterId = character.Id,
            Source = source,
            NewTotal = penalties.TotalFractures,
            NewMaxResonance = penalties.MaxResonanceCapacity,
            WillPenalty = penalties.WillPenalty,
            WitsPenalty = penalties.WitsPenalty,
            Timestamp = DateTime.UtcNow
        });

        return new SoulFractureResult
        {
            NewFractureCount = penalties.TotalFractures,
            NewMaxResonance = penalties.MaxResonanceCapacity,
            WillPenalty = penalties.WillPenalty,
            WitsPenalty = penalties.WitsPenalty,
            IsSoulDeath = penalties.IsSoulDeath
        };
    }

    /// <inheritdoc />
    public int GetSoulFractureCount(Character character) =>
        character.SoulFractures.Sum(f => f.Count);

    /// <inheritdoc />
    public int GetMaxResonanceCapacity(Character character) =>
        100 - GetSoulFractureCount(character);

    /// <inheritdoc />
    public SoulFracturePenalties GetSoulFracturePenalties(Character character) =>
        SoulFracturePenalties.FromFractures(character.SoulFractures);

    // Private helper methods

    private static int GetRiskChance(int combined)
    {
        foreach (var (minCombined, riskChance) in RiskThresholds)
        {
            if (combined >= minCombined)
                return riskChance;
        }
        return 0;
    }

    private ParadoxSeverity GetBaseSeverity(int combined)
    {
        if (combined >= 180) return ParadoxSeverity.Catastrophic;
        if (combined >= 160)
        {
            // Random between Severe and Catastrophic
            return _diceService.RollD100() <= 50
                ? ParadoxSeverity.Severe
                : ParadoxSeverity.Catastrophic;
        }
        if (combined >= 140)
        {
            return _diceService.RollD100() <= 50
                ? ParadoxSeverity.Major
                : ParadoxSeverity.Severe;
        }
        if (combined >= 120)
        {
            return _diceService.RollD100() <= 50
                ? ParadoxSeverity.Minor
                : ParadoxSeverity.Major;
        }
        return ParadoxSeverity.Minor;
    }

    private static int GetSeverityReduction(MasteryTier tier) => tier switch
    {
        MasteryTier.Novice => 0,
        MasteryTier.Apprentice => 1,
        MasteryTier.Adept => 1,
        MasteryTier.Master => 2,
        MasteryTier.Archon => 2,
        _ => 0
    };

    private static int GetAvoidChance(MasteryTier tier) => tier switch
    {
        MasteryTier.Adept => 10,
        MasteryTier.Archon => 25,
        _ => 0
    };
}
```

### Event Records

```csharp
namespace RuneAndRust.Core.Events;

/// <summary>Published when a Mystic triggers a Paradox.</summary>
public record ParadoxTriggeredEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required ParadoxSeverity Severity { get; init; }
    public required int DamageDealt { get; init; }
    public int Combined { get; init; }
    public int Roll { get; init; }
    public int RiskChance { get; init; }
    public required DateTime Timestamp { get; init; }
}

/// <summary>Published when a Mystic enters Aetheric Overflow.</summary>
public record OverflowEnteredEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required int Turn { get; init; }
    public required decimal PotencyBonus { get; init; }
    public required decimal APCostReduction { get; init; }
    public required DateTime Timestamp { get; init; }
}

/// <summary>Published when Overflow forcibly discharges.</summary>
public record OverflowDischargeEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required int DamageDealt { get; init; }
    public required bool FractureGained { get; init; }
    public required int NewMaxResonance { get; init; }
    public required DateTime Timestamp { get; init; }
}

/// <summary>Published when a Soul Fracture is gained.</summary>
public record SoulFractureGainedEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required string Source { get; init; }
    public required int NewTotal { get; init; }
    public required int NewMaxResonance { get; init; }
    public required int WillPenalty { get; init; }
    public required int WitsPenalty { get; init; }
    public required DateTime Timestamp { get; init; }
}

/// <summary>Published when a character's soul shatters completely.</summary>
public record SoulDeathEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required int FinalFractureCount { get; init; }
    public required string Source { get; init; }
    public required DateTime Timestamp { get; init; }
}

/// <summary>Published when a Reality Tear occurs.</summary>
public record RealityTearEvent : IEvent
{
    public required Guid CharacterId { get; init; }
    public required ParadoxSeverity Severity { get; init; }
    public required DateTime Timestamp { get; init; }
}
```

### Result Records

```csharp
namespace RuneAndRust.Core.Models.Magic;

/// <summary>Result of attempting to enter Overflow state.</summary>
public record OverflowResult
{
    public required bool Success { get; init; }
    public OverflowState? State { get; init; }
    public required string Reason { get; init; }

    public static OverflowResult Entered(OverflowState state) => new()
    {
        Success = true,
        State = state,
        Reason = "Aetheric Overflow entered"
    };

    public static OverflowResult AlreadyActive() => new()
    {
        Success = false,
        Reason = "Already in Overflow state"
    };

    public static OverflowResult NotAtCapacity(int currentResonance) => new()
    {
        Success = false,
        Reason = $"Resonance ({currentResonance}) not at maximum capacity"
    };
}

/// <summary>Result of Overflow discharge.</summary>
public record DischargeResult
{
    public required bool Success { get; init; }
    public int DamageDealt { get; init; }
    public int NewFractureCount { get; init; }
    public int NewMaxResonance { get; init; }
    public bool IsSoulDeath { get; init; }
    public required string Reason { get; init; }

    public static DischargeResult Completed(int damage, int fractures, int maxRes, bool soulDeath) => new()
    {
        Success = true,
        DamageDealt = damage,
        NewFractureCount = fractures,
        NewMaxResonance = maxRes,
        IsSoulDeath = soulDeath,
        Reason = "Overflow discharge completed"
    };

    public static DischargeResult NotInOverflow() => new()
    {
        Success = false,
        Reason = "Not in Overflow state"
    };

    public static DischargeResult AlreadyDischarged() => new()
    {
        Success = false,
        Reason = "Discharge already processed this turn"
    };
}

/// <summary>Result of applying a Soul Fracture.</summary>
public record SoulFractureResult
{
    public required int NewFractureCount { get; init; }
    public required int NewMaxResonance { get; init; }
    public required int WillPenalty { get; init; }
    public required int WitsPenalty { get; init; }
    public required bool IsSoulDeath { get; init; }
}
```

---

## Logging Specification

### Log Levels

| Level | Usage |
|-------|-------|
| **Debug** | Method entry, parameter values, calculations |
| **Information** | Paradox outcomes, damage dealt, status applied |
| **Warning** | Paradox triggered, Overflow entered/discharged, Soul Fracture |
| **Error** | Soul Death, Reality Tear |

### Structured Logging Fields

| Field | Type | Description |
|-------|------|-------------|
| `CharacterId` | Guid | Character identifier |
| `Severity` | ParadoxSeverity | Paradox severity level |
| `Combined` | int | Flux + Resonance total |
| `Flux` | int | Environmental Flux |
| `Resonance` | int | Personal Resonance |
| `RiskChance` | int | Paradox risk percentage |
| `Roll` | int | d100 roll result |
| `Damage` | int | Damage dealt |
| `StatusDuration` | int | Aether Sickness duration |
| `CorruptionGained` | int | Corruption added |
| `FractureCount` | int | Total Soul Fractures |
| `MaxResonance` | int | New maximum Resonance |
| `WillPenalty` | int | WILL attribute penalty |
| `WitsPenalty` | int | WITS attribute penalty |
| `Turn` | int | Combat turn number |

### Log Message Templates

```csharp
// Paradox check entry
_logger.LogDebug(
    "CheckParadox called: Character={CharacterId}, Spell={SpellName}, Flux={Flux}",
    character.Id, spell.Name, currentFlux);

// Paradox values
_logger.LogDebug(
    "Paradox values: Flux={Flux}, Resonance={Resonance}, Combined={Combined}",
    currentFlux, resonance, combined);

// Paradox avoided
_logger.LogInformation(
    "Paradox AVOIDED: Character={CharacterId}, Roll={Roll} > Risk={Risk}%",
    character.Id, roll, riskChance);

// Paradox triggered
_logger.LogWarning(
    "PARADOX TRIGGERED: Character={CharacterId}, Roll={Roll} <= Risk={Risk}%",
    character.Id, roll, riskChance);

// Severity calculation
_logger.LogDebug(
    "Mastery mitigation: Tier={Tier}, Reduction={Reduction}, AvoidChance={Avoid}%",
    masteryTier, reduction, avoidChance);

// Damage dealt
_logger.LogInformation(
    "Paradox damage: {Dice}d{Sides} = {Damage}",
    diceCount, diceSides, damage);

// Overflow entered
_logger.LogWarning(
    "OVERFLOW ENTERED: Character={CharacterId}, Turn={Turn}, " +
    "PotencyMod={Potency}, APCostMod={APCost}",
    character.Id, currentTurn, overflowState.PotencyModifier, overflowState.APCostModifier);

// Overflow discharge
_logger.LogWarning(
    "OVERFLOW DISCHARGE: Character={CharacterId}",
    character.Id);

// Soul Fracture
_logger.LogWarning(
    "SOUL FRACTURE: Character={CharacterId}, Source={Source}",
    character.Id, source);

// Soul Fracture totals
_logger.LogInformation(
    "Soul Fracture applied: Total={Total}, MaxResonance={MaxRes}, " +
    "WillPen={Will}, WitsPen={Wits}, IsSoulDeath={Death}",
    penalties.TotalFractures, penalties.MaxResonanceCapacity,
    penalties.WillPenalty, penalties.WitsPenalty, penalties.IsSoulDeath);

// Soul Death
_logger.LogError(
    "SOUL DEATH: Character={CharacterId} soul has shattered completely!",
    character.Id);

// Reality Tear
_logger.LogWarning(
    "REALITY TEAR triggered by {Severity} Paradox!",
    severity);
```

---

## Unit Testing

### Test Class Structure

```csharp
namespace RuneAndRust.Tests.Services;

public class ParadoxServiceTests
{
    private readonly Mock<ILogger<ParadoxService>> _loggerMock;
    private readonly Mock<IEventBus> _eventBusMock;
    private readonly Mock<IDiceService> _diceServiceMock;
    private readonly Mock<IResonanceService> _resonanceServiceMock;
    private readonly Mock<IMasteryService> _masteryServiceMock;
    private readonly Mock<IStatusEffectService> _statusEffectServiceMock;
    private readonly ParadoxService _sut;

    public ParadoxServiceTests()
    {
        _loggerMock = new Mock<ILogger<ParadoxService>>();
        _eventBusMock = new Mock<IEventBus>();
        _diceServiceMock = new Mock<IDiceService>();
        _resonanceServiceMock = new Mock<IResonanceService>();
        _masteryServiceMock = new Mock<IMasteryService>();
        _statusEffectServiceMock = new Mock<IStatusEffectService>();

        _sut = new ParadoxService(
            _loggerMock.Object,
            _eventBusMock.Object,
            _diceServiceMock.Object,
            _resonanceServiceMock.Object,
            _masteryServiceMock.Object,
            _statusEffectServiceMock.Object);
    }
}
```

### Test Categories (30 Tests)

#### Category 1: Risk Calculation (8 tests)

```csharp
[Fact]
public void CheckParadox_NonMystic_ReturnsNotApplicable()
{
    // Arrange
    var character = CreateNonMysticCharacter();
    var spell = CreateTestSpell();

    // Act
    var result = _sut.CheckParadox(character, spell, 50);

    // Assert
    result.Triggered.Should().BeFalse();
    result.Reason.Should().Contain("Not a Mystic");
}

[Fact]
public void CheckParadox_CombinedBelowThreshold_ReturnsSafe()
{
    // Arrange
    var character = CreateMysticCharacter();
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(30);

    // Act
    var result = _sut.CheckParadox(character, spell, currentFlux: 50);

    // Assert
    result.Triggered.Should().BeFalse();
    result.CombinedValue.Should().Be(80);
}

[Theory]
[InlineData(50, 60, 110, 20)]  // 100-119 = 20% risk
[InlineData(70, 60, 130, 35)]  // 120-139 = 35% risk
[InlineData(80, 70, 150, 50)]  // 140-159 = 50% risk
[InlineData(90, 80, 170, 70)]  // 160-179 = 70% risk
[InlineData(95, 90, 185, 90)]  // 180+ = 90% risk
public void CheckParadox_CombinedAboveThreshold_CalculatesCorrectRisk(
    int flux, int resonance, int expectedCombined, int expectedRisk)
{
    // Arrange
    var character = CreateMysticCharacter();
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(resonance);
    _diceServiceMock.Setup(d => d.RollD100()).Returns(99); // Avoid Paradox

    // Act
    var result = _sut.CheckParadox(character, spell, flux);

    // Assert
    result.CombinedValue.Should().Be(expectedCombined);
    result.RiskChance.Should().Be(expectedRisk);
}

[Fact]
public void CheckParadox_RollAboveRisk_ReturnsAvoided()
{
    // Arrange
    var character = CreateMysticCharacter();
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(60);
    _diceServiceMock.Setup(d => d.RollD100()).Returns(50); // 50 > 35% risk

    // Act
    var result = _sut.CheckParadox(character, spell, currentFlux: 70);

    // Assert
    result.Triggered.Should().BeFalse();
    result.Reason.Should().Contain("avoided");
}

[Fact]
public void CheckParadox_RollBelowRisk_ReturnsTriggered()
{
    // Arrange
    var character = CreateMysticCharacter();
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(60);
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, It.IsAny<SpellSchool>()))
        .Returns(MasteryTier.Novice);
    _diceServiceMock.SetupSequence(d => d.RollD100())
        .Returns(10); // 10 <= 35% risk - Paradox!

    // Act
    var result = _sut.CheckParadox(character, spell, currentFlux: 70);

    // Assert
    result.Triggered.Should().BeTrue();
}

[Fact]
public void CheckParadox_ResonanceAt100_EntersOverflow()
{
    // Arrange
    var character = CreateMysticCharacter();
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(100);

    // Act
    var result = _sut.CheckParadox(character, spell, currentFlux: 50);

    // Assert
    result.OverflowEntered.Should().BeTrue();
}

[Fact]
public void CheckParadox_AlreadyInOverflow_SkipsOverflowEntry()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.OverflowState = OverflowState.Create(1);
    var spell = CreateTestSpell();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(100);
    _diceServiceMock.Setup(d => d.RollD100()).Returns(99);

    // Act
    var result = _sut.CheckParadox(character, spell, currentFlux: 50);

    // Assert
    result.OverflowEntered.Should().BeFalse();
}
```

#### Category 2: Severity Determination (6 tests)

```csharp
[Theory]
[InlineData(110, ParadoxSeverity.Minor)]
[InlineData(180, ParadoxSeverity.Catastrophic)]
public void CalculateParadoxSeverity_ReturnsBaseSeverityForNovice(
    int combined, ParadoxSeverity expectedBase)
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Novice);

    // Act
    var severity = _sut.CalculateParadoxSeverity(combined, character, SpellSchool.Destruction);

    // Assert - At 180+, always Catastrophic
    if (combined >= 180)
        severity.Should().Be(ParadoxSeverity.Catastrophic);
    else if (combined < 120)
        severity.Should().Be(ParadoxSeverity.Minor);
}

[Fact]
public void CalculateParadoxSeverity_ApprenticeReducesBySeverity1()
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Apprentice);
    _diceServiceMock.Setup(d => d.RollD100()).Returns(1); // Force Major

    // Act - 130 would normally be Minor or Major
    var severity = _sut.CalculateParadoxSeverity(125, character, SpellSchool.Destruction);

    // Assert - Reduced by 1, minimum Minor
    severity.Should().BeOneOf(ParadoxSeverity.Minor, ParadoxSeverity.Minor);
}

[Fact]
public void CalculateParadoxSeverity_MasterReducesByTwoTiers()
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Master);
    _diceServiceMock.Setup(d => d.RollD100()).Returns(100); // Force higher severity

    // Act - Even at 150+, Master reduces by 2 tiers
    var severity = _sut.CalculateParadoxSeverity(155, character, SpellSchool.Destruction);

    // Assert - Should be at most Major (Severe - 2 = Minor, Major - 2 = Minor)
    severity.Should().BeOneOf(ParadoxSeverity.Minor, ParadoxSeverity.Major);
}

[Fact]
public void CalculateParadoxSeverity_AdeptCanAvoid()
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Adept);
    _diceServiceMock.SetupSequence(d => d.RollD100())
        .Returns(5); // 5 <= 10% avoid chance

    // Act
    var severity = _sut.CalculateParadoxSeverity(150, character, SpellSchool.Destruction);

    // Assert
    severity.Should().Be(ParadoxSeverity.None);
}

[Fact]
public void CalculateParadoxSeverity_ArchonHas25PercentAvoid()
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Archon);
    _diceServiceMock.SetupSequence(d => d.RollD100())
        .Returns(20); // 20 <= 25% avoid chance

    // Act
    var severity = _sut.CalculateParadoxSeverity(180, character, SpellSchool.Destruction);

    // Assert
    severity.Should().Be(ParadoxSeverity.None);
}

[Fact]
public void CalculateParadoxSeverity_MinimumIsMinor()
{
    // Arrange
    var character = CreateMysticCharacter();
    _masteryServiceMock.Setup(m => m.GetMasteryTier(character, SpellSchool.Destruction))
        .Returns(MasteryTier.Archon);
    _diceServiceMock.SetupSequence(d => d.RollD100())
        .Returns(50) // Fail avoid
        .Returns(100); // Force base Minor

    // Act
    var severity = _sut.CalculateParadoxSeverity(110, character, SpellSchool.Destruction);

    // Assert - Can't go below Minor
    severity.Should().Be(ParadoxSeverity.Minor);
}
```

#### Category 3: Effect Application (6 tests)

```csharp
[Fact]
public void ApplyParadoxEffects_MinorSeverity_Deals1d6Damage()
{
    // Arrange
    var character = CreateMysticCharacter();
    _diceServiceMock.Setup(d => d.Roll(1, 6)).Returns(4);

    // Act
    var result = _sut.ApplyParadoxEffects(character, ParadoxSeverity.Minor, SpellSchool.Destruction);

    // Assert
    result.DamageDealt.Should().Be(4);
    _diceServiceMock.Verify(d => d.Roll(1, 6), Times.Once);
}

[Fact]
public void ApplyParadoxEffects_MajorSeverity_AppliesAetherSickness()
{
    // Arrange
    var character = CreateMysticCharacter();
    _diceServiceMock.Setup(d => d.Roll(2, 8)).Returns(10);

    // Act
    var result = _sut.ApplyParadoxEffects(character, ParadoxSeverity.Major, SpellSchool.Destruction);

    // Assert
    result.StatusApplied.Should().Be(StatusEffectType.AetherSickness);
    result.StatusDuration.Should().Be(2);
    _statusEffectServiceMock.Verify(
        s => s.Apply(character, StatusEffectType.AetherSickness, 2),
        Times.Once);
}

[Fact]
public void ApplyParadoxEffects_SevereSeverity_AddsCorruption()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.CurrentCorruption = 20;
    _diceServiceMock.Setup(d => d.Roll(3, 10)).Returns(15);

    // Act
    var result = _sut.ApplyParadoxEffects(character, ParadoxSeverity.Severe, SpellSchool.Destruction);

    // Assert
    result.CorruptionGained.Should().Be(5);
    character.CurrentCorruption.Should().Be(25);
}

[Fact]
public void ApplyParadoxEffects_CatastrophicSeverity_AddsSoulFracture()
{
    // Arrange
    var character = CreateMysticCharacter();
    _diceServiceMock.Setup(d => d.Roll(4, 12)).Returns(30);

    // Act
    var result = _sut.ApplyParadoxEffects(character, ParadoxSeverity.Catastrophic, SpellSchool.Destruction);

    // Assert
    result.SoulFractureGained.Should().BeTrue();
    character.SoulFractures.Should().HaveCount(1);
}

[Fact]
public void ApplyParadoxEffects_CatastrophicSeverity_TriggersRealityTear()
{
    // Arrange
    var character = CreateMysticCharacter();
    _diceServiceMock.Setup(d => d.Roll(4, 12)).Returns(30);

    // Act
    var result = _sut.ApplyParadoxEffects(character, ParadoxSeverity.Catastrophic, SpellSchool.Destruction);

    // Assert
    result.RealityTearTriggered.Should().BeTrue();
    _eventBusMock.Verify(e => e.Publish(It.IsAny<RealityTearEvent>()), Times.Once);
}

[Fact]
public void ApplyParadoxEffects_PublishesParadoxTriggeredEvent()
{
    // Arrange
    var character = CreateMysticCharacter();
    _diceServiceMock.Setup(d => d.Roll(1, 6)).Returns(4);

    // Act
    _sut.ApplyParadoxEffects(character, ParadoxSeverity.Minor, SpellSchool.Destruction);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<ParadoxTriggeredEvent>(ev =>
            ev.CharacterId == character.Id &&
            ev.Severity == ParadoxSeverity.Minor)),
        Times.Once);
}
```

#### Category 4: Overflow (6 tests)

```csharp
[Fact]
public void EnterOverflow_CreatesOverflowState()
{
    // Arrange
    var character = CreateMysticCharacter();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(100);

    // Act
    var result = _sut.EnterOverflow(character, currentTurn: 5);

    // Assert
    result.Success.Should().BeTrue();
    character.OverflowState.Should().NotBeNull();
    character.OverflowState!.IsActive.Should().BeTrue();
    character.OverflowState.TurnEntered.Should().Be(5);
    character.OverflowState.PotencyModifier.Should().Be(1.50m);
    character.OverflowState.APCostModifier.Should().Be(0.50m);
}

[Fact]
public void EnterOverflow_AlreadyActive_ReturnsFailure()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.OverflowState = OverflowState.Create(3);

    // Act
    var result = _sut.EnterOverflow(character, currentTurn: 5);

    // Assert
    result.Success.Should().BeFalse();
    result.Reason.Should().Contain("already");
}

[Fact]
public void EnterOverflow_PublishesEvent()
{
    // Arrange
    var character = CreateMysticCharacter();
    _resonanceServiceMock.Setup(r => r.GetResonance(character)).Returns(100);

    // Act
    _sut.EnterOverflow(character, currentTurn: 5);

    // Assert
    _eventBusMock.Verify(
        e => e.Publish(It.Is<OverflowEnteredEvent>(ev =>
            ev.CharacterId == character.Id &&
            ev.Turn == 5)),
        Times.Once);
}

[Fact]
public void ProcessOverflowDischarge_DealsCatastrophicDamage()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.OverflowState = OverflowState.Create(1);
    _diceServiceMock.Setup(d => d.Roll(4, 12)).Returns(35);

    // Act
    var result = _sut.ProcessOverflowDischarge(character);

    // Assert
    result.Success.Should().BeTrue();
    result.DamageDealt.Should().Be(35);
}

[Fact]
public void ProcessOverflowDischarge_AppliesSoulFracture()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.OverflowState = OverflowState.Create(1);
    _diceServiceMock.Setup(d => d.Roll(4, 12)).Returns(25);

    // Act
    var result = _sut.ProcessOverflowDischarge(character);

    // Assert
    result.FractureGained.Should().BeGreaterThan(0);
    character.SoulFractures.Should().NotBeEmpty();
}

[Fact]
public void ProcessOverflowDischarge_ClearsOverflowState()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.OverflowState = OverflowState.Create(1);
    _diceServiceMock.Setup(d => d.Roll(4, 12)).Returns(25);

    // Act
    _sut.ProcessOverflowDischarge(character);

    // Assert
    character.OverflowState.Should().BeNull();
}
```

#### Category 5: Soul Fracture (4 tests)

```csharp
[Fact]
public void ApplySoulFracture_ReducesMaxResonance()
{
    // Arrange
    var character = CreateMysticCharacter();

    // Act
    var result = _sut.ApplySoulFracture(character, "Test");

    // Assert
    result.NewMaxResonance.Should().Be(99);
    result.NewFractureCount.Should().Be(1);
}

[Fact]
public void ApplySoulFracture_ThreeFractures_AppliesWillPenalty()
{
    // Arrange
    var character = CreateMysticCharacter();
    character.SoulFractures.Add(SoulFracture.FromCatastrophicParadox());
    character.SoulFractures.Add(SoulFracture.FromCatastrophicParadox());

    // Act - Third fracture
    var result = _sut.ApplySoulFracture(character, "Test");

    // Assert
    result.NewFractureCount.Should().Be(3);
    result.WillPenalty.Should().Be(-1);
    result.WitsPenalty.Should().Be(0);
}

[Fact]
public void ApplySoulFracture_SixFractures_AppliesBothPenalties()
{
    // Arrange
    var character = CreateMysticCharacter();
    for (int i = 0; i < 5; i++)
        character.SoulFractures.Add(SoulFracture.FromCatastrophicParadox());

    // Act - Sixth fracture
    var result = _sut.ApplySoulFracture(character, "Test");

    // Assert
    result.NewFractureCount.Should().Be(6);
    result.WillPenalty.Should().Be(-2);
    result.WitsPenalty.Should().Be(-1);
}

[Fact]
public void ApplySoulFracture_TenFractures_TriggersSoulDeath()
{
    // Arrange
    var character = CreateMysticCharacter();
    for (int i = 0; i < 9; i++)
        character.SoulFractures.Add(SoulFracture.FromCatastrophicParadox());

    // Act - Tenth fracture
    var result = _sut.ApplySoulFracture(character, "Final");

    // Assert
    result.IsSoulDeath.Should().BeTrue();
    character.IsSoulDead.Should().BeTrue();
    _eventBusMock.Verify(
        e => e.Publish(It.IsAny<SoulDeathEvent>()),
        Times.Once);
}
```

### Test Helper Methods

```csharp
private static Character CreateMysticCharacter() => new()
{
    Id = Guid.NewGuid(),
    Name = "Test Mystic",
    IsMystic = true,
    SoulFractures = new List<SoulFracture>(),
    CurrentCorruption = 0
};

private static Character CreateNonMysticCharacter() => new()
{
    Id = Guid.NewGuid(),
    Name = "Test Warrior",
    IsMystic = false,
    SoulFractures = new List<SoulFracture>()
};

private static Spell CreateTestSpell() => new()
{
    Id = Guid.NewGuid(),
    Name = "Flame Bolt",
    School = SpellSchool.Destruction,
    APCost = 4,
    FluxCost = 10
};
```

---

## Integration Points

### MagicService Integration

```csharp
// In MagicService.CastSpell()
public async Task<SpellCastResult> CastSpell(Character caster, Spell spell, ITarget target)
{
    _logger.LogDebug("Casting {SpellName} by {CharacterId}", spell.Name, caster.Id);

    var currentFlux = _aetherService.GetCurrentFlux();

    // 1. Paradox check (Mystics only)
    if (caster.IsMystic)
    {
        var paradoxResult = _paradoxService.CheckParadox(caster, spell, currentFlux);

        if (paradoxResult.OverflowEntered)
        {
            _paradoxService.EnterOverflow(caster, _combatService.CurrentTurn);
            // Continue casting with Overflow bonuses
        }

        if (paradoxResult.Triggered)
        {
            _logger.LogWarning(
                "Spell fizzled due to {Severity} Paradox",
                paradoxResult.Severity);
            return SpellCastResult.Fizzled(spell, paradoxResult);
        }
    }

    // 2. Apply Overflow bonuses if active
    var effectiveAPCost = spell.APCost;
    var effectivePotency = 1.0m;

    if (caster.OverflowState?.IsActive == true)
    {
        effectiveAPCost = (int)Math.Ceiling(spell.APCost * caster.OverflowState.APCostModifier);
        effectivePotency = caster.OverflowState.PotencyModifier;
    }

    // 3. Standard Backlash check (for non-Mystics, or in addition to Paradox)
    if (!caster.IsMystic && currentFlux > 50)
    {
        var backlashResult = _backlashService.CheckBacklash(caster, currentFlux);
        if (backlashResult.Triggered)
        {
            return SpellCastResult.Fizzled(spell, backlashResult);
        }
    }

    // 4. Continue with normal spell execution...
    // Apply mastery cost modifiers
    // Execute effect
    // Award mastery XP
}
```

### CombatService Integration

```csharp
// In CombatService end-of-turn processing
private void ProcessEndOfTurn(Combatant combatant)
{
    // Check for Overflow discharge
    if (combatant is Character character &&
        character.OverflowState?.ShouldDischarge(_currentTurn) == true)
    {
        _logger.LogInformation(
            "Processing Overflow discharge for {CharacterName}",
            character.Name);

        var dischargeResult = _paradoxService.ProcessOverflowDischarge(character);

        if (dischargeResult.IsSoulDeath)
        {
            _logger.LogWarning(
                "Character {CharacterName} has suffered Soul Death!",
                character.Name);
            ProcessSoulDeath(character);
        }
    }

    // Other end-of-turn processing...
}
```

### Character Entity Extension

```csharp
// Add to Character class
public class Character
{
    // Existing properties...

    /// <summary>Whether this character is a Mystic archetype.</summary>
    public bool IsMystic { get; set; }

    /// <summary>Current Overflow state (null if not in Overflow).</summary>
    public OverflowState? OverflowState { get; set; }

    /// <summary>Accumulated Soul Fractures from Paradox.</summary>
    public List<SoulFracture> SoulFractures { get; set; } = new();

    /// <summary>Whether the soul has shattered completely.</summary>
    public bool IsSoulDead { get; set; }

    /// <summary>Total accumulated Soul Fractures.</summary>
    public int TotalSoulFractures => SoulFractures.Sum(f => f.Count);

    /// <summary>Maximum Resonance capacity (reduced by fractures).</summary>
    public int MaxResonanceCapacity => Math.Max(0, 100 - TotalSoulFractures);
}
```

---

## Domain 4 Compliance

### Layer Classification

| Content Type | Layer | Voice Requirements |
|--------------|-------|-------------------|
| Severity names | Layer 1 (Mythic) | Archaic, evocative |
| Effect descriptions | Layer 2 (Diagnostic) | Observer perspective |
| Mechanics | Layer 4 (Ground Truth) | Technical spec |

### Forbidden Precision Violations

| Violation | Compliant Alternative |
|-----------|----------------------|
| "20% risk" | "One in five chances the Weave rebels" |
| "4d12 damage" | "Catastrophic trauma tears through the caster" |
| "-1 WILL penalty" | "The caster's resolve is diminished" |
| "100 Resonance" | "The soul brims with impossible power" |

### Compliant Flavor Text (Layer 2)

```csharp
// ParadoxSeverity descriptions
[GameDocument("The Weave snaps back with a whispered rebuke.")]
Minor,

[GameDocument("Reality recoils violently, leaving the caster reeling from arcane feedback.")]
Major,

[GameDocument("The fabric of existence tears, flooding the caster with unbearable energies that scar both flesh and spirit.")]
Severe,

[GameDocument("The Paradox manifests fully—a wound in reality that consumes the caster's very essence, leaving permanent fractures in their soul.")]
Catastrophic

// Overflow descriptions
OverflowEntered = "The Aether floods through you without restraint—" +
    "for a single, brilliant moment, you ARE the Weave itself.";

OverflowDischarge = "The borrowed power extracts its price. " +
    "As the surge recedes, something fundamental within you cracks.";

// Soul Fracture descriptions
SoulFractureGained = "A piece of your essence burns away, " +
    "leaving an absence where once there was wholeness.";

SoulDeath = "The final fracture. Your soul has shattered beyond mending, " +
    "and what remains is no longer truly you.";
```

### UI Display Guidelines

- Use qualitative descriptors, not percentages for risk
- Show Overflow as pulsing visual effect, not numeric countdown
- Soul Fractures displayed as cracked icon, not numeric counter
- Reality Tear shown as screen distortion effect

---

## Changelog Template

```markdown
## [v0.4.4d] - YYYY-MM-DD

### Added

#### Core Models
- `ParadoxSeverity` enum with `None`, `Minor`, `Major`, `Severe`, `Catastrophic` values
- `ParadoxSeverityExtensions` with damage dice, status duration, corruption, and fracture methods
- `SoulFracture` model tracking permanent magical damage
- `SoulFracturePenalties` computed record with WILL/WITS penalties
- `OverflowState` model for temporary power surge tracking
- `ParadoxResult` record with comprehensive effect tracking
- `DischargeResult` and `OverflowResult` records
- `SoulFractureResult` record

#### Events
- `ParadoxTriggeredEvent` for Paradox occurrence notification
- `OverflowEnteredEvent` for Overflow state entry
- `OverflowDischargeEvent` for forced power discharge
- `SoulFractureGainedEvent` for permanent damage tracking
- `SoulDeathEvent` for character soul destruction
- `RealityTearEvent` for Catastrophic Paradox consequence

#### Services
- `IParadoxService` interface with 9 methods for Paradox management
- `ParadoxService` implementation with full risk calculation, severity determination, and effect application
- Risk thresholds: 20% (100-119), 35% (120-139), 50% (140-159), 70% (160-179), 90% (180+)
- Mastery mitigation: -1 to -2 severity tiers based on school mastery
- Avoidance chance: 10% (Adept), 25% (Archon)

#### Character Extensions
- `IsMystic` flag for archetype identification
- `OverflowState` property for power surge tracking
- `SoulFractures` collection for permanent damage
- `IsSoulDead` flag for character state
- Computed properties: `TotalSoulFractures`, `MaxResonanceCapacity`

#### Integration
- MagicService hooks for pre-cast Paradox check
- MagicService hooks for Overflow bonus application
- CombatService hooks for end-of-turn Overflow discharge
- Spell fizzle on Paradox trigger

### Soul Fracture Penalty Table

| Fractures | Max Resonance | WILL | WITS |
|-----------|---------------|------|------|
| 0-2 | 100-98 | 0 | 0 |
| 3-5 | 97-95 | -1 | 0 |
| 6-9 | 94-91 | -2 | -1 |
| 10+ | 90- | SOUL DEATH | - |

### Test Coverage

| Category | Tests | Coverage |
|----------|-------|----------|
| Risk Calculation | 8 | 100% |
| Severity Determination | 6 | 100% |
| Effect Application | 6 | 100% |
| Overflow | 6 | 100% |
| Soul Fracture | 4 | 100% |
| **Total** | **30** | **85%** |

### Dependencies
- Requires v0.4.3d (BacklashService, BacklashSeverity, AetherSickness status)
- Requires v0.4.4a (ResonanceService, ResonanceState)
- Requires v0.4.4c (MasteryService for severity mitigation)

### Migration Notes
- Characters require `IsMystic`, `OverflowState`, `SoulFractures`, `IsSoulDead` properties
- Existing characters default to `IsMystic = false`
- No database migration required (state stored in character entity)

---

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
```

---

## Appendix: Quick Reference

### Risk Thresholds

| Combined | Risk | Min Severity | Max Severity |
|----------|-----:|--------------|--------------|
| 100-119 | 20% | Minor | Minor |
| 120-139 | 35% | Minor | Major |
| 140-159 | 50% | Major | Severe |
| 160-179 | 70% | Severe | Catastrophic |
| 180+ | 90% | Catastrophic | Catastrophic |

### Severity Effects

| Severity | Damage | Status | Corruption | Fracture |
|----------|--------|--------|------------|----------|
| Minor | 1d6 | - | - | - |
| Major | 2d8 | 2 turns | - | - |
| Severe | 3d10 | 4 turns | +5 | - |
| Catastrophic | 4d12 | 6 turns | +10 | +1 |

### Soul Fracture Penalties

| Fractures | Max Res | WILL | WITS |
|-----------|---------|------|------|
| 0-2 | 100-98 | 0 | 0 |
| 3-5 | 97-95 | -1 | 0 |
| 6-9 | 94-91 | -2 | -1 |
| 10 | 90 | **SOUL DEATH** | - |

### Mastery Mitigation

| Tier | Severity Reduction | Avoid Chance |
|------|-------------------|--------------|
| Novice | 0 | 0% |
| Apprentice | -1 | 0% |
| Adept | -1 | 10% |
| Master | -2 | 0% |
| Archon | -2 | 25% |

### File Locations

| File | Path |
|------|------|
| ParadoxSeverity | `Core/Enums/ParadoxSeverity.cs` |
| SoulFracture | `Core/Models/Magic/SoulFracture.cs` |
| OverflowState | `Core/Models/Magic/OverflowState.cs` |
| ParadoxResult | `Core/Models/Magic/ParadoxResult.cs` |
| IParadoxService | `Core/Interfaces/IParadoxService.cs` |
| ParadoxService | `Engine/Services/ParadoxService.cs` |
| ParadoxServiceTests | `Tests/Services/ParadoxServiceTests.cs` |
