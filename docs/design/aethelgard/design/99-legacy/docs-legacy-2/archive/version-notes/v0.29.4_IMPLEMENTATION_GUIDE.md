# v0.29.4 Implementation & Testing Guide
## Service Implementation & Testing

### Implementation Status

**Phase:** Service Integration Complete ‚úì
**Timeline:** ~6 hours (within 9-15 hour estimate)
**Approach:** Pragmatic integration focused on essential mechanics

---

## I. What Was Implemented

### 1. MuspelheimDataRepository (Database Query Layer)

**File:** `RuneAndRust.Persistence/MuspelheimDataRepository.cs`

**Purpose:** Provides database-driven access to all Muspelheim data from v0.29.1-v0.29.3

**Key Methods:**
- `GetRoomTemplates()` - Loads all 8 room templates
- `GetEnemySpawns(minLevel, maxLevel)` - Loads 5 enemy types with level filtering
- `GetEnvironmentalHazards(hazardDensity)` - Loads 8 hazards with density filtering
- `GetResourceDrops()` - Loads 9 resource drops
- `GetBiomeMetadata()` - Loads biome metadata
- `GetEnemyResistances(json)` - Parses Fire/Ice/Physical resistance data from JSON

**Integration Pattern:**
```csharp
var repo = new MuspelheimDataRepository(connectionString);

// Load templates
var templates = repo.GetRoomTemplates();
var entrances = repo.GetEntranceTemplates();

// Load enemies for level 8-10 range
var enemies = repo.GetEnemySpawns(minLevel: 8, maxLevel: 10);

// Load hazards for "High" density room
var hazards = repo.GetEnvironmentalHazards("High");
```

### 2. MuspelheimBiomeService (Orchestration Layer)

**File:** `RuneAndRust.Engine/MuspelheimBiomeService.cs`

**Purpose:** Coordinates Muspelheim mechanics (heat, brittleness, enemy resistances)

**Key Methods:**

#### Party Preparedness
```csharp
public MuspelheimPreparednessReport CheckPartyPreparedness(List<PlayerCharacter> party)
```
- Checks each character's Fire Resistance
- Logs warnings for underprepared characters (<50% Fire Resistance)
- Returns preparedness report with recommendations

#### Enemy Management
```csharp
public void LoadEnemyResistances(Enemy enemy, MuspelheimEnemySpawn spawnData)
```
- Parses resistance data from `spawn_rules_json`
- Loads resistances into `BrittlenessService` for tracking
- Validates [Brittle]-eligibility

```csharp
public Enemy CreateEnemyFromSpawn(MuspelheimEnemySpawn spawnData, int level)
```
- Creates Enemy instance from database spawn data
- Automatically loads resistances
- Calculates HP based on type and level

```csharp
public MuspelheimEnemySpawn SelectWeightedEnemy(List<MuspelheimEnemySpawn> eligible, Random random)
```
- Weighted random selection based on spawn_weight
- Ensures proper distribution (Forge-Hardened 48%, Magma Elemental 26%, etc.)

#### Heat Damage Integration
```csharp
public List<HeatDamageResult> ProcessEndOfTurnHeat(List<PlayerCharacter> characters)
```
- Applies [Intense Heat] STURDINESS checks (DC 12)
- Rolls 2d6 Fire damage on failure
- Applies Fire Resistance (when implemented)
- Tracks deaths from heat

#### Brittleness Integration
```csharp
public BrittlenessResult ApplyIceDamageToEnemy(Enemy enemy, int iceDamage, string source)
```
- Applies Ice damage with vulnerability calculation
- Calls `BrittlenessService.TryApplyBrittle()`
- Returns whether [Brittle] was applied

```csharp
public PhysicalDamageResult ApplyPhysicalDamageToEnemy(Enemy enemy, int physicalDamage, string source)
```
- Calls `BrittlenessService.ApplyBrittleBonus()`
- Applies +50% Physical damage if [Brittle] active
- Returns damage breakdown

---

## II. Integration Examples

### Example 1: Loading Muspelheim Data

```csharp
// Initialize services
var repo = new MuspelheimDataRepository(connectionString);
var heatService = new IntenseHeatService(diceService, resolveService, traumaService);
var brittlenessService = new BrittlenessService();
var biomeService = new MuspelheimBiomeService(repo, heatService, brittlenessService, diceService);

// Load biome metadata
var metadata = biomeService.GetBiomeMetadata();
Console.WriteLine($"Biome: {metadata.BiomeName}");
Console.WriteLine($"Recommended Level: {metadata.MinCharacterLevel}-{metadata.MaxCharacterLevel}");

// Load room templates
var templates = biomeService.GetRoomTemplates();
foreach (var template in templates)
{
    Console.WriteLine($"  Room: {template.TemplateName} ({template.RoomSize}, Hazard Density: {template.HazardDensity})");
}
```

**Expected Output:**
```
Biome: Muspelheim
Recommended Level: 7-12
  Room: Geothermal Control Chamber (Large, Hazard Density: Medium)
  Room: Lava Flow Corridor (Small, Hazard Density: High)
  Room: Collapsed Forge Floor (Medium, Hazard Density: Extreme)
  ... (8 total)
```

### Example 2: Spawning Enemies with Resistances

```csharp
// Get eligible enemies for level 9 encounter
var eligibleEnemies = biomeService.GetEnemySpawnsForLevel(9);

// Select weighted random enemy
var random = new Random(12345);
var selectedSpawn = biomeService.SelectWeightedEnemy(eligibleEnemies, random);

// Create enemy with resistances
var enemy = biomeService.CreateEnemyFromSpawn(selectedSpawn, level: 9);

// Verify resistances loaded
bool isBrittleEligible = brittlenessService.IsBrittleEligible(enemy);
int fireRes = brittlenessService.GetEnemyResistance(enemy.EnemyID, "Fire");
int iceRes = brittlenessService.GetEnemyResistance(enemy.EnemyID, "Ice");

Console.WriteLine($"Spawned: {enemy.Name} (Level {enemy.Level}, HP {enemy.HP}/{enemy.MaxHP})");
Console.WriteLine($"  Fire Resistance: {fireRes}%");
Console.WriteLine($"  Ice Resistance: {iceRes}% {(iceRes < 0 ? "(VULNERABLE)" : "")}");
Console.WriteLine($"  Brittle-Eligible: {isBrittleEligible}");
```

**Expected Output:**
```
Spawned: Forge-Hardened Undying (Level 9, HP 160/160)
  Fire Resistance: 75%
  Ice Resistance: -50% (VULNERABLE)
  Brittle-Eligible: True
```

### Example 3: Heat Damage Loop

```csharp
// Create test party
var party = new List<PlayerCharacter>
{
    CreateWarrior("Thorin", sturdiness: 4, hp: 80),
    CreateMystic("Freya", sturdiness: 2, hp: 50)
};

// Check preparedness
var prepReport = biomeService.CheckPartyPreparedness(party);
Console.WriteLine($"Party Average Fire Resistance: {prepReport.AverageFireResistance}%");

foreach (var charPrep in prepReport.Characters)
{
    Console.WriteLine($"  [{charPrep.WarningLevel}] {charPrep.WarningMessage}");
}

// Simulate 3 turns of heat
for (int turn = 1; turn <= 3; turn++)
{
    Console.WriteLine($"\n=== Turn {turn} ===");
    var heatResults = biomeService.ProcessEndOfTurnHeat(party);

    foreach (var result in heatResults)
    {
        Console.WriteLine(result.Message);
    }
}
```

**Expected Output:**
```
Party Average Fire Resistance: 0%
  [Critical] Thorin has CRITICAL lack of Fire Resistance (0%). Expect frequent deaths from [Intense Heat].
  [Critical] Freya has CRITICAL lack of Fire Resistance (0%). Expect frequent deaths from [Intense Heat].

=== Turn 1 ===
‚úó Thorin fails [Intense Heat] check (7 successes)
   üî• The searing heat overwhelms your defenses!
   Damage: 2d6 = 9
   HP: 71/80
‚úó Freya fails [Intense Heat] check (4 successes)
   üî• The searing heat overwhelms your defenses!
   Damage: 2d6 = 7
   HP: 43/50

=== Turn 2 ===
‚úì Thorin resists [Intense Heat] (STURDINESS check passed)
‚úó Freya fails [Intense Heat] check (5 successes)
   üî• The searing heat overwhelms your defenses!
   Damage: 2d6 = 11
   HP: 32/50
...
```

### Example 4: Brittleness Combo

```csharp
// Spawn Fire-resistant enemy
var forgeHardened = biomeService.CreateEnemyFromSpawn(
    biomeService.GetEnemySpawnsForLevel(8).First(e => e.EnemyName == "Forge-Hardened Undying"),
    level: 8
);

Console.WriteLine($"Enemy: {forgeHardened.Name} (HP: {forgeHardened.HP}/{forgeHardened.MaxHP})");

// Step 1: Ice Mystic casts Frost Bolt
var iceResult = biomeService.ApplyIceDamageToEnemy(forgeHardened, iceDamage: 15, "Frost Bolt");
Console.WriteLine($"\nIce Attack:");
Console.WriteLine($"  Damage: {iceResult.FinalDamageDealt} (Ice vulnerability applied)");
Console.WriteLine($"  {iceResult.Message}");
Console.WriteLine($"  [Brittle] Applied: {iceResult.BrittleApplied}");

// Step 2: Physical Warrior attacks
var physicalResult = biomeService.ApplyPhysicalDamageToEnemy(forgeHardened, physicalDamage: 20, "Greatsword");
Console.WriteLine($"\nPhysical Attack:");
Console.WriteLine($"  Base Damage: {physicalResult.BaseDamage}");
Console.WriteLine($"  Final Damage: {physicalResult.FinalDamage}");
Console.WriteLine($"  [Brittle] Bonus Applied: {physicalResult.BrittleBonusApplied}");
Console.WriteLine($"  {physicalResult.Message}");

Console.WriteLine($"\nEnemy HP: {forgeHardened.HP}/{forgeHardened.MaxHP}");
```

**Expected Output:**
```
Enemy: Forge-Hardened Undying (HP: 150/150)

Ice Attack:
  Damage: 22 (Ice vulnerability applied)
  ‚ùÑÔ∏è Forge-Hardened Undying's heat-resistant tissue flash-freezes, becoming [Brittle]!
  [Brittle] Applied: True

Physical Attack:
  Base Damage: 20
  Final Damage: 30
  [Brittle] Bonus Applied: True
  üí• [Brittle] vulnerability: +10 Physical damage to Forge-Hardened Undying!

Enemy HP: 98/150
```

---

## III. Testing Procedures

### Test 1: Database Query Integration

```csharp
[TestMethod]
public void MuspelheimDataRepository_LoadsAllData()
{
    // Arrange
    var repo = new MuspelheimDataRepository(connectionString);

    // Act
    var templates = repo.GetRoomTemplates();
    var enemies = repo.GetEnemySpawns();
    var hazards = repo.GetEnvironmentalHazards();
    var resources = repo.GetResourceDrops();
    var metadata = repo.GetBiomeMetadata();

    // Assert
    Assert.AreEqual(8, templates.Count, "Should load 8 room templates");
    Assert.AreEqual(5, enemies.Count, "Should load 5 enemy types");
    Assert.AreEqual(8, hazards.Count, "Should load 8 hazards");
    Assert.AreEqual(9, resources.Count, "Should load 9 resources");
    Assert.AreEqual("Muspelheim", metadata.BiomeName);
    Assert.AreEqual(7, metadata.MinCharacterLevel);
    Assert.AreEqual(12, metadata.MaxCharacterLevel);
}
```

### Test 2: Enemy Spawn Weight Distribution

```csharp
[TestMethod]
public void MuspelheimBiomeService_EnemySpawnDistribution()
{
    // Arrange
    var service = CreateMuspelheimBiomeService();
    var eligibleEnemies = service.GetEnemySpawnsForLevel(8);
    var enemyCounts = new Dictionary<string, int>();
    var random = new Random(12345);

    // Act: Spawn 1000 enemies
    for (int i = 0; i < 1000; i++)
    {
        var selected = service.SelectWeightedEnemy(eligibleEnemies, random);
        if (!enemyCounts.ContainsKey(selected.EnemyName))
        {
            enemyCounts[selected.EnemyName] = 0;
        }
        enemyCounts[selected.EnemyName]++;
    }

    // Assert distribution matches spawn weights
    // Forge-Hardened Undying (weight 150) should be ~48%
    // Magma Elemental (weight 80) should be ~26%
    // Rival Berserker (weight 60) should be ~19%
    // Iron-Bane Crusader (weight 20) should be ~6%
    // Surtur's Herald (weight 1) should be <1%

    int forgeHardened = enemyCounts.GetValueOrDefault("Forge-Hardened Undying", 0);
    int magmaElemental = enemyCounts.GetValueOrDefault("Magma Elemental", 0);

    Assert.IsTrue(forgeHardened > magmaElemental,
        $"Forge-Hardened ({forgeHardened}) should be more common than Magma Elemental ({magmaElemental})");

    double forgePercentage = forgeHardened / 1000.0;
    Assert.IsTrue(forgePercentage >= 0.40 && forgePercentage <= 0.55,
        $"Forge-Hardened percentage should be ~48%, got {forgePercentage:P}");
}
```

### Test 3: Heat Damage Survival Time

```csharp
[TestMethod]
public void MuspelheimBiomeService_HeatDamageSurvivalTime()
{
    // Arrange
    var service = CreateMuspelheimBiomeService();
    var character = CreateTestCharacter(sturdiness: 3, hp: 50);
    var party = new List<PlayerCharacter> { character };

    // Act: Simulate heat until death
    int turnsSurvived = 0;
    while (character.HP > 0 && turnsSurvived < 50)
    {
        service.ProcessEndOfTurnHeat(party);
        turnsSurvived++;
    }

    // Assert: Character with 3 STURDINESS should survive ~6-10 turns
    Assert.IsTrue(turnsSurvived >= 5,
        $"Expected survival time ‚â•5 turns, got {turnsSurvived}");
    Assert.IsTrue(turnsSurvived <= 15,
        $"Expected survival time ‚â§15 turns, got {turnsSurvived}");
}
```

### Test 4: Brittleness Combo Damage

```csharp
[TestMethod]
public void MuspelheimBiomeService_BrittlenessCombo()
{
    // Arrange
    var service = CreateMuspelheimBiomeService();
    var repo = new MuspelheimDataRepository(connectionString);
    var forgeHardenedSpawn = repo.GetEnemySpawns()
        .First(e => e.EnemyName == "Forge-Hardened Undying");
    var enemy = service.CreateEnemyFromSpawn(forgeHardenedSpawn, level: 8);

    int initialHP = enemy.HP;

    // Act: Ice damage
    var iceResult = service.ApplyIceDamageToEnemy(enemy, iceDamage: 15, "Frost Bolt");

    // Assert: [Brittle] applied
    Assert.IsTrue(iceResult.BrittleApplied, "[Brittle] should be applied after Ice damage");

    int hpAfterIce = enemy.HP;

    // Act: Physical damage
    var physicalResult = service.ApplyPhysicalDamageToEnemy(enemy, physicalDamage: 20, "Greatsword");

    // Assert: Bonus damage applied
    Assert.IsTrue(physicalResult.BrittleBonusApplied, "[Brittle] bonus should be applied");
    Assert.AreEqual(30, physicalResult.FinalDamage, "20 base damage should become 30 with [Brittle]");

    int totalDamageTaken = initialHP - enemy.HP;
    int expectedMinDamage = 22 + 30; // Ice vulnerable + Brittle Physical
    Assert.IsTrue(totalDamageTaken >= expectedMinDamage,
        $"Total damage {totalDamageTaken} should be ‚â•{expectedMinDamage}");
}
```

### Test 5: Enemy Resistance Loading

```csharp
[TestMethod]
public void MuspelheimBiomeService_LoadsEnemyResistancesCorrectly()
{
    // Arrange
    var service = CreateMuspelheimBiomeService();
    var brittlenessService = new BrittlenessService();
    var repo = new MuspelheimDataRepository(connectionString);

    // Act: Load Magma Elemental (100% Fire, -30% Ice, 25% Physical)
    var magmaSpawn = repo.GetEnemySpawns()
        .First(e => e.EnemyName == "Magma Elemental");
    var magmaElemental = service.CreateEnemyFromSpawn(magmaSpawn, level: 9);

    // Assert resistances
    int fireRes = brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Fire");
    int iceRes = brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Ice");
    int physicalRes = brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Physical");

    Assert.AreEqual(100, fireRes, "Magma Elemental should have 100% Fire Resistance");
    Assert.AreEqual(-30, iceRes, "Magma Elemental should have -30% Ice Resistance (vulnerable)");
    Assert.AreEqual(25, physicalRes, "Magma Elemental should have 25% Physical Resistance");

    // Assert Brittle-eligible
    bool eligible = brittlenessService.IsBrittleEligible(magmaElemental);
    Assert.IsTrue(eligible, "Magma Elemental should be [Brittle]-eligible (Fire Resistance > 0%)");
}
```

---

## IV. What Was NOT Implemented (Deferred to Future Versions)

### 1. Full WFC Room Graph Generation
**Status:** Deferred to v0.29.5
**Reason:** Complex graph-based generation with WFC constraints would require 8-12 additional hours

**Current Approach:**
- Database stores room templates with WFC adjacency rules
- Adjacency rules defined in `wfc_adjacency_rules` JSON field
- Example: `{"allow": ["Lava Flow Corridor", "Equipment Bay"], "forbid": ["Containment Breach Zone"]}`

**Future Implementation:**
- Full Wave Function Collapse algorithm
- Constraint propagation for room placement
- Backtracking for unsolvable states
- Graph validation and connectivity checks

### 2. Procedural Hazard Placement Algorithm
**Status:** Deferred to v0.29.5
**Reason:** Requires tactical grid integration and tile-based placement logic

**Current Approach:**
- `MuspelheimDataRepository.GetEnvironmentalHazards(density)` filters hazards by density
- Returns list of eligible hazards for a room

**Future Implementation:**
- Tile-based hazard placement respecting `tile_coverage_percent`
- Lava river generation (instant death obstacle)
- Dynamic hazard triggers (steam vents, collapsing catwalks)
- Chain reaction logic (gas explosions)

### 3. Procedural Enemy Spawn Placement
**Status:** Deferred to v0.29.5
**Reason:** Requires room size calculation and tactical positioning

**Current Approach:**
- `SelectWeightedEnemy()` selects enemy based on spawn weights
- `CreateEnemyFromSpawn()` creates enemy with resistances loaded

**Future Implementation:**
- Enemy count calculation based on room size
- Tactical positioning (melee front, ranged back)
- Boss room special handling
- Difficulty scaling by party level

### 4. Resource Node Placement
**Status:** Deferred to v0.29.5
**Reason:** Requires loot node system and special node discovery mechanics

**Current Approach:**
- `MuspelheimDataRepository.GetResourceDrops()` returns all 9 resources
- Resources have `requires_special_node` flag and `base_drop_chance`

**Future Implementation:**
- Weighted random resource selection
- Special node placement (Eternal Ember, Surtur Engine Core)
- Hidden legendary node discovery (WITS checks)
- Resource quantity rolling (min/max)

### 5. Biome Statistics Tracking
**Status:** Deferred to v0.29.6
**Reason:** Requires `Characters_BiomeStatus` table integration

**Current Approach:**
- Table exists from v0.29.1
- Fields: `heat_damage_taken`, `times_died_to_heat`, `rooms_explored`, etc.

**Future Implementation:**
- `BiomeStatusService` for tracking statistics
- Heat damage accumulation
- Death tracking
- Boss encounter tracking

### 6. Full Resistance System
**Status:** Deferred to v0.30
**Reason:** Requires equipment/ability system expansion

**Current Approach:**
- `BrittlenessService` stores enemy resistances in dictionary
- Placeholder methods for character Fire Resistance (returns 0)

**Future Implementation:**
- Equipment-based resistances (Ablative Plating gives 75% Fire Resistance)
- Ability-based resistances (Berserker Unflinching gives heat reduction)
- Status effect resistances
- Resistance stacking rules

### 7. Advanced Enemy AI & Behaviors
**Status:** Deferred to v0.36
**Reason:** Requires AI behavior system expansion

**Current Approach:**
- Enemies created with basic stats
- Tags in `spawn_rules_json` indicate special behaviors: `burning_trail`, `death_explosion`, `fury_resource`

**Future Implementation:**
- Magma Elemental burning trail (leaves fire hazard tiles)
- Magma Elemental death explosion (4d6 Fire AoE)
- Rival Berserker Fury mechanic
- Iron-Bane Crusader potential ally diplomacy

### 8. Surtur's Herald Boss Encounter
**Status:** Deferred to v0.35
**Reason:** Multi-phase boss requires dedicated encounter design

**Current Approach:**
- Surtur's Herald exists as spawnable enemy (weight 1)
- Stats: Level 12, Fire Resistance 90%, multi_phase tag

**Future Implementation:**
- Phase 1: Weapon attacks, heat aura
- Phase 2: (50% HP) Summons adds, environmental destruction
- Phase 3: (25% HP) Enraged, multi-attack, AoE fire damage
- Legendary resistances (immune to crowd control)
- Special loot drop (Surtur Engine Core guaranteed)

---

## V. Architecture Integration Points

### Integration with Existing Systems

#### 1. DungeonGenerator & PopulationPipeline
**Current System:** JSON-based `BiomeDefinition` ‚Üí `PopulationPipeline` ‚Üí `DormantProcessSpawner`, `HazardSpawner`, etc.

**Muspelheim Integration Path:**
1. Create `MuspelheimBiomeDefinition.json` in `Data/Biomes/`
2. Reference Muspelheim templates (load from database OR JSON)
3. Use `PopulationPipeline` with custom spawners that read from database
4. Alternatively: Create `MuspelheimDungeonGenerator` that bypasses JSON system

**Recommendation:** Hybrid approach
- Use `PopulationPipeline` architecture
- Create `DatabaseBiomeDefinitionAdapter` to translate database data ‚Üí `BiomeDefinition`
- Leverage existing spawners where possible, create Muspelheim-specific spawners for unique mechanics

#### 2. Tactical Grid Integration
**Existing System:** `battlefield_tiles` table, `TacticalTile` class

**Muspelheim Integration:**
- Lava River hazard ‚Üí Mark tile as `tile_type = 'Chasm'`, instant death on entry
- Burning Ground ‚Üí Add `DynamicHazard` to tile, 8 Fire damage per turn
- Thermal Mirage ‚Üí Add vision penalty modifier to tile

**Example:**
```csharp
// Mark lava river tiles
foreach (var tile in room.Grid.Tiles.Where(t => t.IsLavaRiver))
{
    tile.TileType = TileType.Chasm; // Instant death
    tile.BlocksMovement = true;
}

// Add burning ground hazard
var burningGroundTiles = SelectRandomTiles(room, coveragePercent: 15);
foreach (var tile in burningGroundTiles)
{
    tile.AddHazard(new DynamicHazard
    {
        HazardType = DynamicHazardType.BurningGround,
        DamagePerTurn = 8,
        DamageType = DamageType.Fire
    });
}
```

#### 3. Environmental Combat Integration
**Existing System:** `EnvironmentalCombatService`, destructible objects

**Muspelheim Integration:**
- High-Pressure Steam Vent ‚Üí Destructible, `is_destructible = 1`
- Volatile Gas Pocket ‚Üí Chain reaction, `special_rules = 'chain_reaction,aoe_radius_3'`

**Example:**
```csharp
// Destructible steam vent
var steamVent = new EnvironmentalObject
{
    Name = "[High-Pressure Steam Vent]",
    HP = 30,
    IsDestructible = true,
    OnDestroyEffect = () => {
        // Stop dealing damage, remove Disoriented application
    }
};

// Explosive gas pocket
var gasPocket = new EnvironmentalObject
{
    Name = "[Volatile Gas Pocket]",
    OnFireDamageNearby = (range) => {
        if (range <= 3) // Chain reaction trigger
        {
            // Explode: 4d6 AoE Fire damage, radius 3
        }
    }
};
```

---

## VI. Usage Examples for Future Developers

### Creating a Muspelheim Encounter

```csharp
// Step 1: Initialize services
var connectionString = "Data Source=runeandrust.db";
var repo = new MuspelheimDataRepository(connectionString);
var diceService = new DiceService();
var heatService = new IntenseHeatService(diceService, resolveService, traumaService);
var brittlenessService = new BrittlenessService();
var biomeService = new MuspelheimBiomeService(repo, heatService, brittlenessService, diceService);

// Step 2: Create room from template
var template = repo.GetRoomTemplates().First(t => t.TemplateName == "Collapsed Forge Floor");
var room = new Room
{
    Name = template.TemplateName,
    Description = template.Description
};

// Step 3: Spawn enemies
var eligibleEnemies = biomeService.GetEnemySpawnsForLevel(9);
var random = new Random();

for (int i = 0; i < 3; i++) // Spawn 3 enemies
{
    var spawn = biomeService.SelectWeightedEnemy(eligibleEnemies, random);
    var enemy = biomeService.CreateEnemyFromSpawn(spawn, level: 9);
    room.Enemies.Add(enemy);
}

// Step 4: Add hazards
var hazards = biomeService.GetHazardsForDensity(template.HazardDensity);
// TODO: Place hazards on tactical grid tiles

// Step 5: Combat loop
while (!combatEnded)
{
    // Player turn...

    // End of turn: Apply heat
    var heatResults = biomeService.ProcessEndOfTurnHeat(party);
    foreach (var result in heatResults)
    {
        Console.WriteLine(result.Message);
    }

    // Enemy turn...
}
```

### Testing Brittleness Mechanic

```csharp
// Spawn Magma Elemental (100% Fire immune)
var magmaSpawn = repo.GetEnemySpawns().First(e => e.EnemyName == "Magma Elemental");
var magmaElemental = biomeService.CreateEnemyFromSpawn(magmaSpawn, level: 10);

Console.WriteLine($"Target: {magmaElemental.Name}");
Console.WriteLine($"Fire Resistance: {brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Fire")}%");
Console.WriteLine($"Ice Resistance: {brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Ice")}%");

// Fire attack (ineffective)
Console.WriteLine("\n=== Fire Attack ===");
int fireDamage = 30;
int fireResPercent = brittlenessService.GetEnemyResistance(magmaElemental.EnemyID, "Fire");
int finalFireDamage = fireDamage - (fireDamage * fireResPercent / 100);
Console.WriteLine($"30 Fire damage ‚Üí {finalFireDamage} damage (100% resistance)");

// Ice attack (vulnerable + Brittle)
Console.WriteLine("\n=== Ice Attack ===");
var iceResult = biomeService.ApplyIceDamageToEnemy(magmaElemental, iceDamage: 20, "Frost Bolt");
Console.WriteLine($"20 Ice damage ‚Üí {iceResult.FinalDamageDealt} damage (Ice vulnerable -30%)");
Console.WriteLine($"[Brittle] Applied: {iceResult.BrittleApplied}");

// Physical attack (Brittle bonus)
Console.WriteLine("\n=== Physical Attack ===");
var physicalResult = biomeService.ApplyPhysicalDamageToEnemy(magmaElemental, physicalDamage: 25, "Warhammer");
Console.WriteLine($"25 Physical damage ‚Üí {physicalResult.FinalDamage} damage ([Brittle] +50%)");
Console.WriteLine($"{physicalResult.Message}");
```

---

## VII. Performance Considerations

### Database Query Optimization

**Current Implementation:**
- Single queries per method call
- No caching
- No connection pooling (uses `using` for auto-disposal)

**Recommendations for Future Versions:**
1. **Cache biome data on service initialization:**
   ```csharp
   private readonly List<MuspelheimRoomTemplate> _cachedTemplates;
   private readonly List<MuspelheimEnemySpawn> _cachedEnemies;

   public MuspelheimDataRepository(string connectionString)
   {
       _connectionString = connectionString;
       _cachedTemplates = LoadAndCacheTemplates();
       _cachedEnemies = LoadAndCacheEnemies();
   }
   ```

2. **Batch queries:**
   ```csharp
   public (List<Templates>, List<Enemies>, List<Hazards>) LoadAllBiomeData()
   {
       // Single connection, multiple queries
   }
   ```

3. **Use indexed queries:**
   - Existing indices on `biome_id`, `enemy_type`, `hazard_density_category` are already in place from v0.29.1

### Memory Usage

**Current Implementation:**
- Creates new Enemy instances for each spawn
- No object pooling
- `BrittlenessService` stores resistances in dictionary (grows over time)

**Recommendations:**
- Enemy object pool for frequently spawned enemies
- Clear `BrittlenessService._enemyResistances` dictionary when enemies are defeated
- Consider weak references for long-lived game sessions

---

## VIII. Known Issues & Limitations

### Issue 1: Fire Resistance Not Implemented for Characters
**Impact:** Heat damage calculations always assume 0% Fire Resistance

**Workaround:** Manually modify `ProcessHeatForCharacter()` to return test resistance values

**Resolution:** v0.30 will implement full equipment-based resistance system

### Issue 2: No Actual Room Generation
**Impact:** Services provide data but don't generate playable rooms

**Workaround:** Use existing `DungeonGenerator` with JSON-based biome definition

**Resolution:** v0.29.5 will implement full procedural generation

### Issue 3: Enemy AI Uses Basic Patterns
**Impact:** Special behaviors (burning trail, fury) not yet functional

**Workaround:** Tags in `spawn_rules_json` mark which enemies should have special behaviors

**Resolution:** v0.36 will implement advanced AI behaviors

### Issue 4: No Boss Encounter Framework
**Impact:** Surtur's Herald spawns but has no multi-phase logic

**Workaround:** Treat as standard elite enemy for now

**Resolution:** v0.35 will implement full boss encounter system

---

## IX. Success Criteria

### ‚úÖ Completed
- [x] Database query layer for all Muspelheim data
- [x] Orchestration service for heat and brittleness mechanics
- [x] Enemy resistance loading and tracking
- [x] Weighted enemy spawn selection
- [x] Heat damage integration (STURDINESS checks, 2d6 Fire damage)
- [x] Brittleness integration (Ice ‚Üí [Brittle] ‚Üí +50% Physical)
- [x] Party preparedness checking
- [x] Comprehensive documentation
- [x] Integration examples and test procedures

### ‚è≥ Deferred to Future Versions
- [ ] WFC room graph generation (v0.29.5)
- [ ] Hazard placement algorithm (v0.29.5)
- [ ] Enemy spawn placement (v0.29.5)
- [ ] Resource node placement (v0.29.5)
- [ ] Biome statistics tracking (v0.29.6)
- [ ] Full resistance system (v0.30)
- [ ] Advanced enemy AI (v0.36)
- [ ] Surtur's Herald boss encounter (v0.35)

---

## X. Next Steps

### For Developers Continuing v0.29

**Priority 1: Room Generation (v0.29.5)**
1. Implement `GenerateMuspelheimSector()` method
2. Use WFC constraints from `wfc_adjacency_rules` JSON
3. Create room graph with entrance, exit, and branching paths
4. Validate connectivity

**Priority 2: Hazard & Enemy Placement (v0.29.5)**
1. Implement `PlaceHazardsInRoom()` respecting `tile_coverage_percent`
2. Implement `PlaceEnemiesInRoom()` with tactical positioning
3. Test hazard density filtering
4. Validate spawn weight distribution

**Priority 3: Biome Statistics (v0.29.6)**
1. Create `BiomeStatusService`
2. Track heat damage, deaths, rooms explored
3. Integrate with `Characters_BiomeStatus` table
4. Add statistics dashboard queries

**Priority 4: Full Integration (v0.29.7)**
1. Integrate with existing `DungeonService`
2. Create `MuspelheimBiomeDefinition.json` (or database adapter)
3. Test end-to-end biome generation
4. Performance benchmarks (<2s generation time)

---

## XI. Related Files

**Created in v0.29.4:**
- `RuneAndRust.Persistence/MuspelheimDataRepository.cs` (370 lines)
- `RuneAndRust.Engine/MuspelheimBiomeService.cs` (470 lines)
- `Data/v0.29.4_IMPLEMENTATION_GUIDE.md` (this file)

**Dependencies from Previous Versions:**
- `v0.29.1`: Database schema, room templates, resources
- `v0.29.2`: IntenseHeatService, environmental hazards
- `v0.29.3`: BrittlenessService, enemy spawns

**Related Systems:**
- `DungeonGenerator.cs` - Existing procedural generation
- `PopulationPipeline.cs` - Existing room population
- `BiomeLibrary.cs` - JSON-based biome loading
- `HazardService.cs` - Hazard management

---

**Implementation Status:** Services Complete ‚úì
**Timeline:** ~6 hours (within estimate)
**Approach:** Pragmatic integration with clear path for future enhancement
**Quality:** Production-ready for database access, orchestration, and core mechanics

**Next Version:** v0.29.5 - Procedural Generation & Placement
