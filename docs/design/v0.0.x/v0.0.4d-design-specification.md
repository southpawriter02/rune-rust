# v0.0.4d Implementation Plan: Integration & Polish

## Overview

**Version:** 0.0.4d
**Status:** Implemented
**Focus:** Wire together the class, resource, and ability systems with commands and combat integration
**Prerequisites:** v0.0.4a (Class System), v0.0.4b (Resource System), v0.0.4c (Ability System)
**Estimated Unit Tests:** ~35
**Estimated Implementation Effort:** Medium complexity

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Prerequisites & Dependencies](#prerequisites--dependencies)
3. [Architecture Overview](#architecture-overview)
4. [Command System Implementation](#command-system-implementation)
5. [Turn Processing System](#turn-processing-system)
6. [Combat Integration](#combat-integration)
7. [Presentation Layer Updates](#presentation-layer-updates)
8. [Service Layer Updates](#service-layer-updates)
9. [Implementation Phases](#implementation-phases)
10. [Unit Test Specifications](#unit-test-specifications)
11. [Acceptance Criteria](#acceptance-criteria)
12. [Deliverable Checklist](#deliverable-checklist)

---

## Executive Summary

v0.0.4d is the integration milestone that brings together the foundational systems built in v0.0.4a through v0.0.4c. This version focuses on:

1. **Command System**: Adding `ability` and `abilities` commands for ability usage
2. **Combat Integration**: Allowing abilities to be used during combat encounters
3. **Turn Processing**: Implementing turn boundaries with resource regeneration/decay and cooldown reduction
4. **Resource Management**: Displaying and tracking resource changes during gameplay
5. **Polish**: Ensuring smooth gameplay flow with proper feedback messages

### Key Deliverables
- New commands: `ability <name>`, `abilities`, `skills`, `skill <name>`
- Turn-end processing pipeline
- Combat ability execution
- Resource display in status bar
- Ability list display with costs and cooldowns

### Design Principles
1. **Consistency**: Follow existing command patterns established in codebase
2. **Feedback**: Clear, informative messages for all player actions
3. **Integration**: Seamless connection between previously built systems
4. **Testability**: Maintain existing test patterns and coverage standards

---

## Prerequisites & Dependencies

### From v0.0.4a (Class System)

| Component | Usage in v0.0.4d |
|-----------|------------------|
| `ClassDefinition` | Determines available abilities |
| `Player.ClassId` | Filters ability list by class |
| `ClassService` | Validates class-ability bindings |

### From v0.0.4b (Resource System)

| Component | Usage in v0.0.4d |
|-----------|------------------|
| `ResourceTypeDefinition` | Display configuration (colors, names) |
| `ResourcePool` | Track current/max values |
| `ResourceService` | `SpendResource()`, `ProcessTurnEnd()` |
| `Player.Resources` | Access to resource pools |
| `ResourceChangeResult` | Display resource changes |

### From v0.0.4c (Ability System)

| Component | Usage in v0.0.4d |
|-----------|------------------|
| `AbilityDefinition` | Ability data (cost, cooldown, effects) |
| `PlayerAbility` | Cooldown tracking, usage state |
| `AbilityService` | `CanUseAbility()`, `UseAbility()`, `ProcessTurnEnd()` |
| `AbilityResult` | Execute and report ability outcomes |
| `Player.Abilities` | Access to player's abilities |

### From Existing Codebase (v0.0.1)

| Component | Usage in v0.0.4d |
|-----------|------------------|
| `GameCommand` records | Base for new command types |
| `ConsoleInputHandler` | Command parsing |
| `GameView` | Command dispatch |
| `GameSessionService` | Action orchestration |
| `CombatService` | Combat integration |
| `SpectreGameRenderer` | Display updates |
| `IGameRenderer` | Interface extensions |

---

## Architecture Overview

### System Integration Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           v0.0.4d INTEGRATION LAYER                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                         COMMAND FLOW                                   │  │
│  │                                                                        │  │
│  │    User Input                                                          │  │
│  │        │                                                               │  │
│  │        ▼                                                               │  │
│  │  ┌─────────────────┐                                                  │  │
│  │  │ ConsoleInput    │  "ability flame-bolt"                            │  │
│  │  │ Handler         │  "abilities"                                     │  │
│  │  │                 │  "skill backstab"                                │  │
│  │  └────────┬────────┘                                                  │  │
│  │           │                                                            │  │
│  │           ▼                                                            │  │
│  │  ┌─────────────────┐     ┌─────────────────┐                         │  │
│  │  │ AbilityCommand  │     │ AbilitiesCommand │                         │  │
│  │  │ (abilityName)   │     │ ()               │                         │  │
│  │  └────────┬────────┘     └────────┬─────────┘                         │  │
│  │           │                       │                                    │  │
│  │           ▼                       ▼                                    │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │                        GameView                                  │  │  │
│  │  │              ProcessCommandAsync() switch                        │  │  │
│  │  │                                                                  │  │  │
│  │  │    case AbilityCommand   → HandleAbilityAsync(name)             │  │  │
│  │  │    case AbilitiesCommand → HandleAbilitiesAsync()               │  │  │
│  │  └────────────────────────────────┬────────────────────────────────┘  │  │
│  │                                   │                                    │  │
│  └───────────────────────────────────┼────────────────────────────────────┘  │
│                                      │                                       │
│  ┌───────────────────────────────────┼────────────────────────────────────┐  │
│  │                        SERVICE LAYER                                   │  │
│  │                                   │                                    │  │
│  │                                   ▼                                    │  │
│  │  ┌─────────────────────────────────────────────────────────────────┐  │  │
│  │  │                    GameSessionService                            │  │  │
│  │  │                                                                  │  │  │
│  │  │  + TryUseAbility(abilityName, target?) → AbilityCommandResult   │  │  │
│  │  │  + GetPlayerAbilities() → PlayerAbilitiesDto                    │  │  │
│  │  │  + ProcessTurnEnd() → TurnEndResult                             │  │  │
│  │  │  + IsInCombat() → bool                                          │  │  │
│  │  └─────────────────────────────────────────────────────────────────┘  │  │
│  │           │                       │                       │            │  │
│  │           ▼                       ▼                       ▼            │  │
│  │  ┌───────────────┐      ┌───────────────┐      ┌───────────────────┐  │  │
│  │  │ AbilityService│      │ResourceService│      │  CombatService    │  │  │
│  │  │               │      │               │      │                   │  │  │
│  │  │ UseAbility()  │      │ SpendResource │      │ ExecuteAbility()  │  │  │
│  │  │ ProcessTurn() │      │ ProcessTurn() │      │ ApplyEffects()    │  │  │
│  │  └───────────────┘      └───────────────┘      └───────────────────┘  │  │
│  │                                                                        │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │                         TURN PROCESSING                                 │  │
│  │                                                                         │  │
│  │    After Each Player Action:                                            │  │
│  │                                                                         │  │
│  │    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐               │  │
│  │    │ Increment   │    │ Resource    │    │ Cooldown    │               │  │
│  │    │ Turn Count  │───►│ Regen/Decay │───►│ Reduction   │               │  │
│  │    └─────────────┘    └─────────────┘    └─────────────┘               │  │
│  │                                                                         │  │
│  │    ResourceService.ProcessTurnEnd()  AbilityService.ProcessTurnEnd()   │  │
│  │                                                                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Command Processing Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      ABILITY COMMAND FLOW                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Player: "ability flame-bolt"                                               │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ ConsoleInputHandler.ParseCommand()                                   │    │
│  │                                                                      │    │
│  │   "ability" or "skill" → AbilityCommand(argument)                   │    │
│  │   "abilities" or "skills" → AbilitiesCommand()                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ GameView.ProcessCommandAsync()                                       │    │
│  │                                                                      │    │
│  │   case AbilityCommand(name) => HandleAbilityAsync(name)             │    │
│  │   case AbilitiesCommand => HandleAbilitiesAsync()                   │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ GameView.HandleAbilityAsync(abilityName)                            │    │
│  │                                                                      │    │
│  │   1. Check if in combat (some abilities require combat)             │    │
│  │   2. Call GameSessionService.TryUseAbility(name, target)            │    │
│  │   3. Render ability result                                          │    │
│  │   4. Call ProcessTurnEnd() (handled by service)                     │    │
│  │   5. Check for game state changes (GameOver, Victory)               │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ GameSessionService.TryUseAbility()                                   │    │
│  │                                                                      │    │
│  │   1. Get current target (monster in room if in combat)              │    │
│  │   2. Call AbilityService.UseAbility(player, abilityId, target)      │    │
│  │   3. If in combat, monster counterattacks                           │    │
│  │   4. Process turn end (resources + cooldowns)                       │    │
│  │   5. Return result with message                                     │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ SpectreGameRenderer.RenderAbilityResultAsync()                      │    │
│  │                                                                      │    │
│  │   Display: Ability name, effects applied, damage/healing done,      │    │
│  │           resource cost deducted, cooldown started                  │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Turn Boundary Processing

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       TURN BOUNDARY PROCESSING                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │                   TURN-ENDING ACTIONS                                  │  │
│  │                                                                        │  │
│  │  The following actions trigger turn-end processing:                   │  │
│  │                                                                        │  │
│  │  • MoveCommand (moving to new room)                                   │  │
│  │  • AttackCommand (basic attack)                                       │  │
│  │  • AbilityCommand (using any ability)                                 │  │
│  │  • UseCommand (using consumable items)                                │  │
│  │                                                                        │  │
│  │  NON-turn-ending actions:                                             │  │
│  │  • LookCommand, InventoryCommand, AbilitiesCommand                   │  │
│  │  • StatusCommand, HelpCommand, SaveCommand                           │  │
│  │  • TakeCommand (picking up items is free)                            │  │
│  │                                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                                                              │
│  After Turn-Ending Action Completes:                                        │
│                                                                              │
│  ┌─────────────────┐                                                        │
│  │ 1. INCREMENT    │                                                        │
│  │    TURN COUNT   │  GameSession.TurnCount++                               │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 2. PROCESS      │                                                        │
│  │    RESOURCES    │  ResourceService.ProcessTurnEnd(player, inCombat)      │
│  │                 │                                                        │
│  │  ┌────────────────────────────────────────────────────────────────┐     │
│  │  │ For each resource pool:                                         │     │
│  │  │                                                                 │     │
│  │  │   IF RegenPerTurn > 0 AND !IsFull:                             │     │
│  │  │     pool.Gain(regenAmount)                                     │     │
│  │  │     Log: "Mana +10 (80 → 90)"                                  │     │
│  │  │                                                                 │     │
│  │  │   IF DecayPerTurn > 0 AND !IsEmpty:                            │     │
│  │  │     IF !DecayOnlyOutOfCombat OR !inCombat:                     │     │
│  │  │       pool.Lose(decayAmount)                                   │     │
│  │  │       Log: "Rage -10 (50 → 40)"                                │     │
│  │  └────────────────────────────────────────────────────────────────┘     │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 3. PROCESS      │                                                        │
│  │    COOLDOWNS    │  AbilityService.ProcessTurnEnd(player)                 │
│  │                 │                                                        │
│  │  ┌────────────────────────────────────────────────────────────────┐     │
│  │  │ For each ability in player.Abilities:                          │     │
│  │  │                                                                 │     │
│  │  │   IF CurrentCooldown > 0:                                      │     │
│  │  │     ability.ReduceCooldown(1)                                  │     │
│  │  │     Log: "Shield Bash: 3 → 2 turns"                            │     │
│  │  │                                                                 │     │
│  │  │   IF CurrentCooldown == 0 AND WasOnCooldown:                   │     │
│  │  │     Log: "Shield Bash is now ready!"                           │     │
│  │  └────────────────────────────────────────────────────────────────┘     │
│  └────────┬────────┘                                                        │
│           │                                                                  │
│           ▼                                                                  │
│  ┌─────────────────┐                                                        │
│  │ 4. RETURN       │                                                        │
│  │    TURN RESULT  │  TurnEndResult with all changes for display            │
│  └─────────────────┘                                                        │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Command System Implementation

### 1. New Command Records

**File:** `src/Core/RuneAndRust.Application/Interfaces/IInputHandler.cs` (additions)

```csharp
/// <summary>
/// Command to use a specific ability.
/// </summary>
/// <param name="AbilityName">The name or ID of the ability to use.</param>
public record AbilityCommand(string AbilityName) : GameCommand;

/// <summary>
/// Command to list all available abilities.
/// </summary>
public record AbilitiesCommand : GameCommand;
```

### 2. Command Parsing Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/ConsoleInputHandler.cs`

```csharp
// Add to ParseCommand() switch expression:

"ability" or "skill" => string.IsNullOrEmpty(argument)
    ? LogAndReturn(new UnknownCommand(input), "Ability command requires ability name")
    : new AbilityCommand(argument),

"abilities" or "skills" => new AbilitiesCommand(),
```

### 3. Command Handler Methods

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs`

```csharp
/// <summary>
/// Handles the ability command to use a specific ability.
/// </summary>
private async Task<bool> HandleAbilityAsync(string abilityName, CancellationToken ct)
{
    _logger.LogDebug("HandleAbilityAsync: {AbilityName}", abilityName);

    var result = _gameService.TryUseAbility(abilityName);

    if (result.Success)
    {
        await _renderer.RenderAbilityResultAsync(result, ct);

        // Check for combat victory/defeat
        if (result.TargetDefeated)
        {
            await _renderer.RenderMessageAsync(
                $"The {result.TargetName} has been defeated!",
                MessageType.Success, ct);
        }

        // Render turn-end changes (resource regen, cooldown changes)
        if (result.TurnEndChanges != null && result.TurnEndChanges.HasChanges)
        {
            await _renderer.RenderTurnEndChangesAsync(result.TurnEndChanges, ct);
        }
    }
    else
    {
        await _renderer.RenderMessageAsync(result.Message, MessageType.Warning, ct);
    }

    return await CheckGameStateAsync(ct);
}

/// <summary>
/// Handles the abilities command to list all available abilities.
/// </summary>
private async Task<bool> HandleAbilitiesAsync(CancellationToken ct)
{
    _logger.LogDebug("HandleAbilitiesAsync");

    var abilities = _gameService.GetPlayerAbilities();

    if (abilities == null)
    {
        await _renderer.RenderMessageAsync(
            "No active game session.", MessageType.Warning, ct);
        return true;
    }

    if (abilities.Abilities.Count == 0)
    {
        await _renderer.RenderMessageAsync(
            "You have no abilities.", MessageType.Info, ct);
        return true;
    }

    await _renderer.RenderAbilitiesListAsync(abilities, ct);
    return true;
}
```

### 4. ProcessCommandAsync Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Views/GameView.cs`

```csharp
// Add to ProcessCommandAsync() switch:

AbilityCommand abilityCmd => await HandleAbilityAsync(abilityCmd.AbilityName, ct),
AbilitiesCommand => await HandleAbilitiesAsync(ct),
```

---

## Turn Processing System

### 1. Turn-Ending Action Identification

**Design Decision:** Not all player actions should advance the turn counter and trigger regeneration/cooldowns.

| Action | Ends Turn? | Rationale |
|--------|------------|-----------|
| `MoveCommand` | Yes | Movement is a significant action |
| `AttackCommand` | Yes | Combat action |
| `AbilityCommand` | Yes | Combat/major action |
| `UseCommand` | Yes | Consuming items takes effort |
| `TakeCommand` | No | Quick action, doesn't use resources |
| `DropCommand` | No | Quick action |
| `LookCommand` | No | Information only |
| `InventoryCommand` | No | Information only |
| `AbilitiesCommand` | No | Information only |
| `StatusCommand` | No | Information only |
| `HelpCommand` | No | Meta action |
| `SaveCommand` | No | Meta action |

### 2. TurnEndResult Record

**File:** `src/Core/RuneAndRust.Application/DTOs/TurnEndResult.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Contains all changes that occurred during turn-end processing.
/// </summary>
public record TurnEndResult(
    int NewTurnCount,
    IReadOnlyList<ResourceChangeDto> ResourceChanges,
    IReadOnlyList<CooldownChangeDto> CooldownChanges,
    IReadOnlyList<string> AbilitiesNowReady)
{
    public bool HasChanges =>
        ResourceChanges.Count > 0 ||
        CooldownChanges.Count > 0 ||
        AbilitiesNowReady.Count > 0;

    public static TurnEndResult Empty(int turnCount) => new(
        turnCount,
        Array.Empty<ResourceChangeDto>(),
        Array.Empty<CooldownChangeDto>(),
        Array.Empty<string>());
}

/// <summary>
/// Represents a resource change during turn processing.
/// </summary>
public record ResourceChangeDto(
    string ResourceName,
    string ResourceAbbreviation,
    int PreviousValue,
    int NewValue,
    int MaxValue,
    string ChangeType,  // "Regeneration", "Decay"
    string Color);

/// <summary>
/// Represents a cooldown change during turn processing.
/// </summary>
public record CooldownChangeDto(
    string AbilityName,
    int PreviousCooldown,
    int NewCooldown,
    bool IsNowReady);
```

### 3. GameSession Turn Tracking

**File:** `src/Core/RuneAndRust.Domain/Entities/GameSession.cs` (additions)

```csharp
/// <summary>
/// Gets the current turn number.
/// </summary>
public int TurnCount { get; private set; } = 0;

/// <summary>
/// Advances to the next turn.
/// </summary>
/// <returns>The new turn count.</returns>
public int AdvanceTurn()
{
    TurnCount++;
    UpdateLastPlayed();
    return TurnCount;
}
```

### 4. GameSessionService.ProcessTurnEnd()

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

```csharp
/// <summary>
/// Processes end-of-turn effects including resource regeneration and cooldown reduction.
/// </summary>
/// <returns>Summary of all turn-end changes.</returns>
public TurnEndResult ProcessTurnEnd()
{
    if (_currentSession == null)
    {
        _logger.LogWarning("ProcessTurnEnd called with no active session");
        return TurnEndResult.Empty(0);
    }

    var player = _currentSession.Player;
    var inCombat = IsInCombat();

    // Advance turn counter
    var newTurnCount = _currentSession.AdvanceTurn();
    _logger.LogDebug("Turn advanced to {TurnCount}", newTurnCount);

    // Process resource regeneration/decay
    var resourceResult = _resourceService.ProcessTurnEnd(player, inCombat);
    var resourceChanges = resourceResult.Changes
        .Select(c => MapResourceChange(c))
        .ToList();

    // Process ability cooldowns
    var cooldownChanges = new List<CooldownChangeDto>();
    var abilitiesNowReady = new List<string>();

    foreach (var ability in player.Abilities.Values.Where(a => a.IsOnCooldown))
    {
        var previousCooldown = ability.CurrentCooldown;
        ability.ReduceCooldown();

        var definition = _abilityService.GetAbilityDefinition(ability.AbilityDefinitionId);
        var abilityName = definition?.Name ?? ability.AbilityDefinitionId;

        cooldownChanges.Add(new CooldownChangeDto(
            abilityName,
            previousCooldown,
            ability.CurrentCooldown,
            ability.IsReady));

        if (ability.IsReady)
        {
            abilitiesNowReady.Add(abilityName);
            _logger.LogInformation("{Ability} is now ready", abilityName);
        }
    }

    _logger.LogInformation(
        "Turn {Turn} ended: {ResourceChanges} resource changes, {CooldownChanges} cooldown changes",
        newTurnCount, resourceChanges.Count, cooldownChanges.Count);

    return new TurnEndResult(newTurnCount, resourceChanges, cooldownChanges, abilitiesNowReady);
}

private ResourceChangeDto MapResourceChange(ResourceChange change)
{
    var resourceType = _resourceService.GetResourceType(change.ResourceTypeId);
    return new ResourceChangeDto(
        resourceType?.DisplayName ?? change.ResourceTypeId,
        resourceType?.Abbreviation ?? "??",
        change.PreviousValue,
        change.NewValue,
        resourceType?.DefaultMax ?? 100,
        change.ChangeType.ToString(),
        resourceType?.Color ?? "#FFFFFF");
}
```

---

## Combat Integration

### 1. Combat Flow with Abilities

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    COMBAT WITH ABILITIES FLOW                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  COMBAT START                                                                │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Player enters room with monster OR monster appears                   │    │
│  │ → Display: "A Goblin blocks your path!"                             │    │
│  │ → Set: InCombat = true                                              │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  PLAYER TURN OPTIONS                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                                                                      │    │
│  │  Option 1: Basic Attack                                             │    │
│  │  ┌────────────────────────────────────────────────────────────┐     │    │
│  │  │ > attack                                                    │     │    │
│  │  │                                                             │     │    │
│  │  │ CombatService.ResolveCombatRound(player, monster)          │     │    │
│  │  │ → Player attacks for X damage                              │     │    │
│  │  │ → Monster counterattacks for Y damage                      │     │    │
│  │  │ → Turn ends, ProcessTurnEnd()                              │     │    │
│  │  └────────────────────────────────────────────────────────────┘     │    │
│  │                                                                      │    │
│  │  Option 2: Use Ability                                              │    │
│  │  ┌────────────────────────────────────────────────────────────┐     │    │
│  │  │ > ability flame-bolt                                        │     │    │
│  │  │                                                             │     │    │
│  │  │ AbilityService.CanUseAbility() validation                  │     │    │
│  │  │ → Check has ability, cooldown, resources                   │     │    │
│  │  │                                                             │     │    │
│  │  │ If valid:                                                   │     │    │
│  │  │   ResourceService.SpendResource(mana, 15)                  │     │    │
│  │  │   AbilityService.UseAbility(player, "flame-bolt", monster) │     │    │
│  │  │   → Apply damage effect to monster                         │     │    │
│  │  │   → Set cooldown on ability                                │     │    │
│  │  │   Monster counterattacks (if alive)                        │     │    │
│  │  │   ProcessTurnEnd()                                         │     │    │
│  │  │                                                             │     │    │
│  │  │ Display:                                                    │     │    │
│  │  │   "Flame Bolt deals 25 fire damage to Goblin!"            │     │    │
│  │  │   "Mana: 100 → 85 (-15)"                                  │     │    │
│  │  │   "Goblin strikes back for 8 damage!"                     │     │    │
│  │  └────────────────────────────────────────────────────────────┘     │    │
│  │                                                                      │    │
│  │  Option 3: Self-Targeted Ability (buff/heal)                        │    │
│  │  ┌────────────────────────────────────────────────────────────┐     │    │
│  │  │ > ability healing-word                                      │     │    │
│  │  │                                                             │     │    │
│  │  │ AbilityService.UseAbility(player, "healing-word", player)  │     │    │
│  │  │ → Apply heal effect to player                              │     │    │
│  │  │ Monster attacks (still the monster's turn response)        │     │    │
│  │  │ ProcessTurnEnd()                                           │     │    │
│  │  │                                                             │     │    │
│  │  │ Display:                                                    │     │    │
│  │  │   "Healing Word restores 25 health!"                       │     │    │
│  │  │   "Faith: 100 → 80 (-20)"                                  │     │    │
│  │  │   "Goblin strikes for 8 damage!"                           │     │    │
│  │  └────────────────────────────────────────────────────────────┘     │    │
│  │                                                                      │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
│  COMBAT END                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │ Monster HP <= 0:                                                    │    │
│  │   → "The Goblin has been defeated!"                                │    │
│  │   → InCombat = false                                               │    │
│  │   → Award XP (future)                                              │    │
│  │   → Drop loot (future)                                             │    │
│  │                                                                      │    │
│  │ Player HP <= 0:                                                     │    │
│  │   → "You have been defeated!"                                      │    │
│  │   → GameState = GameOver                                           │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2. GameSessionService.TryUseAbility()

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

```csharp
/// <summary>
/// Result of attempting to use an ability.
/// </summary>
public record AbilityCommandResult(
    bool Success,
    string Message,
    string? AbilityName,
    int? DamageDealt,
    int? HealingDone,
    int? ResourceSpent,
    string? ResourceType,
    bool TargetDefeated,
    string? TargetName,
    int? DamageReceived,
    bool PlayerDefeated,
    TurnEndResult? TurnEndChanges);

/// <summary>
/// Attempts to use an ability.
/// </summary>
/// <param name="abilityName">The ability ID or name to use.</param>
/// <returns>Result of the ability use attempt.</returns>
public AbilityCommandResult TryUseAbility(string abilityName)
{
    _logger.LogDebug("TryUseAbility: {AbilityName}", abilityName);

    if (_currentSession == null)
    {
        return new AbilityCommandResult(false, "No active game session.",
            null, null, null, null, null, false, null, null, false, null);
    }

    var player = _currentSession.Player;

    // Validate ability can be used
    var validation = _abilityService.CanUseAbility(player, abilityName);
    if (!validation.IsValid)
    {
        _logger.LogDebug("Ability validation failed: {Reason}", validation.FailureReason);
        return new AbilityCommandResult(false, validation.FailureReason!,
            null, null, null, null, null, false, null, null, false, null);
    }

    var definition = _abilityService.GetAbilityDefinition(abilityName);

    // Determine target
    object? target = null;
    string? targetName = null;
    var inCombat = IsInCombat();

    if (definition!.TargetType == AbilityTargetType.SingleEnemy ||
        definition.TargetType == AbilityTargetType.AllEnemies)
    {
        if (!inCombat)
        {
            return new AbilityCommandResult(false, "No enemy to target.",
                null, null, null, null, null, false, null, null, false, null);
        }

        var room = _currentSession.Dungeon.GetRoom(_currentSession.CurrentRoomId);
        target = room?.GetAliveMonsters().FirstOrDefault();
        targetName = (target as Monster)?.Name;
    }
    else if (definition.TargetType == AbilityTargetType.Self)
    {
        target = player;
        targetName = player.Name;
    }

    // Use the ability
    var abilityResult = _abilityService.UseAbility(player, abilityName, target);

    if (!abilityResult.Success)
    {
        return new AbilityCommandResult(false, abilityResult.Message,
            null, null, null, null, null, false, null, null, false, null);
    }

    // Monster counterattack if in combat
    int? damageReceived = null;
    bool playerDefeated = false;

    if (inCombat && target is Monster monster && !monster.IsDefeated)
    {
        var counterDamage = _combatService.CalculateMonsterDamage(monster, player);
        player.TakeDamage(counterDamage);
        damageReceived = counterDamage;

        _logger.LogInformation(
            "{Monster} counterattacks {Player} for {Damage} damage",
            monster.Name, player.Name, counterDamage);

        if (player.IsDead)
        {
            _currentSession.SetState(GameState.GameOver);
            playerDefeated = true;
        }
    }

    // Process turn end
    var turnEndResult = ProcessTurnEnd();

    // Check if target was defeated
    var targetDefeated = target is Monster m && m.IsDefeated;

    _logger.LogInformation(
        "Ability {Ability} used successfully. Damage: {Damage}, Healing: {Healing}",
        definition.Name, abilityResult.TotalDamageDealt, abilityResult.TotalHealingDone);

    return new AbilityCommandResult(
        true,
        abilityResult.Message,
        definition.Name,
        abilityResult.TotalDamageDealt > 0 ? abilityResult.TotalDamageDealt : null,
        abilityResult.TotalHealingDone > 0 ? abilityResult.TotalHealingDone : null,
        abilityResult.ResourceSpent?.Delta != 0 ? Math.Abs(abilityResult.ResourceSpent!.Delta) : null,
        abilityResult.ResourceSpent?.ResourceTypeId,
        targetDefeated,
        targetName,
        damageReceived,
        playerDefeated,
        turnEndResult);
}

/// <summary>
/// Gets whether the player is currently in combat.
/// </summary>
public bool IsInCombat()
{
    if (_currentSession == null) return false;

    var room = _currentSession.Dungeon.GetRoom(_currentSession.CurrentRoomId);
    return room?.GetAliveMonsters().Any() ?? false;
}
```

### 3. CombatService Updates

**File:** `src/Core/RuneAndRust.Domain/Services/CombatService.cs` (additions)

```csharp
/// <summary>
/// Calculates damage a monster deals to a player (for counterattacks).
/// </summary>
public int CalculateMonsterDamage(Monster monster, Player player)
{
    return CalculateDamage(monster.Stats.Attack, player.Stats.Defense);
}

/// <summary>
/// Applies ability effects in combat.
/// </summary>
/// <param name="player">The player using the ability.</param>
/// <param name="ability">The ability being used.</param>
/// <param name="target">The target (monster).</param>
/// <returns>Combat result with damage/effects.</returns>
public CombatAbilityResult ExecuteAbility(Player player, AbilityDefinition ability, Monster target)
{
    _logger.LogDebug(
        "ExecuteAbility: Player {Player} uses {Ability} on {Target}",
        player.Name, ability.Name, target.Name);

    var totalDamage = 0;
    var effectsApplied = new List<string>();

    foreach (var effect in ability.Effects)
    {
        switch (effect.EffectType)
        {
            case AbilityEffectType.Damage:
                var damage = CalculateAbilityDamage(player, effect);
                target.TakeDamage(damage);
                totalDamage += damage;
                effectsApplied.Add($"{damage} damage");
                break;

            case AbilityEffectType.DamageOverTime:
                // Future: Add DoT tracking to monster
                effectsApplied.Add($"Applied {effect.StatusEffect}");
                break;

            case AbilityEffectType.Debuff:
                // Future: Add debuff tracking to monster
                if (!string.IsNullOrEmpty(effect.StatusEffect))
                {
                    effectsApplied.Add($"Applied {effect.StatusEffect}");
                }
                break;
        }
    }

    return new CombatAbilityResult(
        totalDamage,
        target.IsDefeated,
        effectsApplied);
}

private int CalculateAbilityDamage(Player player, AbilityEffect effect)
{
    var baseDamage = effect.Value;

    if (effect.HasScaling && !string.IsNullOrEmpty(effect.ScalingStat))
    {
        var statValue = effect.ScalingStat.ToLowerInvariant() switch
        {
            "attack" => player.Stats.Attack,
            "will" => player.Stats.Attack, // Placeholder
            _ => 0
        };
        baseDamage += (int)(statValue * effect.ScalingMultiplier);
    }

    // Add small variance
    var variance = _random.Next(-2, 3);
    return Math.Max(1, baseDamage + variance);
}
```

---

## Presentation Layer Updates

### 1. IGameRenderer Interface Extensions

**File:** `src/Core/RuneAndRust.Application/Interfaces/IGameRenderer.cs` (additions)

```csharp
/// <summary>
/// Renders the list of player abilities with costs and cooldowns.
/// </summary>
Task RenderAbilitiesListAsync(PlayerAbilitiesDto abilities, CancellationToken ct = default);

/// <summary>
/// Renders the result of using an ability.
/// </summary>
Task RenderAbilityResultAsync(AbilityCommandResult result, CancellationToken ct = default);

/// <summary>
/// Renders turn-end changes (resource regen/decay, cooldown changes).
/// </summary>
Task RenderTurnEndChangesAsync(TurnEndResult changes, CancellationToken ct = default);

/// <summary>
/// Renders the player's resource bars.
/// </summary>
Task RenderResourceBarsAsync(IReadOnlyList<ResourcePoolDto> resources, CancellationToken ct = default);
```

### 2. SpectreGameRenderer Implementation

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

```csharp
/// <summary>
/// Renders the list of player abilities.
/// </summary>
public async Task RenderAbilitiesListAsync(PlayerAbilitiesDto abilities, CancellationToken ct = default)
{
    await Task.Yield(); // Allow cancellation check

    var table = new Table()
        .Border(TableBorder.Rounded)
        .Title("[yellow]Available Abilities[/]")
        .AddColumn("Ability")
        .AddColumn("Cost")
        .AddColumn("Cooldown")
        .AddColumn("Status")
        .AddColumn("Description");

    foreach (var ability in abilities.Abilities)
    {
        var costText = ability.Cost > 0
            ? $"[{GetResourceColor(ability.CostResourceType)}]{ability.Cost} {ability.CostResourceType}[/]"
            : "[gray]Free[/]";

        var cooldownText = ability.MaxCooldown > 0
            ? $"{ability.MaxCooldown} turns"
            : "Instant";

        string statusText;
        if (!ability.IsUnlocked)
        {
            statusText = $"[red]Locked (Lvl {ability.UnlockLevel})[/]";
        }
        else if (ability.CurrentCooldown > 0)
        {
            statusText = $"[yellow]CD: {ability.CurrentCooldown}[/]";
        }
        else
        {
            statusText = "[green]Ready[/]";
        }

        table.AddRow(
            $"[white]{Markup.Escape(ability.Name)}[/]",
            costText,
            cooldownText,
            statusText,
            $"[gray]{Markup.Escape(ability.Description)}[/]"
        );
    }

    AnsiConsole.Write(table);

    // Show resources
    if (abilities.Resources.Count > 0)
    {
        AnsiConsole.WriteLine();
        await RenderResourceBarsAsync(abilities.Resources, ct);
    }
}

/// <summary>
/// Renders the result of using an ability.
/// </summary>
public async Task RenderAbilityResultAsync(AbilityCommandResult result, CancellationToken ct = default)
{
    await Task.Yield();

    var panel = new Panel(BuildAbilityResultText(result))
        .Header($"[yellow]{Markup.Escape(result.AbilityName ?? "Ability")}[/]")
        .Border(BoxBorder.Rounded)
        .BorderColor(Color.Cyan1);

    AnsiConsole.Write(panel);
}

private string BuildAbilityResultText(AbilityCommandResult result)
{
    var lines = new List<string>();

    if (result.DamageDealt.HasValue)
    {
        lines.Add($"[red]Dealt {result.DamageDealt} damage to {result.TargetName}[/]");
    }

    if (result.HealingDone.HasValue)
    {
        lines.Add($"[green]Restored {result.HealingDone} health[/]");
    }

    if (result.ResourceSpent.HasValue)
    {
        var color = GetResourceColor(result.ResourceType ?? "");
        lines.Add($"[{color}]Cost: {result.ResourceSpent} {result.ResourceType}[/]");
    }

    if (result.DamageReceived.HasValue)
    {
        lines.Add($"[red]{result.TargetName} counterattacks for {result.DamageReceived} damage![/]");
    }

    if (result.TargetDefeated)
    {
        lines.Add($"[green]{result.TargetName} has been defeated![/]");
    }

    if (result.PlayerDefeated)
    {
        lines.Add("[red]You have been defeated![/]");
    }

    return string.Join("\n", lines);
}

/// <summary>
/// Renders turn-end changes.
/// </summary>
public async Task RenderTurnEndChangesAsync(TurnEndResult changes, CancellationToken ct = default)
{
    await Task.Yield();

    if (!changes.HasChanges) return;

    var lines = new List<string>();

    foreach (var rc in changes.ResourceChanges)
    {
        var delta = rc.NewValue - rc.PreviousValue;
        var sign = delta >= 0 ? "+" : "";
        var changeType = rc.ChangeType == "Regeneration" ? "regenerates" : "decays";
        lines.Add($"[{rc.Color}]{rc.ResourceName} {changeType}: {sign}{delta} ({rc.PreviousValue} → {rc.NewValue})[/]");
    }

    foreach (var ability in changes.AbilitiesNowReady)
    {
        lines.Add($"[green]{ability} is now ready![/]");
    }

    if (lines.Count > 0)
    {
        var panel = new Panel(string.Join("\n", lines))
            .Header("[gray]Turn End[/]")
            .Border(BoxBorder.Rounded)
            .BorderColor(Color.Grey);

        AnsiConsole.Write(panel);
    }
}

/// <summary>
/// Renders resource bars.
/// </summary>
public async Task RenderResourceBarsAsync(IReadOnlyList<ResourcePoolDto> resources, CancellationToken ct = default)
{
    await Task.Yield();

    foreach (var resource in resources)
    {
        var color = GetResourceColor(resource.ResourceTypeId);
        var percentage = resource.Maximum > 0
            ? (double)resource.Current / resource.Maximum
            : 0;

        var barWidth = 20;
        var filledWidth = (int)(percentage * barWidth);
        var emptyWidth = barWidth - filledWidth;

        var bar = new string('█', filledWidth) + new string('░', emptyWidth);

        AnsiConsole.MarkupLine(
            $"[{color}]{resource.Abbreviation}: {resource.Current}/{resource.Maximum} [{bar}][/]");
    }
}

private string GetResourceColor(string resourceType)
{
    return resourceType.ToLowerInvariant() switch
    {
        "health" or "hp" => "red",
        "mana" or "mp" => "blue",
        "rage" or "rg" => "orange1",
        "energy" or "en" => "yellow",
        "faith" or "fth" => "gold1",
        "focus" or "foc" => "cyan1",
        _ => "white"
    };
}
```

### 3. Status Bar Updates

**File:** `src/Presentation/RuneAndRust.Presentation.Tui/Adapters/SpectreGameRenderer.cs`

```csharp
/// <summary>
/// Renders the status bar with health and resources.
/// </summary>
private void RenderStatusBar(PlayerStatsDto player, IReadOnlyList<ResourcePoolDto>? resources)
{
    var healthColor = player.HealthPercentage switch
    {
        > 0.66 => "green",
        > 0.33 => "yellow",
        _ => "red"
    };

    var columns = new List<string>
    {
        $"[white]{Markup.Escape(player.Name)}[/]",
        $"[{healthColor}]HP: {player.Health}/{player.MaxHealth}[/]"
    };

    // Add resource pools
    if (resources != null)
    {
        foreach (var resource in resources.Where(r => r.ResourceTypeId != "health"))
        {
            var color = GetResourceColor(resource.ResourceTypeId);
            columns.Add($"[{color}]{resource.Abbreviation}: {resource.Current}/{resource.Maximum}[/]");
        }
    }

    columns.Add($"[cyan]ATK: {player.Attack}[/]");
    columns.Add($"[blue]DEF: {player.Defense}[/]");

    var statusTable = new Table()
        .Border(TableBorder.None)
        .HideHeaders();

    foreach (var _ in columns)
    {
        statusTable.AddColumn(new TableColumn("").NoWrap());
    }

    statusTable.AddRow(columns.Select(c => new Markup(c)).ToArray());

    AnsiConsole.Write(statusTable);
}
```

### 4. Help Text Updates

**File:** Update help command output to include ability commands

```csharp
private void RenderHelpText()
{
    var helpTable = new Table()
        .Border(TableBorder.Rounded)
        .Title("[yellow]Available Commands[/]")
        .AddColumn("Command")
        .AddColumn("Description");

    // Movement commands
    helpTable.AddRow("[cyan]n, north[/]", "Move north");
    helpTable.AddRow("[cyan]s, south[/]", "Move south");
    helpTable.AddRow("[cyan]e, east[/]", "Move east");
    helpTable.AddRow("[cyan]w, west[/]", "Move west");

    // Combat commands
    helpTable.AddRow("[cyan]attack[/]", "Attack the enemy in the room");
    helpTable.AddRow("[cyan]ability <name>[/]", "Use an ability (e.g., 'ability flame-bolt')");
    helpTable.AddRow("[cyan]skill <name>[/]", "Alias for ability");

    // Information commands
    helpTable.AddRow("[cyan]look[/]", "Look around the current room");
    helpTable.AddRow("[cyan]abilities[/]", "List your available abilities");
    helpTable.AddRow("[cyan]skills[/]", "Alias for abilities");
    helpTable.AddRow("[cyan]inventory, inv, i[/]", "View your inventory");
    helpTable.AddRow("[cyan]status[/]", "View your character status");

    // Item commands
    helpTable.AddRow("[cyan]take <item>[/]", "Pick up an item");
    helpTable.AddRow("[cyan]use <item>[/]", "Use an item from inventory");

    // Game commands
    helpTable.AddRow("[cyan]save[/]", "Save the game");
    helpTable.AddRow("[cyan]help[/]", "Show this help message");
    helpTable.AddRow("[cyan]quit[/]", "Quit the game");

    AnsiConsole.Write(helpTable);
}
```

---

## Service Layer Updates

### 1. PlayerAbilitiesDto

**File:** `src/Core/RuneAndRust.Application/DTOs/PlayerAbilitiesDto.cs`

```csharp
namespace RuneAndRust.Application.DTOs;

/// <summary>
/// Contains all ability and resource information for display.
/// </summary>
public record PlayerAbilitiesDto(
    IReadOnlyList<PlayerAbilityDisplayDto> Abilities,
    IReadOnlyList<ResourcePoolDto> Resources);

/// <summary>
/// Display-friendly ability information.
/// </summary>
public record PlayerAbilityDisplayDto(
    string AbilityId,
    string Name,
    string Description,
    int Cost,
    string CostResourceType,
    int CurrentCooldown,
    int MaxCooldown,
    bool IsReady,
    bool IsUnlocked,
    int UnlockLevel,
    IReadOnlyList<string> Tags);

/// <summary>
/// Display-friendly resource pool information.
/// </summary>
public record ResourcePoolDto(
    string ResourceTypeId,
    string DisplayName,
    string Abbreviation,
    string Color,
    int Current,
    int Maximum,
    float Percentage);
```

### 2. GameSessionService.GetPlayerAbilities()

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

```csharp
/// <summary>
/// Gets the player's abilities and resources for display.
/// </summary>
public PlayerAbilitiesDto? GetPlayerAbilities()
{
    if (_currentSession == null)
    {
        _logger.LogDebug("GetPlayerAbilities: No active session");
        return null;
    }

    var player = _currentSession.Player;

    // Get abilities
    var abilities = player.Abilities.Values
        .Select(pa =>
        {
            var def = _abilityService.GetAbilityDefinition(pa.AbilityDefinitionId);
            return new PlayerAbilityDisplayDto(
                pa.AbilityDefinitionId,
                def?.Name ?? pa.AbilityDefinitionId,
                def?.Description ?? "",
                def?.Cost.Amount ?? 0,
                def?.Cost.ResourceTypeId ?? "",
                pa.CurrentCooldown,
                def?.Cooldown ?? 0,
                pa.IsReady,
                pa.IsUnlocked,
                def?.UnlockLevel ?? 1,
                def?.Tags.ToList() ?? new List<string>());
        })
        .OrderBy(a => a.Name)
        .ToList();

    // Get resources
    var resources = _resourceService.GetPlayerResources(player);

    return new PlayerAbilitiesDto(abilities, resources);
}
```

### 3. Integration with Existing TryAttack

**File:** `src/Core/RuneAndRust.Application/Services/GameSessionService.cs`

Update `TryAttack()` to also call `ProcessTurnEnd()`:

```csharp
public (bool Success, string Message) TryAttack()
{
    // ... existing validation code ...

    var monster = currentRoom.GetAliveMonsters().FirstOrDefault();

    if (monster == null)
    {
        return (false, "There's nothing to attack here.");
    }

    // Execute combat round
    var result = _combatService.ResolveCombatRound(_currentSession.Player, monster);
    var description = _combatService.GetCombatDescription(result, playerName, monster.Name);

    // Process combat-related resource building (Rage on damage dealt/taken)
    _resourceService.ProcessCombatHit(_currentSession.Player, result.DamageDealt, result.DamageReceived);

    // Check for game over
    if (result.PlayerDefeated)
    {
        _currentSession.SetState(GameState.GameOver);
    }

    // Process turn end
    var turnEnd = ProcessTurnEnd();

    // Append turn-end info to description if meaningful
    if (turnEnd.HasChanges)
    {
        description += BuildTurnEndDescription(turnEnd);
    }

    return (true, description);
}

private string BuildTurnEndDescription(TurnEndResult turnEnd)
{
    var parts = new List<string>();

    foreach (var rc in turnEnd.ResourceChanges)
    {
        var delta = rc.NewValue - rc.PreviousValue;
        if (delta != 0)
        {
            var sign = delta > 0 ? "+" : "";
            parts.Add($"{rc.ResourceAbbreviation} {sign}{delta}");
        }
    }

    foreach (var ability in turnEnd.AbilitiesNowReady)
    {
        parts.Add($"{ability} ready!");
    }

    return parts.Count > 0 ? $"\n[{string.Join(", ", parts)}]" : "";
}
```

---

## Implementation Phases

### Phase 1: Command Infrastructure (Priority: Critical)
**Estimated Tasks:** 4

1. Add `AbilityCommand` and `AbilitiesCommand` records to `IInputHandler.cs`
2. Update `ConsoleInputHandler.ParseCommand()` with new command parsing
3. Add command cases to `GameView.ProcessCommandAsync()`
4. Implement `HandleAbilityAsync()` and `HandleAbilitiesAsync()` handlers

### Phase 2: Turn Processing System (Priority: Critical)
**Estimated Tasks:** 5

1. Add `TurnCount` property and `AdvanceTurn()` to `GameSession`
2. Create `TurnEndResult` and related DTOs
3. Implement `GameSessionService.ProcessTurnEnd()`
4. Identify turn-ending vs non-turn-ending actions
5. Call `ProcessTurnEnd()` from appropriate action handlers

### Phase 3: Combat Integration (Priority: High)
**Estimated Tasks:** 4

1. Implement `GameSessionService.TryUseAbility()`
2. Add `CalculateMonsterDamage()` to `CombatService`
3. Implement monster counterattack logic in ability use
4. Update `TryAttack()` to include turn-end processing

### Phase 4: Presentation Layer (Priority: High)
**Estimated Tasks:** 6

1. Add new methods to `IGameRenderer` interface
2. Implement `RenderAbilitiesListAsync()`
3. Implement `RenderAbilityResultAsync()`
4. Implement `RenderTurnEndChangesAsync()`
5. Implement `RenderResourceBarsAsync()`
6. Update status bar to include resources

### Phase 5: Service DTOs and Mapping (Priority: Medium)
**Estimated Tasks:** 3

1. Create `PlayerAbilitiesDto` and related records
2. Create `AbilityCommandResult` record
3. Implement `GetPlayerAbilities()` in `GameSessionService`

### Phase 6: Polish and Help (Priority: Medium)
**Estimated Tasks:** 3

1. Update help text with ability commands
2. Add clear error messages for all failure cases
3. Add logging throughout new code paths

### Phase 7: Testing (Priority: Critical)
**Estimated Tasks:** ~35 unit tests

See [Unit Test Specifications](#unit-test-specifications) below.

---

## Unit Test Specifications

### Command Parsing Tests (~6 tests)

```csharp
[TestFixture]
public class AbilityCommandParsingTests
{
    [Test]
    public void ParseCommand_Ability_WithName_ReturnsAbilityCommand()
    {
        var handler = new ConsoleInputHandler(Mock.Of<ILogger<ConsoleInputHandler>>());
        // Use reflection or test helper to call ParseCommand
        var result = handler.ParseCommand("ability flame-bolt");
        result.Should().BeOfType<AbilityCommand>();
        ((AbilityCommand)result).AbilityName.Should().Be("flame-bolt");
    }

    [Test]
    public void ParseCommand_Skill_WithName_ReturnsAbilityCommand()
    {
        // "skill" alias should work the same
    }

    [Test]
    public void ParseCommand_Ability_WithoutName_ReturnsUnknownCommand()
    {
        // Missing ability name should fail gracefully
    }

    [Test]
    public void ParseCommand_Abilities_ReturnsAbilitiesCommand()
    {
        var result = handler.ParseCommand("abilities");
        result.Should().BeOfType<AbilitiesCommand>();
    }

    [Test]
    public void ParseCommand_Skills_ReturnsAbilitiesCommand()
    {
        // "skills" alias should work
    }

    [Test]
    public void ParseCommand_Ability_WithSpacesInName_ParsesCorrectly()
    {
        // "ability healing word" should parse as "healing word"
    }
}
```

### TryUseAbility Tests (~10 tests)

```csharp
[TestFixture]
public class TryUseAbilityTests
{
    [Test]
    public void TryUseAbility_WithNoSession_ReturnsFalse();

    [Test]
    public void TryUseAbility_WithInvalidAbility_ReturnsFalse();

    [Test]
    public void TryUseAbility_OnCooldown_ReturnsFalse();

    [Test]
    public void TryUseAbility_InsufficientResource_ReturnsFalse();

    [Test]
    public void TryUseAbility_Valid_DeductsResource();

    [Test]
    public void TryUseAbility_Valid_SetsCooldown();

    [Test]
    public void TryUseAbility_DamageAbility_DamagesTarget();

    [Test]
    public void TryUseAbility_HealAbility_HealsPlayer();

    [Test]
    public void TryUseAbility_InCombat_MonsterCounterattacks();

    [Test]
    public void TryUseAbility_KillsMonster_ReturnsTargetDefeated();
}
```

### Turn Processing Tests (~8 tests)

```csharp
[TestFixture]
public class TurnProcessingTests
{
    [Test]
    public void ProcessTurnEnd_IncrementsTurnCount();

    [Test]
    public void ProcessTurnEnd_RegeneratesMana();

    [Test]
    public void ProcessTurnEnd_DecaysRage_WhenOutOfCombat();

    [Test]
    public void ProcessTurnEnd_DoesNotDecayRage_WhenInCombat();

    [Test]
    public void ProcessTurnEnd_ReducesCooldowns();

    [Test]
    public void ProcessTurnEnd_ReportsAbilityReady();

    [Test]
    public void ProcessTurnEnd_WithNoSession_ReturnsEmpty();

    [Test]
    public void ProcessTurnEnd_ReturnsAllChanges();
}
```

### Combat Integration Tests (~6 tests)

```csharp
[TestFixture]
public class CombatAbilityIntegrationTests
{
    [Test]
    public void UseAbility_RequiresTarget_FailsOutOfCombat();

    [Test]
    public void UseAbility_SelfTarget_WorksOutOfCombat();

    [Test]
    public void UseAbility_InCombat_MonsterResponds();

    [Test]
    public void UseAbility_KillsMonster_EndsCombat();

    [Test]
    public void UseAbility_PlayerKilled_SetsGameOver();

    [Test]
    public void BasicAttack_ProcessesTurnEnd();
}
```

### Renderer Tests (~5 tests)

```csharp
[TestFixture]
public class AbilityRendererTests
{
    [Test]
    public void RenderAbilitiesList_DisplaysAllAbilities();

    [Test]
    public void RenderAbilitiesList_ShowsCooldownStatus();

    [Test]
    public void RenderAbilitiesList_ShowsLockedAbilities();

    [Test]
    public void RenderAbilityResult_ShowsDamage();

    [Test]
    public void RenderTurnEndChanges_ShowsRegeneration();
}
```

---

## Acceptance Criteria

### AC-4d-1: Ability Command
- [ ] `ability <name>` command is recognized and parsed
- [ ] `skill <name>` alias works identically
- [ ] Missing ability name produces helpful error message
- [ ] Unknown ability name produces "ability not found" message

### AC-4d-2: Abilities Command
- [ ] `abilities` command lists all player abilities
- [ ] `skills` alias works identically
- [ ] List shows ability name, cost, cooldown, and status
- [ ] Ready abilities show as "Ready"
- [ ] Cooldown abilities show remaining turns
- [ ] Locked abilities show required level

### AC-4d-3: Combat Integration
- [ ] Abilities can be used during combat
- [ ] Damage abilities deal damage to monsters
- [ ] Heal abilities restore player health
- [ ] Monster counterattacks after player ability use
- [ ] Combat ends when monster is defeated
- [ ] Game over when player is defeated

### AC-4d-4: Resource Management
- [ ] Ability costs are deducted from correct resource
- [ ] Insufficient resources prevent ability use
- [ ] Resource changes are displayed to player
- [ ] Status bar shows resource pools

### AC-4d-5: Turn Processing
- [ ] Turn counter increments on turn-ending actions
- [ ] Resources regenerate/decay at turn end
- [ ] Cooldowns reduce by 1 at turn end
- [ ] "Ability ready" message when cooldown reaches 0
- [ ] Non-turn-ending actions don't trigger processing

### AC-4d-6: Display and Feedback
- [ ] Ability results show damage/healing/effects
- [ ] Resource costs show in ability result
- [ ] Turn-end changes display clearly
- [ ] Help text includes ability commands

### AC-4d-7: Logging
- [ ] Ability use logged with player, ability, result
- [ ] Turn processing logged with summary
- [ ] Errors logged with context
- [ ] Debug logging for detailed flow

### AC-4d-8: Unit Tests
- [ ] All ~35 tests pass
- [ ] Command parsing tested
- [ ] Ability validation tested
- [ ] Combat integration tested
- [ ] Turn processing tested

---

## Deliverable Checklist

### Command System
- [ ] `AbilityCommand` record in `IInputHandler.cs`
- [ ] `AbilitiesCommand` record in `IInputHandler.cs`
- [ ] Command parsing in `ConsoleInputHandler.cs`
- [ ] Command dispatch in `GameView.ProcessCommandAsync()`
- [ ] `HandleAbilityAsync()` handler
- [ ] `HandleAbilitiesAsync()` handler

### Turn Processing
- [ ] `GameSession.TurnCount` property
- [ ] `GameSession.AdvanceTurn()` method
- [ ] `TurnEndResult` record
- [ ] `ResourceChangeDto` record
- [ ] `CooldownChangeDto` record
- [ ] `GameSessionService.ProcessTurnEnd()` method

### Combat Integration
- [ ] `AbilityCommandResult` record
- [ ] `GameSessionService.TryUseAbility()` method
- [ ] `GameSessionService.IsInCombat()` method
- [ ] `CombatService.CalculateMonsterDamage()` method
- [ ] Monster counterattack logic
- [ ] Updated `TryAttack()` with turn processing

### Presentation
- [ ] `IGameRenderer.RenderAbilitiesListAsync()`
- [ ] `IGameRenderer.RenderAbilityResultAsync()`
- [ ] `IGameRenderer.RenderTurnEndChangesAsync()`
- [ ] `IGameRenderer.RenderResourceBarsAsync()`
- [ ] `SpectreGameRenderer` implementations
- [ ] Updated status bar with resources
- [ ] Updated help text

### DTOs
- [ ] `PlayerAbilitiesDto`
- [ ] `PlayerAbilityDisplayDto`
- [ ] `ResourcePoolDto` (if not from v0.0.4b)
- [ ] `GameSessionService.GetPlayerAbilities()`

### Tests
- [ ] `AbilityCommandParsingTests.cs`
- [ ] `TryUseAbilityTests.cs`
- [ ] `TurnProcessingTests.cs`
- [ ] `CombatAbilityIntegrationTests.cs`
- [ ] `AbilityRendererTests.cs`

### Documentation
- [ ] XML documentation on all public members
- [ ] Update ROADMAP.md to mark v0.0.4 complete

---

## Dependencies Summary

```
v0.0.4d Integration & Polish
    │
    ├── REQUIRES from v0.0.4a (Class System)
    │   ├── ClassDefinition
    │   ├── Player.ClassId
    │   └── ClassService
    │
    ├── REQUIRES from v0.0.4b (Resource System)
    │   ├── ResourceTypeDefinition
    │   ├── ResourcePool
    │   ├── ResourceService.SpendResource()
    │   ├── ResourceService.ProcessTurnEnd()
    │   └── Player.Resources
    │
    ├── REQUIRES from v0.0.4c (Ability System)
    │   ├── AbilityDefinition
    │   ├── PlayerAbility
    │   ├── AbilityService.CanUseAbility()
    │   ├── AbilityService.UseAbility()
    │   └── Player.Abilities
    │
    ├── REQUIRES from v0.0.1 (Core)
    │   ├── GameCommand system
    │   ├── ConsoleInputHandler
    │   ├── GameView
    │   ├── GameSessionService
    │   ├── CombatService
    │   └── SpectreGameRenderer
    │
    └── PROVIDES to v0.0.5+ (Future)
        ├── Complete class-based gameplay
        ├── Turn-based resource management
        ├── Ability-enhanced combat
        └── Foundation for advanced mechanics
```

---

## Completion Criteria for v0.0.4

When v0.0.4d is complete, the v0.0.4 milestone (Class-Based Combat) will be fully implemented:

| Sub-version | Feature | Status |
|-------------|---------|--------|
| v0.0.4a | Archetype & Class Foundations | Required |
| v0.0.4b | Resource Pool System | Required |
| v0.0.4c | Ability System | Required |
| **v0.0.4d** | **Integration & Polish** | **This Plan** |

**Complete v0.0.4 Features:**
- Players choose a class during character creation
- Each class has unique resource mechanics
- Classes have distinct abilities with costs and cooldowns
- Abilities integrate with combat
- Turn-based resource regeneration/decay
- Full command support for ability usage

---

*This implementation plan provides a comprehensive roadmap for completing v0.0.4d and the entire v0.0.4 milestone. It builds upon the foundations established in v0.0.4a, v0.0.4b, and v0.0.4c while maintaining the clean architecture principles already present in the codebase.*
