# v0.3.22c: The Forecast (Predictive UI) - Expanded Implementation Plan

## Overview

Tactical games thrive on informed decisions. Players shouldn't perform mental math for hit chances or damage ranges. **v0.3.22c** introduces a "Combat Forecast" system that shows the probable outcome of an action *before* it is committed. This enables players to make informed tactical choices by displaying hit chance, damage range, and critical probability.

**Parent Plan:** [v0.3.22](./v0.3.22.md)
**Status:** Planned
**Dependencies:** `v0.3.22a` (CombatViewModel structure), `v0.3.22b` (KnowledgeTier for fog of war)

---

## Architecture Summary

### Key Design Decisions

1. **Dry-Run Calculation** - Extract calculation logic from `AttackResolutionService.ResolveMeleeAttack()` into pure, deterministic methods
2. **CombatForecast Record** - Immutable DTO containing all predictive data (hit %, crit %, damage range, stamina cost)
3. **KnowledgeTier Integration** - Obscure forecast data for Unknown enemies (exploit prevention)
4. **Command-Based Trigger** - `forecast <attack-type> <target>` command for TUI compatibility
5. **Persistent Forecast Bar** - Optional UI element showing forecast for last-targeted enemy

### Forecast Pipeline Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                      FORECAST PIPELINE                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  [User: "forecast heavy goblin"] ─────► [CommandParser.HandleCombat]│
│         │                                       │                    │
│         │                                       ▼                    │
│         │                    ┌─────────────────────────────────┐    │
│         │                    │ IAttackResolutionService        │    │
│         │                    │ .GetForecast(attacker, target,  │    │
│         │                    │              attackType)         │    │
│         │                    └──────────────┬──────────────────┘    │
│         │                                   │                        │
│         │                                   ▼                        │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                   FORECAST CALCULATION                        │   │
│  ├──────────────────────────────────────────────────────────────┤   │
│  │ 1. Calculate Attack Pool                                     │   │
│  │    └─ Pool = Attacker.Might + HitModifier[attackType]        │   │
│  │                                                               │   │
│  │ 2. Calculate Defense Score                                   │   │
│  │    └─ Defense = 10 + Defender.Finesse - StressPenalty        │   │
│  │    └─ Threshold = Defense / 5                                │   │
│  │                                                               │   │
│  │ 3. Calculate Hit Probability                                 │   │
│  │    └─ P(Success) = P(d10 >= 8) = 0.30                        │   │
│  │    └─ P(Hit) = Binomial(pool, threshold, 0.30)               │   │
│  │                                                               │   │
│  │ 4. Calculate Damage Range                                    │   │
│  │    └─ MinDmg = (Might + 1 + Bonus - Soak)                    │   │
│  │    └─ MaxDmg = (Might + WeaponDie + Bonus - Soak)            │   │
│  │    └─ Apply outcome modifiers (Glancing/Critical)            │   │
│  │                                                               │   │
│  │ 5. Apply Knowledge Tier Masking                              │   │
│  │    └─ Unknown: "??? | ???"                                   │   │
│  │    └─ Obscured: "~60% | ~4-8"                                │   │
│  │    └─ Known+: "62% | 4-9"                                    │   │
│  └──────────────────────────────────────────────────────────────┘   │
│                              │                                       │
│                              ▼                                       │
│                     [CombatForecast]                                │
│                    ┌─────────┴─────────┐                            │
│                    ▼                   ▼                            │
│           CombatViewModel      ForecastRenderer                     │
│           .ActiveForecast      .Render(forecast)                    │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Existing Infrastructure Analysis

### Attack Resolution System

| Component | Location | Purpose |
|-----------|----------|---------|
| `IAttackResolutionService` | `Core/Interfaces/` | Contract for attack mechanics |
| `AttackResolutionService` | `Engine/Services/` | Hit/damage calculation implementation |
| `AttackResult` | `Core/Models/Combat/` | Result record with outcome, damage, etc. |
| `AttackType` | `Core/Enums/` | Light (15 STA), Standard (25 STA), Heavy (40 STA) |
| `AttackOutcome` | `Core/Enums/` | Fumble, Miss, Glancing, Solid, Critical |
| `DamageType` | `Core/Enums/` | Physical, Fire, Ice, Lightning, etc. |

### Dice Pool System

| Concept | Value | Description |
|---------|-------|-------------|
| Success Threshold | d10 >= 8 | 30% chance per die |
| Botch Threshold | d10 == 1 | 10% chance per die |
| Pool Size | Might + Modifier | Minimum 1 die |
| Defense Score | 10 + Finesse - Stress | Baseline defender protection |
| Success Threshold | Defense / 5 | Required successes to hit |

### Attack Type Modifiers

| Attack Type | Stamina Cost | Hit Modifier | Damage Bonus |
|-------------|--------------|--------------|--------------|
| Light | 15 | +1 | +0 |
| Standard | 25 | +0 | +2 |
| Heavy | 40 | -1 | +4 |

### Damage Outcome Multipliers

| Outcome | Net Successes | Damage Modifier |
|---------|---------------|-----------------|
| Glancing | 1-2 | Damage / 2 |
| Solid | 3-4 | Damage (no modifier) |
| Critical | 5+ | Damage * 2 |

---

## Probability Mathematics

### Binomial Distribution for Hit Calculation

The probability of getting exactly `k` successes from `n` dice, where each die has `p = 0.30` chance of success:

```
P(X = k) = C(n, k) * p^k * (1-p)^(n-k)
```

The probability of hitting (net successes > 0) is:

```
P(Hit) = P(Successes > Threshold) = 1 - P(Successes <= Threshold)
       = 1 - Σ[k=0 to threshold] C(n, k) * 0.30^k * 0.70^(n-k)
```

### Pre-Calculated Hit Tables

For performance, we pre-calculate common scenarios:

| Pool Size | Threshold 1 | Threshold 2 | Threshold 3 | Threshold 4 |
|-----------|-------------|-------------|-------------|-------------|
| 2 | 51% | 9% | 0% | 0% |
| 3 | 65% | 22% | 3% | 0% |
| 4 | 76% | 35% | 8% | 1% |
| 5 | 83% | 47% | 16% | 3% |
| 6 | 88% | 58% | 26% | 7% |
| 7 | 92% | 67% | 35% | 13% |
| 8 | 94% | 74% | 45% | 19% |

### Critical Probability

P(Critical) = P(Net Successes >= 5) requires significantly more successes than the threshold.

---

## Files to Create (5 new files)

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Models/Combat/CombatForecast.cs` | Immutable forecast DTO |
| `RuneAndRust.Engine/Helpers/ProbabilityCalculator.cs` | Binomial probability utilities |
| `RuneAndRust.Terminal/Rendering/ForecastRenderer.cs` | Spectre.Console forecast bar |
| `RuneAndRust.Tests/Engine/ProbabilityCalculatorTests.cs` | Probability calculation tests |
| `RuneAndRust.Tests/Engine/ForecastIntegrationTests.cs` | End-to-end forecast tests |

## Files to Modify (5 existing files)

| File | Changes |
|------|---------|
| `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs` | Add `GetForecast()` method |
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Implement `GetForecast()` with extracted logic |
| `RuneAndRust.Core/ViewModels/CombatViewModel.cs` | Add `CombatForecast? ActiveForecast` property |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Add `forecast` command handling |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | Render forecast bar |

---

## Implementation Order

1. Create `ProbabilityCalculator` helper with binomial math
2. Create `CombatForecast` record
3. Add `GetForecast()` to `IAttackResolutionService`
4. Implement `GetForecast()` in `AttackResolutionService`
5. Create `ForecastRenderer`
6. Add `ActiveForecast` to `CombatViewModel`
7. Update `CombatScreenRenderer` to render forecast bar
8. Update `CommandParser` with `forecast` command
9. Create unit tests
10. Create integration tests
11. Build and verify all tests pass

---

## Detailed Code Specifications

### 1. CombatForecast Record

**File:** `RuneAndRust.Core/Models/Combat/CombatForecast.cs`

```csharp
namespace RuneAndRust.Core.Models.Combat;

using RuneAndRust.Core.Enums;

/// <summary>
/// Immutable record containing predicted attack outcome data.
/// Generated by IAttackResolutionService.GetForecast() for pre-attack visualization.
/// </summary>
/// <remarks>
/// See: SPEC-FORECAST-001 for Combat Forecast System design.
/// v0.3.22c: Initial implementation.
/// </remarks>
/// <param name="AttackerName">Display name of the attacking combatant.</param>
/// <param name="TargetName">Display name of the target combatant.</param>
/// <param name="AttackType">The type of attack being forecast (Light, Standard, Heavy).</param>
/// <param name="HitChancePercent">Probability of hitting the target (0-100).</param>
/// <param name="CritChancePercent">Probability of achieving a critical hit (0-100).</param>
/// <param name="MinDamage">Minimum possible damage on a Glancing hit after soak.</param>
/// <param name="MaxDamage">Maximum possible damage on a Critical hit after soak.</param>
/// <param name="ExpectedDamage">Average expected damage accounting for all outcomes.</param>
/// <param name="DamageType">The type of damage that will be dealt.</param>
/// <param name="StaminaCost">Stamina required to execute this attack.</param>
/// <param name="IsObscured">True if data is partially hidden due to low KnowledgeTier.</param>
/// <param name="IsHidden">True if all data is hidden (Unknown tier).</param>
public record CombatForecast(
    string AttackerName,
    string TargetName,
    AttackType AttackType,
    int HitChancePercent,
    int CritChancePercent,
    int MinDamage,
    int MaxDamage,
    int ExpectedDamage,
    DamageType DamageType,
    int StaminaCost,
    bool IsObscured = false,
    bool IsHidden = false
)
{
    /// <summary>
    /// Creates a hidden forecast for Unknown-tier enemies.
    /// Prevents exploitation of forecast system to reveal hidden stats.
    /// </summary>
    public static CombatForecast CreateHidden(
        string attackerName,
        string targetName,
        AttackType attackType,
        int staminaCost) => new(
        AttackerName: attackerName,
        TargetName: targetName,
        AttackType: attackType,
        HitChancePercent: 0,
        CritChancePercent: 0,
        MinDamage: 0,
        MaxDamage: 0,
        ExpectedDamage: 0,
        DamageType: DamageType.Physical,
        StaminaCost: staminaCost,
        IsObscured: false,
        IsHidden: true
    );

    /// <summary>
    /// Creates an obscured forecast for Obscured-tier enemies.
    /// Shows approximate values rounded to nearest 5/10.
    /// </summary>
    public static CombatForecast CreateObscured(CombatForecast precise) => precise with
    {
        HitChancePercent = RoundToNearest(precise.HitChancePercent, 10),
        CritChancePercent = RoundToNearest(precise.CritChancePercent, 5),
        MinDamage = RoundToNearest(precise.MinDamage, 2),
        MaxDamage = RoundToNearest(precise.MaxDamage, 2),
        ExpectedDamage = RoundToNearest(precise.ExpectedDamage, 2),
        IsObscured = true
    };

    /// <summary>
    /// Rounds a value to the nearest multiple.
    /// </summary>
    private static int RoundToNearest(int value, int multiple)
    {
        return ((value + multiple / 2) / multiple) * multiple;
    }

    /// <summary>
    /// Gets the display string for hit chance based on visibility.
    /// </summary>
    public string HitDisplay => IsHidden ? "???" :
        IsObscured ? $"~{HitChancePercent}%" : $"{HitChancePercent}%";

    /// <summary>
    /// Gets the display string for damage range based on visibility.
    /// </summary>
    public string DamageDisplay => IsHidden ? "???" :
        IsObscured ? $"~{MinDamage}-{MaxDamage}" : $"{MinDamage}-{MaxDamage}";

    /// <summary>
    /// Gets the display string for critical chance based on visibility.
    /// </summary>
    public string CritDisplay => IsHidden ? "???" :
        IsObscured ? $"~{CritChancePercent}%" : $"{CritChancePercent}%";
}
```

### 2. ProbabilityCalculator Helper

**File:** `RuneAndRust.Engine/Helpers/ProbabilityCalculator.cs`

```csharp
namespace RuneAndRust.Engine.Helpers;

/// <summary>
/// Provides probability calculations for the d10 dice pool system.
/// Uses binomial distribution to calculate hit probabilities.
/// </summary>
/// <remarks>
/// See: SPEC-FORECAST-001 for Combat Forecast System design.
/// v0.3.22c: Initial implementation.
/// </remarks>
public static class ProbabilityCalculator
{
    /// <summary>
    /// Probability of rolling 8+ on a d10 (success).
    /// </summary>
    private const double SuccessProbability = 0.30;

    /// <summary>
    /// Pre-calculated binomial coefficients for performance.
    /// C[n][k] = n! / (k! * (n-k)!)
    /// </summary>
    private static readonly long[,] BinomialCoefficients = new long[21, 21];

    static ProbabilityCalculator()
    {
        // Pre-calculate Pascal's triangle for binomial coefficients
        for (int n = 0; n <= 20; n++)
        {
            BinomialCoefficients[n, 0] = 1;
            BinomialCoefficients[n, n] = 1;
            for (int k = 1; k < n; k++)
            {
                BinomialCoefficients[n, k] = BinomialCoefficients[n - 1, k - 1] + BinomialCoefficients[n - 1, k];
            }
        }
    }

    /// <summary>
    /// Calculates the probability of getting at least the required number of successes.
    /// Uses binomial distribution: P(X >= threshold) = 1 - P(X < threshold)
    /// </summary>
    /// <param name="dicePool">Number of d10 dice in the pool.</param>
    /// <param name="requiredSuccesses">Minimum successes needed (defender threshold + 1).</param>
    /// <returns>Probability as a value between 0 and 1.</returns>
    public static double CalculateHitProbability(int dicePool, int requiredSuccesses)
    {
        if (dicePool <= 0) return 0;
        if (requiredSuccesses <= 0) return 1;
        if (requiredSuccesses > dicePool) return CalculateLowProbability(dicePool, requiredSuccesses);

        // P(Hit) = 1 - P(Successes < requiredSuccesses)
        // P(Hit) = 1 - Σ[k=0 to required-1] P(X = k)
        double cumulativeMiss = 0;
        for (int k = 0; k < requiredSuccesses; k++)
        {
            cumulativeMiss += BinomialProbability(dicePool, k);
        }

        return Math.Max(0, Math.Min(1, 1 - cumulativeMiss));
    }

    /// <summary>
    /// Calculates probability of achieving a critical hit (net successes >= 5).
    /// </summary>
    /// <param name="dicePool">Number of d10 dice in the pool.</param>
    /// <param name="defenseThreshold">Defender's success threshold.</param>
    /// <returns>Probability as a value between 0 and 1.</returns>
    public static double CalculateCriticalProbability(int dicePool, int defenseThreshold)
    {
        // Critical requires net successes >= 5
        // Total successes needed = threshold + 5
        int requiredForCrit = defenseThreshold + 5;
        return CalculateHitProbability(dicePool, requiredForCrit);
    }

    /// <summary>
    /// Calculates probability for cases where required successes exceed pool size.
    /// Still possible with lucky rolls but very unlikely.
    /// </summary>
    private static double CalculateLowProbability(int dicePool, int requiredSuccesses)
    {
        // Even if all dice succeed, we can't meet the requirement
        if (requiredSuccesses > dicePool) return 0;
        return CalculateHitProbability(dicePool, requiredSuccesses);
    }

    /// <summary>
    /// Calculates exact binomial probability P(X = k).
    /// </summary>
    private static double BinomialProbability(int n, int k)
    {
        if (k < 0 || k > n) return 0;
        if (n > 20) n = 20; // Cap for pre-calculated table

        double coefficient = BinomialCoefficients[n, k];
        double successTerm = Math.Pow(SuccessProbability, k);
        double failureTerm = Math.Pow(1 - SuccessProbability, n - k);

        return coefficient * successTerm * failureTerm;
    }

    /// <summary>
    /// Converts a probability (0-1) to a percentage (0-100).
    /// </summary>
    public static int ToPercent(double probability)
    {
        return (int)Math.Round(probability * 100);
    }
}
```

### 3. IAttackResolutionService Update

**File:** `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs`

Add to existing interface:

```csharp
/// <summary>
/// Calculates a forecast for an attack without performing it.
/// Used by v0.3.22c Combat Forecast system for pre-attack visualization.
/// </summary>
/// <param name="attacker">The attacking combatant.</param>
/// <param name="defender">The target combatant.</param>
/// <param name="attackType">The type of attack to forecast.</param>
/// <returns>A CombatForecast containing hit chance, damage range, and costs.</returns>
CombatForecast GetForecast(Combatant attacker, Combatant defender, AttackType attackType);

/// <summary>
/// Calculates the minimum damage for an attack type (Glancing hit, min weapon roll).
/// </summary>
/// <param name="attacker">The attacking combatant.</param>
/// <param name="defender">The target combatant.</param>
/// <param name="attackType">The type of attack.</param>
/// <returns>Minimum possible damage after soak.</returns>
int CalculateMinDamage(Combatant attacker, Combatant defender, AttackType attackType);

/// <summary>
/// Calculates the maximum damage for an attack type (Critical hit, max weapon roll).
/// </summary>
/// <param name="attacker">The attacking combatant.</param>
/// <param name="defender">The target combatant.</param>
/// <param name="attackType">The type of attack.</param>
/// <returns>Maximum possible damage after soak.</returns>
int CalculateMaxDamage(Combatant attacker, Combatant defender, AttackType attackType);
```

### 4. AttackResolutionService.GetForecast Implementation

**File:** `RuneAndRust.Engine/Services/AttackResolutionService.cs`

Add to existing class:

```csharp
/// <inheritdoc/>
public CombatForecast GetForecast(Combatant attacker, Combatant defender, AttackType attackType)
{
    _logger.LogDebug(
        "[Forecast] Calculating {AttackType} forecast: {Attacker} vs {Defender}",
        attackType, attacker.Name, defender.Name);

    // 1. Calculate attack pool
    var basePool = attacker.GetAttribute(CharacterAttribute.Might);
    var hitModifier = HitModifiers[attackType];
    var attackPool = Math.Max(1, basePool + hitModifier);

    // 2. Calculate defense threshold
    var defenseScore = CalculateDefenseScore(defender);
    var threshold = GetSuccessThreshold(defenseScore);

    // 3. Calculate hit probability using binomial distribution
    // We need net successes > 0, so we need successes > threshold
    var hitProbability = ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 1);
    var critProbability = ProbabilityCalculator.CalculateCriticalProbability(attackPool, threshold);

    // 4. Calculate damage range
    var minDamage = CalculateMinDamage(attacker, defender, attackType);
    var maxDamage = CalculateMaxDamage(attacker, defender, attackType);

    // 5. Calculate expected damage (weighted average based on outcome probabilities)
    var expectedDamage = CalculateExpectedDamage(attackPool, threshold, attacker, defender, attackType);

    // 6. Get stamina cost
    var staminaCost = GetStaminaCost(attackType);

    _logger.LogDebug(
        "[Forecast] Result: Pool={Pool}, Threshold={Threshold}, Hit={Hit}%, Crit={Crit}%, Dmg={Min}-{Max}",
        attackPool, threshold,
        ProbabilityCalculator.ToPercent(hitProbability),
        ProbabilityCalculator.ToPercent(critProbability),
        minDamage, maxDamage);

    return new CombatForecast(
        AttackerName: attacker.Name,
        TargetName: defender.Name,
        AttackType: attackType,
        HitChancePercent: ProbabilityCalculator.ToPercent(hitProbability),
        CritChancePercent: ProbabilityCalculator.ToPercent(critProbability),
        MinDamage: minDamage,
        MaxDamage: maxDamage,
        ExpectedDamage: expectedDamage,
        DamageType: DamageType.Physical,
        StaminaCost: staminaCost
    );
}

/// <inheritdoc/>
public int CalculateMinDamage(Combatant attacker, Combatant defender, AttackType attackType)
{
    // Min damage: Glancing hit (halved) with minimum weapon roll (1)
    var might = attacker.GetAttribute(CharacterAttribute.Might);
    var weaponMin = 1; // Minimum die roll
    var damageBonus = DamageBonuses[attackType];

    var rawDamage = might + weaponMin + damageBonus;
    var glancingDamage = rawDamage / 2; // Glancing halves damage

    // Apply soak
    var baseSoak = defender.ArmorSoak;
    var soakModifier = _statusEffects.GetSoakModifier(defender);
    var totalSoak = baseSoak + soakModifier;

    // Minimum 1 damage on hit
    return Math.Max(1, glancingDamage - totalSoak);
}

/// <inheritdoc/>
public int CalculateMaxDamage(Combatant attacker, Combatant defender, AttackType attackType)
{
    // Max damage: Critical hit (doubled) with maximum weapon roll
    var might = attacker.GetAttribute(CharacterAttribute.Might);
    var weaponMax = attacker.WeaponDamageDie; // Maximum die roll
    var damageBonus = DamageBonuses[attackType];

    var rawDamage = might + weaponMax + damageBonus;
    var criticalDamage = rawDamage * 2; // Critical doubles damage

    // Apply damage multiplier from status effects (e.g., Vulnerable)
    var damageMultiplier = _statusEffects.GetDamageMultiplier(defender);
    var modifiedDamage = (int)(criticalDamage * damageMultiplier);

    // Apply soak (minimum soak of 0 for max damage scenario)
    var baseSoak = defender.ArmorSoak;
    var soakModifier = _statusEffects.GetSoakModifier(defender);
    var totalSoak = Math.Max(0, baseSoak + soakModifier);

    return Math.Max(1, modifiedDamage - totalSoak);
}

/// <summary>
/// Calculates expected damage accounting for hit probability and outcome distribution.
/// </summary>
private int CalculateExpectedDamage(int attackPool, int threshold, Combatant attacker, Combatant defender, AttackType attackType)
{
    var might = attacker.GetAttribute(CharacterAttribute.Might);
    var weaponAvg = (1 + attacker.WeaponDamageDie) / 2.0; // Average die roll
    var damageBonus = DamageBonuses[attackType];
    var baseSoak = defender.ArmorSoak + _statusEffects.GetSoakModifier(defender);
    var damageMultiplier = _statusEffects.GetDamageMultiplier(defender);

    var baseRawDamage = might + weaponAvg + damageBonus;

    // Calculate probability of each outcome tier
    var pMiss = 1 - ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 1);
    var pGlancing = ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 1)
                  - ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 3);
    var pSolid = ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 3)
               - ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 5);
    var pCritical = ProbabilityCalculator.CalculateHitProbability(attackPool, threshold + 5);

    // Expected damage = Σ P(outcome) * damage(outcome)
    var glancingDmg = Math.Max(1, (int)((baseRawDamage / 2 * damageMultiplier) - baseSoak));
    var solidDmg = Math.Max(1, (int)((baseRawDamage * damageMultiplier) - baseSoak));
    var criticalDmg = Math.Max(1, (int)((baseRawDamage * 2 * damageMultiplier) - baseSoak));

    var expected = (pGlancing * glancingDmg) + (pSolid * solidDmg) + (pCritical * criticalDmg);
    return (int)Math.Round(expected);
}
```

### 5. ForecastRenderer

**File:** `RuneAndRust.Terminal/Rendering/ForecastRenderer.cs`

```csharp
namespace RuneAndRust.Terminal.Rendering;

using RuneAndRust.Core.Enums;
using RuneAndRust.Core.Models.Combat;
using Spectre.Console;

/// <summary>
/// Renders the combat forecast bar using Spectre.Console.
/// Displays hit chance, damage range, and critical probability.
/// </summary>
/// <remarks>
/// See: SPEC-FORECAST-001 for Combat Forecast System design.
/// v0.3.22c: Initial implementation.
/// </remarks>
public static class ForecastRenderer
{
    /// <summary>
    /// Renders a compact forecast bar for inline display.
    /// Format: [Target] Hit: 85% | Dmg: 4-10 | Crit: 5% | STA: 25
    /// </summary>
    /// <param name="forecast">The combat forecast to render.</param>
    /// <returns>A Markup object for inline rendering.</returns>
    public static Markup RenderInline(CombatForecast forecast)
    {
        if (forecast.IsHidden)
        {
            return new Markup($"[grey][[{Markup.Escape(forecast.TargetName)}]] Hit: ??? | Dmg: ??? | Crit: ??? | STA: {forecast.StaminaCost}[/]");
        }

        var hitColor = GetHitChanceColor(forecast.HitChancePercent);
        var critColor = GetCritChanceColor(forecast.CritChancePercent);
        var dmgColor = "yellow";

        var prefix = forecast.IsObscured ? "~" : "";
        var suffix = forecast.IsObscured ? " [grey](uncertain)[/]" : "";

        return new Markup(
            $"[white][[{Markup.Escape(forecast.TargetName)}]][/] " +
            $"Hit: [{hitColor}]{prefix}{forecast.HitChancePercent}%[/] | " +
            $"Dmg: [{dmgColor}]{prefix}{forecast.MinDamage}-{forecast.MaxDamage}[/] | " +
            $"Crit: [{critColor}]{prefix}{forecast.CritChancePercent}%[/] | " +
            $"STA: [cyan]{forecast.StaminaCost}[/]" +
            suffix);
    }

    /// <summary>
    /// Renders a full forecast panel for detailed display.
    /// Used when player explicitly requests forecast.
    /// </summary>
    /// <param name="forecast">The combat forecast to render.</param>
    /// <returns>A Panel containing the detailed forecast.</returns>
    public static Panel RenderPanel(CombatForecast forecast)
    {
        var content = new List<string>();

        // Header
        var attackTypeName = forecast.AttackType switch
        {
            AttackType.Light => "Light Attack",
            AttackType.Standard => "Standard Attack",
            AttackType.Heavy => "Heavy Attack",
            _ => "Attack"
        };

        content.Add($"[bold white]{Markup.Escape(forecast.AttackerName)}[/] → [bold yellow]{Markup.Escape(forecast.TargetName)}[/]");
        content.Add($"[grey]{attackTypeName} ({forecast.DamageType})[/]");
        content.Add("");

        if (forecast.IsHidden)
        {
            content.Add("[grey]Insufficient knowledge to predict outcome.[/]");
            content.Add("[grey italic]Gather more Codex fragments to reveal enemy stats.[/]");
        }
        else
        {
            var prefix = forecast.IsObscured ? "~" : "";

            // Hit Chance with visual bar
            var hitColor = GetHitChanceColor(forecast.HitChancePercent);
            var hitBar = RenderProgressBar(forecast.HitChancePercent, 20, hitColor);
            content.Add($"[white]Hit Chance:[/]  {hitBar} [{hitColor}]{prefix}{forecast.HitChancePercent}%[/]");

            // Critical Chance
            var critColor = GetCritChanceColor(forecast.CritChancePercent);
            var critBar = RenderProgressBar(forecast.CritChancePercent, 20, critColor);
            content.Add($"[white]Crit Chance:[/] {critBar} [{critColor}]{prefix}{forecast.CritChancePercent}%[/]");

            content.Add("");

            // Damage Range
            content.Add($"[white]Damage Range:[/] [yellow]{prefix}{forecast.MinDamage}[/] - [red]{prefix}{forecast.MaxDamage}[/]");
            content.Add($"[white]Expected Dmg:[/] [orange1]{prefix}{forecast.ExpectedDamage}[/]");

            if (forecast.IsObscured)
            {
                content.Add("");
                content.Add("[grey italic]Values are approximate (Obscured knowledge).[/]");
            }
        }

        content.Add("");
        content.Add($"[cyan]Stamina Cost:[/] {forecast.StaminaCost}");

        var panel = new Panel(string.Join("\n", content))
        {
            Header = new PanelHeader("[bold]COMBAT FORECAST[/]"),
            Border = BoxBorder.Rounded,
            BorderStyle = new Style(Color.Blue),
            Padding = new Padding(2, 1),
            Width = 50
        };

        return panel;
    }

    #region Private Helpers

    /// <summary>
    /// Gets the color for hit chance based on probability.
    /// </summary>
    private static string GetHitChanceColor(int percent) => percent switch
    {
        >= 80 => "green",
        >= 60 => "yellow",
        >= 40 => "orange1",
        >= 20 => "red",
        _ => "grey"
    };

    /// <summary>
    /// Gets the color for critical chance based on probability.
    /// </summary>
    private static string GetCritChanceColor(int percent) => percent switch
    {
        >= 20 => "purple",
        >= 10 => "magenta1",
        >= 5 => "red",
        _ => "grey"
    };

    /// <summary>
    /// Renders a text-based progress bar.
    /// </summary>
    private static string RenderProgressBar(int percent, int width, string color)
    {
        var filled = (int)Math.Round(percent / 100.0 * width);
        var empty = width - filled;

        var filledChars = new string('=', filled);
        var emptyChars = new string('-', empty);

        return $"[{color}]{filledChars}[/][grey]{emptyChars}[/]";
    }

    #endregion
}
```

### 6. CombatViewModel Update

**File:** `RuneAndRust.Core/ViewModels/CombatViewModel.cs`

Add to existing record parameters:

```csharp
// Add to CombatViewModel record parameters:

/// <param name="ActiveForecast">The currently displayed combat forecast (v0.3.22c).</param>
public record CombatViewModel(
    int RoundNumber,
    string ActiveCombatantName,
    List<CombatantView> TurnOrder,
    List<string> CombatLog,
    PlayerStatsView PlayerStats,
    List<AbilityView>? PlayerAbilities = null,
    // Row-grouped combatants for grid display (v0.3.6a)
    List<CombatantView>? PlayerFrontRow = null,
    List<CombatantView>? PlayerBackRow = null,
    List<CombatantView>? EnemyFrontRow = null,
    List<CombatantView>? EnemyBackRow = null,
    // Timeline projection (v0.3.6b)
    List<TimelineEntryView>? TimelineProjection = null,
    // Context help tips (v0.3.9c)
    List<HelpTip>? ContextTips = null,
    // Inspection overlay (v0.3.22b)
    EnemyIntel? ActiveInspection = null,
    // Combat forecast (v0.3.22c)
    CombatForecast? ActiveForecast = null
);
```

### 7. CommandParser Update

**File:** `RuneAndRust.Engine/Services/CommandParser.cs`

Add to `HandleCombat()` method:

```csharp
// In HandleCombat(), add forecast command handling:

// Check for forecast command (v0.3.22c)
if (command.StartsWith("forecast ", StringComparison.OrdinalIgnoreCase) ||
    command.StartsWith("check ", StringComparison.OrdinalIgnoreCase))
{
    return await ExecuteForecastCommand(command);
}

// ... existing switch statement ...

// Add new private method:

/// <summary>
/// Executes the forecast command to preview attack outcomes.
/// v0.3.22c: The Forecast implementation.
/// Syntax: forecast [attack-type] [target]
/// Examples: "forecast heavy goblin", "check standard draugr", "forecast light"
/// </summary>
private async Task<ParseResult> ExecuteForecastCommand(string command)
{
    if (_attackResolution == null || _combatService == null)
    {
        _inputHandler.DisplayError("Forecast system not available.");
        return ParseResult.None;
    }

    // Parse command: "forecast [type] [target]" or "check [type] [target]"
    var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);

    // Default attack type is Standard
    var attackType = AttackType.Standard;
    string? targetName = null;

    // Parse arguments
    for (int i = 1; i < parts.Length; i++)
    {
        var arg = parts[i].ToLowerInvariant();

        if (arg == "light" || arg == "l")
            attackType = AttackType.Light;
        else if (arg == "standard" || arg == "std" || arg == "s")
            attackType = AttackType.Standard;
        else if (arg == "heavy" || arg == "h")
            attackType = AttackType.Heavy;
        else
            targetName = string.Join(" ", parts.Skip(i));
    }

    // Get player combatant
    var combatState = _combatService.GetCombatState();
    if (combatState == null)
    {
        _inputHandler.DisplayError("Not in combat.");
        return ParseResult.None;
    }

    var player = combatState.TurnOrder.FirstOrDefault(c => c.IsPlayer);
    if (player == null)
    {
        _inputHandler.DisplayError("Player not found in combat.");
        return ParseResult.None;
    }

    // Find target (use last targeted if none specified)
    Combatant? target = null;
    if (!string.IsNullOrEmpty(targetName))
    {
        target = FindTargetCombatant(targetName);
    }
    else
    {
        // Use first enemy as default
        target = combatState.TurnOrder.FirstOrDefault(c => !c.IsPlayer);
    }

    if (target == null)
    {
        _inputHandler.DisplayError($"Target not found{(targetName != null ? $": '{targetName}'" : "")}");
        return ParseResult.None;
    }

    // Generate forecast
    var forecast = _attackResolution.GetForecast(player, target, attackType);

    // Apply knowledge tier masking (v0.3.22b integration)
    if (_analysisService != null && _gameState.CurrentCharacter != null)
    {
        var tier = await _analysisService.GetKnowledgeTierAsync(target.Name, _gameState.CurrentCharacter);
        forecast = ApplyKnowledgeTierMasking(forecast, tier);
    }

    // Render forecast panel
    var panel = ForecastRenderer.RenderPanel(forecast);
    AnsiConsole.Write(panel);

    return ParseResult.None;
}

/// <summary>
/// Applies knowledge tier masking to a forecast.
/// </summary>
private CombatForecast ApplyKnowledgeTierMasking(CombatForecast forecast, KnowledgeTier tier)
{
    return tier switch
    {
        KnowledgeTier.Unknown => CombatForecast.CreateHidden(
            forecast.AttackerName,
            forecast.TargetName,
            forecast.AttackType,
            forecast.StaminaCost),
        KnowledgeTier.Obscured => CombatForecast.CreateObscured(forecast),
        _ => forecast // Known and Mastered get precise values
    };
}
```

---

## CombatScreenRenderer Integration

**File:** `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs`

Add forecast bar rendering in `Render()` method:

```csharp
/// <inheritdoc/>
public void Render(CombatViewModel vm)
{
    AnsiConsole.Clear();

    // Check for active inspection overlay (v0.3.22b)
    if (vm.ActiveInspection != null)
    {
        var inspectPanel = InspectWindowRenderer.Render(vm.ActiveInspection);
        AnsiConsole.Write(inspectPanel);
        return;
    }

    // ... existing render code (Header, Grid, Timeline, Abilities, Tips, Log) ...

    // 7. Combat Forecast Bar (v0.3.22c) - render above input prompt
    if (vm.ActiveForecast != null)
    {
        var forecastLine = ForecastRenderer.RenderInline(vm.ActiveForecast);
        AnsiConsole.Write(forecastLine);
        AnsiConsole.WriteLine();
    }

    // ... rest of existing render code ...
}
```

---

## Test Coverage (~18 tests)

### ProbabilityCalculatorTests.cs

| Test Name | Description |
|-----------|-------------|
| `CalculateHitProbability_Pool2_Threshold1_Returns51Percent` | Basic 2d10 vs threshold 1 |
| `CalculateHitProbability_Pool5_Threshold2_Returns47Percent` | Medium pool calculation |
| `CalculateHitProbability_Pool0_ReturnsZero` | Edge case: no dice |
| `CalculateHitProbability_ThresholdExceedsPool_ReturnsZero` | Impossible hit |
| `CalculateCriticalProbability_Pool7_Threshold2_Returns13Percent` | Critical calculation |
| `ToPercent_ConvertsCorrectly` | 0.85 → 85% |

### CombatForecastTests.cs

| Test Name | Description |
|-----------|-------------|
| `CreateHidden_ReturnsHiddenForecast` | Factory method validation |
| `CreateObscured_RoundsValues` | 62% → ~60%, 7 → ~6 |
| `HitDisplay_ReturnsCorrectFormat` | "85%" vs "~80%" vs "???" |
| `DamageDisplay_ReturnsCorrectFormat` | "4-10" vs "~4-10" vs "???" |

### AttackResolutionServiceForecastTests.cs

| Test Name | Description |
|-----------|-------------|
| `GetForecast_ReturnsValidForecast` | Basic forecast generation |
| `GetForecast_CalculatesCorrectHitChance` | Verifies probability math |
| `GetForecast_CalculatesMinDamage_GlancingHit` | Min = (Might + 1 + Bonus) / 2 - Soak |
| `GetForecast_CalculatesMaxDamage_CriticalHit` | Max = (Might + Die + Bonus) * 2 - Soak |
| `GetForecast_RespectsStatusEffects` | Vulnerable/Fortified modifiers |
| `CalculateMinDamage_ReturnsAtLeastOne` | Minimum damage rule |
| `CalculateMaxDamage_AppliesDamageMultiplier` | Vulnerable doubles damage |

### ForecastIntegrationTests.cs

| Test Name | Description |
|-----------|-------------|
| `Forecast_Matches_ActualAttackRange` | Forecast min/max bounds actual results |

---

## Logging Matrix

| System | Event | Level | Message Template | Properties |
|--------|-------|-------|------------------|------------|
| Forecast | Calculate | Debug | `[Forecast] Calculating {AttackType} forecast: {Attacker} vs {Defender}` | AttackType, Attacker, Defender |
| Forecast | Result | Debug | `[Forecast] Result: Pool={Pool}, Threshold={Threshold}, Hit={Hit}%, Crit={Crit}%, Dmg={Min}-{Max}` | Pool, Threshold, Hit, Crit, Min, Max |
| Forecast | Command | Debug | `[Combat] Forecast command: {AttackType} vs {Target}` | AttackType, Target |
| Forecast | Masked | Debug | `[Forecast] Applied {Tier} masking to forecast for {Target}` | Tier, Target |

---

## Deliverable Checklist (v0.3.22c)

### Core Layer
- [ ] Create `RuneAndRust.Core/Models/Combat/CombatForecast.cs`
- [ ] Update `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs` with forecast methods
- [ ] Update `RuneAndRust.Core/ViewModels/CombatViewModel.cs` with `ActiveForecast`

### Engine Layer
- [ ] Create `RuneAndRust.Engine/Helpers/ProbabilityCalculator.cs`
- [ ] Update `RuneAndRust.Engine/Services/AttackResolutionService.cs` with `GetForecast()`
- [ ] Update `RuneAndRust.Engine/Services/CommandParser.cs` with `forecast` command

### Terminal Layer
- [ ] Create `RuneAndRust.Terminal/Rendering/ForecastRenderer.cs`
- [ ] Update `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` for forecast bar

### Testing
- [ ] Create `RuneAndRust.Tests/Engine/ProbabilityCalculatorTests.cs` (~6 tests)
- [ ] Create `RuneAndRust.Tests/Core/CombatForecastTests.cs` (~4 tests)
- [ ] Create `RuneAndRust.Tests/Engine/AttackResolutionServiceForecastTests.cs` (~7 tests)
- [ ] Create `RuneAndRust.Tests/Engine/ForecastIntegrationTests.cs` (~1 test)

---

## Critical Files Reference

| File | Purpose |
|------|---------|
| `RuneAndRust.Core/Interfaces/IAttackResolutionService.cs` | Forecast method contract |
| `RuneAndRust.Engine/Services/AttackResolutionService.cs` | Existing attack logic to extract |
| `RuneAndRust.Core/Models/Combat/AttackResult.cs` | Reference for attack data structure |
| `RuneAndRust.Core/Enums/AttackType.cs` | Light/Standard/Heavy definitions |
| `RuneAndRust.Core/Enums/DamageType.cs` | Damage type enumeration |
| `RuneAndRust.Core/Models/Combat/Combatant.cs` | Attacker/Defender data |
| `RuneAndRust.Core/Interfaces/IAnalysisService.cs` | KnowledgeTier lookup (v0.3.22b) |
| `RuneAndRust.Engine/Services/CommandParser.cs` | Command handling location |
| `RuneAndRust.Terminal/Services/CombatScreenRenderer.cs` | UI integration point |

---

## Command Usage Examples

```
> forecast heavy goblin
┌────────────────────────────────────────────────────┐
│ COMBAT FORECAST                                    │
├────────────────────────────────────────────────────┤
│ Thrain → Goblin Scout                              │
│ Heavy Attack (Physical)                            │
│                                                    │
│ Hit Chance:  ================----  76%             │
│ Crit Chance: ====-----------------  12%            │
│                                                    │
│ Damage Range: 4 - 18                               │
│ Expected Dmg: 9                                    │
│                                                    │
│ Stamina Cost: 40                                   │
└────────────────────────────────────────────────────┘

> forecast light
[Goblin Scout] Hit: 88% | Dmg: 1-6 | Crit: 3% | STA: 15
```

---

## Knowledge Tier Fog of War Examples

**Unknown Enemy:**
```
> forecast standard ???
┌────────────────────────────────────────────────────┐
│ COMBAT FORECAST                                    │
├────────────────────────────────────────────────────┤
│ Thrain → Unknown Entity                            │
│ Standard Attack (Physical)                         │
│                                                    │
│ Insufficient knowledge to predict outcome.         │
│ Gather more Codex fragments to reveal enemy stats. │
│                                                    │
│ Stamina Cost: 25                                   │
└────────────────────────────────────────────────────┘
```

**Obscured Enemy:**
```
> forecast standard draugr
┌────────────────────────────────────────────────────┐
│ COMBAT FORECAST                                    │
├────────────────────────────────────────────────────┤
│ Thrain → Rusted Draugr                             │
│ Standard Attack (Physical)                         │
│                                                    │
│ Hit Chance:  ==============------  ~70%            │
│ Crit Chance: ==------------------  ~10%            │
│                                                    │
│ Damage Range: ~4 - ~12                             │
│ Expected Dmg: ~7                                   │
│                                                    │
│ Values are approximate (Obscured knowledge).       │
│                                                    │
│ Stamina Cost: 25                                   │
└────────────────────────────────────────────────────┘
```

---

## Future Extensions

### Ability Forecasts (v0.3.23+)
- Extend forecast system to abilities
- Show AP/Stamina cost, area effects, status application chances

### Persistent Forecast Bar
- Auto-display forecast for current target during action selection
- Update dynamically as player cycles through attack types

### Comparative Forecasts
- Show forecasts for all three attack types side-by-side
- Highlight optimal choice based on situation

---

## Estimated Metrics

| Metric | Value |
|--------|-------|
| New Files | 5 |
| Modified Files | 5 |
| New Lines (Services) | ~400 |
| New Lines (Tests) | ~300 |
| New Unit Tests | ~18 |
| New Commands | 2 (forecast, check) |

---

## Pre-Commit Checks

- [ ] Verify probability calculations match actual dice statistics
- [ ] Ensure Unknown enemies don't leak defense stats via forecast
- [ ] Test forecast accuracy against 1000 simulated attacks
- [ ] Verify forecast bar rendering on narrow terminals (< 80 cols)
- [ ] Confirm Obscured rounding doesn't create illogical ranges (min > max)
- [ ] Test status effect integration (Vulnerable, Fortified)

**End of Plan**
