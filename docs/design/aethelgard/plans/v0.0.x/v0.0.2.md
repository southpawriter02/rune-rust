Based on the "Walking Skeleton" strategy and the Clean Architecture principles established in v0.0.1, here is the comprehensive implementation plan for v0.0.2: The Domain & Logic.
v0.0.2: The Domain & Logic (Dice & State)
Goal: Implement the mathematical core of the game (Dice System) and the fundamental data structures (Character, Attributes) without worrying about database persistence or complex UI yet.

## Table of Contents
- [1. Implementation Workflow](#1-implementation-workflow)
- [2. Code Implementation](#2-code-implementation)
- [3. Architecture Decision Tree](#3-architecture-decision-tree-v002)
- [4. Deliverable Checklist](#4-v002-deliverable-checklist)

1. Implementation Workflow
Execute these steps to flesh out the empty projects created in v0.0.1.
# 1. Create Test Project (Critical for Logic verification)
dotnet new xunit -n RuneAndRust.Tests
dotnet sln add RuneAndRust.Tests
dotnet add RuneAndRust.Tests reference RuneAndRust.Core
dotnet add RuneAndRust.Tests reference RuneAndRust.Engine

# 2. Folder Structure Setup
# In RuneAndRust.Core
mkdir -p Enums Entities Interfaces

# In RuneAndRust.Engine
mkdir -p Services Models

2. Code Implementation
A. Core Layer (Domain Definitions)
We define what exists. This layer remains pure C# with no logic.
File: RuneAndRust.Core/Enums/Attribute.cs
namespace RuneAndRust.Core.Enums;

public enum Attribute
{
    Might,
    Finesse,
    Sturdiness,
    Wits,
    Will
}
File: RuneAndRust.Core/Entities/Character.cs
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Core.Entities;

public class Character
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; } = string.Empty;

    // Base Attributes
    public Dictionary<Attribute, int> Attributes { get; set; } = new()
    {
        { Attribute.Might, 5 },
        { Attribute.Finesse, 5 },
        { Attribute.Sturdiness, 5 },
        { Attribute.Wits, 5 },
        { Attribute.Will, 5 }
    };

    // Derived Stats (Current state)
    public int CurrentHp { get; set; }
    public int MaxHp { get; set; }
    public int CurrentStamina { get; set; }
    public int MaxStamina { get; set; }
}
File: RuneAndRust.Core/Interfaces/IDiceService.cs
namespace RuneAndRust.Core.Interfaces;

public record DiceResult(int Successes, int Botches, List<int> Rolls);

public interface IDiceService
{
    /// <summary>
    /// Rolls a pool of d10s. Success on 8, 9, 10. Botch on 1.
    /// </summary>
    DiceResult Roll(int poolSize);
}
B. Engine Layer (Game Logic)
We define how it works. This uses the Core definitions.
File: RuneAndRust.Engine/Services/DiceService.cs
using RuneAndRust.Core.Interfaces;

namespace RuneAndRust.Engine.Services;

public class DiceService : IDiceService
{
    private readonly Random _random = new();

    public DiceResult Roll(int poolSize)
    {
        if (poolSize < 1) poolSize = 1; // Minimum roll rule

        var rolls = new List<int>();
        var successes = 0;
        var botches = 0;

        for (int i = 0; i < poolSize; i++)
        {
            // d10 roll (1-10)
            int roll = _random.Next(1, 11);
            rolls.Add(roll);

            if (roll >= 8) successes++;
            else if (roll == 1) botches++;
        }

        // Net successes: Rune & Rust does NOT subtract botches from successes
        // unless specific mechanics say so. Botches trigger Fumbles only if Successes == 0.
        // For raw result, we return raw counts.
        return new DiceResult(successes, botches, rolls);
    }
}
File: RuneAndRust.Engine/Services/StatCalculationService.cs
using RuneAndRust.Core.Entities;
using RuneAndRust.Core.Enums;

namespace RuneAndRust.Engine.Services;

public class StatCalculationService
{
    public void RecalculateStats(Character character)
    {
        int sturdiness = character.Attributes[Attribute.Sturdiness];
        int finesse = character.Attributes[Attribute.Finesse];

        // HP Formula: 50 + (Sturdiness * 10)
        character.MaxHp = 50 + (sturdiness * 10);

        // Stamina Formula: 50 + (Sturdiness * 5) + (Finesse * 2)
        character.MaxStamina = 50 + (sturdiness * 5) + (finesse * 2);

        // Reset currents to max for initialization
        if (character.CurrentHp == 0) character.CurrentHp = character.MaxHp;
        if (character.CurrentStamina == 0) character.CurrentStamina = character.MaxStamina;
    }
}
C. Testing (Verification)
Prove the math works before building the UI.
File: RuneAndRust.Tests/DiceTests.cs
using FluentAssertions;
using RuneAndRust.Engine.Services;
using Xunit;

public class DiceTests
{
    [Fact]
    public void Roll_AlwaysReturnsCorrectCount()
    {
        var service = new DiceService();
        var result = service.Roll(10);
        result.Rolls.Count.Should().Be(10);
    }

    [Fact]
    public void Roll_ZeroPool_RollsMinimumOne()
    {
        var service = new DiceService();
        var result = service.Roll(0);
        result.Rolls.Count.Should().Be(1);
    }
}

3. Architecture Decision Tree (v0.0.2)
When implementing logic in this phase, use this guide:
	•	Q: Where does CurrentHP live?
	◦	Core.Entities.Character. It is state data that needs to be saved.
	•	Q: Where does the formula 50 + (Sturdiness * 10) live?
	◦	Engine.Services.StatCalculationService. It is business logic. Core entities should remain "dumb" data containers where possible (anemic model) or contain only self-validation logic.
	•	Q: Should DiceService be static?
	◦	No. Implement IDiceService and inject it. This allows us to mock dice rolls in unit tests (e.g., forcing a critical hit to test combat logic later).
	•	Q: Do we need a Database yet?
	◦	No. For v0.0.2, instantiate Character objects in memory in Program.cs to test the logic.

4. v0.0.2 Deliverable Checklist
	•	[ ] Core: Attribute Enum defined (5 values).
	•	[ ] Core: Character entity created with dictionary of attributes.
	•	[ ] Engine: DiceService implemented with d10 logic (Success >= 8).
	•	[ ] Engine: StatCalculationService implements correct HP/Stamina formulas.
	•	[ ] Tests: Unit tests project created and dotnet test passes.
	•	[ ] DI: Register IDiceService and StatCalculationService in Program.cs.
	•	[ ] Smoke Test: In Program.cs, create a character, run calculations, and print MaxHP to console to verify the formula works.
Once the math is proven, we can move to v0.0.3, where we will build the Command Loop to let the user interact with these stats.
Ready to implement the code or move to v0.0.3 planning?
