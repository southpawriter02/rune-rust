# v0.5.0a Design Specification: Grid Core

**Version:** 0.5.0a
**Phase Name:** Grid Core
**Parent Version:** v0.5.0 (Combat Grid Foundation)
**Prerequisites:** v0.4.3d Complete (Skills & Environment)
**Estimated Tests:** ~30 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [MovementDirection Enum](#4-movementdirection-enum)
5. [GridPosition Value Object](#5-gridposition-value-object)
6. [GridCell Value Object](#6-gridcell-value-object)
7. [CombatGrid Entity](#7-combatgrid-entity)
8. [CombatGridService](#8-combatgridservice)
9. [Data Model Changes](#9-data-model-changes)
10. [Configuration File Schemas](#10-configuration-file-schemas)
11. [Logging Specifications](#11-logging-specifications)
12. [Unit Testing Requirements](#12-unit-testing-requirements)
13. [Use Cases](#13-use-cases)
14. [Deliverable Checklist](#14-deliverable-checklist)
15. [Acceptance Criteria](#15-acceptance-criteria)
16. [Dependencies](#16-dependencies)
17. [Future Considerations](#17-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification establishes the foundational combat grid data structures that transform combat from abstract exchanges into spatial tactical encounters. v0.5.0a creates the core grid infrastructure including the CombatGrid entity, GridPosition and GridCell value objects, and the CombatGridService for grid management.

The combat grid enables positional tracking for all combatants on a 2D coordinate system, providing the foundation for movement mechanics (v0.5.0b) and visual display (v0.5.0c).

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `CombatGrid` |
| **Domain Value Objects** | `GridPosition`, `GridCell` |
| **Domain Enums** | `MovementDirection` |
| **Application Interfaces** | `ICombatGridService` |
| **Application Services** | `CombatGridService` |
| **Result Types** | `GridInitializationResult` |
| **Configuration** | `grid.json` |
| **Tests** | ~30 unit tests |

### 1.3 Architectural Significance

This version establishes the **Combat Grid Pattern**:

- **2D Coordinate System**: X,Y grid with configurable dimensions (3-20 cells)
- **Position Notation**: Human-readable notation (A1, B3, H8)
- **Cell-Based Tracking**: Each cell tracks occupancy and passability
- **Entity Position Registry**: Fast lookup of entity positions
- **Distance Calculations**: Chebyshev and Manhattan distance support
- **Adjacency Detection**: Determines if entities are adjacent for melee combat

---

## 2. Feature Overview

```
v0.5.0a Grid Core
├── MovementDirection Enum
│   ├── North, South, East, West (cardinal)
│   └── NorthEast, NorthWest, SouthEast, SouthWest (diagonal)
├── GridPosition Value Object
│   ├── X, Y coordinates
│   ├── Move(direction)
│   ├── DistanceTo() (Chebyshev)
│   ├── ManhattanDistanceTo()
│   ├── IsAdjacentTo()
│   ├── ToString() → "A1"
│   └── TryParse("A1") → position
├── GridCell Value Object
│   ├── Position
│   ├── IsOccupied, OccupantId
│   ├── IsPlayerOccupied
│   ├── IsPassable
│   ├── PlaceEntity()
│   ├── RemoveEntity()
│   └── GetDisplayChar()
├── CombatGrid Entity
│   ├── Width, Height
│   ├── Cells dictionary
│   ├── EntityPositions registry
│   ├── Create(), CreateDefault()
│   ├── GetCell(), IsInBounds()
│   ├── PlaceEntity(), RemoveEntity()
│   ├── MoveEntity()
│   ├── GetEntityPosition()
│   ├── GetDistanceBetween()
│   ├── AreAdjacent()
│   └── GetEntitiesInRange()
└── CombatGridService
    ├── CreateGrid()
    ├── InitializePositions()
    ├── GetActiveGrid() / SetActiveGrid()
    ├── ClearGrid()
    ├── GetEntityPosition()
    ├── GetDistance()
    └── AreAdjacent()
```

### 2.1 Scope Alignment

**In Scope:**
- `GridPosition` value object (X, Y coordinates)
- `GridCell` value object (cell contents, occupant tracking)
- `CombatGrid` entity (dimensions, cell collection, initialization)
- `MovementDirection` enum
- `ICombatGridService` interface
- `CombatGridService` for grid management
- Grid initialization when combat begins
- Entity placement on grid
- Grid boundary validation
- Basic cell queries (get cell at position, is cell occupied)
- Grid configuration (default dimensions)

**Out of Scope:**
- Movement mechanics (v0.5.0b)
- Movement points (v0.5.0b)
- `move` command (v0.5.0b)
- ASCII grid display (v0.5.0c)
- Combat service integration (v0.5.0c)

---

## 3. Architecture Diagrams

### 3.1 Grid Coordinate System

```
┌─────────────────────────────────────────────────────────────────────┐
│                       GRID COORDINATE SYSTEM                         │
└─────────────────────────────────────────────────────────────────────┘

        X →  0     1     2     3     4     5     6     7
             A     B     C     D     E     F     G     H
        ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
  Y=0 1 │ A1  │ B1  │ C1  │ D1  │ E1  │ F1  │ G1  │ H1  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    1 2 │ A2  │ B2  │ C2  │ D2  │ E2  │ F2  │ G2  │ H2  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    2 3 │ A3  │ B3  │ C3  │ D3  │ E3  │ F3  │ G3  │ H3  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
  ↓ 3 4 │ A4  │ B4  │ C4  │ D4  │ E4  │ F4  │ G4  │ H4  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    4 5 │ A5  │ B5  │ C5  │ D5  │ E5  │ F5  │ G5  │ H5  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    5 6 │ A6  │ B6  │ C6  │ D6  │ E6  │ F6  │ G6  │ H6  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    6 7 │ A7  │ B7  │ C7  │ D7  │ E7  │ F7  │ G7  │ H7  │
        ├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
    7 8 │ A8  │ B8  │ C8  │ D8  │ E8  │ F8  │ G8  │ H8  │
        └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

    Notation: Column Letter + Row Number (1-indexed)
    Internal: X = column index, Y = row index (0-indexed)
```

### 3.2 Direction Movement

```
┌─────────────────────────────────────────────────────────────────────┐
│                       MOVEMENT DIRECTIONS                            │
└─────────────────────────────────────────────────────────────────────┘

                    NorthWest    North    NorthEast
                    (-1, -1)    (0, -1)    (+1, -1)
                         ↖        ↑         ↗

                    West         ●         East
                   (-1, 0)    (X, Y)     (+1, 0)
                         ←                  →

                    SouthWest   South    SouthEast
                    (-1, +1)   (0, +1)    (+1, +1)
                         ↙        ↓         ↘
```

### 3.3 Layer Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                       APPLICATION LAYER                              │
├─────────────────────────────────────────────────────────────────────┤
│  ICombatGridService / CombatGridService                              │
│  ├── CreateGrid(room, width?, height?): CombatGrid                  │
│  ├── InitializePositions(grid, player, monsters): GridInitResult    │
│  ├── GetActiveGrid(): CombatGrid?                                   │
│  ├── SetActiveGrid(grid): void                                      │
│  ├── ClearGrid(): void                                              │
│  ├── GetEntityPosition(entityId): GridPosition?                     │
│  ├── GetDistance(entityId1, entityId2): int?                        │
│  └── AreAdjacent(entityId1, entityId2): bool                        │
├─────────────────────────────────────────────────────────────────────┤
│  Result Types                                                        │
│  └── GridInitializationResult { Success, PlayerPos, MonsterPos }    │
└───────┬─────────────────────────────────────────────────────────────┘
        │
        ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         DOMAIN LAYER                                 │
├─────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐  ┌──────────────────────────────────────┐  │
│  │ MovementDirection  │  │           GridPosition               │  │
│  │      (Enum)        │  │        (Value Object)                │  │
│  ├────────────────────┤  ├──────────────────────────────────────┤  │
│  │ North, South       │  │ + X: int, Y: int                     │  │
│  │ East, West         │  │ + Move(dir): GridPosition            │  │
│  │ NorthEast, NW      │  │ + DistanceTo(pos): int               │  │
│  │ SouthEast, SW      │  │ + ManhattanDistanceTo(pos): int      │  │
│  └────────────────────┘  │ + IsAdjacentTo(pos): bool            │  │
│                          │ + ToString(): string ("A1")          │  │
│                          │ + TryParse(s, out pos): bool         │  │
│                          │ + Origin: GridPosition               │  │
│                          └──────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                         GridCell                              │  │
│  │                      (Value Object)                           │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ + Position: GridPosition                                     │  │
│  │ + IsOccupied: bool                                           │  │
│  │ + OccupantId: Guid?                                          │  │
│  │ + IsPlayerOccupied: bool                                     │  │
│  │ + IsPassable: bool                                           │  │
│  │ + PlaceEntity(id, isPlayer): bool                            │  │
│  │ + RemoveEntity(): bool                                       │  │
│  │ + SetPassable(passable): void                                │  │
│  │ + GetDisplayChar(): char                                     │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                        CombatGrid                             │  │
│  │                         (Entity)                              │  │
│  ├──────────────────────────────────────────────────────────────┤  │
│  │ + Id: Guid                                                   │  │
│  │ + Width: int, Height: int                                    │  │
│  │ + RoomId: Guid?                                              │  │
│  │ + Cells: IReadOnlyDict<GridPosition, GridCell>               │  │
│  │ + EntityPositions: IReadOnlyDict<Guid, GridPosition>         │  │
│  │                                                              │  │
│  │ + Create(width, height, roomId?): CombatGrid                 │  │
│  │ + CreateDefault(roomId?): CombatGrid (8x8)                   │  │
│  │ + GetCell(position): GridCell?                               │  │
│  │ + IsInBounds(position): bool                                 │  │
│  │ + IsValidPosition(position): bool                            │  │
│  │ + PlaceEntity(id, position, isPlayer): bool                  │  │
│  │ + RemoveEntity(id): bool                                     │  │
│  │ + MoveEntity(id, newPosition): bool                          │  │
│  │ + GetEntityPosition(id): GridPosition?                       │  │
│  │ + GetDistanceBetween(id1, id2): int?                         │  │
│  │ + AreAdjacent(id1, id2): bool                                │  │
│  │ + GetEntitiesInRange(center, range): IEnumerable<Guid>       │  │
│  │ + GetAdjacentCells(position): IEnumerable<GridCell>          │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.4 Entity Position Tracking

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ENTITY POSITION TRACKING                          │
└─────────────────────────────────────────────────────────────────────┘

    CombatGrid
    ├── _cells: Dict<GridPosition, GridCell>
    │   ├── (0,0) → GridCell { OccupantId: null }
    │   ├── (1,0) → GridCell { OccupantId: monster1-id }
    │   ├── (3,7) → GridCell { OccupantId: player-id, IsPlayerOccupied: true }
    │   └── ...
    │
    └── _entityPositions: Dict<Guid, GridPosition>
        ├── player-id → (3, 7)     [Fast lookup by entity]
        ├── monster1-id → (1, 0)
        └── monster2-id → (5, 2)

    Two-Way Tracking:
    ┌───────────────┐         ┌───────────────┐
    │ GridCell      │◄───────►│ EntityPositions│
    │ Has occupant  │         │ Maps to cell   │
    └───────────────┘         └───────────────┘
```

---

## 4. MovementDirection Enum

### 4.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Enums/MovementDirection.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Directions for grid movement.
/// </summary>
public enum MovementDirection
{
    /// <summary>Up on the grid (Y decreases).</summary>
    North,

    /// <summary>Down on the grid (Y increases).</summary>
    South,

    /// <summary>Right on the grid (X increases).</summary>
    East,

    /// <summary>Left on the grid (X decreases).</summary>
    West,

    /// <summary>Up-right diagonal.</summary>
    NorthEast,

    /// <summary>Up-left diagonal.</summary>
    NorthWest,

    /// <summary>Down-right diagonal.</summary>
    SouthEast,

    /// <summary>Down-left diagonal.</summary>
    SouthWest
}
```

### 4.2 Direction Offsets Table

| Direction | X Offset | Y Offset | Abbreviations |
|-----------|----------|----------|---------------|
| North | 0 | -1 | n, north |
| South | 0 | +1 | s, south |
| East | +1 | 0 | e, east |
| West | -1 | 0 | w, west |
| NorthEast | +1 | -1 | ne, northeast |
| NorthWest | -1 | -1 | nw, northwest |
| SouthEast | +1 | +1 | se, southeast |
| SouthWest | -1 | +1 | sw, southwest |

---

## 5. GridPosition Value Object

### 5.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GridPosition.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a position on the combat grid.
/// </summary>
public readonly record struct GridPosition
{
    public int X { get; }
    public int Y { get; }

    public GridPosition(int x, int y) { X = x; Y = y; }

    public GridPosition Move(MovementDirection direction) => direction switch
    {
        MovementDirection.North => new GridPosition(X, Y - 1),
        MovementDirection.South => new GridPosition(X, Y + 1),
        MovementDirection.East => new GridPosition(X + 1, Y),
        MovementDirection.West => new GridPosition(X - 1, Y),
        MovementDirection.NorthEast => new GridPosition(X + 1, Y - 1),
        MovementDirection.NorthWest => new GridPosition(X - 1, Y - 1),
        MovementDirection.SouthEast => new GridPosition(X + 1, Y + 1),
        MovementDirection.SouthWest => new GridPosition(X - 1, Y + 1),
        _ => this
    };

    /// <summary>Chebyshev distance (allows diagonal movement).</summary>
    public int DistanceTo(GridPosition other) =>
        Math.Max(Math.Abs(X - other.X), Math.Abs(Y - other.Y));

    /// <summary>Manhattan distance (cardinal only).</summary>
    public int ManhattanDistanceTo(GridPosition other) =>
        Math.Abs(X - other.X) + Math.Abs(Y - other.Y);

    public bool IsAdjacentTo(GridPosition other) => DistanceTo(other) == 1;

    /// <summary>Returns display notation (e.g., "A1", "H8").</summary>
    public override string ToString()
    {
        var column = (char)('A' + X);
        var row = Y + 1;
        return $"{column}{row}";
    }

    public static bool TryParse(string input, out GridPosition position)
    {
        position = default;
        if (string.IsNullOrWhiteSpace(input) || input.Length < 2)
            return false;

        var column = char.ToUpperInvariant(input[0]);
        if (column < 'A' || column > 'Z')
            return false;

        if (!int.TryParse(input[1..], out var row) || row < 1)
            return false;

        position = new GridPosition(column - 'A', row - 1);
        return true;
    }

    public static GridPosition FromNotation(string notation)
    {
        if (!TryParse(notation, out var position))
            throw new ArgumentException($"Invalid grid notation: {notation}", nameof(notation));
        return position;
    }

    public static GridPosition Origin => new(0, 0);
}
```

---

## 6. GridCell Value Object

### 6.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/GridCell.cs`

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Represents a single cell on the combat grid.
/// </summary>
public class GridCell
{
    public GridPosition Position { get; }
    public bool IsOccupied => OccupantId.HasValue;
    public Guid? OccupantId { get; private set; }
    public bool IsPlayerOccupied { get; private set; }
    public bool IsPassable { get; private set; } = true;

    private GridCell(GridPosition position) { Position = position; }

    public static GridCell Create(GridPosition position) => new(position);
    public static GridCell Create(int x, int y) => new(new GridPosition(x, y));

    public bool PlaceEntity(Guid entityId, bool isPlayer)
    {
        if (IsOccupied || !IsPassable) return false;
        OccupantId = entityId;
        IsPlayerOccupied = isPlayer;
        return true;
    }

    public bool RemoveEntity()
    {
        if (!IsOccupied) return false;
        OccupantId = null;
        IsPlayerOccupied = false;
        return true;
    }

    public void SetPassable(bool passable) => IsPassable = passable;

    public char GetDisplayChar()
    {
        if (!IsPassable) return '#';
        if (IsPlayerOccupied) return '@';
        if (IsOccupied) return 'M';
        return '.';
    }
}
```

### 6.2 Display Characters

| Character | Meaning |
|-----------|---------|
| `.` | Empty passable cell |
| `@` | Player position |
| `M` | Monster position |
| `#` | Impassable terrain |

---

## 7. CombatGrid Entity

### 7.1 Implementation

**File:** `src/Core/RuneAndRust.Domain/Entities/CombatGrid.cs`

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a 2D grid for tactical combat positioning.
/// </summary>
public class CombatGrid : IEntity
{
    public Guid Id { get; private set; }
    public int Width { get; private set; }
    public int Height { get; private set; }
    public Guid? RoomId { get; private set; }

    private readonly Dictionary<GridPosition, GridCell> _cells = new();
    private readonly Dictionary<Guid, GridPosition> _entityPositions = new();

    public IReadOnlyDictionary<GridPosition, GridCell> Cells => _cells;
    public IReadOnlyDictionary<Guid, GridPosition> EntityPositions => _entityPositions;

    private CombatGrid() { }

    public static CombatGrid Create(int width, int height, Guid? roomId = null)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(width, 3);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(width, 20);
        ArgumentOutOfRangeException.ThrowIfLessThan(height, 3);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(height, 20);

        var grid = new CombatGrid
        {
            Id = Guid.NewGuid(),
            Width = width,
            Height = height,
            RoomId = roomId
        };
        grid.InitializeCells();
        return grid;
    }

    public static CombatGrid CreateDefault(Guid? roomId = null) => Create(8, 8, roomId);

    private void InitializeCells()
    {
        for (int y = 0; y < Height; y++)
            for (int x = 0; x < Width; x++)
            {
                var pos = new GridPosition(x, y);
                _cells[pos] = GridCell.Create(pos);
            }
    }

    public GridCell? GetCell(GridPosition position) =>
        _cells.TryGetValue(position, out var cell) ? cell : null;

    public GridCell? GetCell(int x, int y) => GetCell(new GridPosition(x, y));

    public bool IsInBounds(GridPosition pos) =>
        pos.X >= 0 && pos.X < Width && pos.Y >= 0 && pos.Y < Height;

    public bool IsValidPosition(GridPosition pos)
    {
        if (!IsInBounds(pos)) return false;
        var cell = GetCell(pos);
        return cell != null && cell.IsPassable && !cell.IsOccupied;
    }

    public bool PlaceEntity(Guid entityId, GridPosition position, bool isPlayer)
    {
        if (!IsInBounds(position)) return false;
        var cell = GetCell(position);
        if (cell == null || !cell.PlaceEntity(entityId, isPlayer)) return false;
        _entityPositions[entityId] = position;
        return true;
    }

    public bool RemoveEntity(Guid entityId)
    {
        if (!_entityPositions.TryGetValue(entityId, out var pos)) return false;
        var cell = GetCell(pos);
        if (cell == null || !cell.RemoveEntity()) return false;
        _entityPositions.Remove(entityId);
        return true;
    }

    public bool MoveEntity(Guid entityId, GridPosition newPosition)
    {
        if (!_entityPositions.TryGetValue(entityId, out var currentPos)) return false;
        if (!IsValidPosition(newPosition)) return false;

        var currentCell = GetCell(currentPos);
        var newCell = GetCell(newPosition);
        if (currentCell == null || newCell == null) return false;

        var isPlayer = currentCell.IsPlayerOccupied;
        if (!currentCell.RemoveEntity()) return false;
        if (!newCell.PlaceEntity(entityId, isPlayer))
        {
            currentCell.PlaceEntity(entityId, isPlayer); // Rollback
            return false;
        }
        _entityPositions[entityId] = newPosition;
        return true;
    }

    public GridPosition? GetEntityPosition(Guid entityId) =>
        _entityPositions.TryGetValue(entityId, out var pos) ? pos : null;

    public int? GetDistanceBetween(Guid id1, Guid id2)
    {
        var pos1 = GetEntityPosition(id1);
        var pos2 = GetEntityPosition(id2);
        if (!pos1.HasValue || !pos2.HasValue) return null;
        return pos1.Value.DistanceTo(pos2.Value);
    }

    public bool AreAdjacent(Guid id1, Guid id2) =>
        GetDistanceBetween(id1, id2) == 1;

    public IEnumerable<Guid> GetEntitiesInRange(GridPosition center, int range)
    {
        foreach (var (entityId, pos) in _entityPositions)
            if (center.DistanceTo(pos) <= range)
                yield return entityId;
    }

    public IEnumerable<GridCell> GetAdjacentCells(GridPosition position)
    {
        var directions = Enum.GetValues<MovementDirection>();
        foreach (var dir in directions)
        {
            var adjacent = position.Move(dir);
            if (IsInBounds(adjacent))
            {
                var cell = GetCell(adjacent);
                if (cell != null) yield return cell;
            }
        }
    }
}
```

---

## 8. CombatGridService

### 8.1 Interface

**File:** `src/Core/RuneAndRust.Application/Interfaces/ICombatGridService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

public interface ICombatGridService
{
    CombatGrid CreateGrid(Room room, int? width = null, int? height = null);
    GridInitializationResult InitializePositions(CombatGrid grid, Player player, IEnumerable<Monster> monsters);
    CombatGrid? GetActiveGrid();
    void SetActiveGrid(CombatGrid? grid);
    void ClearGrid();
    GridPosition? GetEntityPosition(Guid entityId);
    int? GetDistance(Guid entityId1, Guid entityId2);
    bool AreAdjacent(Guid entityId1, Guid entityId2);
}

public readonly record struct GridInitializationResult(
    bool Success, GridPosition PlayerPosition,
    IReadOnlyDictionary<Guid, GridPosition> MonsterPositions, string Message);
```

### 8.2 Implementation

**File:** `src/Core/RuneAndRust.Application/Services/CombatGridService.cs`

```csharp
namespace RuneAndRust.Application.Services;

public class CombatGridService : ICombatGridService
{
    private readonly IGameConfigurationProvider _config;
    private readonly ILogger<CombatGridService> _logger;
    private CombatGrid? _activeGrid;

    public CombatGridService(IGameConfigurationProvider config, ILogger<CombatGridService> logger)
    {
        _config = config;
        _logger = logger;
    }

    public CombatGrid CreateGrid(Room room, int? width = null, int? height = null)
    {
        var settings = _config.GetGridSettings();
        var w = width ?? settings.DefaultWidth;
        var h = height ?? settings.DefaultHeight;

        var grid = CombatGrid.Create(w, h, room.Id);
        _logger.LogInformation("Created {W}x{H} combat grid for room {Room}", w, h, room.Name);
        return grid;
    }

    public GridInitializationResult InitializePositions(
        CombatGrid grid, Player player, IEnumerable<Monster> monsters)
    {
        var monsterPositions = new Dictionary<Guid, GridPosition>();

        // Place player at center-south
        var playerPos = new GridPosition(grid.Width / 2, grid.Height - 2);
        if (!grid.PlaceEntity(player.Id, playerPos, true))
        {
            return new GridInitializationResult(false, default, monsterPositions,
                "Failed to place player on grid.");
        }
        _logger.LogDebug("Placed player at {Pos}", playerPos);

        // Place monsters in north zone
        var monsterList = monsters.ToList();
        var spacing = Math.Max(1, grid.Width / (monsterList.Count + 1));
        var y = 1;

        for (int i = 0; i < monsterList.Count; i++)
        {
            var monster = monsterList[i];
            var x = spacing * (i + 1);
            if (x >= grid.Width) x = grid.Width - 1;

            var pos = new GridPosition(x, y);
            if (grid.PlaceEntity(monster.Id, pos, false))
            {
                monsterPositions[monster.Id] = pos;
                _logger.LogDebug("Placed {Monster} at {Pos}", monster.Name, pos);
            }
        }

        return new GridInitializationResult(true, playerPos, monsterPositions,
            $"Initialized grid with player and {monsterPositions.Count} monsters.");
    }

    public CombatGrid? GetActiveGrid() => _activeGrid;
    public void SetActiveGrid(CombatGrid? grid) => _activeGrid = grid;
    public void ClearGrid() => _activeGrid = null;

    public GridPosition? GetEntityPosition(Guid entityId) =>
        _activeGrid?.GetEntityPosition(entityId);

    public int? GetDistance(Guid id1, Guid id2) =>
        _activeGrid?.GetDistanceBetween(id1, id2);

    public bool AreAdjacent(Guid id1, Guid id2) =>
        _activeGrid?.AreAdjacent(id1, id2) ?? false;
}
```

---

## 9. Data Model Changes

| Type | Layer | Description |
|------|-------|-------------|
| `MovementDirection` | Domain/Enums | Eight-direction movement |
| `GridPosition` | Domain/ValueObjects | X,Y coordinates with notation |
| `GridCell` | Domain/ValueObjects | Cell occupancy tracking |
| `CombatGrid` | Domain/Entities | Grid dimensions and cells |
| `ICombatGridService` | Application/Interfaces | Grid service interface |
| `CombatGridService` | Application/Services | Grid management implementation |

---

## 10. Configuration File Schemas

**File:** `config/grid.json`

```json
{
  "$schema": "./schemas/grid.schema.json",
  "gridSettings": {
    "defaultWidth": 8,
    "defaultHeight": 8,
    "minWidth": 3,
    "maxWidth": 20,
    "minHeight": 3,
    "maxHeight": 20,
    "playerStartPosition": "center-south",
    "monsterSpawnZone": "north"
  },
  "roomGridOverrides": [
    { "roomId": "boss-chamber", "width": 12, "height": 12 },
    { "roomId": "narrow-corridor", "width": 3, "height": 10 }
  ]
}
```

---

## 11. Logging Specifications

| Component | Level | Events |
|-----------|-------|--------|
| `CombatGridService` | Information | Grid created, combat started/ended |
| `CombatGridService` | Debug | Entity placements, position lookups |

---

## 12. Unit Testing Requirements

| Feature | Test Count |
|---------|------------|
| MovementDirection Enum | ~2 |
| GridPosition | ~10 |
| GridCell | ~6 |
| CombatGrid | ~8 |
| CombatGridService | ~4 |
| **Total** | **~30** |

---

## 13. Use Cases

### UC-001: Create Combat Grid
**Flow:** Combat starts → CreateGrid(room) → Initialize cells → SetActiveGrid

### UC-002: Place Entities
**Flow:** InitializePositions → Place player center-south → Place monsters north zone

### UC-003: Check Adjacency
**Flow:** Melee attack → AreAdjacent(player, monster) → Allow/deny attack

### UC-004: Get Distance
**Flow:** Range check → GetDistance(attacker, target) → Compare to weapon range

---

## 14. Deliverable Checklist

### Domain Layer
- [ ] `MovementDirection` enum
- [ ] `GridPosition` value object
- [ ] `GridCell` value object
- [ ] `CombatGrid` entity

### Application Layer
- [ ] `ICombatGridService` interface
- [ ] `CombatGridService` implementation
- [ ] `GridInitializationResult` record

### Configuration
- [ ] `grid.json` with settings
- [ ] `grid.schema.json`

### Testing
- [ ] ~30 unit tests
- [ ] All tests passing

---

## 15. Acceptance Criteria

### Functional
- [ ] GridPosition stores X, Y coordinates correctly
- [ ] GridPosition calculates distance (Chebyshev and Manhattan)
- [ ] GridPosition.Move returns correct adjacent position
- [ ] GridPosition string notation works (A1, B3, etc.)
- [ ] GridCell tracks occupancy state
- [ ] GridCell prevents multiple occupants
- [ ] CombatGrid initializes with correct dimensions (3-20 range)
- [ ] CombatGrid validates boundary positions
- [ ] CombatGrid places entities correctly
- [ ] CombatGrid moves entities between cells with rollback
- [ ] CombatGrid tracks all entity positions bidirectionally
- [ ] CombatGridService creates grids for rooms
- [ ] CombatGridService initializes entity positions (player south, monsters north)

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~30 unit tests pass
- [ ] Configuration validates against schema
- [ ] XML documentation complete

---

## 16. Dependencies

### Required from v0.4.3d
| Type | Usage |
|------|-------|
| `Room` | Grid association |
| `Player`, `Monster` | Entity placement |

### Provides to v0.5.0b
- `CombatGrid` for movement operations
- `GridPosition` for position tracking
- `ICombatGridService` for movement validation

### Provides to v0.5.0c
- `GridCell.GetDisplayChar()` for ASCII rendering
- Grid dimensions for display sizing

---

## 17. Future Considerations

### Deferred to v0.5.0b
- Movement speed stat
- Movement points per turn
- `move` command
- Movement cost (1 cardinal, 1.5 diagonal)

### Deferred to v0.5.0c
- ASCII grid display
- Combat service integration
- Position display in attacks

### Out of Scope for v0.5.0
- Terrain types
- Cover mechanics
- Line of sight

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: AI Assistant*
