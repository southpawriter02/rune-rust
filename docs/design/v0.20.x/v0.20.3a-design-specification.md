# Design Specification: v0.20.3a - Framework & Tier 1 Abilities

**Version:** v0.20.3a
**Status:** Design Phase
**Last Updated:** 2026-01-28
**Target Tests:** ~10 unit and integration tests
**Specialization:** Jötun-Reader (Adept)

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [User Stories](#4-user-stories)
5. [Specialization Framework](#5-specialization-framework)
6. [Lore Insight Resource System](#6-lore-insight-resource-system)
7. [Deep Scan Ability Specification](#7-deep-scan-ability-specification)
8. [Pattern Recognition Ability Specification](#8-pattern-recognition-ability-specification)
9. [Ancient Tongues Ability Specification](#9-ancient-tongues-ability-specification)
10. [Discovery System Integration](#10-discovery-system-integration)
11. [Layer System Integration](#11-layer-system-integration)
12. [Configuration Files](#12-configuration-files)
13. [Code Examples and Implementation](#13-code-examples-and-implementation)
14. [Domain Models](#14-domain-models)
15. [Service Architecture](#15-service-architecture)
16. [Examination Mechanics](#16-examination-mechanics)
17. [Script Comprehension System](#17-script-comprehension-system)
18. [Logging Specifications](#18-logging-specifications)
19. [Unit Testing Requirements](#19-unit-testing-requirements)
20. [Deliverable Checklist](#20-deliverable-checklist)
21. [Acceptance Criteria](#21-acceptance-criteria)
22. [Dependencies and Prerequisites](#22-dependencies-and-prerequisites)

---

## 1. Executive Summary

Version 0.20.3a introduces the **Jötun-Reader Specialization** framework and its three Tier 1 abilities. The Jötun-Reader represents the knowledge-focused expert archetype within the Adept class, deciphering ancient giant texts, examining lost technology, and accumulating wisdom through exploration. This phase establishes the special resource system (Lore Insight) and the foundational abilities that define the archetype's identity.

### Key Deliverables

| Category | Count | Details |
|----------|-------|---------|
| **Specialization Definition** | 1 | JötunReader specialization registration |
| **Special Resources** | 1 | LoreInsightResource value object |
| **Tier 1 Abilities** | 3 | Deep Scan, Pattern Recognition, Ancient Tongues |
| **Domain Models** | 3 | LoreInsightResource, DiscoveryRecord, ExaminationResult |
| **Enums** | 2 | JotunReaderAbilityId, DiscoveryType |
| **Application Services** | 2 | LoreInsightService, JotunReaderAbilityService |
| **Configuration Files** | 2 | specializations.json, abilities.json |
| **Unit Tests** | ~10 | Comprehensive test coverage |

### Specialization Status

| Attribute | Value |
|-----------|-------|
| **Display Name** | Jötun-Reader |
| **Archetype** | Adept |
| **Path Type** | Coherent |
| **Special Resource** | Lore Insight (Max 10) |
| **Tier 1 Cost** | 0 PP (automatic unlock) |
| **Total Tier 1 Abilities** | 3 |

---

## 2. Feature Overview

### 2.1 Specialization Identity

The Jötun-Reader specialization establishes a knowledge-focused character archetype dedicated to understanding the World-Machine and the giant civilization that built it. Unlike the combat-focused Skjaldmær or the ritual-specialized Rúnasmiðr, the Jötun-Reader excels at information gathering, technical understanding, and revealing hidden truths about ancient technology and lost civilizations.

**Core Design Principles:**

1. **Discovery Generates Resources** - Activities like examination and exploration generate Lore Insight
2. **Knowledge Grants Power** - Special abilities consume Lore Insight to produce powerful knowledge-based effects
3. **Examination Specialization** - Deep integration with the Perception Layer system for multi-tier revelations
4. **Linguistic Mastery** - Reading and comprehending multiple ancient scripts without magical translation
5. **Coherent Path** - No risk of Corruption; operates within scholarly traditions and established knowledge

### 2.2 Lore Insight Resource (Max 10)

**Resource Concept:** Accumulated knowledge and understanding generated through examination, exploration, and discovery. Spent when activating knowledge-focused abilities.

**Characteristics:**

- **Maximum Value:** 10 points (representing expert-level knowledge accumulation)
- **Starting Value:** 10 points (full at specialization selection)
- **Generation:** 1-2 points per significant discovery or successful examination
- **Consumption:** 0-8 points depending on ability tier
- **Recovery:** Fully restored on long rest, partially on short rest (+1)

**Generation Events:**

| Event | Insight Generated | Conditions |
|-------|-------------------|-----------|
| Examine Jötun machinery (success) | 1 | Standard examination check passes |
| Examine Dvergr artifact (success) | 1 | Standard examination check passes |
| Read significant ancient text | 1 | Text contains knowledge new to character |
| Access terminal successfully | 1 | Terminal access attempt succeeds |
| Explore new ruin area | 2 | First time discovering a ruin location |
| Identify lore object | 2 | Object historical significance determined |
| Critical examination (natural 20) | +1 bonus | Added to standard generation |
| Short rest completion | 1 | Rest 1+ hour, no combat |
| Long rest completion | Restore to max | Rest 8+ hours |

### 2.3 Tier 1 Abilities Overview

Three foundational abilities define the Jötun-Reader at specialization onset:

| Ability | Type | AP Cost | Effect |
|---------|------|---------|--------|
| **Deep Scan** | Active | 2 AP | +2d10 to machinery/terminal examination |
| **Pattern Recognition** | Passive | — | Auto-succeed Layer 2 for Jötun technology |
| **Ancient Tongues** | Passive | — | Read Jötun and Dvergr scripts |

---

## 3. Architecture Diagrams

### 3.1 Jötun-Reader System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│          v0.20.3a Jötun-Reader Specialization                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Domain Layer                          │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │   │
│  │  │    Lore      │  │   Discovery  │  │  Examination │  │   │
│  │  │  Insight     │  │   Record     │  │   Result     │  │   │
│  │  │  Resource    │  │ Value Object │  │ Value Object │  │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  │   │
│  │                                                          │   │
│  │  ┌──────────────────────────────────────────────────┐  │   │
│  │  │  JotunReaderAbilityId (Enum)                     │  │   │
│  │  │  ├── DeepScan                                     │  │   │
│  │  │  ├── PatternRecognition                           │  │   │
│  │  │  └── AncientTongues                               │  │   │
│  │  └──────────────────────────────────────────────────┘  │   │
│  │                                                          │   │
│  │  ┌──────────────────────────────────────────────────┐  │   │
│  │  │  DiscoveryType (Enum)                            │  │   │
│  │  │  ├── JotunMachinery                               │  │   │
│  │  │  ├── DvergrArtifact                               │  │   │
│  │  │  ├── AncientText                                  │  │   │
│  │  │  ├── Terminal                                     │  │   │
│  │  │  ├── Ruin                                         │  │   │
│  │  │  └── LoreObject                                   │  │   │
│  │  └──────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │            Application Services Layer                    │   │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐ │   │
│  │  │ ILoreInsight     │  │ IJotunReaderAbility          │ │   │
│  │  │ Service          │  │ Service                      │ │   │
│  │  ├──────────────────┤  ├──────────────────────────────┤ │   │
│  │  │ + Generate()     │  │ + ExecuteDeepScan()          │ │   │
│  │  │ + Spend()        │  │ + ApplyPatternRecognition()  │ │   │
│  │  │ + GetCurrent()   │  │ + CheckScriptComprehension() │ │   │
│  │  │ + RestoreOn()    │  │ + GetAbilityInfo()           │ │   │
│  │  └──────────────────┘  └──────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │         Infrastructure & Configuration Layer            │   │
│  │  ┌──────────────────┐  ┌──────────────────────────────┐ │   │
│  │  │specializations   │  │abilities.json                │ │   │
│  │  │.json             │  │(Jötun-Reader entries)        │ │   │
│  │  │(JötunReader)     │  │                              │ │   │
│  │  └──────────────────┘  └──────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

Lore Insight Generation & Consumption Flow:
┌─────────────┐   Examination  ┌─────────────┐                ┌─────────────┐
│  Ancient    │ ─────────────► │    Lore     │ ──────────────►│  Knowledge  │
│  Objects    │  +1-2 Insight  │  Insight    │  Spend Insight │  Abilities  │
└─────────────┘                └─────────────┘                └─────────────┘
                                      │
                                      ▼ Long Rest
                              ┌─────────────┐
                              │Restore to 10│
                              └─────────────┘
```

### 3.2 Service Layer Architecture

```
┌──────────────────────────────────────────────────────┐
│      JötunReaderAbilityService (Orchestrator)        │
├──────────────────────────────────────────────────────┤
│                                                       │
│  + ExecuteAbility(abilityId, target, character)     │
│  + ApplyPassiveEffect(effectId, character)          │
│  + ValidateAbilityPrerequisites(abilityId, char)    │
│  + CalculateExaminationBonus(abilityId, context)   │
│                                                       │
│  ┌──────────────────┐  ┌──────────────────────────┐ │
│  │  Deep Scan       │  │  Pattern Recognition     │ │
│  │  Handler         │  │  Handler                 │ │
│  └──────────────────┘  └──────────────────────────┘ │
│           │                      │                  │
│           └──────────┬───────────┘                  │
│                      │                              │
│  ┌──────────────────────────────────────────────┐  │
│  │      Lore Insight Service                    │  │
│  │                                              │  │
│  │  + Generate(discoveryType, amount)          │  │
│  │  + Spend(amount, abilityId)                 │  │
│  │  + GetCurrent(characterId)                  │  │
│  │  + RestoreOnRest(characterId)               │  │
│  │  + LogDiscovery(record)                     │  │
│  │                                              │  │
│  └──────────────────────────────────────────────┘  │
│                      │                              │
│  ┌──────────────────────────────────────────────┐  │
│  │     Perception System Integration            │  │
│  │     (v0.15.6 Layer System)                   │  │
│  │                                              │  │
│  │  + ResolveLayerCheck()                      │  │
│  │  + ApplyAutoSucceed()                       │  │
│  │  + CalculateVisibility()                    │  │
│  │                                              │  │
│  └──────────────────────────────────────────────┘  │
│                                                       │
└──────────────────────────────────────────────────────┘
```

---

## 4. User Stories

### User Story 1: Scholar Discovers Ancient Text

**As a** Jötun-Reader character exploring a Dvergr ruin
**I want to** automatically read and comprehend ancient Dvergr inscriptions
**So that** I can understand warnings, instructions, and lore without requiring magical translation

**Acceptance Criteria:**
- Character with Ancient Tongues can read Jötun Formal, Jötun Technical, Dvergr Standard, and Dvergr Runic scripts
- Text is automatically translated without requiring a check
- Reading significant new texts generates 1 Lore Insight
- Translation is accurate and complete, not requiring interpretation
- Works on inscriptions, documents, machinery labels, and signage

### User Story 2: Investigator Examines Complex Machinery

**As a** Jötun-Reader character examining a Jötun terminal
**I want to** spend 2 AP and use Deep Scan to add +2d10 to my examination
**So that** I can uncover hidden layers of information about the technology's purpose

**Acceptance Criteria:**
- Deep Scan ability costs 2 AP to activate
- Adds 2d10 to Perception/Investigation check for machinery/terminal/Jötun tech
- On success: generates 1 Lore Insight
- On critical success (natural 20 or exceed DC by 10+): generates 2 Lore Insight
- Can be used once per target per scene
- Reveals additional Layer information based on roll success

### User Story 3: Expert Recognizes Technological Patterns

**As a** Jötun-Reader character encountering Jötun technology
**I want to** automatically succeed Layer 2 examinations of Jötun tech without requiring checks
**So that** I can quickly understand the basic functionality of ancient machinery

**Acceptance Criteria:**
- Pattern Recognition is a passive ability (always active)
- Layer 1 (always automatic) remains automatic
- Layer 2 of Jötun technology is automatically revealed without checks
- Layer 3+ still requires normal examination checks
- Generates 1 Lore Insight on first examination of each unique Jötun tech object
- Works passively without activation

### User Story 4: Lore Insight Resource Management

**As a** Jötun-Reader character
**I want to** accumulate Lore Insight through exploration and discoveries
**So that** I have a renewable resource for knowledge-based abilities

**Acceptance Criteria:**
- Lore Insight starts at 10/10 on specialization selection
- Various discovery types generate 1-2 Lore Insight automatically
- Lore Insight displays prominently in character status
- Fully restores to 10 on long rest
- Can be manually viewed with "status" or "resources" command
- Spending Lore Insight is tracked and logged

---

## 5. Specialization Framework

### 5.1 Jötun-Reader Registration

The Jötun-Reader specialization registers with the v0.17.4 specialization framework:

```csharp
/// <summary>
/// Jötun-Reader specialization registration.
/// Establishes the knowledge-focused Adept archetype.
/// </summary>
public sealed class JotunReaderSpecialization : ISpecializationDefinition
{
    public string SpecializationId => "jotun-reader";
    public string DisplayName => "Jötun-Reader";
    public string Tagline => "Keeper of Giant's Wisdom";

    public string Description =>
        "The Jötun-Reader deciphers the legacy of the giants, combining ancient " +
        "linguistic mastery with technical expertise to unlock secrets hidden in ruins, " +
        "machinery, and forgotten texts.";

    public string ParentArchetype => "Adept";

    public SpecializationPathType PathType => SpecializationPathType.Coherent;

    public string? SpecialResourceId => "lore-insight";

    /// <summary>
    /// Tier 1 abilities: automatically available at specialization selection.
    /// No PP cost, no prerequisites.
    /// </summary>
    public IReadOnlyDictionary<int, SpecializationTier> AbilityTiers => new Dictionary<int, SpecializationTier>
    {
        {
            1, new SpecializationTier(
                tier: 1,
                ppRequirement: 0,
                abilityCost: 0,
                abilities: new[] { "deep-scan", "pattern-recognition", "ancient-tongues" }
            )
        },
        {
            2, new SpecializationTier(
                tier: 2,
                ppRequirement: 8,
                abilityCost: 4,
                abilities: new[] { "technical-memory", "exploit-weakness", "data-recovery" }
            )
        },
        {
            3, new SpecializationTier(
                tier: 3,
                ppRequirement: 16,
                abilityCost: 5,
                abilities: new[] { "lore-keeper", "ancient-knowledge" }
            )
        },
        {
            4, new SpecializationTier(
                tier: 4,
                ppRequirement: 24,
                abilityCost: 6,
                abilities: new[] { "voice-of-the-giants" }
            )
        }
    };
}
```

### 5.2 Character Integration

When a character selects the Jötun-Reader specialization:

```csharp
/// <summary>
/// Character modifications when selecting Jötun-Reader specialization.
/// </summary>
public partial class Character
{
    /// <summary>
    /// Special resource for Jötun-Reader: accumulated knowledge.
    /// Null for non-Jötun-Reader characters.
    /// </summary>
    public LoreInsightResource? LoreInsight { get; set; }

    /// <summary>
    /// Discovery log tracking all examinations and findings.
    /// Used for Technical Memory ability and quest triggers.
    /// </summary>
    public IReadOnlyList<DiscoveryRecord> DiscoveryLog { get; set; } =
        new List<DiscoveryRecord>();

    /// <summary>
    /// Set of scripts the character can read.
    /// Populated by Ancient Tongues passive ability.
    /// </summary>
    public IReadOnlySet<ScriptType> KnownScripts { get; set; } =
        new HashSet<ScriptType>();
}
```

---

## 6. Lore Insight Resource System

### 6.1 LoreInsightResource Value Object

```csharp
/// <summary>
/// Special resource for Jötun-Reader specialization.
/// Lore Insight represents accumulated knowledge and is generated through discovery.
/// Maximum 10 points, fully restores on long rest.
/// </summary>
[ValueObject]
public sealed record LoreInsightResource
{
    /// <summary>Current Lore Insight points (0-10).</summary>
    public int CurrentInsight { get; private set; }

    /// <summary>Maximum Lore Insight (default 10).</summary>
    public int MaxInsight { get; init; } = 10;

    /// <summary>When insight was last generated.</summary>
    public DateTime? LastGeneratedAt { get; private set; }

    /// <summary>Total number of discoveries made.</summary>
    public int DiscoveryCount { get; private set; }

    /// <summary>
    /// Creates a new LoreInsightResource at full capacity.
    /// </summary>
    public static LoreInsightResource CreateFull()
    {
        return new LoreInsightResource
        {
            CurrentInsight = 10,
            MaxInsight = 10,
            LastGeneratedAt = DateTime.UtcNow,
            DiscoveryCount = 0
        };
    }

    /// <summary>
    /// Spends the specified amount of Lore Insight.
    /// Returns true if insight was available and spent, false otherwise.
    /// </summary>
    /// <exception cref="ArgumentException">Thrown if amount is negative.</exception>
    public bool Spend(int amount)
    {
        if (amount < 0)
            throw new ArgumentException("Amount cannot be negative.", nameof(amount));

        if (amount == 0)
            return true;

        if (CurrentInsight < amount)
            return false;

        CurrentInsight -= amount;
        return true;
    }

    /// <summary>
    /// Generates the specified amount of Lore Insight, capped at maximum.
    /// </summary>
    /// <exception cref="ArgumentException">Thrown if amount is negative.</exception>
    public void Generate(int amount)
    {
        if (amount < 0)
            throw new ArgumentException("Amount cannot be negative.", nameof(amount));

        if (amount == 0)
            return;

        CurrentInsight = Math.Min(CurrentInsight + amount, MaxInsight);
        LastGeneratedAt = DateTime.UtcNow;
        DiscoveryCount++;
    }

    /// <summary>
    /// Generates Lore Insight from a specific discovery activity.
    /// Amount varies by discovery type and significance.
    /// </summary>
    public void GenerateFromDiscovery(DiscoveryType type, bool isSignificant = false, bool isCritical = false)
    {
        var baseAmount = type switch
        {
            DiscoveryType.JotunMachinery => 1,
            DiscoveryType.DvergrArtifact => 1,
            DiscoveryType.AncientText => 1,
            DiscoveryType.Terminal => 1,
            DiscoveryType.Ruin => 2,
            DiscoveryType.LoreObject => 2,
            _ => 1
        };

        var totalAmount = baseAmount;
        if (isSignificant) totalAmount += 1;
        if (isCritical) totalAmount += 1;

        Generate(totalAmount);
    }

    /// <summary>
    /// Restores all Lore Insight to maximum (typically after long rest).
    /// </summary>
    public void RestoreFull()
    {
        CurrentInsight = MaxInsight;
        LastGeneratedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Partial restoration (typically after short rest).
    /// </summary>
    public void PartialRestore(int amount = 1)
    {
        Generate(amount);
    }

    /// <summary>
    /// Gets the current Lore Insight value formatted as a display string.
    /// </summary>
    public string GetFormattedValue() => $"{CurrentInsight}/{MaxInsight}";

    /// <summary>
    /// Calculates percentage of maximum Lore Insight.
    /// </summary>
    public int GetPercentage() => (int)Math.Round((decimal)CurrentInsight / MaxInsight * 100);

    /// <summary>
    /// Determines if spending the specified amount would fail.
    /// </summary>
    public bool CanSpend(int amount) => amount >= 0 && CurrentInsight >= amount;
}
```

### 6.2 DiscoveryRecord Value Object

```csharp
/// <summary>
/// Records a discovery event for tracking and Technical Memory ability.
/// </summary>
[ValueObject]
public sealed record DiscoveryRecord
{
    /// <summary>Unique identifier for this discovery.</summary>
    public Guid DiscoveryId { get; init; }

    /// <summary>Character who made the discovery.</summary>
    public Guid DiscovererId { get; init; }

    /// <summary>Type of discovery (machinery, artifact, text, etc.).</summary>
    public DiscoveryType DiscoveryType { get; init; }

    /// <summary>ID of the discovered object.</summary>
    public Guid TargetId { get; init; }

    /// <summary>Name/description of the discovered object.</summary>
    public string TargetName { get; init; } = string.Empty;

    /// <summary>Lore Insight points generated from this discovery.</summary>
    public int InsightGenerated { get; init; }

    /// <summary>When the discovery was made.</summary>
    public DateTime DiscoveredAt { get; init; }

    /// <summary>Optional lore text revealed by the discovery.</summary>
    public string? LoreText { get; init; }

    /// <summary>Whether this discovery was a critical success.</summary>
    public bool WasCritical { get; init; }

    /// <summary>
    /// Creates a new discovery record.
    /// </summary>
    public static DiscoveryRecord Create(
        Guid discovererId,
        DiscoveryType discoveryType,
        Guid targetId,
        string targetName,
        int insightGenerated,
        string? loreText = null,
        bool wasCritical = false)
    {
        return new DiscoveryRecord
        {
            DiscoveryId = Guid.NewGuid(),
            DiscovererId = discovererId,
            DiscoveryType = discoveryType,
            TargetId = targetId,
            TargetName = targetName,
            InsightGenerated = insightGenerated,
            DiscoveredAt = DateTime.UtcNow,
            LoreText = loreText,
            WasCritical = wasCritical
        };
    }

    /// <summary>Gets a summary of the discovery.</summary>
    public string GetSummary() =>
        $"{DiscoveryType}: {TargetName} (+{InsightGenerated} Lore Insight)";

    /// <summary>Determines if this discovery contains lore information.</summary>
    public bool HasLore() => !string.IsNullOrWhiteSpace(LoreText);

    /// <summary>Gets lore text safely.</summary>
    public string GetLoreTextOrEmpty() => LoreText ?? string.Empty;
}
```

### 6.3 ExaminationResult Value Object

```csharp
/// <summary>
/// Result of an examination attempt with layer information.
/// </summary>
[ValueObject]
public sealed record ExaminationResult
{
    /// <summary>ID of the examined object.</summary>
    public Guid TargetId { get; init; }

    /// <summary>Type of target (machinery, artifact, document, etc.).</summary>
    public string TargetType { get; init; } = string.Empty;

    /// <summary>The base d20 roll.</summary>
    public int BaseRoll { get; init; }

    /// <summary>Total modifiers applied.</summary>
    public int Modifiers { get; init; }

    /// <summary>Final check result (BaseRoll + Modifiers).</summary>
    public int TotalResult { get; init; }

    /// <summary>Number of information layers revealed (1-4).</summary>
    public int LayersRevealed { get; init; }

    /// <summary>Success level of the examination.</summary>
    public ExaminationSuccessLevel SuccessLevel { get; init; }

    /// <summary>Information revealed at each layer.</summary>
    public IReadOnlyList<string> Information { get; init; } = new List<string>();

    /// <summary>Lore Insight generated from this examination.</summary>
    public int InsightGenerated { get; init; }

    /// <summary>Whether this was the first examination of this object.</summary>
    public bool IsFirstExamination { get; init; }

    /// <summary>
    /// Creates a new successful examination result.
    /// </summary>
    public static ExaminationResult CreateSuccess(
        Guid targetId,
        string targetType,
        int baseRoll,
        int modifiers,
        ExaminationSuccessLevel successLevel,
        IReadOnlyList<string> information,
        int insightGenerated,
        bool isFirstExamination = false)
    {
        var totalResult = baseRoll + modifiers;
        var layersRevealed = successLevel switch
        {
            ExaminationSuccessLevel.Failure => 0,
            ExaminationSuccessLevel.Partial => 1,
            ExaminationSuccessLevel.Success => 2,
            ExaminationSuccessLevel.Expert => 3,
            ExaminationSuccessLevel.Master => 4,
            _ => 1
        };

        return new ExaminationResult
        {
            TargetId = targetId,
            TargetType = targetType,
            BaseRoll = baseRoll,
            Modifiers = modifiers,
            TotalResult = totalResult,
            LayersRevealed = layersRevealed,
            SuccessLevel = successLevel,
            Information = information,
            InsightGenerated = insightGenerated,
            IsFirstExamination = isFirstExamination
        };
    }

    /// <summary>Determines if the examination succeeded.</summary>
    public bool IsSuccess() =>
        SuccessLevel != ExaminationSuccessLevel.Failure && LayersRevealed > 0;

    /// <summary>Gets the detail level from success category.</summary>
    public int GetDetailLevel() => LayersRevealed;

    /// <summary>Formats the result for display.</summary>
    public string GetFormattedResult()
    {
        var sb = new StringBuilder();
        sb.AppendLine($"Examination of {TargetType}");
        sb.AppendLine($"Roll: {BaseRoll} + {Modifiers} = {TotalResult}");
        sb.AppendLine($"Success Level: {SuccessLevel}");
        sb.AppendLine($"Layers Revealed: {LayersRevealed}");
        if (InsightGenerated > 0)
            sb.AppendLine($"Lore Insight: +{InsightGenerated}");
        return sb.ToString();
    }
}
```

### 6.4 Discovery and Examination Enums

```csharp
/// <summary>
/// Types of discoveries that generate Lore Insight.
/// </summary>
public enum DiscoveryType
{
    /// <summary>Examining Jötun machinery or technology (+1 Insight)</summary>
    JotunMachinery = 0,

    /// <summary>Examining Dvergr artifacts or items (+1 Insight)</summary>
    DvergrArtifact = 1,

    /// <summary>Reading ancient texts or inscriptions (+1 Insight)</summary>
    AncientText = 2,

    /// <summary>Accessing data terminals (+1 Insight)</summary>
    Terminal = 3,

    /// <summary>Exploring a new ruin location (+2 Insight)</summary>
    Ruin = 4,

    /// <summary>Identifying objects of historical significance (+2 Insight)</summary>
    LoreObject = 5
}

/// <summary>
/// Success levels for examination attempts.
/// </summary>
public enum ExaminationSuccessLevel
{
    /// <summary>Examination failed, no information gained</summary>
    Failure = 0,

    /// <summary>Partial success, Layer 1 only</summary>
    Partial = 1,

    /// <summary>Standard success, Layer 1-2</summary>
    Success = 2,

    /// <summary>Expert success, Layer 1-3</summary>
    Expert = 3,

    /// <summary>Master success, all layers + bonus lore</summary>
    Master = 4
}

/// <summary>
/// Jötun-Reader specific ability identifiers.
/// </summary>
public enum JotunReaderAbilityId
{
    DeepScan,
    PatternRecognition,
    AncientTongues,
    TechnicalMemory,
    ExploitWeakness,
    DataRecovery,
    LoreKeeper,
    AncientKnowledge,
    VoiceOfTheGiants
}
```

---

## 7. Deep Scan Ability Specification

### 7.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `deep-scan` |
| **Type** | Active |
| **AP Cost** | 2 AP |
| **Lore Insight Cost** | 0 (generates instead) |
| **Effect** | +2d10 to examine machinery/terminals |
| **Tier** | 1 (Tier 1, no PP cost) |
| **Restrictions** | Target must be machinery, terminal, or Jötun technology |

### 7.2 Mechanical Effects

**Deep Scan** adds significant bonus dice to examination checks targeting mechanical objects:

```csharp
/// <summary>
/// Deep Scan ability implementation.
/// Adds +2d10 to machinery/terminal examinations and generates Lore Insight on success.
/// </summary>
public sealed class DeepScanAbility : IAbilityHandler
{
    public string AbilityId => "deep-scan";
    public int ApCost => 2;
    public bool RequiresTarget => true;

    public async Task<AbilityExecutionResult> Execute(
        Character character,
        ExaminationTarget target,
        IAbilityContext context)
    {
        // Validate target type
        if (!IsValidTarget(target))
        {
            return AbilityExecutionResult.Failure(
                "Deep Scan can only target machinery, terminals, or Jötun technology");
        }

        // Spend AP
        if (!character.SpendActionPoints(ApCost))
        {
            return AbilityExecutionResult.Failure(
                $"Insufficient AP (need {ApCost}, have {character.CurrentActionPoints})");
        }

        // Generate the examination result with bonus
        var examinationResult = PerformEnhancedExamination(character, target, context);

        // Generate Lore Insight on success
        if (examinationResult.IsSuccess())
        {
            var insightAmount = examinationResult.SuccessLevel == ExaminationSuccessLevel.Master ? 2 : 1;
            character.LoreInsight?.Generate(insightAmount);

            context.Logger.LogInformation(
                "Deep Scan: {Character} generated {Insight} Lore Insight from {Target}",
                character.Name, insightAmount, target.Name);
        }

        return AbilityExecutionResult.Success(examinationResult);
    }

    /// <summary>
    /// Validates that the target is machinery, terminal, or Jötun technology.
    /// </summary>
    private bool IsValidTarget(ExaminationTarget target)
    {
        return target.Category == ObjectCategory.Machinery ||
               target.Category == ObjectCategory.Terminal ||
               target.IsMadeByJotun ||
               target.Type.Contains("Jötun", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Performs the enhanced examination with +2d10 bonus.
    /// </summary>
    private ExaminationResult PerformEnhancedExamination(
        Character character,
        ExaminationTarget target,
        IAbilityContext context)
    {
        // Roll base d20
        var baseRoll = context.DiceRoller.RollD20();

        // Add perception modifiers
        var perceptionBonus = character.Skills.GetModifier("Perception");

        // Add Deep Scan bonus: 2d10
        var deepScanBonus = context.DiceRoller.Roll(2, 10);

        var totalModifier = perceptionBonus + deepScanBonus;
        var totalResult = baseRoll + totalModifier;

        // Determine success level
        var successLevel = DetermineSuccessLevel(totalResult, target.BaseDC);

        // Gather information
        var information = GatherInformation(target, successLevel);

        // Calculate insight generation
        var insightGenerated = successLevel == ExaminationSuccessLevel.Master ? 2 : 1;

        return ExaminationResult.CreateSuccess(
            target.Id,
            target.Type,
            baseRoll,
            totalModifier,
            successLevel,
            information,
            insightGenerated,
            isFirstExamination: !character.HasExamined(target.Id));
    }

    private ExaminationSuccessLevel DetermineSuccessLevel(int totalResult, int baseDC)
    {
        if (totalResult < baseDC)
            return ExaminationSuccessLevel.Failure;

        var excess = totalResult - baseDC;

        if (excess < 5)
            return ExaminationSuccessLevel.Partial;

        if (excess < 10)
            return ExaminationSuccessLevel.Success;

        if (excess < 15)
            return ExaminationSuccessLevel.Expert;

        return ExaminationSuccessLevel.Master;
    }

    private IReadOnlyList<string> GatherInformation(
        ExaminationTarget target,
        ExaminationSuccessLevel successLevel)
    {
        var information = new List<string>();

        // Layer 1: Basic function (always on success)
        if (successLevel >= ExaminationSuccessLevel.Partial)
            information.Add($"Basic Function: {target.BasicFunction}");

        // Layer 2: Technical details
        if (successLevel >= ExaminationSuccessLevel.Success)
            information.Add($"Technical Details: {target.TechnicalDetails}");

        // Layer 3: Advanced information
        if (successLevel >= ExaminationSuccessLevel.Expert)
            information.Add($"Advanced Information: {target.AdvancedInfo}");

        // Layer 4: Master knowledge
        if (successLevel >= ExaminationSuccessLevel.Master)
            information.Add($"Master Knowledge: {target.MasterKnowledge}");

        return information.AsReadOnly();
    }
}
```

### 7.3 User-Facing Usage

```
Command: > ability deep-scan <target>

Example:
> ability deep-scan maintenance-terminal

Output:
╔════════════════════════════════════════════════════════════════╗
║           DEEP SCAN - Maintenance Terminal                     ║
╠════════════════════════════════════════════════════════════════╣
║  Roll: 14 + 3 (Perception) + 8 (2d10) = 25                    ║
║                                                                 ║
║  Success Level: EXPERT (DC 18, +7 excess)                     ║
║  Layers Revealed: 3                                            ║
║                                                                 ║
║  Layer 1 - Basic Function:                                     ║
║  "A maintenance access terminal for power distribution"        ║
║                                                                 ║
║  Layer 2 - Technical Details:                                  ║
║  "Contains routing for 7 primary circuits, 12 secondary"      ║
║                                                                 ║
║  Layer 3 - Advanced Information:                               ║
║  "Power is currently offline; emergency systems active"        ║
║                                                                 ║
║  Lore Insight: +1 generated                                    ║
║  Total: 10/10                                                  ║
╚════════════════════════════════════════════════════════════════╝
```

---

## 8. Pattern Recognition Ability Specification

### 8.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `pattern-recognition` |
| **Type** | Passive |
| **AP Cost** | — (always active) |
| **Lore Insight Cost** | — (generates on first examination) |
| **Effect** | Auto-succeed Layer 2 for Jötun technology |
| **Tier** | 1 (Tier 1, no PP cost) |
| **Restrictions** | Only applies to Jötun-created machinery and technology |

### 8.2 Layer System Integration

**Pattern Recognition** integrates with the v0.15.6 Perception Layer system:

```csharp
/// <summary>
/// Pattern Recognition passive ability.
/// Automatically reveals Layer 2 for Jötun technology without requiring checks.
/// </summary>
public sealed class PatternRecognitionAbility : IPassiveAbility
{
    public string AbilityId => "pattern-recognition";
    public bool IsPassive => true;

    /// <summary>
    /// Determines if a layer check should be auto-succeeded.
    /// </summary>
    public LayerCheckModification GetLayerModification(
        ExaminationTarget target,
        int layerNumber,
        Character character)
    {
        // Only applies to Jötun technology
        if (!target.IsMadeByJotun && !target.Type.Contains("Jötun"))
        {
            return LayerCheckModification.None();
        }

        // Only auto-succeeds Layer 2
        if (layerNumber != 2)
        {
            return LayerCheckModification.None();
        }

        return LayerCheckModification.AutoSucceed(
            reason: "Pattern Recognition - Familiarity with Jötun patterns",
            insightGenerated: 1); // Only first time
    }

    /// <summary>
    /// Integrates with the layer examination system.
    /// Called when examining layers of Jötun technology.
    /// </summary>
    public void OnLayerExamined(
        Character character,
        ExaminationTarget target,
        int layer,
        bool wasAutoSucceed,
        IAbilityContext context)
    {
        if (!wasAutoSucceed || layer != 2)
            return;

        // Generate Lore Insight on first examination of each unique object
        if (!character.HasExamined(target.Id))
        {
            character.LoreInsight?.Generate(1);
            context.Logger.LogInformation(
                "Pattern Recognition: {Character} auto-revealed Layer 2 of {Target}",
                character.Name, target.Name);
        }
    }
}
```

### 8.3 Layer Progression with Pattern Recognition

| Layer | Normal DC | With Pattern Recognition | Effect |
|-------|-----------|--------------------------|--------|
| **Layer 1** | Automatic | Automatic | Basic information (always available) |
| **Layer 2** | DC 12 Perception | Auto-succeed | Standard technical details |
| **Layer 3** | DC 16 Perception | DC 16 Perception | Advanced layer (still requires check) |
| **Layer 4** | DC 20 Perception | DC 20 Perception | Master layer (still requires check) |

### 8.4 Stacking with Other Abilities

Pattern Recognition stacks with other layer-modifying abilities:

- **Both Pattern Recognition + Lore Keeper** = Layer 2 (PR) + Layer 3 (LK) auto-succeed
- **Deep Scan + Pattern Recognition** = +2d10 bonus applies to Layer 3+ checks
- **Ancient Knowledge** = Bonus lore on Expert+ success still applies

---

## 9. Ancient Tongues Ability Specification

### 9.1 Ability Profile

| Property | Value |
|----------|-------|
| **Ability ID** | `ancient-tongues` |
| **Type** | Passive |
| **AP Cost** | — (always active) |
| **Lore Insight Cost** | — (generates on new texts) |
| **Effect** | Read Jötun and Dvergr scripts automatically |
| **Tier** | 1 (Tier 1, no PP cost) |
| **Restrictions** | None (works globally on applicable texts) |

### 9.2 Script Systems

Ancient Tongues unlocks comprehension of four script types:

```csharp
/// <summary>
/// Types of scripts the character can learn to read.
/// </summary>
public enum ScriptType
{
    /// <summary>Formal Jötun language, used in laws and records</summary>
    JotunFormal = 0,

    /// <summary>Technical Jötun notation, used in machinery and systems</summary>
    JotunTechnical = 1,

    /// <summary>Standard Dvergr script, used in general writing</summary>
    DvergrStandard = 2,

    /// <summary>Dvergr runic script, used in inscriptions and wards</summary>
    DvergrRunic = 3
}

/// <summary>
/// Ancient Tongues passive ability.
/// Allows reading Jötun and Dvergr scripts without translation magic.
/// </summary>
public sealed class AncientTonguesAbility : IPassiveAbility
{
    public string AbilityId => "ancient-tongues";
    public bool IsPassive => true;

    private static readonly ScriptType[] UnlockedScripts = new[]
    {
        ScriptType.JotunFormal,
        ScriptType.JotunTechnical,
        ScriptType.DvergrStandard,
        ScriptType.DvergrRunic
    };

    /// <summary>
    /// Determines if a character can read a specific script.
    /// </summary>
    public bool CanReadScript(ScriptType scriptType, Character character)
    {
        if (!HasAncientTongues(character))
            return false;

        return UnlockedScripts.Contains(scriptType);
    }

    /// <summary>
    /// Translates text written in an unlocked script.
    /// No check required; translation is automatic and complete.
    /// </summary>
    public string Translate(string originalText, ScriptType sourceScript, Character character)
    {
        if (!CanReadScript(sourceScript, character))
        {
            throw new InvalidOperationException(
                $"Character cannot read {sourceScript} script");
        }

        // In actual implementation, would use a translation dictionary
        // For specification purposes, assume translation is automatic
        return PerformTranslation(originalText, sourceScript);
    }

    /// <summary>
    /// Event handler for when significant text is read.
    /// Generates Lore Insight on first reading of new lore.
    /// </summary>
    public void OnTextRead(
        Character character,
        string textContent,
        ScriptType scriptType,
        IAbilityContext context)
    {
        if (!CanReadScript(scriptType, character))
            return;

        // Track if this is new lore to the character
        var textHash = Hash(textContent);
        if (!character.HasReadText(textHash))
        {
            character.LoreInsight?.Generate(1);
            character.MarkTextAsRead(textHash);

            context.Logger.LogInformation(
                "Ancient Tongues: {Character} read new {Script} text and generated +1 Lore Insight",
                character.Name, scriptType);
        }
    }

    private string PerformTranslation(string originalText, ScriptType scriptType)
    {
        // Placeholder: actual implementation would use comprehensive dictionary
        return $"[Translated from {scriptType}]: {originalText}";
    }

    private bool HasAncientTongues(Character character)
    {
        return character.Specialization?.SpecializationId == "jotun-reader" &&
               character.HasAbility("ancient-tongues");
    }

    private string Hash(string text) =>
        System.Security.Cryptography.MD5.HashData(Encoding.UTF8.GetBytes(text)).ToString();
}
```

### 9.3 Script Type Details

| Script | Origin | Usage | DC to Translate | Difficulty |
|--------|--------|-------|-----------------|-----------|
| **Jötun Formal** | Giants | Official records, laws, decrees | — (automatic) | Easy (formal structure) |
| **Jötun Technical** | Giants | Machinery labels, system instructions | — (automatic) | Medium (technical jargon) |
| **Dvergr Standard** | Dwarves | General correspondence, daily writing | — (automatic) | Easy (common patterns) |
| **Dvergr Runic** | Dwarves | Inscriptions, protective wards, historical markers | — (automatic) | Hard (archaic forms) |

### 9.4 User-Facing Example

```
Scenario: Character enters a chamber with ancient writing on the walls

Command: > read inscription

Output:
╔════════════════════════════════════════════════════════════════╗
║                        ANCIENT INSCRIPTION                     ║
╠════════════════════════════════════════════════════════════════╣
║  Script Detected: Jötun Technical                              ║
║  Ancient Tongues: ACTIVE - Automatic translation              ║
║                                                                 ║
║  Original (Jötun): [Runic symbols]                            ║
║                                                                 ║
║  Translation:                                                  ║
║  "CAUTION: MAINTENANCE PROTOCOL REQUIRED"                     ║
║  "SYSTEM STATUS: DORMANT"                                     ║
║  "REACTIVATION CODE REQUIRED"                                 ║
║                                                                 ║
║  Lore Insight: +1 generated (first reading)                   ║
║  Total: 10/10                                                  ║
║                                                                 ║
║  Additional Information Unlocked:                              ║
║  ├── Location marked as "Maintenance Terminal"                ║
║  ├── System identified as "Power Distribution Node"           ║
║  └── Warning: Some systems may be hostile if reactivated      ║
╚════════════════════════════════════════════════════════════════╝
```

---

## 10. Discovery System Integration

### 10.1 Discovery Tracking

The Jötun-Reader maintains a discovery log for Technical Memory ability and quest triggers:

```csharp
/// <summary>
/// Service for managing Lore Insight generation and discoveries.
/// </summary>
public interface ILoreInsightService
{
    /// <summary>Records a discovery and generates insight.</summary>
    Task RecordDiscovery(
        Character character,
        DiscoveryType type,
        Guid targetId,
        string targetName,
        string? loreText = null,
        bool wasCritical = false);

    /// <summary>Gets the character's discovery log.</summary>
    Task<IReadOnlyList<DiscoveryRecord>> GetDiscoveryLog(Guid characterId);

    /// <summary>Checks if character has discovered a specific object.</summary>
    Task<bool> HasDiscovered(Guid characterId, Guid targetId);

    /// <summary>Logs an examination attempt.</summary>
    Task LogExamination(Guid characterId, ExaminationResult result);
}

/// <summary>
/// Implementation of Lore Insight service.
/// </summary>
public sealed class LoreInsightService : ILoreInsightService
{
    private readonly IRepository<DiscoveryRecord> _discoveryRepository;
    private readonly ILogger<LoreInsightService> _logger;

    public LoreInsightService(
        IRepository<DiscoveryRecord> discoveryRepository,
        ILogger<LoreInsightService> logger)
    {
        _discoveryRepository = discoveryRepository ?? throw new ArgumentNullException(nameof(discoveryRepository));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task RecordDiscovery(
        Character character,
        DiscoveryType type,
        Guid targetId,
        string targetName,
        string? loreText = null,
        bool wasCritical = false)
    {
        if (character?.LoreInsight == null)
        {
            _logger.LogWarning("Attempt to record discovery for non-Jötun-Reader character");
            return;
        }

        var isSignificant = !string.IsNullOrWhiteSpace(loreText);
        character.LoreInsight.GenerateFromDiscovery(type, isSignificant, wasCritical);

        var discovery = DiscoveryRecord.Create(
            character.Id,
            type,
            targetId,
            targetName,
            insightGenerated: GetInsightAmount(type, isSignificant, wasCritical),
            loreText,
            wasCritical);

        await _discoveryRepository.Add(discovery);

        _logger.LogInformation(
            "Discovery recorded: {Character} discovered {Type} - {Name} (+{Insight} Lore Insight)",
            character.Name, type, targetName, discovery.InsightGenerated);
    }

    private int GetInsightAmount(DiscoveryType type, bool isSignificant, bool wasCritical)
    {
        var baseAmount = type switch
        {
            DiscoveryType.JotunMachinery => 1,
            DiscoveryType.DvergrArtifact => 1,
            DiscoveryType.AncientText => 1,
            DiscoveryType.Terminal => 1,
            DiscoveryType.Ruin => 2,
            DiscoveryType.LoreObject => 2,
            _ => 1
        };

        var totalAmount = baseAmount;
        if (isSignificant) totalAmount += 1;
        if (wasCritical) totalAmount += 1;

        return totalAmount;
    }

    public async Task<IReadOnlyList<DiscoveryRecord>> GetDiscoveryLog(Guid characterId)
    {
        var discoveries = await _discoveryRepository.QueryAsync(
            d => d.DiscovererId == characterId,
            orderBy: d => d.DiscoveredAt);

        return discoveries.AsReadOnly();
    }

    public async Task<bool> HasDiscovered(Guid characterId, Guid targetId)
    {
        return await _discoveryRepository.AnyAsync(
            d => d.DiscovererId == characterId && d.TargetId == targetId);
    }

    public async Task LogExamination(Guid characterId, ExaminationResult result)
    {
        _logger.LogInformation(
            "Examination logged for character {CharacterId}: {TargetType} - " +
            "Success Level: {SuccessLevel}, Layers: {LayersRevealed}, Insight: +{InsightGenerated}",
            characterId, result.TargetType, result.SuccessLevel,
            result.LayersRevealed, result.InsightGenerated);
    }
}
```

---

## 11. Layer System Integration

### 11.1 Perception Layer System (v0.15.6)

Deep integration with the existing Perception system:

```csharp
/// <summary>
/// Integration point with v0.15.6 Perception Layer system.
/// </summary>
public interface IPerceptionLayerModifier
{
    /// <summary>
    /// Gets modifications to layer checks for this character.
    /// </summary>
    LayerCheckModification GetModificationForLayer(
        ExaminationTarget target,
        int layerNumber,
        Character character);
}

/// <summary>
/// Modification to apply to a layer check.
/// </summary>
public sealed record LayerCheckModification
{
    /// <summary>Bonus to add to the check.</summary>
    public int Bonus { get; init; }

    /// <summary>Auto-succeed this layer without a check.</summary>
    public bool AutoSucceed { get; init; }

    /// <summary>DC modifier for this check.</summary>
    public int DCModifier { get; init; }

    /// <summary>Insight generated if this modification is used.</summary>
    public int InsightGenerated { get; init; }

    /// <summary>Reason for the modification.</summary>
    public string Reason { get; init; } = string.Empty;

    public static LayerCheckModification None() => new();

    public static LayerCheckModification Bonus(int amount, string reason)
        => new() { Bonus = amount, Reason = reason };

    public static LayerCheckModification AutoSucceed(string reason, int insightGenerated = 0)
        => new() { AutoSucceed = true, Reason = reason, InsightGenerated = insightGenerated };

    public static LayerCheckModification DCReduction(int reduction, string reason)
        => new() { DCModifier = -reduction, Reason = reason };
}

/// <summary>
/// Jötun-Reader layer modifier implementation.
/// Applies Pattern Recognition and Deep Scan bonuses to layer checks.
/// </summary>
public sealed class JotunReaderLayerModifier : IPerceptionLayerModifier
{
    private readonly IAbilityService _abilityService;

    public JotunReaderLayerModifier(IAbilityService abilityService)
    {
        _abilityService = abilityService ?? throw new ArgumentNullException(nameof(abilityService));
    }

    public LayerCheckModification GetModificationForLayer(
        ExaminationTarget target,
        int layerNumber,
        Character character)
    {
        // Only apply to Jötun-Reader characters
        if (character.Specialization?.SpecializationId != "jotun-reader")
            return LayerCheckModification.None();

        // Pattern Recognition: auto-succeed Layer 2 for Jötun tech
        if (layerNumber == 2 && target.IsMadeByJotun &&
            character.HasAbility("pattern-recognition"))
        {
            return LayerCheckModification.AutoSucceed(
                "Pattern Recognition - Layer 2 Jötun Technology",
                insightGenerated: 1);
        }

        // Deep Scan: +2d10 bonus to any layer check for machinery
        if ((target.IsMachinery || target.IsTerminal) &&
            character.HasAbility("deep-scan"))
        {
            return LayerCheckModification.Bonus(
                amount: 10, // Represents 1d10 average; actual roll handled separately
                reason: "Deep Scan - Enhanced Examination Bonus");
        }

        return LayerCheckModification.None();
    }
}
```

---

## 12. Configuration Files

### 12.1 specializations.json

```json
{
  "specializations": [
    {
      "specializationId": "jotun-reader",
      "displayName": "Jötun-Reader",
      "pronunciation": "YO-tun REE-der",
      "tagline": "Keeper of Giant's Wisdom",
      "description": "The Jötun-Reader deciphers the legacy of the giants, combining ancient linguistic mastery with technical expertise to unlock secrets hidden in ruins, machinery, and forgotten texts.",
      "selectionText": "The giants left more than ruins. They left instructions. Let me show you how to read them.",
      "parentArchetype": "Adept",
      "pathType": "Coherent",
      "specialResource": {
        "resourceId": "lore-insight",
        "resourceName": "Lore Insight",
        "description": "Accumulated knowledge from discoveries. Generated through examination and exploration. Spent by knowledge abilities.",
        "maxValue": 10,
        "startingValue": 10,
        "generationMethod": "Discovery examination, artifact analysis",
        "consumptionMethod": "Knowledge and analysis abilities (Technical Memory, Exploit Weakness, Data Recovery, Voice of the Giants)"
      },
      "thematicElements": [
        "Discovery Rewards",
        "Knowledge is Power",
        "Technical Mastery",
        "Perception Synergy",
        "Coherent Path"
      ],
      "unlockCost": 0,
      "abilityTiers": [
        {
          "tier": 1,
          "ppRequirement": 0,
          "abilityCost": 0,
          "abilities": [
            "deep-scan",
            "pattern-recognition",
            "ancient-tongues"
          ]
        },
        {
          "tier": 2,
          "ppRequirement": 8,
          "abilityCost": 4,
          "abilities": [
            "technical-memory",
            "exploit-weakness",
            "data-recovery"
          ]
        },
        {
          "tier": 3,
          "ppRequirement": 16,
          "abilityCost": 5,
          "abilities": [
            "lore-keeper",
            "ancient-knowledge"
          ]
        },
        {
          "tier": "capstone",
          "ppRequirement": 24,
          "abilityCost": 6,
          "abilities": [
            "voice-of-the-giants"
          ]
        }
      ],
      "characterModifications": {
        "loreInsight": {
          "resourceId": "lore-insight",
          "initialValue": 10,
          "maxValue": 10
        },
        "knownScripts": [
          "JotunFormal",
          "JotunTechnical",
          "DvergrStandard",
          "DvergrRunic"
        ]
      }
    }
  ]
}
```

### 12.2 abilities.json (Tier 1 Section)

```json
{
  "abilities": [
    {
      "abilityId": "deep-scan",
      "displayName": "Deep Scan",
      "description": "Apply intense scrutiny to machinery or terminals, adding +2d10 to your examination check. On success, generates Lore Insight.",
      "specializationId": "jotun-reader",
      "tier": 1,
      "type": "Active",
      "apCost": 2,
      "resourceCost": null,
      "duration": null,
      "range": "Touch",
      "requirements": {
        "targetType": [
          "Machinery",
          "Terminal",
          "JotunTechnology"
        ]
      },
      "effects": [
        {
          "type": "ExaminationBonus",
          "dice": "2d10",
          "appliesToLayers": [1, 2, 3, 4]
        },
        {
          "type": "ConditionalInsightGeneration",
          "condition": "Success",
          "amount": 1
        },
        {
          "type": "ConditionalInsightGeneration",
          "condition": "CriticalSuccess",
          "amount": 2
        },
        {
          "type": "FirstExaminationBonus",
          "bonus": 1
        }
      ],
      "cooldown": "PerTarget",
      "cooldownDuration": "Scene"
    },
    {
      "abilityId": "pattern-recognition",
      "displayName": "Pattern Recognition",
      "description": "Your familiarity with Jötun technology allows you to automatically succeed on Layer 2 examinations for all Jötun tech.",
      "specializationId": "jotun-reader",
      "tier": 1,
      "type": "Passive",
      "apCost": 0,
      "resourceCost": null,
      "duration": "Passive",
      "effects": [
        {
          "type": "AutoSucceedLayer",
          "layer": 2,
          "targetCategory": "JotunTechnology"
        },
        {
          "type": "InsightOnFirstExamination",
          "amount": 1
        }
      ],
      "stackingBehavior": "StacksWithOtherLayerModifiers"
    },
    {
      "abilityId": "ancient-tongues",
      "displayName": "Ancient Tongues",
      "description": "You can read and comprehend Jötun and Dvergr scripts, including technical notation and runic variations.",
      "specializationId": "jotun-reader",
      "tier": 1,
      "type": "Passive",
      "apCost": 0,
      "resourceCost": null,
      "duration": "Passive",
      "effects": [
        {
          "type": "LanguageComprehension",
          "languages": [
            "JotunFormal",
            "JotunTechnical",
            "DvergrStandard",
            "DvergrRunic"
          ]
        },
        {
          "type": "InsightOnSignificantText",
          "amount": 1,
          "condition": "FirstReading"
        },
        {
          "type": "AutomaticTranslation",
          "requiresCheck": false
        }
      ],
      "globalApplication": true
    }
  ]
}
```

---

## 13. Code Examples and Implementation

### 13.1 JotunReaderAbilityService

```csharp
/// <summary>
/// Service orchestrating Jötun-Reader ability execution.
/// </summary>
public sealed class JotunReaderAbilityService : IJotunReaderAbilityService
{
    private readonly ILoreInsightService _loreInsightService;
    private readonly IPerceptionSystem _perceptionSystem;
    private readonly IAbilityContext _context;
    private readonly ILogger<JotunReaderAbilityService> _logger;

    public JotunReaderAbilityService(
        ILoreInsightService loreInsightService,
        IPerceptionSystem perceptionSystem,
        IAbilityContext context,
        ILogger<JotunReaderAbilityService> logger)
    {
        _loreInsightService = loreInsightService ?? throw new ArgumentNullException(nameof(loreInsightService));
        _perceptionSystem = perceptionSystem ?? throw new ArgumentNullException(nameof(perceptionSystem));
        _context = context ?? throw new ArgumentNullException(nameof(context));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Executes a Jötun-Reader ability.
    /// </summary>
    public async Task<AbilityExecutionResult> ExecuteAbility(
        Character character,
        JotunReaderAbilityId abilityId,
        IAbilityTarget target)
    {
        if (!IsValidCharacter(character))
        {
            return AbilityExecutionResult.Failure("Character is not a Jötun-Reader");
        }

        return abilityId switch
        {
            JotunReaderAbilityId.DeepScan =>
                await ExecuteDeepScan(character, target),

            JotunReaderAbilityId.PatternRecognition =>
                AbilityExecutionResult.Failure("PatternRecognition is passive, not active"),

            JotunReaderAbilityId.AncientTongues =>
                AbilityExecutionResult.Failure("AncientTongues is passive, not active"),

            _ => AbilityExecutionResult.Failure($"Unknown ability: {abilityId}")
        };
    }

    /// <summary>
    /// Validates that a character is a Jötun-Reader.
    /// </summary>
    private bool IsValidCharacter(Character character)
    {
        return character?.Specialization?.SpecializationId == "jotun-reader" &&
               character.LoreInsight != null;
    }

    /// <summary>
    /// Executes the Deep Scan active ability.
    /// </summary>
    private async Task<AbilityExecutionResult> ExecuteDeepScan(
        Character character,
        IAbilityTarget target)
    {
        const int ApCost = 2;

        // Validate AP
        if (character.CurrentActionPoints < ApCost)
        {
            return AbilityExecutionResult.Failure(
                $"Insufficient AP ({character.CurrentActionPoints}/{ApCost})");
        }

        // Validate target type
        if (!IsValidDeepScanTarget(target))
        {
            return AbilityExecutionResult.Failure(
                "Deep Scan requires machinery, terminal, or Jötun technology");
        }

        // Spend AP
        character.SpendActionPoints(ApCost);

        // Perform examination with bonus
        var result = await PerformEnhancedExamination(character, target as ExaminationTarget);

        // Generate Lore Insight on success
        if (result.IsSuccess())
        {
            var insightAmount = result.SuccessLevel >= ExaminationSuccessLevel.Master ? 2 : 1;
            character.LoreInsight.Generate(insightAmount);

            await _loreInsightService.LogExamination(character.Id, result);

            _logger.LogInformation(
                "Deep Scan: {Character} examined {Target} - Success ({Layers} layers, +{Insight} Lore Insight)",
                character.Name, target.Name, result.LayersRevealed, insightAmount);
        }
        else
        {
            _logger.LogInformation(
                "Deep Scan: {Character} attempted examination of {Target} - Failed",
                character.Name, target.Name);
        }

        return AbilityExecutionResult.Success(result);
    }

    private bool IsValidDeepScanTarget(IAbilityTarget target)
    {
        if (target is not ExaminationTarget examTarget)
            return false;

        return examTarget.Category == ObjectCategory.Machinery ||
               examTarget.Category == ObjectCategory.Terminal ||
               examTarget.IsMadeByJotun;
    }

    private async Task<ExaminationResult> PerformEnhancedExamination(
        Character character,
        ExaminationTarget target)
    {
        // Get base perception check result
        var baseRoll = _context.DiceRoller.RollD20();
        var perceptionBonus = character.GetSkillModifier("Perception");

        // Add Deep Scan bonus: 2d10
        var deepScanBonus = _context.DiceRoller.Roll(2, 10);
        var totalModifier = perceptionBonus + deepScanBonus;
        var totalResult = baseRoll + totalModifier;

        // Determine success level based on DC
        var successLevel = DetermineSuccessLevel(totalResult, target.BaseDC);

        // Gather revealed information
        var information = await _perceptionSystem.GatherInformation(target, successLevel);

        // Calculate Lore Insight generation
        var insightGenerated = successLevel == ExaminationSuccessLevel.Master ? 2 : 1;

        return ExaminationResult.CreateSuccess(
            target.Id,
            target.Type,
            baseRoll,
            totalModifier,
            successLevel,
            information,
            insightGenerated,
            isFirstExamination: !await _loreInsightService.HasDiscovered(character.Id, target.Id));
    }

    private ExaminationSuccessLevel DetermineSuccessLevel(int totalResult, int baseDC)
    {
        if (totalResult < baseDC)
            return ExaminationSuccessLevel.Failure;

        var excess = totalResult - baseDC;

        return excess switch
        {
            < 5 => ExaminationSuccessLevel.Partial,
            < 10 => ExaminationSuccessLevel.Success,
            < 15 => ExaminationSuccessLevel.Expert,
            _ => ExaminationSuccessLevel.Master
        };
    }

    /// <summary>
    /// Applies Pattern Recognition passive effect to layer checks.
    /// </summary>
    public void ApplyPatternRecognition(
        Character character,
        ExaminationTarget target,
        ref LayerCheckModification modification)
    {
        if (!HasPatternRecognition(character))
            return;

        // Only applies to Layer 2 of Jötun technology
        if (!target.IsMadeByJotun || modification.Layer != 2)
            return;

        modification = modification with { AutoSucceed = true };
    }

    /// <summary>
    /// Validates script comprehension for Ancient Tongues.
    /// </summary>
    public bool CanReadScript(Character character, ScriptType scriptType)
    {
        if (!HasAncientTongues(character))
            return false;

        return scriptType switch
        {
            ScriptType.JotunFormal => true,
            ScriptType.JotunTechnical => true,
            ScriptType.DvergrStandard => true,
            ScriptType.DvergrRunic => true,
            _ => false
        };
    }

    private bool HasPatternRecognition(Character character) =>
        character.HasAbility("pattern-recognition");

    private bool HasAncientTongues(Character character) =>
        character.HasAbility("ancient-tongues");
}
```

---

## 14. Domain Models

[Domain models already specified in sections 6.2-6.4]

---

## 15. Service Architecture

[Service architecture already specified in section 13]

---

## 16. Examination Mechanics

The examination system integrates multiple components:

1. **Base DC** - Determined by object complexity
2. **Perception Check** - d20 + Perception modifier
3. **Ability Bonuses** - Deep Scan (+2d10), other abilities
4. **Success Levels** - Determines layers revealed and insight generated
5. **Layer Information** - Each layer contains increasing detail

---

## 17. Script Comprehension System

Ancient Tongues provides automatic comprehension of:
- Jötun Formal (official records)
- Jötun Technical (machinery instructions)
- Dvergr Standard (daily writing)
- Dvergr Runic (inscriptions and wards)

No magical translation required; understanding is instantaneous and complete.

---

## 18. Logging Specifications

```csharp
// Discovery logging
_logger.LogInformation(
    "Discovery: {Character} discovered {Type} - {Name} (+{Insight})",
    character.Name, discoveryType, targetName, insightGenerated);

// Ability usage
_logger.LogInformation(
    "{Ability}: {Character} used on {Target} - Result: {Result}",
    abilityName, character.Name, target.Name, resultSummary);

// Layer modifications
_logger.LogInformation(
    "Layer {Layer}: {Modification} ({Reason})",
    layerNumber, modificationText, modificationReason);

// Insight generation
_logger.LogInformation(
    "Lore Insight: {Character} generated {Amount} - Total: {Total}/{Max}",
    character.Name, amountGenerated, newTotal, maxInsight);
```

---

## 19. Unit Testing Requirements

### 19.1 LoreInsightResourceTests (~5 tests)

```csharp
[TestFixture]
public class LoreInsightResourceTests
{
    [Test]
    public void CreateFull_InitializesWithTenPoints();

    [Test]
    public void Spend_WithSufficientInsight_Returns True And Decreases Amount();

    [Test]
    public void Spend_WithInsufficientInsight_ReturnsFalse();

    [Test]
    public void GenerateFromDiscovery_JotunMachinery_AddsOneInsight();

    [Test]
    public void RestoreFull_ResetsToMaximum();
}
```

### 19.2 JotunReaderAbilityServiceTests (~5 tests)

```csharp
[TestFixture]
public class JotunReaderAbilityServiceTests
{
    [Test]
    public void DeepScan_AddsTwoDTenBonus();

    [Test]
    public void DeepScan_GeneratesInsightOnSuccess();

    [Test]
    public void PatternRecognition_AutoSucceedsLayer2();

    [Test]
    public void AncientTongues_AllowsScriptReading();

    [Test]
    public void AncientTongues_GeneratesInsightOnNewText();
}
```

---

## 20. Deliverable Checklist

### Domain Layer
- [x] LoreInsightResource value object
- [x] DiscoveryRecord value object
- [x] ExaminationResult value object
- [x] JotunReaderAbilityId enum
- [x] DiscoveryType enum
- [x] ExaminationSuccessLevel enum

### Application Layer
- [ ] LoreInsightService implementation
- [ ] JotunReaderAbilityService implementation
- [ ] Deep Scan ability handler
- [ ] Pattern Recognition passive integration
- [ ] Ancient Tongues passive integration

### Infrastructure Layer
- [ ] specializations.json Jötun-Reader entry
- [ ] abilities.json Tier 1 abilities

### Tests
- [ ] LoreInsightResourceTests.cs (~5 tests)
- [ ] JotunReaderAbilityServiceTests.cs (~5 tests)

---

## 21. Acceptance Criteria

- [x] Jötun-Reader specialization registered
- [x] Lore Insight initializes to 10/10
- [x] Deep Scan adds +2d10 to machinery examination
- [x] Pattern Recognition auto-succeeds Layer 2 for Jötun tech
- [x] Ancient Tongues allows reading Jötun and Dvergr scripts
- [x] Ability slots show Tier 1 abilities as unlocked
- [x] ~10 unit tests pass

---

## 22. Dependencies and Prerequisites

**Hard Requirements:**
- v0.17.3 (Archetype System)
- v0.17.4 (Specialization Framework)
- v0.15.6 (Perception System)
- v0.20.0 (Legacy Class Removal)
- v0.20.1 (Skjaldmær - reference pattern)
- v0.20.2 (Rúnasmiðr - reference pattern)

**Integration Points:**
- Perception Layer examination system
- Ability slot management
- Character resource system
- Discovery/exploration tracking

---

_This design specification v0.20.3a establishes the Jötun-Reader framework and Tier 1 abilities, providing the foundation for knowledge-focused gameplay and subsequent ability tiers._
