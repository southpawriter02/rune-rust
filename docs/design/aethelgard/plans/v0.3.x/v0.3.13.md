Here is the comprehensive implementation plan for v0.3.13: The Scales (Balance & Tuning).
This milestone shifts focus from feature implementation to data validation and balancing. It introduces "Headless Simulation" tools that run thousands of iterations of game loops (Loot and Combat) to generate statistical reports. This ensures that drop rates are rewarding without breaking the economy and that combat is challenging without being mathematically impossible.
To manage the distinct domains of economy and combat math, this version is split into two sub-versions:
	•	v0.3.13a: The Loot Audit – Monte Carlo simulations for item drops and economy.
	•	v0.3.13b: The Combat Simulator – Headless battle resolution for Time-To-Kill (TTK) and win-rate analysis.

v0.3.13a: The Loot Audit
Goal: Implement LootAuditService to run batch simulations of LootService.GenerateLoot(). This tool will verify that drop rates for Myth-Forged items, specific material types, and overall scrap value match the design intent across all Danger Levels.
1. Architecture & Data Flow
	•	Input: BiomeType, DangerLevel, IterationCount (e.g., 10,000).
	•	Process:
	1	Loop N times.
	2	Call LootService.GenerateLoot(context).
	3	Aggregate results (Count per ItemType, Count per Rarity, Total Value).
	•	Output: Generate a Markdown report (loot-report.md) summarizing distribution percentages vs. target weights.
2. Logic Decision Trees
A. Audit Loop Logic Input: Audit Configuration
	1	Initialize Aggregators: Dictionary<Rarity, int>, Dictionary<ItemType, int>.
	2	Execute Loop:
	◦	Generate Context (random WITS bonus if range specified).
	◦	Result = LootService.GenerateLoot().
	◦	Update Aggregators.
	3	Analysis:
	◦	Calculate Actual % = (Count / Total) * 100.
	◦	Compare vs Expected % (defined in LootTables).
	◦	Flag "Deviation" if > 5% difference.
3. Deliverable Checklist
	•	Engine:
	◦	[ ] Create LootAuditService.
	◦	[ ] Implement GenerateReportAsync.
	•	Terminal:
	◦	[ ] Add CLI command audit-loot --iterations 10000.
	•	Analysis:
	◦	[ ] Verify "Myth-Forged" drop rate is < 1% in Safe zones.
	◦	[ ] Verify "Consumable" drop rate matches Biome bias (e.g., Organic > Industrial).
4. Code Implementation
File: RuneAndRust.Engine/Services/LootAuditService.cs
public async Task<string> RunAuditAsync(int iterations, DangerLevel danger)
{
    var stats = new LootStatistics();
    var context = new LootGenerationContext(BiomeType.Ruin, danger, null, 0);

    for(int i = 0; i < iterations; i++)
    {
        var result = _lootService.GenerateLoot(context);
        stats.Record(result.Items);
    }

    return stats.GenerateMarkdownReport();
}

v0.3.13b: The Combat Simulator
Goal: Implement CombatSimulationService to run headless (no UI) combat encounters. This allows developers to pit specific Archetypes against specific Enemy Templates to measure Win Rate, Turn Counts, and Resource Drain.
1. Architecture & Data Flow
	•	Simulation Harness: A specialized version of the Game Loop that bypasses IInputHandler and ICombatScreenRenderer.
	•	Agent Logic:
	◦	Player Agent: A simplified AI that uses a fixed rotation (e.g., "Always Attack", "Use Ability on Cooldown").
	◦	Enemy AI: Uses existing EnemyAIService.
	•	Metrics: Track Turns, HP Remaining, Resources Spent, Status Effects Applied.
2. Logic Decision Trees
A. Headless Combat Loop Input: PlayerCharacter, EnemyTemplate
	1	Setup: Initialize CombatState with Player and Enemy.
	2	Loop: While both alive:
	◦	Phase: Update Cooldowns/Status.
	◦	Action:
	▪	If Player Turn: Execute SimulatedPlayerAction (e.g., Best available attack).
	▪	If Enemy Turn: Execute EnemyAIService.DetermineAction.
	◦	Resolve: Apply damage/effects. Check Death.
	3	Result: Record Winner, Turns, Final HP.
3. Deliverable Checklist
	•	Engine:
	◦	[ ] Create CombatSimulationService.
	◦	[ ] Create SimulatedPlayerAgent (Basic AI for player).
	•	Terminal:
	◦	[ ] Add CLI command sim-combat --archetype Warrior --enemy Draugr --count 100.
	•	Data:
	◦	[ ] Export combat-balance.csv for spreadsheet analysis.
4. Code Implementation
File: RuneAndRust.Engine/Services/CombatSimulationService.cs
public async Task<SimulationResult> RunBatchAsync(Character archetype, string enemyId, int count)
{
    int playerWins = 0;
    int totalTurns = 0;

    for(int i = 0; i < count; i++)
    {
        // Reset state
        var player = Combatant.FromCharacter(archetype); // Fresh copy
        var enemy = _enemyFactory.CreateById(enemyId);

        var result = await RunSingleMatch(player, enemy);
        if (result.PlayerWon) playerWins++;
        totalTurns += result.Turns;
    }

    return new SimulationResult(playerWins, count, totalTurns / (double)count);
}

5. Logging Requirements
System
Event
Level
Message Template
Properties
Audit
Loot Summary
Info
"Loot Audit: {Rarity} rate {Rate}% (Expected {Expected}%)"
Rarity, Rate, Expected
Sim
Match End
Debug
"Sim Match {Id}: Winner {Winner} in {Turns} turns."
Id, Winner, Turns
Sim
Batch Result
Info
"Simulation Complete: Win Rate {WinRate}%, Avg Turns {AvgTurns}."
WinRate, AvgTurns

6. Testing Strategy
	•	Integration Test (LootAuditTests.cs):
	◦	Run small batch (100). Assert total items > 0. Assert no exceptions.
	•	Integration Test (CombatSimTests.cs):
	◦	Simulate Warrior vs Minion. Assert Win Rate > 90%.
	◦	Simulate Warrior vs Boss. Assert Win Rate < 100%.

7. Draft Changelog (v0.3.13)
# v0.3.13 Changelog: The Scales (Balance & Tuning)
**Release Date:** 2026-01-20

## Summary
This release introduces "Headless Simulation" tools to scientifically balance the game. Developers can now run thousands of automated loot drops and combat encounters to verify mathematical probabilities and difficulty curves.

## New Features
*   **Loot Audit Tool:** CLI command `audit-loot` generates statistical reports on item drop rates across biomes and danger levels.
*   **Combat Simulator:** CLI command `sim-combat` pits AI-controlled players against enemies to measure Time-To-Kill and Win Rates.
*   **Automated Balancing:** Fixed issue where Myth-Forged items dropped too frequently in Safe zones based on audit data.

## Technical Changes
*   Implemented `LootAuditService` and `CombatSimulationService` in Engine.
*   Added `SimulatedPlayerAgent` to drive player actions during tests.
*   Added CSV/Markdown export for analysis data.
Would you like to proceed to the next version in the roadmap?
