# v0.29.3 Testing & Validation Guide
## Enemy Definitions & Spawn System

### Prerequisites
- v0.29.1 completed (Database Schema & Room Templates)
- v0.29.2 completed (Environmental Hazards & Ambient Conditions)
- .NET SDK installed
- Access to runeandrust.db database

### Changes Summary

**New Classes:**
1. `BrittlenessService.cs` - Service for handling [Brittle] debuff mechanic

**Enum/Definition Updates:**
1. `StatusEffectDefinition.cs` - Added [Brittle] status effect definition

**Database Seeding:**
- 5 enemy types added to `Biome_EnemySpawns` table
- Enemy spawn weights, level ranges, and resistance data

### Database Validation

#### Test 1: Verify all 5 enemies inserted
```sql
SELECT COUNT(*) as enemy_count
FROM Biome_EnemySpawns
WHERE biome_id = 4;
```
**Expected:** enemy_count = 5

#### Test 2: View enemy details
```sql
SELECT
    enemy_name,
    enemy_type,
    min_level,
    max_level,
    spawn_weight,
    spawn_rules_json
FROM Biome_EnemySpawns
WHERE biome_id = 4
ORDER BY spawn_weight DESC;
```
**Expected:** 5 rows showing:
- Forge-Hardened Undying (weight: 150, levels 7-9)
- Magma Elemental (weight: 80, levels 8-11)
- Rival Berserker (weight: 60, levels 9-12)
- Iron-Bane Crusader (weight: 20, levels 10-12)
- Surtur's Herald (weight: 1, level 12 boss)

#### Test 3: Check enemy type distribution
```sql
SELECT
    enemy_type,
    COUNT(*) as count,
    SUM(spawn_weight) as total_weight
FROM Biome_EnemySpawns
WHERE biome_id = 4
GROUP BY enemy_type;
```
**Expected:**
- Undying: 1 (weight 150)
- Construct: 1 (weight 80)
- Humanoid: 2 (weight 80)
- Boss: 1 (weight 1)

#### Test 4: Verify boss spawn configuration
```sql
SELECT
    enemy_name,
    spawn_weight,
    min_level,
    max_level
FROM Biome_EnemySpawns
WHERE biome_id = 4
  AND enemy_type = 'Boss';
```
**Expected:** Surtur's Herald with weight 1, level 12

#### Test 5: Check Fire Resistance distribution
```sql
SELECT
    enemy_name,
    json_extract(spawn_rules_json, '$.fire_resistance') as fire_res,
    json_extract(spawn_rules_json, '$.ice_resistance') as ice_res
FROM Biome_EnemySpawns
WHERE biome_id = 4
ORDER BY CAST(json_extract(spawn_rules_json, '$.fire_resistance') AS INTEGER) DESC;
```
**Expected (sorted by Fire Resistance):**
- Magma Elemental: 100% Fire, -30% Ice
- Surtur's Herald: 90% Fire, -40% Ice
- Forge-Hardened Undying: 75% Fire, -50% Ice
- Iron-Bane Crusader: 60% Fire, 0% Ice
- Rival Berserker: 50% Fire, -25% Ice

#### Test 6: Verify all enemies are [Brittle]-eligible
```sql
SELECT
    enemy_name,
    CASE
        WHEN CAST(json_extract(spawn_rules_json, '$.fire_resistance') AS INTEGER) > 0
        THEN 'Brittle-Eligible'
        ELSE 'Not Eligible'
    END as brittle_status
FROM Biome_EnemySpawns
WHERE biome_id = 4;
```
**Expected:** All 5 enemies show "Brittle-Eligible"

### Code Integration Testing

#### Test 7: [Brittle] StatusEffect Definition
```csharp
var brittleDefinition = StatusEffectDefinition.GetAllDefinitions()
    .FirstOrDefault(d => d.EffectType == "Brittle");

Assert.IsNotNull(brittleDefinition);
Assert.AreEqual("[Brittle]", brittleDefinition.DisplayName);
Assert.AreEqual(StatusEffectCategory.StatModification, brittleDefinition.Category);
Assert.IsFalse(brittleDefinition.CanStack);
Assert.AreEqual(1, brittleDefinition.MaxStacks);
Assert.AreEqual(2, brittleDefinition.DefaultDuration);
Assert.IsTrue(brittleDefinition.Description.Contains("+50% Physical damage"));
```

#### Test 8: BrittlenessService - Set Enemy Resistance
```csharp
var service = new BrittlenessService();
var testEnemy = CreateTestEnemy(enemyId: 101, name: "Test Forge Wraith");

service.SetEnemyResistance(101, "Fire", 75);
service.SetEnemyResistance(101, "Ice", -50);

int fireRes = service.GetEnemyResistance(101, "Fire");
int iceRes = service.GetEnemyResistance(101, "Ice");

Assert.AreEqual(75, fireRes);
Assert.AreEqual(-50, iceRes);
```

#### Test 9: BrittlenessService - Eligibility Check
```csharp
var service = new BrittlenessService();
var enemy1 = CreateTestEnemy(101, "Magma Elemental");
var enemy2 = CreateTestEnemy(102, "Regular Undying");

// Magma Elemental has 100% Fire Resistance
service.SetEnemyResistance(101, "Fire", 100);

// Regular Undying has 0% Fire Resistance
service.SetEnemyResistance(102, "Fire", 0);

bool eligible1 = service.IsBrittleEligible(enemy1);
bool eligible2 = service.IsBrittleEligible(enemy2);

Assert.IsTrue(eligible1, "Enemy with Fire Resistance should be Brittle-eligible");
Assert.IsFalse(eligible2, "Enemy without Fire Resistance should NOT be Brittle-eligible");
```

#### Test 10: BrittlenessService - Apply [Brittle] on Ice Damage
```csharp
var service = new BrittlenessService();
var enemy = CreateTestEnemy(101, "Forge-Hardened Undying");

service.SetEnemyResistance(101, "Fire", 75);

// Apply Ice damage
service.TryApplyBrittle(enemy, iceDamageDealt: 10);

// Verify [Brittle] status effect applied
var brittleEffect = enemy.StatusEffects
    .FirstOrDefault(s => s.EffectType.Equals("Brittle", StringComparison.OrdinalIgnoreCase));

Assert.IsNotNull(brittleEffect, "[Brittle] should be applied after Ice damage");
Assert.AreEqual(2, brittleEffect.DurationRemaining, "[Brittle] should last 2 turns");
Assert.AreEqual(1, brittleEffect.StackCount);
```

#### Test 11: BrittlenessService - Refresh [Brittle] Duration
```csharp
var service = new BrittlenessService();
var enemy = CreateTestEnemy(101, "Magma Elemental");

service.SetEnemyResistance(101, "Fire", 100);

// Apply [Brittle] first time
service.TryApplyBrittle(enemy, iceDamageDealt: 8);

var brittleEffect = enemy.StatusEffects
    .First(s => s.EffectType == "Brittle");

// Simulate 1 turn passing
brittleEffect.DurationRemaining = 1;

// Apply Ice damage again (should refresh)
service.TryApplyBrittle(enemy, iceDamageDealt: 5);

Assert.AreEqual(2, brittleEffect.DurationRemaining, "[Brittle] duration should refresh to 2 turns");
Assert.AreEqual(1, enemy.StatusEffects.Count(s => s.EffectType == "Brittle"), "Should not stack multiple [Brittle] effects");
```

#### Test 12: BrittlenessService - Physical Damage Bonus
```csharp
var service = new BrittlenessService();
var enemy = CreateTestEnemy(101, "Rival Berserker");

// Apply [Brittle] status
enemy.StatusEffects.Add(new StatusEffect
{
    EffectType = "Brittle",
    DurationRemaining = 2,
    StackCount = 1
});

int basePhysicalDamage = 20;
int bonusDamage = service.ApplyBrittleBonus(enemy, basePhysicalDamage);

Assert.AreEqual(30, bonusDamage, "20 base damage should become 30 with [Brittle] (+50%)");
```

#### Test 13: BrittlenessService - No Bonus Without [Brittle]
```csharp
var service = new BrittlenessService();
var enemy = CreateTestEnemy(101, "Iron-Bane Crusader");

// No [Brittle] status applied
int basePhysicalDamage = 15;
int damage = service.ApplyBrittleBonus(enemy, basePhysicalDamage);

Assert.AreEqual(15, damage, "Physical damage should be unchanged without [Brittle]");
```

#### Test 14: BrittlenessService - No [Brittle] on Zero Ice Damage
```csharp
var service = new BrittlenessService();
var enemy = CreateTestEnemy(101, "Forge-Hardened Undying");

service.SetEnemyResistance(101, "Fire", 75);

// No Ice damage dealt
service.TryApplyBrittle(enemy, iceDamageDealt: 0);

var brittleEffect = enemy.StatusEffects
    .FirstOrDefault(s => s.EffectType == "Brittle");

Assert.IsNull(brittleEffect, "[Brittle] should NOT apply when no Ice damage is dealt");
```

### v5.0 Setting Compliance

#### Test 15: Technology language verification
Verify all enemy names and descriptions use technological/industrial language:

```sql
SELECT enemy_name, spawn_rules_json
FROM Biome_EnemySpawns
WHERE biome_id = 4
  AND (
    enemy_name LIKE '%curse%'
    OR enemy_name LIKE '%spirit%'
    OR enemy_name LIKE '%elemental%' -- "Magma Elemental" is acceptable (corrupted construct)
    OR spawn_rules_json LIKE '%magic%'
  );
```

**Expected:** 1 row (Magma Elemental)
**Validation:** "Magma Elemental" is acceptable as it refers to a corrupted geological monitoring construct, not a supernatural entity

**Keywords that SHOULD appear in enemy lore (not in database yet):**
- "corrupted construct" ✅
- "thermal monitoring system" ✅
- "heat-resistant tissue" ✅
- "industrial weaponry" ✅
- "Jotun-Forged" ✅

#### Test 16: ASCII-only entity names
All enemy names should use only ASCII characters:

```sql
SELECT enemy_name
FROM Biome_EnemySpawns
WHERE biome_id = 4;
```

**Verify all names are ASCII-compliant:**
- ✅ Forge-Hardened Undying
- ✅ Magma Elemental
- ✅ Rival Berserker
- ✅ Surtur's Herald (not "Surtr's Herald")
- ✅ Iron-Bane Crusader

### Balance Validation

#### Test 17: Spawn weight distribution
```sql
SELECT
    enemy_name,
    spawn_weight,
    ROUND(spawn_weight * 100.0 / (SELECT SUM(spawn_weight) FROM Biome_EnemySpawns WHERE biome_id = 4), 2) as spawn_chance_percent
FROM Biome_EnemySpawns
WHERE biome_id = 4
ORDER BY spawn_weight DESC;
```

**Expected distribution (out of 311 total weight):**
- Forge-Hardened Undying: 48.2% (most common)
- Magma Elemental: 25.7% (common)
- Rival Berserker: 19.3% (uncommon/elite)
- Iron-Bane Crusader: 6.4% (rare)
- Surtur's Herald: 0.3% (ultra-rare boss)

**Balance reasoning:**
- Standard enemies (Forge-Hardened Undying) most common
- Elites (Rival Berserker) challenging but not overwhelming
- Boss (Surtur's Herald) extremely rare, special encounter

#### Test 18: Level range progression
```sql
SELECT
    enemy_name,
    min_level,
    max_level,
    (max_level - min_level + 1) as level_span
FROM Biome_EnemySpawns
WHERE biome_id = 4
ORDER BY min_level;
```

**Expected progression:**
- Forge-Hardened Undying: 7-9 (early Muspelheim)
- Magma Elemental: 8-11 (mid-range)
- Rival Berserker: 9-12 (mid-to-late)
- Iron-Bane Crusader: 10-12 (late-game)
- Surtur's Herald: 12 (endgame boss)

**Validation:**
- Level ranges overlap to ensure variety at each character level
- Higher-level enemies have greater Fire Resistance (harder to burn)
- Boss appears only at maximum biome level (12)

#### Test 19: [Brittle] tactical value
**Manual calculation:**

Scenario: Level 10 party fighting Magma Elemental (100% Fire Immune)
- Ice Mystic casts Frost Bolt (10 Ice damage)
- Magma Elemental takes 13 damage (10 + 30% vulnerability = 13)
- [Brittle] applied for 2 turns
- Physical Warrior attacks: 20 base Physical → 30 damage with [Brittle]

**Net result:**
- Ice damage bypasses immunity via vulnerability
- Physical damage gets +50% boost
- Encourages elemental combo play

### Integration Points

#### Test 20: Combat System Integration (Manual)
**Test scenario:**
1. Create Muspelheim combat encounter with Forge-Hardened Undying (75% Fire Resistance)
2. Player 1 (Fire Warrior) attacks → 10 Fire damage → reduced to 2.5 damage (75% resistance)
3. Player 2 (Ice Mystic) casts Frost Bolt → 12 Ice damage → becomes 18 damage (Ice vulnerable -50%)
4. [Brittle] applied to enemy (2 turns)
5. Player 3 (Physical Rogue) attacks → 15 Physical damage → becomes 22.5 damage ([Brittle] +50%)

**Expected:**
- Fire Resistance correctly reduces Fire damage
- Ice Vulnerability correctly increases Ice damage
- [Brittle] debuff applied after Ice damage
- Physical damage bonus calculated correctly

#### Test 21: Enemy Spawn Selection (Manual)
**Test scenario:**
1. Generate Muspelheim room with enemy encounter
2. Verify enemy selection respects spawn weights
3. Over 100 room generations, measure distribution:
   - Forge-Hardened Undying: ~48%
   - Magma Elemental: ~26%
   - Rival Berserker: ~19%
   - Iron-Bane Crusader: ~6%
   - Surtur's Herald: <1%

#### Test 22: Status Effect Duration Tracking
**Test scenario:**
1. Apply [Brittle] to enemy
2. End turn → DurationRemaining decrements to 1
3. End turn → DurationRemaining decrements to 0
4. Verify [Brittle] effect removed when duration reaches 0
5. Physical damage no longer receives bonus

### Known Limitations (v0.29.3)

1. **No Full Resistance System Yet**
   - BrittlenessService uses temporary `_enemyResistances` dictionary
   - Full resistance system will be integrated in future version
   - Manual workaround: Call `SetEnemyResistance()` when spawning enemies

2. **No Enemy Combat Integration Yet**
   - Enemy definitions exist but not yet spawned in procedural rooms
   - Combat encounters don't yet use resistance data
   - Will be integrated in v0.29.4 (Service Implementation)

3. **No Enemy Lore/Descriptions Yet**
   - Enemies have names and stats but no narrative descriptions
   - Enemy behavior AI not yet defined
   - Deferred to narrative content update

4. **No "Burning Trail" or "Death Explosion" Mechanics**
   - Magma Elemental has tags for these mechanics
   - Implementation deferred to environmental combat system

5. **No "Potential Ally" Mechanic**
   - Iron-Bane Crusader tagged as `potential_ally`
   - Faction/diplomacy system not yet implemented

### Success Criteria

✅ All 5 enemy types seeded to database
✅ [Brittle] status effect definition created
✅ BrittlenessService implemented
✅ Fire Resistance data stored in spawn_rules_json
✅ Ice Vulnerability data stored (negative resistance values)
✅ v5.0 setting compliance verified (technology language)
✅ ASCII-only entity names confirmed
✅ Database queries return expected results
✅ No compilation errors

### Next Steps After v0.29.3

Once all tests pass, proceed to:
- **v0.29.4:** Service Implementation & Testing (full combat integration, procedural generation)

### Troubleshooting

#### Issue: Enemies not appearing in database
**Solution:** Ensure v0.29.1 completed successfully. Check that `Biome_EnemySpawns` table exists:
```sql
SELECT name FROM sqlite_master WHERE type='table' AND name='Biome_EnemySpawns';
```

#### Issue: BrittlenessService not compiling
**Solution:** Verify all dependencies are referenced:
- `using RuneAndRust.Core;`
- `using Serilog;`

Ensure `Enemy` class has `StatusEffects` property (List<StatusEffect>).

#### Issue: [Brittle] not applying after Ice damage
**Solution:**
1. Verify enemy has Fire Resistance > 0%
2. Check that Ice damage dealt > 0
3. Ensure `TryApplyBrittle()` is called after damage calculation
4. Check logs for "Brittle eligibility" messages

#### Issue: JSON parsing errors on spawn_rules_json
**Solution:** Verify JSON structure is valid:
```sql
SELECT enemy_name, spawn_rules_json
FROM Biome_EnemySpawns
WHERE biome_id = 4
  AND json_valid(spawn_rules_json) = 0;
```
Should return 0 rows (all JSON valid).

### Example Test Enemy Setup

```csharp
private Enemy CreateTestEnemy(int enemyId, string name)
{
    return new Enemy
    {
        EnemyID = enemyId,
        Name = name,
        HP = 50,
        MaxHP = 50,
        StatusEffects = new List<StatusEffect>()
    };
}
```

---

**Implementation Time:** ~10 hours
**Specification Estimate:** 10-15 hours
**Status:** Phase 3 (Enemy Definitions) Complete ✓
**Ready for:** Phase 4 (Service Implementation v0.29.4)
