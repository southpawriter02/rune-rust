# v0.4.2a Design Specification: Puzzle Core

**Version:** 0.4.2a
**Phase Name:** Puzzle Core
**Parent Version:** v0.4.2 (Puzzles & Riddles)
**Prerequisites:** v0.4.1c Complete (Environmental Hazards)
**Estimated Tests:** ~35 unit tests

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Feature Overview](#2-feature-overview)
3. [Architecture Diagrams](#3-architecture-diagrams)
4. [Puzzle Entity](#4-puzzle-entity)
5. [Puzzle Enums](#5-puzzle-enums)
6. [PuzzleAttempt Value Object](#6-puzzleattempt-value-object)
7. [PuzzleDefinition](#7-puzzledefinition)
8. [PuzzleService](#8-puzzleservice)
9. [Room Integration](#9-room-integration)
10. [User-Facing Commands](#10-user-facing-commands)
11. [Data Model Changes](#11-data-model-changes)
12. [Configuration File Schemas](#12-configuration-file-schemas)
13. [Logging Specifications](#13-logging-specifications)
14. [Unit Testing Requirements](#14-unit-testing-requirements)
15. [Use Cases](#15-use-cases)
16. [Deliverable Checklist](#16-deliverable-checklist)
17. [Acceptance Criteria](#17-acceptance-criteria)
18. [Dependencies](#18-dependencies)
19. [Future Considerations](#19-future-considerations)

---

## 1. Executive Summary

### 1.1 Purpose

This specification establishes the foundational `Puzzle` entity with state management, type classification, and attempt tracking. v0.4.2a creates the core puzzle infrastructure that specific puzzle types will extend in subsequent phases (v0.4.2b) and riddle mechanics will build upon (v0.4.2c).

Puzzles represent logic challenges that players can attempt to solve, ranging from sequence puzzles requiring ordered activation to combination locks and pattern matching. This phase focuses on the entity structure, state machine, and service layer without implementing specific puzzle type mechanics.

### 1.2 Key Deliverables

| Category | Items |
|----------|-------|
| **Domain Entities** | `Puzzle` |
| **Domain Enums** | `PuzzleState`, `PuzzleType` |
| **Domain Definitions** | `PuzzleDefinition` |
| **Value Objects** | `PuzzleAttempt` |
| **Application Services** | `PuzzleService` |
| **Application Interfaces** | `IPuzzleService` |
| **Result Types** | `PuzzleAttemptResult`, `PuzzleSolveResult`, `PuzzleStepResult`, `PuzzleHintResult`, `PuzzleRewardResult` |
| **Commands** | `solve`, `reset` (puzzle-related) |
| **Room Updates** | `Puzzles` collection |
| **Configuration** | `puzzles.json` |
| **Tests** | ~35 unit tests |

### 1.3 Architectural Significance

This version establishes the **Puzzle Entity Pattern** that will be used throughout the puzzle system:

- **State Machine**: Five-state lifecycle (Unsolved → InProgress → Solved/Failed/Locked)
- **Attempt Tracking**: Progress persistence across game sessions
- **Reset Mechanics**: Time-based and action-based puzzle recovery
- **Prerequisite System**: Puzzles can depend on other puzzle completion
- **Type Classification**: Enum-based puzzle categorization for future type-specific logic

---

## 2. Feature Overview

```
v0.4.2a Puzzle Core
├── Puzzle Entity
│   ├── State Management (5 states)
│   ├── Type Classification (5 types)
│   ├── Attempt Tracking
│   ├── Reset Mechanics
│   └── Prerequisite Support
├── PuzzleState Enum
│   ├── Unsolved
│   ├── InProgress
│   ├── Solved
│   ├── Failed
│   └── Locked
├── PuzzleType Enum
│   ├── Sequence
│   ├── Combination
│   ├── Pattern
│   ├── Riddle
│   └── Logic
├── PuzzleAttempt Value Object
│   ├── Progress Tracking
│   ├── Step Completion
│   └── Input Recording
├── PuzzleDefinition
│   └── JSON Configuration
├── PuzzleService
│   ├── Attempt Management
│   ├── Solution Validation
│   ├── Reset Processing
│   └── Lock Updates
├── Room Integration
│   ├── Puzzles Collection
│   └── Query Methods
└── Commands
    ├── solve <puzzle>
    ├── reset <puzzle>
    └── examine <puzzle>
```

### 2.1 Scope Alignment

**In Scope:**
- `Puzzle` entity with state and solution tracking
- `PuzzleState` enum (Unsolved, InProgress, Solved, Failed, Locked)
- `PuzzleType` enum (Sequence, Combination, Pattern, Riddle, Logic)
- `PuzzleDefinition` for JSON configuration
- `PuzzleAttempt` for tracking player progress
- `PuzzleService` for puzzle logic and validation
- `Room.Puzzles` collection
- `solve` command for simple puzzles
- Puzzle reset mechanics (time-based or action-based)
- Puzzle completion tracking
- Basic puzzle examination

**Out of Scope:**
- Specific puzzle type implementations (v0.4.2b)
- Riddle NPCs (v0.4.2c)
- Hint system (v0.4.2c)
- Multi-part puzzles (v0.4.2c)
- Puzzle rewards beyond basic loot (v0.4.2c)

---

## 3. Architecture Diagrams

### 3.1 Puzzle State Flow

```
                              ┌─────────────────┐
                              │     Locked      │
                              │  (prerequisite  │
                              │    not met)     │
                              └────────┬────────┘
                                       │ Unlock()
                                       │ (prerequisite solved)
                                       ▼
┌─────────────────┐    BeginAttempt()  ┌─────────────────┐
│    Unsolved     │ ─────────────────▶ │   InProgress    │
│  (initial/reset)│                    │  (attempting)   │
└─────────────────┘                    └────────┬────────┘
        ▲                                       │
        │                         ┌─────────────┴─────────────┐
        │                         │                           │
        │ Reset()                 │ Solve()                   │ RecordFailedAttempt()
        │ (if CanReset)           ▼                           │ (max attempts reached)
        │                ┌─────────────────┐                  │
        │                │     Solved      │                  │
        │                │   (complete)    │                  │
        │                └─────────────────┘                  │
        │                                                     ▼
        │                                          ┌─────────────────┐
        └──────────────────────────────────────────│     Failed      │
                         TickReset()               │ (max attempts)  │
                    (TurnsUntilReset = 0)          └─────────────────┘
```

### 3.2 Service Layer Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Application Layer                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      IPuzzleService                          │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │  + GetPuzzle(room, keyword): Puzzle?                        │   │
│  │  + GetPuzzles(room): IEnumerable<Puzzle>                    │   │
│  │  + GetUnsolvedPuzzles(room): IEnumerable<Puzzle>            │   │
│  │  + BeginAttempt(player, puzzle): PuzzleAttemptResult        │   │
│  │  + AttemptSolve(player, puzzle, input): PuzzleSolveResult   │   │
│  │  + ValidateStep(puzzle, attempt, stepId): PuzzleStepResult  │   │
│  │  + GetCurrentAttempt(player, puzzle): PuzzleAttempt?        │   │
│  │  + RequestHint(player, puzzle): PuzzleHintResult            │   │
│  │  + ProcessPuzzleResets(room): IEnumerable<Puzzle>           │   │
│  │  + UpdatePuzzleLocks(room): void                            │   │
│  │  + ApplyPuzzleReward(player, puzzle): PuzzleRewardResult    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                               │                                      │
│                               │ implements                           │
│                               ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                       PuzzleService                          │   │
│  ├─────────────────────────────────────────────────────────────┤   │
│  │  - _logger: ILogger<PuzzleService>                          │   │
│  │  - _activeAttempts: Dictionary<(Guid, Guid), PuzzleAttempt> │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                                 │ uses
                                 ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          Domain Layer                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────────┐  │
│  │    Puzzle    │  │ PuzzleState  │  │      PuzzleAttempt       │  │
│  │   (Entity)   │  │    (Enum)    │  │     (Value Object)       │  │
│  └──────────────┘  └──────────────┘  └──────────────────────────┘  │
│                                                                      │
│  ┌──────────────┐  ┌──────────────────────────────────────────────┐│
│  │  PuzzleType  │  │             PuzzleDefinition                 ││
│  │    (Enum)    │  │              (Definition)                    ││
│  └──────────────┘  └──────────────────────────────────────────────┘│
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 Room-Puzzle Integration

```
┌─────────────────────────────────────────────────────────────┐
│                          Room                                │
├─────────────────────────────────────────────────────────────┤
│  - _puzzles: List<Puzzle>                                   │
├─────────────────────────────────────────────────────────────┤
│  + Puzzles: IReadOnlyList<Puzzle>                           │
│  + HasPuzzles: bool                                         │
│  + HasUnsolvedPuzzles: bool                                 │
│  + AddPuzzle(puzzle): void                                  │
│  + RemovePuzzle(puzzle): bool                               │
│  + GetPuzzleByKeyword(keyword): Puzzle?                     │
│  + GetUnsolvedPuzzles(): IEnumerable<Puzzle>                │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ contains
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                         Puzzle                               │
├─────────────────────────────────────────────────────────────┤
│  + Id: Guid                                                 │
│  + DefinitionId: string                                     │
│  + Name: string                                             │
│  + Description: string                                      │
│  + State: PuzzleState                                       │
│  + Type: PuzzleType                                         │
│  + MaxAttempts: int                                         │
│  + AttemptCount: int                                        │
│  + CanReset: bool                                           │
│  + ResetDelay: int                                          │
│  + TurnsUntilReset: int?                                    │
│  + Difficulty: int                                          │
│  + HasHints: bool                                           │
│  + HintsRevealed: int                                       │
│  + RewardId: string?                                        │
│  + PrerequisitePuzzleId: string?                            │
│  + AffectedObjectIds: IReadOnlyList<Guid>                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. Puzzle Entity

### 4.1 Overview

The `Puzzle` entity represents a logic challenge that players can attempt to solve. It tracks state, attempt counts, reset timers, and provides methods for state transitions.

**File:** `src/Core/RuneAndRust.Domain/Entities/Puzzle.cs`

### 4.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `Id` | `Guid` | Unique identifier for this puzzle instance |
| `DefinitionId` | `string` | Reference to configuration definition |
| `Name` | `string` | Display name shown to players |
| `Description` | `string` | Examination description |
| `State` | `PuzzleState` | Current puzzle state |
| `Type` | `PuzzleType` | Category of puzzle mechanics |
| `MaxAttempts` | `int` | Maximum attempts allowed (-1 = unlimited) |
| `AttemptCount` | `int` | Current number of attempts made |
| `CanReset` | `bool` | Whether puzzle can reset after failure |
| `ResetDelay` | `int` | Turns until reset (-1 = manual only) |
| `TurnsUntilReset` | `int?` | Countdown to automatic reset |
| `Difficulty` | `int` | Difficulty rating (1-5 scale) |
| `HasHints` | `bool` | Whether hints are available |
| `HintsRevealed` | `int` | Number of hints already revealed |
| `RewardId` | `string?` | Associated reward definition ID |
| `PrerequisitePuzzleId` | `string?` | Puzzle that must be solved first |
| `AffectedObjectIds` | `IReadOnlyList<Guid>` | Objects affected on solve |

### 4.3 Computed Properties

| Property | Type | Description |
|----------|------|-------------|
| `IsSolvable` | `bool` | True if State is Unsolved or InProgress |
| `IsSolved` | `bool` | True if State is Solved |
| `IsFailed` | `bool` | True if State is Failed |
| `IsLocked` | `bool` | True if State is Locked |
| `HasAttemptsRemaining` | `bool` | True if unlimited or AttemptCount < MaxAttempts |

### 4.4 Implementation

```csharp
namespace RuneAndRust.Domain.Entities;

/// <summary>
/// Represents a logic challenge that players can attempt to solve.
/// </summary>
public class Puzzle : IEntity
{
    /// <summary>
    /// Gets the unique identifier for this puzzle.
    /// </summary>
    public Guid Id { get; private set; }

    /// <summary>
    /// Gets the definition ID from configuration.
    /// </summary>
    public string DefinitionId { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the display name of this puzzle.
    /// </summary>
    public string Name { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the description shown when examining the puzzle.
    /// </summary>
    public string Description { get; private set; } = string.Empty;

    /// <summary>
    /// Gets the current state of this puzzle.
    /// </summary>
    public PuzzleState State { get; private set; } = PuzzleState.Unsolved;

    /// <summary>
    /// Gets the type of this puzzle.
    /// </summary>
    public PuzzleType Type { get; private set; }

    /// <summary>
    /// Gets the maximum number of attempts allowed (-1 = unlimited).
    /// </summary>
    public int MaxAttempts { get; private set; } = -1;

    /// <summary>
    /// Gets the current attempt count.
    /// </summary>
    public int AttemptCount { get; private set; }

    /// <summary>
    /// Gets whether this puzzle can be reset after failure.
    /// </summary>
    public bool CanReset { get; private set; } = true;

    /// <summary>
    /// Gets the turns until reset after failure (-1 = manual reset only).
    /// </summary>
    public int ResetDelay { get; private set; } = -1;

    /// <summary>
    /// Gets turns remaining until reset.
    /// </summary>
    public int? TurnsUntilReset { get; private set; }

    /// <summary>
    /// Gets the difficulty rating (1-5 scale for UI display).
    /// </summary>
    public int Difficulty { get; private set; } = 1;

    /// <summary>
    /// Gets whether hints are available for this puzzle.
    /// </summary>
    public bool HasHints { get; private set; }

    /// <summary>
    /// Gets the number of hints revealed.
    /// </summary>
    public int HintsRevealed { get; private set; }

    /// <summary>
    /// Gets whether this puzzle is currently solvable.
    /// </summary>
    public bool IsSolvable => State == PuzzleState.Unsolved || State == PuzzleState.InProgress;

    /// <summary>
    /// Gets whether this puzzle has been solved.
    /// </summary>
    public bool IsSolved => State == PuzzleState.Solved;

    /// <summary>
    /// Gets whether this puzzle has failed.
    /// </summary>
    public bool IsFailed => State == PuzzleState.Failed;

    /// <summary>
    /// Gets whether this puzzle is locked (requires prerequisite).
    /// </summary>
    public bool IsLocked => State == PuzzleState.Locked;

    /// <summary>
    /// Gets whether attempts remain for this puzzle.
    /// </summary>
    public bool HasAttemptsRemaining => MaxAttempts < 0 || AttemptCount < MaxAttempts;

    /// <summary>
    /// Gets the associated reward definition ID (null if no reward).
    /// </summary>
    public string? RewardId { get; private set; }

    /// <summary>
    /// Gets the prerequisite puzzle ID that must be solved first.
    /// </summary>
    public string? PrerequisitePuzzleId { get; private set; }

    /// <summary>
    /// Gets IDs of objects affected when puzzle is solved.
    /// </summary>
    public IReadOnlyList<Guid> AffectedObjectIds { get; private set; } = Array.Empty<Guid>();

    private Puzzle() { }

    /// <summary>
    /// Creates a new puzzle.
    /// </summary>
    public static Puzzle Create(
        string definitionId,
        string name,
        string description,
        PuzzleType type,
        int maxAttempts = -1,
        bool canReset = true,
        int resetDelay = -1,
        int difficulty = 1,
        bool hasHints = false,
        string? rewardId = null,
        string? prerequisiteId = null,
        IEnumerable<Guid>? affectedObjects = null)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(definitionId);
        ArgumentException.ThrowIfNullOrWhiteSpace(name);

        return new Puzzle
        {
            Id = Guid.NewGuid(),
            DefinitionId = definitionId,
            Name = name,
            Description = description,
            Type = type,
            MaxAttempts = maxAttempts,
            CanReset = canReset,
            ResetDelay = resetDelay,
            Difficulty = Math.Clamp(difficulty, 1, 5),
            HasHints = hasHints,
            RewardId = rewardId,
            PrerequisitePuzzleId = prerequisiteId,
            AffectedObjectIds = affectedObjects?.ToList() ?? Array.Empty<Guid>()
        };
    }

    /// <summary>
    /// Begins an attempt on this puzzle.
    /// </summary>
    public bool BeginAttempt()
    {
        if (!IsSolvable || !HasAttemptsRemaining)
            return false;

        if (State == PuzzleState.Unsolved)
            State = PuzzleState.InProgress;

        return true;
    }

    /// <summary>
    /// Records a failed attempt.
    /// </summary>
    public void RecordFailedAttempt()
    {
        AttemptCount++;

        if (MaxAttempts > 0 && AttemptCount >= MaxAttempts)
        {
            State = PuzzleState.Failed;
            if (CanReset && ResetDelay >= 0)
            {
                TurnsUntilReset = ResetDelay;
            }
        }
    }

    /// <summary>
    /// Marks this puzzle as solved.
    /// </summary>
    public void Solve()
    {
        State = PuzzleState.Solved;
    }

    /// <summary>
    /// Resets this puzzle to unsolved state.
    /// </summary>
    public bool Reset()
    {
        if (!CanReset || State == PuzzleState.Solved)
            return false;

        State = PuzzleState.Unsolved;
        AttemptCount = 0;
        TurnsUntilReset = null;
        return true;
    }

    /// <summary>
    /// Processes turn tick for resetting puzzles.
    /// </summary>
    public bool TickReset()
    {
        if (State != PuzzleState.Failed || !TurnsUntilReset.HasValue)
            return false;

        TurnsUntilReset--;

        if (TurnsUntilReset <= 0)
        {
            return Reset();
        }

        return false;
    }

    /// <summary>
    /// Reveals a hint for this puzzle.
    /// </summary>
    public bool RevealHint()
    {
        if (!HasHints)
            return false;

        HintsRevealed++;
        return true;
    }

    /// <summary>
    /// Locks this puzzle (requires prerequisite).
    /// </summary>
    public void Lock()
    {
        if (State == PuzzleState.Unsolved)
            State = PuzzleState.Locked;
    }

    /// <summary>
    /// Unlocks this puzzle when prerequisite is met.
    /// </summary>
    public void Unlock()
    {
        if (State == PuzzleState.Locked)
            State = PuzzleState.Unsolved;
    }
}
```

### 4.5 State Transition Rules

| Current State | Method | New State | Conditions |
|---------------|--------|-----------|------------|
| Unsolved | `BeginAttempt()` | InProgress | HasAttemptsRemaining |
| Unsolved | `Lock()` | Locked | Has prerequisite |
| InProgress | `Solve()` | Solved | Correct solution |
| InProgress | `RecordFailedAttempt()` | Failed | MaxAttempts reached |
| Failed | `TickReset()` | Unsolved | TurnsUntilReset = 0, CanReset |
| Failed | `Reset()` | Unsolved | CanReset = true |
| Locked | `Unlock()` | Unsolved | Prerequisite solved |

---

## 5. Puzzle Enums

### 5.1 PuzzleState Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/PuzzleState.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Represents the current state of a puzzle.
/// </summary>
public enum PuzzleState
{
    /// <summary>Puzzle has not been attempted.</summary>
    Unsolved,

    /// <summary>Puzzle attempt is in progress.</summary>
    InProgress,

    /// <summary>Puzzle has been successfully solved.</summary>
    Solved,

    /// <summary>Puzzle was failed (max attempts reached).</summary>
    Failed,

    /// <summary>Puzzle is locked (prerequisite not met).</summary>
    Locked
}
```

### 5.2 PuzzleType Enum

**File:** `src/Core/RuneAndRust.Domain/Enums/PuzzleType.cs`

```csharp
namespace RuneAndRust.Domain.Enums;

/// <summary>
/// Categories of puzzle mechanics.
/// </summary>
public enum PuzzleType
{
    /// <summary>Activate objects in a specific order.</summary>
    Sequence,

    /// <summary>Enter a correct combination/code.</summary>
    Combination,

    /// <summary>Match or reproduce a pattern.</summary>
    Pattern,

    /// <summary>Answer a riddle correctly.</summary>
    Riddle,

    /// <summary>General logic puzzle (custom validation).</summary>
    Logic
}
```

---

## 6. PuzzleAttempt Value Object

### 6.1 Overview

The `PuzzleAttempt` class tracks the progress of an active puzzle attempt, including completed steps for sequence puzzles and current input for combination puzzles.

**File:** `src/Core/RuneAndRust.Domain/ValueObjects/PuzzleAttempt.cs`

### 6.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `PuzzleId` | `Guid` | The puzzle being attempted |
| `StartedAt` | `DateTime` | When the attempt began |
| `CompletedSteps` | `IReadOnlyList<string>` | Steps completed (sequence puzzles) |
| `CurrentInput` | `string` | Current input (combination puzzles) |
| `IsActive` | `bool` | Whether attempt is still in progress |
| `Succeeded` | `bool?` | Result of attempt (null if active) |

### 6.3 Implementation

```csharp
namespace RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Tracks the progress of a puzzle attempt.
/// </summary>
public class PuzzleAttempt
{
    /// <summary>
    /// Gets the puzzle ID being attempted.
    /// </summary>
    public Guid PuzzleId { get; private set; }

    /// <summary>
    /// Gets when the attempt started.
    /// </summary>
    public DateTime StartedAt { get; private set; }

    /// <summary>
    /// Gets the steps completed so far (for sequence puzzles).
    /// </summary>
    public IReadOnlyList<string> CompletedSteps { get; private set; } = Array.Empty<string>();

    /// <summary>
    /// Gets the current input (for combination puzzles).
    /// </summary>
    public string CurrentInput { get; private set; } = string.Empty;

    /// <summary>
    /// Gets whether this attempt is still active.
    /// </summary>
    public bool IsActive { get; private set; } = true;

    /// <summary>
    /// Gets the result of this attempt (null if still active).
    /// </summary>
    public bool? Succeeded { get; private set; }

    private readonly List<string> _completedSteps = [];

    private PuzzleAttempt() { }

    /// <summary>
    /// Creates a new puzzle attempt.
    /// </summary>
    public static PuzzleAttempt Create(Guid puzzleId)
    {
        return new PuzzleAttempt
        {
            PuzzleId = puzzleId,
            StartedAt = DateTime.UtcNow
        };
    }

    /// <summary>
    /// Adds a completed step (for sequence puzzles).
    /// </summary>
    public void AddStep(string stepId)
    {
        _completedSteps.Add(stepId);
        CompletedSteps = _completedSteps.ToList();
    }

    /// <summary>
    /// Sets the current input (for combination puzzles).
    /// </summary>
    public void SetInput(string input)
    {
        CurrentInput = input;
    }

    /// <summary>
    /// Appends to the current input.
    /// </summary>
    public void AppendInput(string value)
    {
        CurrentInput += value;
    }

    /// <summary>
    /// Clears the current input.
    /// </summary>
    public void ClearInput()
    {
        CurrentInput = string.Empty;
    }

    /// <summary>
    /// Marks this attempt as completed.
    /// </summary>
    public void Complete(bool succeeded)
    {
        IsActive = false;
        Succeeded = succeeded;
    }

    /// <summary>
    /// Resets this attempt for a retry.
    /// </summary>
    public void Reset()
    {
        _completedSteps.Clear();
        CompletedSteps = Array.Empty<string>();
        CurrentInput = string.Empty;
        IsActive = true;
        Succeeded = null;
    }
}
```

---

## 7. PuzzleDefinition

### 7.1 Overview

The `PuzzleDefinition` class provides JSON configuration for puzzle types, loaded at runtime to create `Puzzle` instances.

**File:** `src/Core/RuneAndRust.Domain/Definitions/PuzzleDefinition.cs`

### 7.2 Properties

| Property | Type | Description |
|----------|------|-------------|
| `Id` | `string` | Unique definition identifier |
| `Name` | `string` | Display name |
| `Description` | `string` | Examination description |
| `Type` | `PuzzleType` | Puzzle category |
| `Difficulty` | `int` | Difficulty rating (1-5) |
| `MaxAttempts` | `int` | Maximum attempts (-1 = unlimited) |
| `CanReset` | `bool` | Whether puzzle can reset |
| `ResetDelay` | `int` | Turns until reset |
| `HasHints` | `bool` | Whether hints available |
| `RewardId` | `string?` | Associated reward |
| `PrerequisiteId` | `string?` | Required puzzle to unlock |
| `Keywords` | `List<string>` | Reference keywords |

### 7.3 Implementation

```csharp
namespace RuneAndRust.Domain.Definitions;

using RuneAndRust.Domain.Enums;

/// <summary>
/// Configuration definition for a puzzle type.
/// </summary>
public class PuzzleDefinition
{
    /// <summary>
    /// Gets or sets the unique identifier for this definition.
    /// </summary>
    public string Id { get; init; } = string.Empty;

    /// <summary>
    /// Gets or sets the display name of puzzles created from this definition.
    /// </summary>
    public string Name { get; init; } = string.Empty;

    /// <summary>
    /// Gets or sets the description shown when examining the puzzle.
    /// </summary>
    public string Description { get; init; } = string.Empty;

    /// <summary>
    /// Gets or sets the type of puzzle.
    /// </summary>
    public PuzzleType Type { get; init; }

    /// <summary>
    /// Gets or sets the difficulty rating (1-5 scale).
    /// </summary>
    public int Difficulty { get; init; } = 1;

    /// <summary>
    /// Gets or sets the maximum number of attempts (-1 = unlimited).
    /// </summary>
    public int MaxAttempts { get; init; } = -1;

    /// <summary>
    /// Gets or sets whether this puzzle can be reset after failure.
    /// </summary>
    public bool CanReset { get; init; } = true;

    /// <summary>
    /// Gets or sets the turns until reset after failure.
    /// </summary>
    public int ResetDelay { get; init; } = -1;

    /// <summary>
    /// Gets or sets whether hints are available.
    /// </summary>
    public bool HasHints { get; init; }

    /// <summary>
    /// Gets or sets the associated reward definition ID.
    /// </summary>
    public string? RewardId { get; init; }

    /// <summary>
    /// Gets or sets the prerequisite puzzle ID.
    /// </summary>
    public string? PrerequisiteId { get; init; }

    /// <summary>
    /// Gets or sets keywords for referencing the puzzle.
    /// </summary>
    public List<string> Keywords { get; init; } = [];
}
```

---

## 8. PuzzleService

### 8.1 Interface Definition

**File:** `src/Core/RuneAndRust.Application/Interfaces/IPuzzleService.cs`

```csharp
namespace RuneAndRust.Application.Interfaces;

/// <summary>
/// Service for managing puzzle interactions and validation.
/// </summary>
public interface IPuzzleService
{
    /// <summary>
    /// Gets a puzzle by ID from the current room.
    /// </summary>
    Puzzle? GetPuzzle(Room room, string puzzleKeyword);

    /// <summary>
    /// Gets all puzzles in a room.
    /// </summary>
    IEnumerable<Puzzle> GetPuzzles(Room room);

    /// <summary>
    /// Gets all unsolved puzzles in a room.
    /// </summary>
    IEnumerable<Puzzle> GetUnsolvedPuzzles(Room room);

    /// <summary>
    /// Begins an attempt on a puzzle.
    /// </summary>
    PuzzleAttemptResult BeginAttempt(Player player, Puzzle puzzle);

    /// <summary>
    /// Submits a solution attempt for a puzzle.
    /// </summary>
    PuzzleSolveResult AttemptSolve(Player player, Puzzle puzzle, string input);

    /// <summary>
    /// Validates a sequence step.
    /// </summary>
    PuzzleStepResult ValidateStep(Puzzle puzzle, PuzzleAttempt attempt, string stepId);

    /// <summary>
    /// Gets the current attempt for a puzzle (if any).
    /// </summary>
    PuzzleAttempt? GetCurrentAttempt(Player player, Puzzle puzzle);

    /// <summary>
    /// Requests a hint for a puzzle.
    /// </summary>
    PuzzleHintResult RequestHint(Player player, Puzzle puzzle);

    /// <summary>
    /// Processes puzzle resets at end of turn.
    /// </summary>
    IEnumerable<Puzzle> ProcessPuzzleResets(Room room);

    /// <summary>
    /// Checks and updates puzzle prerequisites.
    /// </summary>
    void UpdatePuzzleLocks(Room room);

    /// <summary>
    /// Applies puzzle completion effects.
    /// </summary>
    PuzzleRewardResult ApplyPuzzleReward(Player player, Puzzle puzzle);
}
```

### 8.2 Result Types

**File:** `src/Core/RuneAndRust.Application/Interfaces/IPuzzleService.cs` (continued)

```csharp
/// <summary>
/// Result of beginning a puzzle attempt.
/// </summary>
public readonly record struct PuzzleAttemptResult
{
    public Puzzle Puzzle { get; init; }
    public bool Success { get; init; }
    public PuzzleAttempt? Attempt { get; init; }
    public string Message { get; init; }

    public static PuzzleAttemptResult Started(Puzzle puzzle, PuzzleAttempt attempt) =>
        new() { Puzzle = puzzle, Success = true, Attempt = attempt, Message = "Puzzle attempt started." };

    public static PuzzleAttemptResult AlreadyInProgress(Puzzle puzzle, PuzzleAttempt attempt) =>
        new() { Puzzle = puzzle, Success = true, Attempt = attempt, Message = "Puzzle attempt already in progress." };

    public static PuzzleAttemptResult PuzzleLocked(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, Attempt = null, Message = "This puzzle is locked." };

    public static PuzzleAttemptResult NoAttemptsRemaining(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, Attempt = null, Message = "No attempts remaining." };

    public static PuzzleAttemptResult AlreadySolved(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, Attempt = null, Message = "This puzzle has already been solved." };
}

/// <summary>
/// Result of attempting to solve a puzzle.
/// </summary>
public readonly record struct PuzzleSolveResult
{
    public Puzzle Puzzle { get; init; }
    public bool Solved { get; init; }
    public bool Failed { get; init; }
    public int AttemptsRemaining { get; init; }
    public string Message { get; init; }

    public static PuzzleSolveResult Success(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Solved = true, Failed = false, AttemptsRemaining = 0, Message = "Puzzle solved!" };

    public static PuzzleSolveResult Incorrect(Puzzle puzzle, int remaining) =>
        new() { Puzzle = puzzle, Solved = false, Failed = false, AttemptsRemaining = remaining, Message = "Incorrect solution." };

    public static PuzzleSolveResult Failure(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Solved = false, Failed = true, AttemptsRemaining = 0, Message = "Puzzle failed. Maximum attempts reached." };

    public static PuzzleSolveResult NotSolvable(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Solved = false, Failed = false, AttemptsRemaining = 0, Message = "This puzzle cannot be solved in its current state." };
}

/// <summary>
/// Result of validating a puzzle step.
/// </summary>
public readonly record struct PuzzleStepResult
{
    public Puzzle Puzzle { get; init; }
    public string StepId { get; init; }
    public bool Correct { get; init; }
    public bool SequenceComplete { get; init; }
    public bool SequenceFailed { get; init; }
    public int StepsRemaining { get; init; }
    public string Message { get; init; }

    public static PuzzleStepResult CorrectStep(Puzzle puzzle, string stepId, int remaining) =>
        new() { Puzzle = puzzle, StepId = stepId, Correct = true, SequenceComplete = false, SequenceFailed = false, StepsRemaining = remaining, Message = "Correct step." };

    public static PuzzleStepResult SequenceCompleted(Puzzle puzzle, string stepId) =>
        new() { Puzzle = puzzle, StepId = stepId, Correct = true, SequenceComplete = true, SequenceFailed = false, StepsRemaining = 0, Message = "Sequence completed!" };

    public static PuzzleStepResult WrongStep(Puzzle puzzle, string stepId, bool reset) =>
        new() { Puzzle = puzzle, StepId = stepId, Correct = false, SequenceComplete = false, SequenceFailed = reset, StepsRemaining = 0, Message = reset ? "Wrong step. Sequence reset." : "Wrong step." };
}

/// <summary>
/// Result of requesting a hint.
/// </summary>
public readonly record struct PuzzleHintResult
{
    public Puzzle Puzzle { get; init; }
    public bool Success { get; init; }
    public string? Hint { get; init; }
    public int HintsRevealed { get; init; }
    public string Message { get; init; }

    public static PuzzleHintResult HintRevealed(Puzzle puzzle, string hint, int revealed) =>
        new() { Puzzle = puzzle, Success = true, Hint = hint, HintsRevealed = revealed, Message = "Hint revealed." };

    public static PuzzleHintResult NoHintsAvailable(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, Hint = null, HintsRevealed = 0, Message = "No hints available for this puzzle." };

    public static PuzzleHintResult AllHintsRevealed(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, Hint = null, HintsRevealed = puzzle.HintsRevealed, Message = "All hints have been revealed." };
}

/// <summary>
/// Result of applying puzzle rewards.
/// </summary>
public readonly record struct PuzzleRewardResult
{
    public Puzzle Puzzle { get; init; }
    public bool Success { get; init; }
    public string? RewardId { get; init; }
    public string Message { get; init; }

    public static PuzzleRewardResult RewardGranted(Puzzle puzzle, string rewardId) =>
        new() { Puzzle = puzzle, Success = true, RewardId = rewardId, Message = "Reward granted." };

    public static PuzzleRewardResult NoReward(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = true, RewardId = null, Message = "No reward for this puzzle." };

    public static PuzzleRewardResult NotSolved(Puzzle puzzle) =>
        new() { Puzzle = puzzle, Success = false, RewardId = null, Message = "Puzzle must be solved first." };
}
```

### 8.3 Service Implementation

**File:** `src/Core/RuneAndRust.Application/Services/PuzzleService.cs`

```csharp
namespace RuneAndRust.Application.Services;

using Microsoft.Extensions.Logging;
using RuneAndRust.Application.Interfaces;
using RuneAndRust.Domain.Entities;
using RuneAndRust.Domain.ValueObjects;

/// <summary>
/// Service for managing puzzle interactions and validation.
/// </summary>
public class PuzzleService : IPuzzleService
{
    private readonly ILogger<PuzzleService> _logger;
    private readonly Dictionary<(Guid PlayerId, Guid PuzzleId), PuzzleAttempt> _activeAttempts = [];

    public PuzzleService(ILogger<PuzzleService> logger)
    {
        _logger = logger;
    }

    /// <inheritdoc />
    public Puzzle? GetPuzzle(Room room, string puzzleKeyword)
    {
        return room.GetPuzzleByKeyword(puzzleKeyword);
    }

    /// <inheritdoc />
    public IEnumerable<Puzzle> GetPuzzles(Room room)
    {
        return room.Puzzles;
    }

    /// <inheritdoc />
    public IEnumerable<Puzzle> GetUnsolvedPuzzles(Room room)
    {
        return room.GetUnsolvedPuzzles();
    }

    /// <inheritdoc />
    public PuzzleAttemptResult BeginAttempt(Player player, Puzzle puzzle)
    {
        if (puzzle.IsSolved)
        {
            _logger.LogDebug("Player {PlayerId} attempted already-solved puzzle {PuzzleId}", player.Id, puzzle.Id);
            return PuzzleAttemptResult.AlreadySolved(puzzle);
        }

        if (puzzle.IsLocked)
        {
            _logger.LogDebug("Player {PlayerId} attempted locked puzzle {PuzzleId}", player.Id, puzzle.Id);
            return PuzzleAttemptResult.PuzzleLocked(puzzle);
        }

        if (!puzzle.HasAttemptsRemaining)
        {
            _logger.LogDebug("Player {PlayerId} has no attempts remaining for puzzle {PuzzleId}", player.Id, puzzle.Id);
            return PuzzleAttemptResult.NoAttemptsRemaining(puzzle);
        }

        var key = (player.Id, puzzle.Id);
        if (_activeAttempts.TryGetValue(key, out var existingAttempt) && existingAttempt.IsActive)
        {
            _logger.LogDebug("Player {PlayerId} resuming existing attempt on puzzle {PuzzleId}", player.Id, puzzle.Id);
            return PuzzleAttemptResult.AlreadyInProgress(puzzle, existingAttempt);
        }

        puzzle.BeginAttempt();
        var attempt = PuzzleAttempt.Create(puzzle.Id);
        _activeAttempts[key] = attempt;

        _logger.LogInformation("Player {PlayerId} began attempt on puzzle {PuzzleId}", player.Id, puzzle.Id);
        return PuzzleAttemptResult.Started(puzzle, attempt);
    }

    /// <inheritdoc />
    public PuzzleSolveResult AttemptSolve(Player player, Puzzle puzzle, string input)
    {
        if (!puzzle.IsSolvable)
        {
            return PuzzleSolveResult.NotSolvable(puzzle);
        }

        // Type-specific validation will be implemented in v0.4.2b
        // For now, this is a placeholder for basic solve logic
        _logger.LogInformation("Player {PlayerId} attempted to solve puzzle {PuzzleId} with input: {Input}",
            player.Id, puzzle.Id, input);

        // Placeholder: always fail until type-specific validation is implemented
        puzzle.RecordFailedAttempt();

        if (puzzle.IsFailed)
        {
            _logger.LogInformation("Player {PlayerId} failed puzzle {PuzzleId} - max attempts reached", player.Id, puzzle.Id);
            return PuzzleSolveResult.Failure(puzzle);
        }

        var remaining = puzzle.MaxAttempts < 0 ? -1 : puzzle.MaxAttempts - puzzle.AttemptCount;
        return PuzzleSolveResult.Incorrect(puzzle, remaining);
    }

    /// <inheritdoc />
    public PuzzleStepResult ValidateStep(Puzzle puzzle, PuzzleAttempt attempt, string stepId)
    {
        // Implementation deferred to v0.4.2b (SequencePuzzle)
        _logger.LogDebug("ValidateStep called for puzzle {PuzzleId}, step {StepId}", puzzle.Id, stepId);
        return PuzzleStepResult.WrongStep(puzzle, stepId, false);
    }

    /// <inheritdoc />
    public PuzzleAttempt? GetCurrentAttempt(Player player, Puzzle puzzle)
    {
        var key = (player.Id, puzzle.Id);
        return _activeAttempts.TryGetValue(key, out var attempt) && attempt.IsActive ? attempt : null;
    }

    /// <inheritdoc />
    public PuzzleHintResult RequestHint(Player player, Puzzle puzzle)
    {
        // Hint system deferred to v0.4.2c
        if (!puzzle.HasHints)
        {
            return PuzzleHintResult.NoHintsAvailable(puzzle);
        }

        _logger.LogDebug("Hint requested for puzzle {PuzzleId} by player {PlayerId}", puzzle.Id, player.Id);
        return PuzzleHintResult.NoHintsAvailable(puzzle);
    }

    /// <inheritdoc />
    public IEnumerable<Puzzle> ProcessPuzzleResets(Room room)
    {
        var resetPuzzles = new List<Puzzle>();

        foreach (var puzzle in room.Puzzles.Where(p => p.IsFailed && p.CanReset))
        {
            if (puzzle.TickReset())
            {
                _logger.LogInformation("Puzzle {PuzzleId} in room {RoomId} has reset", puzzle.Id, room.Id);
                resetPuzzles.Add(puzzle);
            }
        }

        return resetPuzzles;
    }

    /// <inheritdoc />
    public void UpdatePuzzleLocks(Room room)
    {
        foreach (var puzzle in room.Puzzles.Where(p => p.PrerequisitePuzzleId != null))
        {
            var prerequisite = room.Puzzles.FirstOrDefault(p => p.DefinitionId == puzzle.PrerequisitePuzzleId);

            if (prerequisite == null)
                continue;

            if (prerequisite.IsSolved && puzzle.IsLocked)
            {
                puzzle.Unlock();
                _logger.LogInformation("Puzzle {PuzzleId} unlocked after prerequisite {PrerequisiteId} solved",
                    puzzle.Id, prerequisite.Id);
            }
            else if (!prerequisite.IsSolved && !puzzle.IsLocked && puzzle.State == PuzzleState.Unsolved)
            {
                puzzle.Lock();
                _logger.LogDebug("Puzzle {PuzzleId} locked - prerequisite {PrerequisiteId} not solved",
                    puzzle.Id, prerequisite.Id);
            }
        }
    }

    /// <inheritdoc />
    public PuzzleRewardResult ApplyPuzzleReward(Player player, Puzzle puzzle)
    {
        if (!puzzle.IsSolved)
        {
            return PuzzleRewardResult.NotSolved(puzzle);
        }

        if (string.IsNullOrEmpty(puzzle.RewardId))
        {
            return PuzzleRewardResult.NoReward(puzzle);
        }

        // Reward application deferred to v0.4.2c
        _logger.LogInformation("Player {PlayerId} earned reward {RewardId} from puzzle {PuzzleId}",
            player.Id, puzzle.RewardId, puzzle.Id);

        return PuzzleRewardResult.RewardGranted(puzzle, puzzle.RewardId);
    }
}
```

---

## 9. Room Integration

### 9.1 Room Modifications

**File:** `src/Core/RuneAndRust.Domain/Entities/Room.cs` (modifications)

```
MODIFY: Room
├── ADD: _puzzles: List<Puzzle>
├── ADD: Puzzles: IReadOnlyList<Puzzle>
├── ADD: HasPuzzles: bool
├── ADD: HasUnsolvedPuzzles: bool
├── ADD: AddPuzzle(Puzzle): void
├── ADD: RemovePuzzle(Puzzle): bool
├── ADD: GetPuzzleByKeyword(string): Puzzle?
└── ADD: GetUnsolvedPuzzles(): IEnumerable<Puzzle>
```

### 9.2 Implementation

```csharp
// Add to Room.cs

private readonly List<Puzzle> _puzzles = [];

/// <summary>
/// Gets the puzzles in this room.
/// </summary>
public IReadOnlyList<Puzzle> Puzzles => _puzzles.AsReadOnly();

/// <summary>
/// Gets whether this room contains any puzzles.
/// </summary>
public bool HasPuzzles => _puzzles.Count > 0;

/// <summary>
/// Gets whether this room has unsolved puzzles.
/// </summary>
public bool HasUnsolvedPuzzles => _puzzles.Any(p => p.IsSolvable);

/// <summary>
/// Adds a puzzle to this room.
/// </summary>
/// <param name="puzzle">The puzzle to add.</param>
public void AddPuzzle(Puzzle puzzle)
{
    ArgumentNullException.ThrowIfNull(puzzle);
    _puzzles.Add(puzzle);
}

/// <summary>
/// Removes a puzzle from this room.
/// </summary>
/// <param name="puzzle">The puzzle to remove.</param>
/// <returns>True if the puzzle was removed.</returns>
public bool RemovePuzzle(Puzzle puzzle)
{
    return _puzzles.Remove(puzzle);
}

/// <summary>
/// Gets a puzzle by keyword.
/// </summary>
/// <param name="keyword">The keyword to search for.</param>
/// <returns>The matching puzzle, or null.</returns>
public Puzzle? GetPuzzleByKeyword(string keyword)
{
    if (string.IsNullOrWhiteSpace(keyword))
        return null;

    return _puzzles.FirstOrDefault(p =>
        p.Name.Contains(keyword, StringComparison.OrdinalIgnoreCase) ||
        p.DefinitionId.Equals(keyword, StringComparison.OrdinalIgnoreCase));
}

/// <summary>
/// Gets all unsolved puzzles in this room.
/// </summary>
/// <returns>Unsolved puzzles.</returns>
public IEnumerable<Puzzle> GetUnsolvedPuzzles()
{
    return _puzzles.Where(p => p.IsSolvable);
}
```

---

## 10. User-Facing Commands

### 10.1 Command Overview

| Command | Description |
|---------|-------------|
| `examine <puzzle>` | View puzzle description and status |
| `solve <puzzle>` | Begin/continue puzzle attempt |
| `reset <puzzle>` | Reset a failed puzzle (if allowed) |

### 10.2 Examining a Puzzle

```
> examine stone altar

Stone Altar Puzzle
==================
A circular stone altar with four carved symbols around
its edge. The symbols appear to represent the four
elements: fire, water, earth, and air.

Type: Sequence
Status: Unsolved
Difficulty: ★★★☆☆
Attempts: 0

The symbols seem to need activation in a specific order.
```

### 10.3 Beginning an Attempt

```
> solve stone altar

You focus on the Stone Altar Puzzle...

The altar glows faintly as you approach. You sense that
the symbols must be activated in the correct order.

[Puzzle: In Progress]
Remaining steps: 4
```

### 10.4 Failed Attempt

```
> solve combination lock

You try the combination: 4-7-2-1

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[Attempts: 2/3 remaining]

---

> solve combination lock

You try the combination: 1-2-3-4

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[Attempts: 1/3 remaining]

---

> solve combination lock

You try the combination: 9-9-9-9

The lock mechanism clicks but doesn't open.
That combination was incorrect.

[PUZZLE FAILED]
You've exhausted your attempts.
The puzzle will reset in 5 turns.
```

### 10.5 Successful Solve

```
> solve combination lock

You try the combination: 3-1-4-1

*CLICK*

The lock mechanism turns smoothly and the vault door
swings open!

[PUZZLE SOLVED]
```

### 10.6 Locked Puzzle

```
> examine ancient door

Ancient Door Mechanism
======================
An ornate door with strange symbols. The mechanism
appears to be connected to the altar nearby.

Type: Logic
Status: Locked
Difficulty: ★★★★☆

This puzzle is locked. Solve the Elemental Altar first.
```

### 10.7 Resetting a Puzzle

```
> reset combination lock

The combination lock resets with a series of clicks.

[Puzzle Reset]
You may attempt the puzzle again.
Attempts: 0/3
```

---

## 11. Data Model Changes

### 11.1 Summary

| Type | Layer | Name | Description |
|------|-------|------|-------------|
| Entity | Domain | `Puzzle` | Logic challenge players can solve |
| Enum | Domain | `PuzzleState` | Current puzzle state (5 values) |
| Enum | Domain | `PuzzleType` | Puzzle category (5 values) |
| Definition | Domain | `PuzzleDefinition` | JSON configuration |
| Value Object | Domain | `PuzzleAttempt` | Attempt progress tracking |
| Interface | Application | `IPuzzleService` | Puzzle service contract |
| Service | Application | `PuzzleService` | Puzzle logic implementation |
| Result | Application | `PuzzleAttemptResult` | Begin attempt result |
| Result | Application | `PuzzleSolveResult` | Solve attempt result |
| Result | Application | `PuzzleStepResult` | Sequence step result |
| Result | Application | `PuzzleHintResult` | Hint request result |
| Result | Application | `PuzzleRewardResult` | Reward application result |

### 11.2 File Locations

| File | Path |
|------|------|
| `Puzzle.cs` | `src/Core/RuneAndRust.Domain/Entities/` |
| `PuzzleState.cs` | `src/Core/RuneAndRust.Domain/Enums/` |
| `PuzzleType.cs` | `src/Core/RuneAndRust.Domain/Enums/` |
| `PuzzleDefinition.cs` | `src/Core/RuneAndRust.Domain/Definitions/` |
| `PuzzleAttempt.cs` | `src/Core/RuneAndRust.Domain/ValueObjects/` |
| `IPuzzleService.cs` | `src/Core/RuneAndRust.Application/Interfaces/` |
| `PuzzleService.cs` | `src/Core/RuneAndRust.Application/Services/` |

---

## 12. Configuration File Schemas

### 12.1 Puzzles Configuration

**File:** `config/puzzles.json`

```json
{
  "$schema": "../schemas/puzzles.schema.json",
  "puzzles": [
    {
      "id": "altar-sequence-fire",
      "name": "Elemental Altar",
      "description": "A circular stone altar with four carved symbols representing the elements.",
      "type": "Sequence",
      "difficulty": 3,
      "maxAttempts": -1,
      "canReset": true,
      "hasHints": true,
      "rewardId": "altar-treasure"
    },
    {
      "id": "vault-combination",
      "name": "Vault Lock",
      "description": "A complex combination lock with four rotating dials.",
      "type": "Combination",
      "difficulty": 2,
      "maxAttempts": 3,
      "canReset": true,
      "resetDelay": 5,
      "hasHints": true
    },
    {
      "id": "mirror-pattern",
      "name": "Mirror Puzzle",
      "description": "A series of mirrors that must be aligned to create a pattern of light.",
      "type": "Pattern",
      "difficulty": 4,
      "maxAttempts": -1,
      "canReset": true
    },
    {
      "id": "door-logic",
      "name": "Ancient Door Mechanism",
      "description": "An ornate door with strange symbols connected to the altar.",
      "type": "Logic",
      "difficulty": 4,
      "maxAttempts": 5,
      "canReset": true,
      "resetDelay": 10,
      "prerequisiteId": "altar-sequence-fire"
    },
    {
      "id": "sphinx-riddle",
      "name": "Sphinx's Challenge",
      "description": "The sphinx blocks your path and poses a riddle.",
      "type": "Riddle",
      "difficulty": 3,
      "maxAttempts": 3,
      "canReset": false,
      "hasHints": false
    }
  ]
}
```

### 12.2 JSON Schema

**File:** `config/schemas/puzzles.schema.json`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "puzzles.schema.json",
  "title": "Puzzle Definitions",
  "description": "Schema for puzzle configuration",
  "type": "object",
  "properties": {
    "$schema": {
      "type": "string"
    },
    "puzzles": {
      "type": "array",
      "items": {
        "$ref": "#/$defs/puzzleDefinition"
      }
    }
  },
  "required": ["puzzles"],
  "$defs": {
    "puzzleDefinition": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for this puzzle definition"
        },
        "name": {
          "type": "string",
          "description": "Display name of the puzzle"
        },
        "description": {
          "type": "string",
          "description": "Description shown when examining the puzzle"
        },
        "type": {
          "type": "string",
          "enum": ["Sequence", "Combination", "Pattern", "Riddle", "Logic"],
          "description": "Category of puzzle mechanics"
        },
        "difficulty": {
          "type": "integer",
          "minimum": 1,
          "maximum": 5,
          "default": 1,
          "description": "Difficulty rating (1-5 scale)"
        },
        "maxAttempts": {
          "type": "integer",
          "default": -1,
          "description": "Maximum attempts allowed (-1 = unlimited)"
        },
        "canReset": {
          "type": "boolean",
          "default": true,
          "description": "Whether the puzzle can be reset after failure"
        },
        "resetDelay": {
          "type": "integer",
          "default": -1,
          "description": "Turns until automatic reset (-1 = manual only)"
        },
        "hasHints": {
          "type": "boolean",
          "default": false,
          "description": "Whether hints are available for this puzzle"
        },
        "rewardId": {
          "type": "string",
          "description": "Associated reward definition ID"
        },
        "prerequisiteId": {
          "type": "string",
          "description": "Puzzle ID that must be solved first"
        },
        "keywords": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Keywords for referencing the puzzle"
        }
      },
      "required": ["id", "name", "description", "type"]
    }
  }
}
```

---

## 13. Logging Specifications

### 13.1 Log Levels by Component

| Component | Level | Events |
|-----------|-------|--------|
| `PuzzleService` | Information | Attempt started, puzzle solved, puzzle failed, puzzle reset |
| `PuzzleService` | Debug | Attempt resumed, step validated, hint requested, lock state changed |
| `PuzzleService` | Warning | Invalid attempt on locked/failed puzzle |
| `PuzzleService` | Error | Configuration loading failures |

### 13.2 Log Message Examples

```csharp
// Information level
_logger.LogInformation("Player {PlayerId} began attempt on puzzle {PuzzleId}", player.Id, puzzle.Id);
_logger.LogInformation("Player {PlayerId} solved puzzle {PuzzleId}", player.Id, puzzle.Id);
_logger.LogInformation("Player {PlayerId} failed puzzle {PuzzleId} - max attempts reached", player.Id, puzzle.Id);
_logger.LogInformation("Puzzle {PuzzleId} in room {RoomId} has reset", puzzle.Id, room.Id);

// Debug level
_logger.LogDebug("Player {PlayerId} resuming existing attempt on puzzle {PuzzleId}", player.Id, puzzle.Id);
_logger.LogDebug("ValidateStep called for puzzle {PuzzleId}, step {StepId}", puzzle.Id, stepId);
_logger.LogDebug("Puzzle {PuzzleId} unlocked after prerequisite {PrerequisiteId} solved", puzzle.Id, prerequisite.Id);

// Warning level
_logger.LogWarning("Player {PlayerId} attempted locked puzzle {PuzzleId}", player.Id, puzzle.Id);
```

---

## 14. Unit Testing Requirements

### 14.1 Test Count by Feature

| Feature | Test Count |
|---------|------------|
| Puzzle Entity | ~12 |
| PuzzleState Transitions | ~6 |
| PuzzleAttempt | ~5 |
| PuzzleService | ~8 |
| Room Integration | ~4 |
| **Total** | **~35** |

### 14.2 Test Categories

#### Puzzle Entity Tests
- Create puzzle with valid parameters
- Create puzzle with invalid parameters throws
- BeginAttempt transitions Unsolved to InProgress
- BeginAttempt returns false when Locked
- RecordFailedAttempt increments count
- RecordFailedAttempt transitions to Failed at max
- Solve transitions to Solved
- Reset transitions Failed to Unsolved
- Reset returns false for Solved puzzles
- TickReset decrements counter
- TickReset triggers reset at zero
- Lock/Unlock state transitions

#### PuzzleAttempt Tests
- Create returns valid attempt
- AddStep appends to CompletedSteps
- SetInput updates CurrentInput
- AppendInput concatenates input
- Complete marks attempt inactive

#### PuzzleService Tests
- GetPuzzle finds by keyword
- GetUnsolvedPuzzles filters correctly
- BeginAttempt returns AlreadySolved for solved
- BeginAttempt returns PuzzleLocked for locked
- ProcessPuzzleResets calls TickReset
- UpdatePuzzleLocks unlocks when prerequisite solved
- ApplyPuzzleReward returns NotSolved when not solved
- GetCurrentAttempt returns active attempt

#### Room Integration Tests
- AddPuzzle adds to collection
- RemovePuzzle removes from collection
- GetPuzzleByKeyword finds by name
- HasUnsolvedPuzzles returns correct value

---

## 15. Use Cases

### UC-001: Player Examines Puzzle
**Actor:** Player
**Flow:** Enter room → Look at puzzle → View puzzle status → See difficulty and attempts

### UC-002: Player Begins Puzzle Attempt
**Actor:** Player
**Flow:** Examine puzzle → Use solve command → Puzzle transitions to InProgress → Attempt created

### UC-003: Player Solves Puzzle Successfully
**Actor:** Player
**Flow:** Begin attempt → Enter correct solution → Puzzle transitions to Solved → Reward granted (if any)

### UC-004: Player Fails Puzzle
**Actor:** Player
**Flow:** Begin attempt → Enter wrong solutions → Exhaust max attempts → Puzzle transitions to Failed → Reset timer starts

### UC-005: Puzzle Resets After Failure
**Actor:** System
**Flow:** Puzzle Failed → Turns pass → TurnsUntilReset reaches 0 → Puzzle transitions to Unsolved → AttemptCount reset

### UC-006: Prerequisites Unlock Puzzles
**Actor:** System
**Flow:** Puzzle A solved → System checks dependents → Puzzle B prerequisite met → Puzzle B unlocked

### UC-007: Player Manually Resets Puzzle
**Actor:** Player
**Flow:** Puzzle Failed → Use reset command → Puzzle transitions to Unsolved (if CanReset)

### UC-008: Player Attempts Locked Puzzle
**Actor:** Player
**Flow:** Examine locked puzzle → Attempt solve → Error message shown → Player informed of prerequisite

---

## 16. Deliverable Checklist

### Domain Layer
- [ ] `Puzzle.cs` entity created
- [ ] `PuzzleState.cs` enum created
- [ ] `PuzzleType.cs` enum created
- [ ] `PuzzleDefinition.cs` definition created
- [ ] `PuzzleAttempt.cs` value object created
- [ ] `Room.cs` updated with Puzzles collection

### Application Layer
- [ ] `IPuzzleService.cs` interface created
- [ ] `PuzzleService.cs` service created
- [ ] `PuzzleAttemptResult` struct created
- [ ] `PuzzleSolveResult` struct created
- [ ] `PuzzleStepResult` struct created
- [ ] `PuzzleHintResult` struct created
- [ ] `PuzzleRewardResult` struct created

### Configuration
- [ ] `puzzles.json` created with sample data
- [ ] `puzzles.schema.json` created

### Testing
- [ ] ~35 unit tests implemented
- [ ] All tests passing

### Integration
- [ ] DI registration for IPuzzleService
- [ ] solve command integrated
- [ ] reset command integrated
- [ ] examine command updated for puzzles

---

## 17. Acceptance Criteria

### Functional
- [ ] Puzzle entity stores state, type, and attempt information
- [ ] PuzzleState enum covers all necessary states
- [ ] PuzzleType enum categorizes all puzzle varieties
- [ ] PuzzleAttempt tracks progress through puzzle
- [ ] Room.Puzzles collection works correctly
- [ ] `solve` command begins puzzle attempts
- [ ] Failed puzzles track attempts remaining
- [ ] Puzzles can reset after configurable delay
- [ ] Locked puzzles require prerequisite completion
- [ ] Puzzles appear in room examination

### Quality
- [ ] Build succeeds with 0 errors/warnings
- [ ] ~35 unit tests pass
- [ ] Configuration files validate against schemas
- [ ] XML documentation complete for all public members
- [ ] All state transitions validated and logged

---

## 18. Dependencies

### 18.1 Prerequisites

| Version | Component | Usage |
|---------|-----------|-------|
| v0.4.1c | Room entity | Puzzles collection pattern |
| v0.4.0a | IEntity interface | Entity base |
| v0.4.0a | Player entity | Attempt tracking |
| Prior | ILogger | Service logging |

### 18.2 Provides For

| Version | Component | Usage |
|---------|-----------|-------|
| v0.4.2b | SequencePuzzle | Type-specific validation |
| v0.4.2b | CombinationPuzzle | Type-specific validation |
| v0.4.2b | PatternPuzzle | Type-specific validation |
| v0.4.2c | Riddle NPCs | Riddle puzzle type |
| v0.4.2c | Hint System | HasHints, HintsRevealed |
| v0.4.2c | Rewards | RewardId integration |

---

## 19. Future Considerations

### 19.1 Deferred to v0.4.2b
- **SequencePuzzle**: Ordered step validation with RequiredSequence
- **CombinationPuzzle**: Code input with solution matching
- **PatternPuzzle**: Pattern display and matching logic
- **input command**: Combination entry interface
- **activate integration**: Sequence step triggers

### 19.2 Deferred to v0.4.2c
- **Riddle NPCs**: NPCs that pose riddles
- **Hint System**: Progressive hint revelation with dice checks
- **Multi-part Puzzles**: Puzzles spanning multiple rooms
- **Puzzle Rewards**: Full reward system integration
- **answer command**: Riddle response interface

### 19.3 Out of Scope
- Multiplayer puzzle coordination
- Puzzle difficulty scaling
- Procedurally generated puzzles
- Puzzle achievement tracking

---

*Document Version: 1.0*
*Last Updated: 2026-01-10*
*Author: Claude*
